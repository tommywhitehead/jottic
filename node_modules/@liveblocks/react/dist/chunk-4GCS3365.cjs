"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/contexts.ts
var _core = require('@liveblocks/core');
var _react = require('react'); var React = _interopRequireWildcard(_react);
var ClientContext = _react.createContext.call(void 0, null);
function useClientOrNull() {
  return _react.useContext.call(void 0, ClientContext);
}
function useClient() {
  return _nullishCoalesce(useClientOrNull(), () => ( _core.raise.call(void 0, "LiveblocksProvider is missing from the React tree.")));
}
var RoomContext = _react.createContext.call(void 0, null);
function useRoomOrNull() {
  return _react.useContext.call(void 0, RoomContext);
}
function useIsInsideRoom() {
  const room = useRoomOrNull();
  return room !== null;
}

// src/lib/use-latest.ts

function useLatest(value) {
  const ref = _react.useRef.call(void 0, value);
  _react.useEffect.call(void 0, () => {
    ref.current = value;
  }, [value]);
  return ref;
}

// src/ai.tsx


function useAi() {
  return useClient()[_core.kInternal].ai;
}
function useRandom() {
  return _react.useState.call(void 0, _core.nanoid)[0];
}
var RegisterAiKnowledge = _react.memo.call(void 0, function RegisterAiKnowledge2(props) {
  const layerId = _react.useId.call(void 0, );
  const ai = useAi();
  const { description, value } = props;
  const [layerKey, setLayerKey] = _react.useState.call(void 0, );
  _react.useEffect.call(void 0, () => {
    const layerKey2 = ai.registerKnowledgeLayer(layerId);
    setLayerKey(layerKey2);
    return () => {
      ai.deregisterKnowledgeLayer(layerKey2);
      setLayerKey(void 0);
    };
  }, [ai, layerId]);
  const randomKey = useRandom();
  const knowledgeKey = _nullishCoalesce(props.id, () => ( randomKey));
  _react.useEffect.call(void 0, () => {
    if (layerKey !== void 0) {
      ai.updateKnowledge(layerKey, { description, value }, knowledgeKey);
    }
  }, [ai, layerKey, knowledgeKey, description, value]);
  return null;
});
var RegisterAiTool = _react.memo.call(void 0, function RegisterAiTool2({
  chatId,
  name,
  tool,
  enabled
}) {
  const client = useClient();
  const ai = client[_core.kInternal].ai;
  _react.useEffect.call(void 0, () => {
    const toolWithEnabled = enabled !== void 0 ? { ...tool, enabled } : tool;
    return ai.registerTool(name, toolWithEnabled, chatId);
  }, [ai, chatId, name, tool, enabled]);
  return null;
});

// src/use-sync-external-store-with-selector.ts







function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
  const instRef = _react.useRef.call(void 0, null);
  let inst;
  if (instRef.current === null) {
    inst = {
      hasValue: false,
      value: null
    };
    instRef.current = inst;
  } else {
    inst = instRef.current;
  }
  const [getSelection, getServerSelection] = _react.useMemo.call(void 0, () => {
    let hasMemo = false;
    let memoizedSnapshot;
    let memoizedSelection;
    const memoizedSelector = (nextSnapshot) => {
      if (!hasMemo) {
        hasMemo = true;
        memoizedSnapshot = nextSnapshot;
        const nextSelection2 = selector(nextSnapshot);
        if (isEqual !== void 0) {
          if (inst.hasValue) {
            const currentSelection = inst.value;
            if (isEqual(currentSelection, nextSelection2)) {
              memoizedSelection = currentSelection;
              return currentSelection;
            }
          }
        }
        memoizedSelection = nextSelection2;
        return nextSelection2;
      }
      const prevSnapshot = memoizedSnapshot;
      const prevSelection = memoizedSelection;
      if (is(prevSnapshot, nextSnapshot)) {
        return prevSelection;
      }
      const nextSelection = selector(nextSnapshot);
      if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
        memoizedSnapshot = nextSnapshot;
        return prevSelection;
      }
      memoizedSnapshot = nextSnapshot;
      memoizedSelection = nextSelection;
      return nextSelection;
    };
    const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());
    const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : () => memoizedSelector(maybeGetServerSnapshot());
    return [getSnapshotWithSelector, getServerSnapshotWithSelector];
  }, [getSnapshot, getServerSnapshot, selector, isEqual]);
  const value = _react.useSyncExternalStore.call(void 0, 
    subscribe,
    getSelection,
    getServerSelection
  );
  _react.useEffect.call(void 0, () => {
    inst.hasValue = true;
    inst.value = value;
  }, [value]);
  _react.useDebugValue.call(void 0, value);
  return value;
}

// src/use-signal.ts

var identity = (value) => value;
function useSignal(signal, selector, isEqual) {
  if (signal instanceof _core.MutableSignal) {
    throw new Error(
      "Using a mutable Signal with useSignal will likely not work as expected."
    );
  }
  return useSyncExternalStoreWithSelector(
    signal.subscribe,
    signal.get,
    signal.get,
    _nullishCoalesce(selector, () => ( identity)),
    isEqual
  );
}

// src/liveblocks.tsx


















// src/config.ts
var SECONDS = 1e3;
var MINUTES = 60 * SECONDS;
var config = {
  SMOOTH_DELAY: 1 * SECONDS,
  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,
  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,
  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,
  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,
  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,
  USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,
  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,
  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,
  ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,
  ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,
  USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,
  USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES
};

// src/lib/AsyncResult.ts
var ASYNC_LOADING = Object.freeze({ isLoading: true });
var ASYNC_ERR = (error) => Object.freeze({ isLoading: false, error });
function ASYNC_OK(fieldOrData, data) {
  if (arguments.length === 1) {
    return Object.freeze({ isLoading: false, data: fieldOrData });
  } else {
    return Object.freeze({ isLoading: false, [fieldOrData]: data });
  }
}

// src/lib/itertools.ts
function find(it, predicate) {
  for (const item of it) {
    if (predicate(item)) return item;
  }
  return void 0;
}
function count(it, predicate) {
  let total = 0;
  for (const item of it) {
    if (predicate(item)) total++;
  }
  return total;
}

// src/lib/ssr.ts
function ensureNotServerSide() {
  if (typeof window === "undefined") {
    throw new Error(
      "You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense"
    );
  }
}

// src/lib/use-initial.ts

function useInitial(value, roomId) {
  return _react.useMemo.call(void 0, () => value, [roomId]);
}
function useInitialUnlessFunction(latestValue, roomId) {
  const frozenValue = useInitial(latestValue, roomId);
  const ref = useLatest(latestValue);
  const wrapper = _react.useCallback.call(void 0, 
    (...args) => ref.current(...args),
    [ref]
  );
  if (typeof frozenValue === "function") {
    return wrapper;
  } else {
    return frozenValue;
  }
}

// src/lib/use-polyfill.ts

var reactUse = React[" use ".trim().toString()];
var use = _nullishCoalesce(reactUse, () => ( ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    promise.status = "pending";
    promise.then(
      (v) => {
        promise.status = "fulfilled";
        promise.value = v;
      },
      (e) => {
        promise.status = "rejected";
        promise.reason = e;
      }
    );
    throw promise;
  }
})));

// src/umbrella-store.ts





















// src/lib/autobind.ts
function autobind(self) {
  const seen = /* @__PURE__ */ new Set();
  seen.add("constructor");
  let obj = self.constructor.prototype;
  do {
    for (const key of Reflect.ownKeys(obj)) {
      if (seen.has(key)) continue;
      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
      if (typeof _optionalChain([descriptor, 'optionalAccess', _ => _.value]) === "function") {
        seen.add(key);
        self[key] = self[key].bind(self);
      }
    }
  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);
}

// src/lib/querying.ts

function makeThreadsFilter(query) {
  return (thread) => matchesThreadsQuery(thread, query) && matchesMetadata(thread, query);
}
function matchesThreadsQuery(thread, q) {
  return q.resolved === void 0 || thread.resolved === q.resolved;
}
function matchesMetadata(thread, q) {
  const metadata = thread.metadata;
  return q.metadata === void 0 || Object.entries(q.metadata).every(
    ([key, op]) => (
      // Ignore explicit-undefined filters
      // Boolean logic: op? => value matches the operator
      op === void 0 || matchesOperator(metadata[key], op)
    )
  );
}
function matchesOperator(value, op) {
  if (op === null) {
    return value === void 0;
  } else if (_core.isStartsWithOperator.call(void 0, op)) {
    return typeof value === "string" && value.startsWith(op.startsWith);
  } else {
    return value === op;
  }
}
function makeInboxNotificationsFilter(query) {
  return (inboxNotification) => matchesInboxNotificationsQuery(inboxNotification, query);
}
function matchesInboxNotificationsQuery(inboxNotification, q) {
  return (q.roomId === void 0 || q.roomId === inboxNotification.roomId) && (q.kind === void 0 || q.kind === inboxNotification.kind);
}

// src/ThreadDB.ts

function sanitizeThread(thread) {
  if (thread.deletedAt) {
    if (thread.comments.length > 0) {
      return { ...thread, comments: [] };
    }
  }
  const hasComment = thread.comments.some((c) => !c.deletedAt);
  if (!hasComment) {
    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };
  }
  return thread;
}
var ThreadDB = class _ThreadDB {
  #byId;
  #asc;
  #desc;
  // This signal will be notified on every mutation
  
  constructor() {
    this.#asc = _core.SortedList.from([], (t1, t2) => {
      const d1 = t1.createdAt;
      const d2 = t2.createdAt;
      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;
    });
    this.#desc = _core.SortedList.from([], (t1, t2) => {
      const d2 = t2.updatedAt;
      const d1 = t1.updatedAt;
      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;
    });
    this.#byId = /* @__PURE__ */ new Map();
    this.signal = new (0, _core.MutableSignal)(this);
  }
  //
  // Public APIs
  //
  clone() {
    const newPool = new _ThreadDB();
    newPool.#byId = new Map(this.#byId);
    newPool.#asc = this.#asc.clone();
    newPool.#desc = this.#desc.clone();
    return newPool;
  }
  /** Returns an existing thread by ID. Will never return a deleted thread. */
  get(threadId) {
    const thread = this.getEvenIfDeleted(threadId);
    return _optionalChain([thread, 'optionalAccess', _2 => _2.deletedAt]) ? void 0 : thread;
  }
  /** Returns the (possibly deleted) thread by ID. */
  getEvenIfDeleted(threadId) {
    return this.#byId.get(threadId);
  }
  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */
  upsert(thread) {
    this.signal.mutate(() => {
      thread = sanitizeThread(thread);
      const id = thread.id;
      const toRemove = this.#byId.get(id);
      if (toRemove) {
        if (toRemove.deletedAt) return false;
        this.#asc.remove(toRemove);
        this.#desc.remove(toRemove);
      }
      if (!thread.deletedAt) {
        this.#asc.add(thread);
        this.#desc.add(thread);
      }
      this.#byId.set(id, thread);
      return true;
    });
  }
  /** Like .upsert(), except it won't update if a thread by this ID already exists. */
  // TODO Consider renaming this to just .upsert(). I'm not sure if we really
  // TODO need the raw .upsert(). Would be nice if this behavior was the default.
  upsertIfNewer(thread) {
    const existing = this.get(thread.id);
    if (!existing || thread.updatedAt >= existing.updatedAt) {
      this.upsert(thread);
    }
  }
  applyDelta(newThreads, deletedThreads) {
    _core.batch.call(void 0, () => {
      for (const thread of newThreads) {
        this.upsertIfNewer(thread);
      }
      for (const { id, deletedAt } of deletedThreads) {
        const existing = this.getEvenIfDeleted(id);
        if (!existing) continue;
        this.delete(id, deletedAt);
      }
    });
  }
  /**
   * Marks a thread as deleted. It will no longer pop up in .findMany()
   * queries, but it can still be accessed via `.getEvenIfDeleted()`.
   */
  delete(threadId, deletedAt) {
    const existing = this.#byId.get(threadId);
    if (existing && !existing.deletedAt) {
      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });
    }
  }
  /**
   * Returns all threads matching a given roomId and query. If roomId is not
   * specified, it will return all threads matching the query, across all
   * rooms.
   *
   * Returns the results in the requested order. Please note:
   *   'asc'  means by createdAt ASC
   *   'desc' means by updatedAt DESC
   *
   * Will never return deleted threads in the result.
   */
  findMany(roomId, query, direction) {
    const index = direction === "desc" ? this.#desc : this.#asc;
    const crit = [];
    if (roomId !== void 0) {
      crit.push((t) => t.roomId === roomId);
    }
    if (query !== void 0) {
      crit.push(makeThreadsFilter(query));
    }
    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));
  }
};

// src/umbrella-store.ts
function makeRoomThreadsQueryKey(roomId, query) {
  return _core.stableStringify.call(void 0, [roomId, _nullishCoalesce(query, () => ( {}))]);
}
function makeUserThreadsQueryKey(query) {
  return _core.stableStringify.call(void 0, _nullishCoalesce(query, () => ( {})));
}
function makeAiChatsQueryKey(query) {
  return _core.stableStringify.call(void 0, _nullishCoalesce(query, () => ( {})));
}
function makeInboxNotificationsQueryKey(query) {
  return _core.stableStringify.call(void 0, _nullishCoalesce(query, () => ( {})));
}
function usify(promise) {
  if ("status" in promise) {
    return promise;
  }
  const usable = promise;
  usable.status = "pending";
  usable.then(
    (value) => {
      usable.status = "fulfilled";
      usable.value = value;
    },
    (err) => {
      usable.status = "rejected";
      usable.reason = err;
    }
  );
  return usable;
}
var noop = Promise.resolve();
var PaginatedResource = class {
  #signal;
  
  #fetchPage;
  #pendingFetchMore;
  constructor(fetchPage) {
    this.#signal = new (0, _core.Signal)(ASYNC_LOADING);
    this.#fetchPage = fetchPage;
    this.#pendingFetchMore = null;
    this.signal = this.#signal.asReadonly();
    autobind(this);
  }
  get() {
    return this.#signal.get();
  }
  #patch(patch) {
    const state = this.#signal.get();
    if (state.data === void 0) return;
    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));
  }
  async #fetchMore() {
    const state = this.#signal.get();
    if (!_optionalChain([state, 'access', _3 => _3.data, 'optionalAccess', _4 => _4.cursor]) || state.data.isFetchingMore) {
      return;
    }
    this.#patch({ isFetchingMore: true });
    try {
      const nextCursor = await this.#fetchPage(state.data.cursor);
      this.#patch({
        cursor: nextCursor,
        hasFetchedAll: nextCursor === null,
        fetchMoreError: void 0,
        isFetchingMore: false
      });
    } catch (err) {
      this.#patch({
        isFetchingMore: false,
        fetchMoreError: err
      });
    }
  }
  fetchMore() {
    const state = this.#signal.get();
    if (!_optionalChain([state, 'access', _5 => _5.data, 'optionalAccess', _6 => _6.cursor])) return noop;
    if (!this.#pendingFetchMore) {
      this.#pendingFetchMore = this.#fetchMore().finally(() => {
        this.#pendingFetchMore = null;
      });
    }
    return this.#pendingFetchMore;
  }
  #cachedPromise = null;
  waitUntilLoaded() {
    if (this.#cachedPromise) {
      return this.#cachedPromise;
    }
    const initialPageFetch$ = _core.autoRetry.call(void 0, 
      () => this.#fetchPage(
        /* cursor */
        void 0
      ),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(initialPageFetch$);
    promise.then(
      (cursor) => {
        this.#signal.set(
          ASYNC_OK({
            cursor,
            hasFetchedAll: cursor === null,
            isFetchingMore: false,
            fetchMoreError: void 0,
            fetchMore: this.fetchMore
          })
        );
      },
      (err) => {
        this.#signal.set(ASYNC_ERR(err));
        setTimeout(() => {
          this.#cachedPromise = null;
          this.#signal.set(ASYNC_LOADING);
        }, 5e3);
      }
    );
    this.#cachedPromise = promise;
    return this.#cachedPromise;
  }
};
var SinglePageResource = class {
  #signal;
  
  #fetchPage;
  constructor(fetchPage) {
    this.#signal = new (0, _core.Signal)(ASYNC_LOADING);
    this.signal = this.#signal.asReadonly();
    this.#fetchPage = fetchPage;
    autobind(this);
  }
  get() {
    return this.#signal.get();
  }
  #cachedPromise = null;
  waitUntilLoaded() {
    if (this.#cachedPromise) {
      return this.#cachedPromise;
    }
    const initialFetcher$ = _core.autoRetry.call(void 0, 
      () => this.#fetchPage(),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(initialFetcher$);
    promise.then(
      () => {
        this.#signal.set(ASYNC_OK(void 0));
      },
      (err) => {
        this.#signal.set(ASYNC_ERR(err));
        setTimeout(() => {
          this.#cachedPromise = null;
          this.#signal.set(ASYNC_LOADING);
        }, 5e3);
      }
    );
    this.#cachedPromise = promise;
    return promise;
  }
};
function createStore_forNotifications() {
  const signal = new (0, _core.MutableSignal)(/* @__PURE__ */ new Map());
  function markRead(notificationId, readAt) {
    signal.mutate((lut) => {
      const existing = lut.get(notificationId);
      if (!existing) {
        return false;
      }
      lut.set(notificationId, { ...existing, readAt });
      return true;
    });
  }
  function markAllRead(readAt) {
    signal.mutate((lut) => {
      for (const n of lut.values()) {
        n.readAt = readAt;
      }
    });
  }
  function deleteOne(inboxNotificationId) {
    signal.mutate((lut) => lut.delete(inboxNotificationId));
  }
  function clear() {
    signal.mutate((lut) => lut.clear());
  }
  function applyDelta(newNotifications, deletedNotifications) {
    signal.mutate((lut) => {
      let mutated = false;
      for (const n of newNotifications) {
        const existing = lut.get(n.id);
        if (existing) {
          const result = compareInboxNotifications(existing, n);
          if (result === 1) continue;
        }
        lut.set(n.id, n);
        mutated = true;
      }
      for (const n of deletedNotifications) {
        lut.delete(n.id);
        mutated = true;
      }
      return mutated;
    });
  }
  function updateAssociatedNotification(newComment) {
    signal.mutate((lut) => {
      const existing = find(
        lut.values(),
        (notification) => notification.kind === "thread" && notification.threadId === newComment.threadId
      );
      if (!existing) return false;
      lut.set(existing.id, {
        ...existing,
        notifiedAt: newComment.createdAt,
        readAt: newComment.createdAt
      });
      return true;
    });
  }
  function upsert(notification) {
    signal.mutate((lut) => {
      lut.set(notification.id, notification);
    });
  }
  return {
    signal: signal.asReadonly(),
    // Mutations
    markAllRead,
    markRead,
    delete: deleteOne,
    applyDelta,
    clear,
    updateAssociatedNotification,
    upsert
  };
}
function createStore_forSubscriptions(updates, threads) {
  const baseSignal = new (0, _core.MutableSignal)(/* @__PURE__ */ new Map());
  function applyDelta(newSubscriptions, deletedSubscriptions) {
    baseSignal.mutate((lut) => {
      let mutated = false;
      for (const s of newSubscriptions) {
        lut.set(_core.getSubscriptionKey.call(void 0, s), s);
        mutated = true;
      }
      for (const s of deletedSubscriptions) {
        lut.delete(_core.getSubscriptionKey.call(void 0, s));
        mutated = true;
      }
      return mutated;
    });
  }
  function create(subscription) {
    baseSignal.mutate((lut) => {
      lut.set(_core.getSubscriptionKey.call(void 0, subscription), subscription);
    });
  }
  function deleteOne(subscriptionKey) {
    baseSignal.mutate((lut) => {
      lut.delete(subscriptionKey);
    });
  }
  return {
    signal: _core.DerivedSignal.from(
      baseSignal,
      updates,
      (base, updates2) => applyOptimisticUpdates_forSubscriptions(base, threads, updates2)
    ),
    // Mutations
    applyDelta,
    create,
    delete: deleteOne
  };
}
function createStore_forRoomSubscriptionSettings(updates) {
  const baseSignal = new (0, _core.MutableSignal)(/* @__PURE__ */ new Map());
  function update(roomId, settings) {
    baseSignal.mutate((lut) => {
      lut.set(roomId, settings);
    });
  }
  return {
    signal: _core.DerivedSignal.from(
      baseSignal,
      updates,
      (base, updates2) => applyOptimisticUpdates_forRoomSubscriptionSettings(base, updates2)
    ),
    // Mutations
    update
  };
}
function createStore_forHistoryVersions() {
  const baseSignal = new (0, _core.MutableSignal)(
    new (0, _core.DefaultMap)(() => /* @__PURE__ */ new Map())
  );
  function update(roomId, versions) {
    baseSignal.mutate((lut) => {
      const versionsById = lut.getOrCreate(roomId);
      for (const version of versions) {
        versionsById.set(version.id, version);
      }
    });
  }
  return {
    signal: _core.DerivedSignal.from(
      baseSignal,
      (hv) => Object.fromEntries(
        [...hv].map(([roomId, versions]) => [
          roomId,
          Object.fromEntries(versions)
        ])
      )
    ),
    // Mutations
    update
  };
}
function createStore_forPermissionHints() {
  const permissionsByRoomId = new (0, _core.DefaultMap)(
    () => new (0, _core.Signal)(/* @__PURE__ */ new Set())
  );
  function update(newHints) {
    _core.batch.call(void 0, () => {
      for (const [roomId, permissions] of Object.entries(newHints)) {
        const signal = permissionsByRoomId.getOrCreate(roomId);
        const existingPermissions = new Set(signal.get());
        for (const permission of permissions) {
          existingPermissions.add(permission);
        }
        signal.set(existingPermissions);
      }
    });
  }
  function getPermissionForRoom\u03A3(roomId) {
    return permissionsByRoomId.getOrCreate(roomId);
  }
  return {
    getPermissionForRoom\u03A3,
    // Mutations
    update
  };
}
function createStore_forNotificationSettings(updates) {
  const signal = new (0, _core.Signal)(
    _core.createNotificationSettings.call(void 0, {})
  );
  function update(settings) {
    signal.set(settings);
  }
  return {
    signal: _core.DerivedSignal.from(
      signal,
      updates,
      (base, updates2) => applyOptimisticUpdates_forNotificationSettings(base, updates2)
    ),
    // Mutations
    update
  };
}
function createStore_forOptimistic(client) {
  const signal = new (0, _core.Signal)([]);
  const syncSource = client[_core.kInternal].createSyncSource();
  signal.subscribe(
    () => syncSource.setSyncStatus(
      signal.get().length > 0 ? "synchronizing" : "synchronized"
    )
  );
  function add(optimisticUpdate) {
    const id = _core.nanoid.call(void 0, );
    const newUpdate = { ...optimisticUpdate, id };
    signal.set((state) => [...state, newUpdate]);
    return id;
  }
  function remove(optimisticId) {
    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));
  }
  return {
    signal: signal.asReadonly(),
    // Mutations
    add,
    remove
  };
}
var UmbrellaStore = class {
  #client;
  //
  // Internally, the UmbrellaStore keeps track of a few source signals that can
  // be set and mutated individually. When any of those are mutated then the
  // clean "external state" is recomputed.
  //
  //   Mutate inputs...                                             ...observe clean/consistent output!
  //
  //            .-> Base ThreadDB ---------+                 +-------> Clean threads by ID         (Part 1)
  //           /                           |                 |
  //   mutate ----> Base Notifications --+ |                 | +-----> Clean notifications         (Part 1)
  //          \                          | |                 | |       & notifications by ID
  //         | \                         | |      Apply      | |
  //         |   `-> OptimisticUpdates --+--+--> Optimistic -+-+-+-+-> Subscriptions               (Part 2)
  //          \                          |        Updates    |   | |
  //           `------- etc etc ---------+                   |   | +-> History Versions            (Part 3)
  //                       ^                                 |   |
  //                       |                                 |   +---> Room Subscription Settings  (Part 4)
  //                       |                                 |
  //                       |                                 +-------> Notification Settings       (Part 5)
  //                       |
  //                       |
  //                       |                        ^                  ^
  //                    Signal                      |                  |
  //                      or                   DerivedSignal      DerivedSignals
  //                  MutableSignal
  //
  //
  // Input signals.
  // (Can be mutated directly.)
  //
  // XXX_vincent Now that we have createStore_forX, we should probably also change
  // `threads` to this pattern, ie create a createStore_forThreads helper as
  // well. It almost works like that already anyway!
  
  // Exposes its signal under `.signal` prop
  
  
  
  // prettier-ignore
  
  
  
  
  //
  // Output signals.
  // (Readonly, clean, consistent. With optimistic updates applied.)
  //
  // Note that the output of threadifications signal is the same as the ones for
  // threads and notifications separately, but the threadifications signal will
  // be updated whenever either of them change.
  //
  
  // Notifications
  #notificationsLastRequestedAt = null;
  // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.
  // Room Threads
  #roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
  // User Threads
  #userThreadsLastRequestedAt = null;
  // Room versions
  #roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
  // Notification Settings
  #notificationSettings;
  constructor(client) {
    this.#client = client[_core.kInternal].as();
    this.optimisticUpdates = createStore_forOptimistic(this.#client);
    this.permissionHints = createStore_forPermissionHints();
    const notificationSettingsFetcher = async () => {
      const result = await this.#client.getNotificationSettings();
      this.notificationSettings.update(result);
    };
    this.notificationSettings = createStore_forNotificationSettings(
      this.optimisticUpdates.signal
    );
    this.#notificationSettings = new SinglePageResource(
      notificationSettingsFetcher
    );
    this.threads = new ThreadDB();
    this.subscriptions = createStore_forSubscriptions(
      this.optimisticUpdates.signal,
      this.threads
    );
    this.notifications = createStore_forNotifications();
    this.roomSubscriptionSettings = createStore_forRoomSubscriptionSettings(
      this.optimisticUpdates.signal
    );
    this.historyVersions = createStore_forHistoryVersions();
    const threadifications = _core.DerivedSignal.from(
      this.threads.signal,
      this.notifications.signal,
      this.optimisticUpdates.signal,
      (ts, ns, updates) => applyOptimisticUpdates_forThreadifications(ts, ns, updates)
    );
    const threads = _core.DerivedSignal.from(threadifications, (s) => s.threadsDB);
    const notifications = _core.DerivedSignal.from(
      threadifications,
      (s) => ({
        sortedNotifications: s.sortedNotifications,
        notificationsById: s.notificationsById
      }),
      _core.shallow
    );
    const threadSubscriptions = _core.DerivedSignal.from(
      notifications,
      this.subscriptions.signal,
      (n, s) => ({
        subscriptions: s,
        notifications: n.sortedNotifications
      })
    );
    const loadingUserThreads = new (0, _core.DefaultMap)(
      (queryKey) => {
        const query = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await this.#client[_core.kInternal].httpClient.getUserThreads_experimental({
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications,
            result.subscriptions
          );
          this.permissionHints.update(result.permissionHints);
          if (this.#userThreadsLastRequestedAt === null) {
            this.#userThreadsLastRequestedAt = result.requestedAt;
          }
          return result.nextCursor;
        });
        const signal = _core.DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const threads2 = this.outputs.threads.get().findMany(
            void 0,
            // Do _not_ filter by roomId
            _nullishCoalesce(query, () => ( {})),
            "desc"
          );
          const page = result.data;
          return {
            isLoading: false,
            threads: threads2,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, _core.shallow2);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const loadingRoomThreads = new (0, _core.DefaultMap)(
      (queryKey) => {
        const [roomId, query] = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await this.#client[_core.kInternal].httpClient.getThreads({
            roomId,
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications,
            result.subscriptions
          );
          this.permissionHints.update(result.permissionHints);
          const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
            this.#roomThreadsLastRequestedAtByRoom.set(
              roomId,
              result.requestedAt
            );
          }
          return result.nextCursor;
        });
        const signal = _core.DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const threads2 = this.outputs.threads.get().findMany(roomId, _nullishCoalesce(query, () => ( {})), "asc");
          const page = result.data;
          return {
            isLoading: false,
            threads: threads2,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, _core.shallow2);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const loadingNotifications = new (0, _core.DefaultMap)(
      (queryKey) => {
        const query = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await this.#client.getInboxNotifications({
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications,
            result.subscriptions
          );
          if (this.#notificationsLastRequestedAt === null) {
            this.#notificationsLastRequestedAt = result.requestedAt;
          }
          const nextCursor = result.nextCursor;
          return nextCursor;
        });
        const signal = _core.DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const crit = [];
          if (query !== void 0) {
            crit.push(makeInboxNotificationsFilter(query));
          }
          const inboxNotifications = this.outputs.notifications.get().sortedNotifications.filter(
            (inboxNotification) => crit.every((pred) => pred(inboxNotification))
          );
          const page = result.data;
          return {
            isLoading: false,
            inboxNotifications,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, _core.shallow2);
        return {
          signal,
          waitUntilLoaded: resource.waitUntilLoaded
        };
      }
    );
    const roomSubscriptionSettingsByRoomId = new (0, _core.DefaultMap)(
      (roomId) => {
        const resource = new SinglePageResource(async () => {
          const room = this.#client.getRoom(roomId);
          if (room === null) {
            throw new Error(`Room '${roomId}' is not available on client`);
          }
          const result = await room.getSubscriptionSettings();
          this.roomSubscriptionSettings.update(roomId, result);
        });
        const signal = _core.DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          } else {
            return ASYNC_OK(
              "settings",
              _core.nn.call(void 0, this.roomSubscriptionSettings.signal.get()[roomId])
            );
          }
        }, _core.shallow);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const versionsByRoomId = new (0, _core.DefaultMap)(
      (roomId) => {
        const resource = new SinglePageResource(async () => {
          const room = this.#client.getRoom(roomId);
          if (room === null) {
            throw new Error(`Room '${roomId}' is not available on client`);
          }
          const result = await room[_core.kInternal].listTextVersions();
          this.historyVersions.update(roomId, result.versions);
          const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
            this.#roomVersionsLastRequestedAtByRoom.set(
              roomId,
              result.requestedAt
            );
          }
        });
        const signal = _core.DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          } else {
            return ASYNC_OK(
              "versions",
              Object.values(_nullishCoalesce(this.historyVersions.signal.get()[roomId], () => ( {})))
            );
          }
        }, _core.shallow);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const notificationSettings = {
      signal: _core.DerivedSignal.from(() => {
        const result = this.#notificationSettings.get();
        if (result.isLoading || result.error) {
          return result;
        }
        return ASYNC_OK(
          "settings",
          _core.nn.call(void 0, this.notificationSettings.signal.get())
        );
      }, _core.shallow),
      waitUntilLoaded: this.#notificationSettings.waitUntilLoaded
    };
    const aiChats = new (0, _core.DefaultMap)(
      (queryKey) => {
        const query = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await this.#client[_core.kInternal].ai.getChats({
            cursor,
            query
          });
          return result.nextCursor;
        });
        const signal = _core.DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const chats = this.#client[_core.kInternal].ai.queryChats(query);
          return {
            isLoading: false,
            chats,
            hasFetchedAll: result.data.hasFetchedAll,
            isFetchingMore: result.data.isFetchingMore,
            fetchMore: result.data.fetchMore,
            fetchMoreError: result.data.fetchMoreError
          };
        }, _core.shallow);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const messagesByChatId = new (0, _core.DefaultMap)((chatId) => {
      const resource\u03A3 = new SinglePageResource(async () => {
        await this.#client[_core.kInternal].ai.getMessageTree(chatId);
      });
      return new (0, _core.DefaultMap)(
        (branch) => {
          const signal = _core.DerivedSignal.from(() => {
            const result = resource\u03A3.get();
            if (result.isLoading || result.error) {
              return result;
            }
            return ASYNC_OK(
              "messages",
              this.#client[_core.kInternal].ai.signals.getChatMessagesForBranch\u03A3(chatId, _nullishCoalesce(branch, () => ( void 0))).get()
            );
          });
          return { signal, waitUntilLoaded: resource\u03A3.waitUntilLoaded };
        }
      );
    });
    const aiChatById = new (0, _core.DefaultMap)((chatId) => {
      const resource = new SinglePageResource(async () => {
        await this.#client[_core.kInternal].ai.getOrCreateChat(chatId);
      });
      const signal = _core.DerivedSignal.from(() => {
        const chat = this.#client[_core.kInternal].ai.getChatById(chatId);
        if (chat === void 0) {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          } else {
            return ASYNC_OK(
              "chat",
              _core.nn.call(void 0, this.#client[_core.kInternal].ai.getChatById(chatId))
            );
          }
        } else {
          return ASYNC_OK(
            "chat",
            _core.nn.call(void 0, this.#client[_core.kInternal].ai.getChatById(chatId))
          );
        }
      }, _core.shallow);
      return { signal, waitUntilLoaded: resource.waitUntilLoaded };
    });
    this.outputs = {
      threadifications,
      threads,
      loadingRoomThreads,
      loadingUserThreads,
      notifications,
      loadingNotifications,
      roomSubscriptionSettingsByRoomId,
      versionsByRoomId,
      notificationSettings,
      threadSubscriptions,
      aiChats,
      messagesByChatId,
      aiChatById
    };
    autobind(this);
  }
  /**
   * Updates an existing inbox notification with a new value, replacing the
   * corresponding optimistic update.
   *
   * This will not update anything if the inbox notification ID isn't found.
   */
  markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.markRead(inboxNotificationId, readAt);
    });
  }
  markAllInboxNotificationsRead(optimisticId, readAt) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.markAllRead(readAt);
    });
  }
  /**
   * Deletes an existing inbox notification, replacing the corresponding
   * optimistic update.
   */
  deleteInboxNotification(inboxNotificationId, optimisticId) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.delete(inboxNotificationId);
    });
  }
  /**
   * Deletes *all* inbox notifications, replacing the corresponding optimistic
   * update.
   */
  deleteAllInboxNotifications(optimisticId) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.clear();
    });
  }
  /**
   * Creates an existing subscription, replacing the corresponding
   * optimistic update.
   */
  createSubscription(subscription, optimisticId) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.subscriptions.create(subscription);
    });
  }
  /**
   * Deletes an existing subscription, replacing the corresponding
   * optimistic update.
   */
  deleteSubscription(subscriptionKey, optimisticId) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.subscriptions.delete(subscriptionKey);
    });
  }
  /**
   * Creates an new thread, replacing the corresponding optimistic update.
   */
  createThread(optimisticId, thread) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.threads.upsert(thread);
    });
  }
  /**
   * Updates an existing thread with a new value, replacing the corresponding
   * optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted; or
   * - The thread ID was updated more recently than the optimistic update's
   *   timestamp (if given)
   */
  #updateThread(threadId, optimisticId, callback, updatedAt) {
    _core.batch.call(void 0, () => {
      if (optimisticId !== null) {
        this.optimisticUpdates.remove(optimisticId);
      }
      const db = this.threads;
      const existing = db.get(threadId);
      if (!existing) return;
      if (!!updatedAt && existing.updatedAt > updatedAt) return;
      db.upsert(callback(existing));
    });
  }
  patchThread(threadId, optimisticId, patch, updatedAt) {
    return this.#updateThread(
      threadId,
      optimisticId,
      (thread) => ({ ...thread, ..._core.compactObject.call(void 0, patch) }),
      updatedAt
    );
  }
  addReaction(threadId, optimisticId, commentId, reaction, createdAt) {
    this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyAddReaction(thread, commentId, reaction),
      createdAt
    );
  }
  removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {
    this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),
      removedAt
    );
  }
  /**
   * Soft-deletes an existing thread by setting its `deletedAt` value,
   * replacing the corresponding optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted
   */
  deleteThread(threadId, optimisticId) {
    return this.#updateThread(
      threadId,
      optimisticId,
      // A deletion is actually an update of the deletedAt property internally
      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })
    );
  }
  /**
   * Creates an existing comment and ensures the associated notification is
   * updated correctly, replacing the corresponding optimistic update.
   */
  createComment(newComment, optimisticId) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      const existingThread = this.threads.get(newComment.threadId);
      if (!existingThread) {
        return;
      }
      this.threads.upsert(applyUpsertComment(existingThread, newComment));
      this.notifications.updateAssociatedNotification(newComment);
    });
  }
  editComment(threadId, optimisticId, editedComment) {
    return this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyUpsertComment(thread, editedComment)
    );
  }
  deleteComment(threadId, optimisticId, commentId, deletedAt) {
    return this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyDeleteComment(thread, commentId, deletedAt),
      deletedAt
    );
  }
  updateThreadifications(threads, notifications, subscriptions, deletedThreads = [], deletedNotifications = [], deletedSubscriptions = []) {
    _core.batch.call(void 0, () => {
      this.threads.applyDelta(threads, deletedThreads);
      this.notifications.applyDelta(notifications, deletedNotifications);
      this.subscriptions.applyDelta(subscriptions, deletedSubscriptions);
    });
  }
  /**
   * Updates existing subscription settings for a room with a new value,
   * replacing the corresponding optimistic update.
   */
  updateRoomSubscriptionSettings(roomId, optimisticId, settings) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticId);
      this.roomSubscriptionSettings.update(roomId, settings);
    });
  }
  async fetchNotificationsDeltaUpdate(signal) {
    const lastRequestedAt = this.#notificationsLastRequestedAt;
    if (lastRequestedAt === null) {
      return;
    }
    const result = await this.#client.getInboxNotificationsSince({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      this.#notificationsLastRequestedAt = result.requestedAt;
    }
    this.updateThreadifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.subscriptions.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted,
      result.subscriptions.deleted
    );
  }
  async fetchRoomThreadsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const updates = await this.#client[_core.kInternal].httpClient.getThreadsSince({
      roomId,
      since: lastRequestedAt,
      signal
    });
    this.updateThreadifications(
      updates.threads.updated,
      updates.inboxNotifications.updated,
      updates.subscriptions.updated,
      updates.threads.deleted,
      updates.inboxNotifications.deleted,
      updates.subscriptions.deleted
    );
    this.permissionHints.update(updates.permissionHints);
    if (lastRequestedAt < updates.requestedAt) {
      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
    }
  }
  async fetchUserThreadsDeltaUpdate(signal) {
    const lastRequestedAt = this.#userThreadsLastRequestedAt;
    if (lastRequestedAt === null) {
      return;
    }
    const result = await this.#client[_core.kInternal].httpClient.getUserThreadsSince_experimental({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      this.#notificationsLastRequestedAt = result.requestedAt;
    }
    this.updateThreadifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.subscriptions.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted,
      result.subscriptions.deleted
    );
    this.permissionHints.update(result.permissionHints);
  }
  async fetchRoomVersionsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const room = _core.nn.call(void 0, 
      this.#client.getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const updates = await room[_core.kInternal].listTextVersionsSince({
      since: lastRequestedAt,
      signal
    });
    this.historyVersions.update(roomId, updates.versions);
    if (lastRequestedAt < updates.requestedAt) {
      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
    }
  }
  async refreshRoomSubscriptionSettings(roomId, signal) {
    const room = _core.nn.call(void 0, 
      this.#client.getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const result = await room.getSubscriptionSettings({ signal });
    this.roomSubscriptionSettings.update(roomId, result);
  }
  /**
   * Refresh notification settings from poller
   */
  async refreshNotificationSettings(signal) {
    const result = await this.#client.getNotificationSettings({
      signal
    });
    this.notificationSettings.update(result);
  }
  /**
   * Updates notification settings with a new value, replacing the
   * corresponding optimistic update.
   */
  updateNotificationSettings_confirmOptimisticUpdate(settings, optimisticUpdateId) {
    _core.batch.call(void 0, () => {
      this.optimisticUpdates.remove(optimisticUpdateId);
      this.notificationSettings.update(settings);
    });
  }
};
function applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {
  const threadsDB = baseThreadsDB.clone();
  let notificationsById = Object.fromEntries(notificationsLUT);
  for (const optimisticUpdate of optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "create-thread": {
        threadsDB.upsert(optimisticUpdate.thread);
        break;
      }
      case "edit-thread-metadata": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        if (thread.updatedAt > optimisticUpdate.updatedAt) {
          break;
        }
        threadsDB.upsert({
          ...thread,
          updatedAt: optimisticUpdate.updatedAt,
          metadata: {
            ...thread.metadata,
            ...optimisticUpdate.metadata
          }
        });
        break;
      }
      case "mark-thread-as-resolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: true });
        break;
      }
      case "mark-thread-as-unresolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: false });
        break;
      }
      case "create-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        const inboxNotification = Object.values(notificationsById).find(
          (notification) => notification.kind === "thread" && notification.threadId === thread.id
        );
        if (inboxNotification === void 0) {
          break;
        }
        notificationsById[inboxNotification.id] = {
          ...inboxNotification,
          notifiedAt: optimisticUpdate.comment.createdAt,
          readAt: optimisticUpdate.comment.createdAt
        };
        break;
      }
      case "edit-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        break;
      }
      case "delete-comment": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyDeleteComment(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.deletedAt
          )
        );
        break;
      }
      case "delete-thread": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({
          ...thread,
          deletedAt: optimisticUpdate.deletedAt,
          updatedAt: optimisticUpdate.deletedAt,
          comments: []
        });
        break;
      }
      case "add-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyAddReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.reaction
          )
        );
        break;
      }
      case "remove-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyRemoveReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.emoji,
            optimisticUpdate.userId,
            optimisticUpdate.removedAt
          )
        );
        break;
      }
      case "mark-inbox-notification-as-read": {
        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];
        if (ibn === void 0) {
          break;
        }
        notificationsById[optimisticUpdate.inboxNotificationId] = {
          ...ibn,
          readAt: optimisticUpdate.readAt
        };
        break;
      }
      case "mark-all-inbox-notifications-as-read": {
        for (const id in notificationsById) {
          const ibn = notificationsById[id];
          if (ibn === void 0) {
            break;
          }
          notificationsById[id] = {
            ...ibn,
            readAt: optimisticUpdate.readAt
          };
        }
        break;
      }
      case "delete-inbox-notification": {
        delete notificationsById[optimisticUpdate.inboxNotificationId];
        break;
      }
      case "delete-all-inbox-notifications": {
        notificationsById = {};
        break;
      }
    }
  }
  const sortedNotifications = (
    // Sort so that the most recent notifications are first
    Object.values(notificationsById).filter(
      (ibn) => ibn.kind === "thread" ? threadsDB.get(ibn.threadId) !== void 0 : true
    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())
  );
  return {
    sortedNotifications,
    notificationsById,
    threadsDB
  };
}
function applyOptimisticUpdates_forRoomSubscriptionSettings(settingsLUT, optimisticUpdates) {
  const roomSubscriptionSettingsByRoomId = Object.fromEntries(settingsLUT);
  for (const optimisticUpdate of optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "update-room-subscription-settings": {
        const settings = roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId];
        if (settings === void 0) {
          break;
        }
        roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId] = {
          ...settings,
          ...optimisticUpdate.settings
        };
      }
    }
  }
  return roomSubscriptionSettingsByRoomId;
}
function applyOptimisticUpdates_forSubscriptions(subscriptionsLUT, threads, optimisticUpdates) {
  const subscriptions = Object.fromEntries(subscriptionsLUT);
  for (const update of optimisticUpdates) {
    switch (update.type) {
      case "update-room-subscription-settings": {
        if (!update.settings.threads) {
          continue;
        }
        const roomThreads = threads.findMany(update.roomId, void 0, "desc");
        for (const thread of roomThreads) {
          const subscriptionKey = _core.getSubscriptionKey.call(void 0, "thread", thread.id);
          switch (update.settings.threads) {
            // Create subscriptions for all existing threads in the room
            case "all": {
              subscriptions[subscriptionKey] = {
                kind: "thread",
                subjectId: thread.id,
                createdAt: /* @__PURE__ */ new Date()
              };
              break;
            }
            // Delete subscriptions for all existing threads in the room
            case "none": {
              delete subscriptions[subscriptionKey];
              break;
            }
            case "replies_and_mentions": {
              break;
            }
            default:
              _core.assertNever.call(void 0, 
                update.settings.threads,
                "Unexpected thread subscription settings."
              );
          }
        }
      }
    }
  }
  return subscriptions;
}
function applyOptimisticUpdates_forNotificationSettings(settings, optimisticUpdates) {
  let outcoming = settings;
  for (const update of optimisticUpdates) {
    if (update.type === "update-notification-settings") {
      outcoming = _core.patchNotificationSettings.call(void 0, outcoming, update.settings);
    }
  }
  return outcoming;
}
function compareInboxNotifications(inboxNotificationA, inboxNotificationB) {
  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {
    return 1;
  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {
    return -1;
  }
  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {
    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;
  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {
    return inboxNotificationA.readAt ? 1 : -1;
  }
  return 0;
}
function applyUpsertComment(thread, comment) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  if (comment.threadId !== thread.id) {
    _core.console.warn(
      `Comment ${comment.id} does not belong to thread ${thread.id}`
    );
    return thread;
  }
  const existingComment = thread.comments.find(
    (existingComment2) => existingComment2.id === comment.id
  );
  if (existingComment === void 0) {
    const updatedAt = new Date(
      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())
    );
    const updatedThread = {
      ...thread,
      updatedAt,
      comments: [...thread.comments, comment]
    };
    return updatedThread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {
    const updatedComments = thread.comments.map(
      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2
    );
    const updatedThread = {
      ...thread,
      updatedAt: new Date(
        Math.max(
          thread.updatedAt.getTime(),
          _optionalChain([comment, 'access', _7 => _7.editedAt, 'optionalAccess', _8 => _8.getTime, 'call', _9 => _9()]) || comment.createdAt.getTime()
        )
      ),
      comments: updatedComments
    };
    return updatedThread;
  }
  return thread;
}
function applyDeleteComment(thread, commentId, deletedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      deletedAt,
      // We optimistically remove the comment body and attachments when marking it as deleted
      body: void 0,
      attachments: []
    } : comment
  );
  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {
    return {
      ...thread,
      deletedAt,
      updatedAt: deletedAt
    };
  }
  return {
    ...thread,
    updatedAt: deletedAt,
    comments: updatedComments
  };
}
function applyAddReaction(thread, commentId, reaction) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: upsertReaction(comment.reactions, reaction)
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: comment.reactions.map(
        (reaction) => reaction.emoji === emoji ? {
          ...reaction,
          users: reaction.users.filter((user) => user.id !== userId)
        } : reaction
      ).filter((reaction) => reaction.users.length > 0)
      // Remove reactions with no users left
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(removedAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function upsertReaction(reactions, reaction) {
  const existingReaction = reactions.find(
    (existingReaction2) => existingReaction2.emoji === reaction.emoji
  );
  if (existingReaction === void 0) {
    return [
      ...reactions,
      {
        emoji: reaction.emoji,
        createdAt: reaction.createdAt,
        users: [{ id: reaction.userId }]
      }
    ];
  }
  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {
    return reactions.map(
      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {
        ...existingReaction2,
        users: [...existingReaction2.users, { id: reaction.userId }]
      } : existingReaction2
    );
  }
  return reactions;
}

// src/liveblocks.tsx
var _jsxruntime = require('react/jsx-runtime');
function missingUserError(userId) {
  return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
  return new Error(
    `resolveRoomsInfo didn't return anything for room '${roomId}'`
  );
}
function missingGroupInfoError(groupId) {
  return new Error(
    `resolveGroupsInfo didn't return anything for group '${groupId}'`
  );
}
function identity2(x) {
  return x;
}
var _umbrellaStores = /* @__PURE__ */ new WeakMap();
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
function selectorFor_useUnreadInboxNotificationsCount(result) {
  if (!result.inboxNotifications) {
    return result;
  }
  return ASYNC_OK(
    "count",
    count(
      result.inboxNotifications,
      (n) => n.readAt === null || n.readAt < n.notifiedAt
    )
  );
}
function selectorFor_useUser(state, userId) {
  if (state === void 0 || _optionalChain([state, 'optionalAccess', _10 => _10.isLoading])) {
    return _nullishCoalesce(state, () => ( { isLoading: true }));
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingUserError(userId)
    };
  }
  return {
    isLoading: false,
    user: state.data
  };
}
function selectorFor_useRoomInfo(state, roomId) {
  if (state === void 0 || _optionalChain([state, 'optionalAccess', _11 => _11.isLoading])) {
    return _nullishCoalesce(state, () => ( { isLoading: true }));
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingRoomInfoError(roomId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function selectorFor_useGroupInfo(state, groupId) {
  if (state === void 0 || _optionalChain([state, 'optionalAccess', _12 => _12.isLoading])) {
    return _nullishCoalesce(state, () => ( { isLoading: true }));
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingGroupInfoError(groupId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function getOrCreateContextBundle(client) {
  let bundle = _bundles.get(client);
  if (!bundle) {
    bundle = makeLiveblocksContextBundle(client);
    _bundles.set(client, bundle);
  }
  return bundle;
}
function getUmbrellaStoreForClient(client) {
  let store = _umbrellaStores.get(client);
  if (!store) {
    store = new UmbrellaStore(client);
    _umbrellaStores.set(client, store);
  }
  return store;
}
function getLiveblocksExtrasForClient(client) {
  let extras = _extras.get(client);
  if (!extras) {
    extras = makeLiveblocksExtrasForClient(client);
    _extras.set(client, extras);
  }
  return extras;
}
function useEnsureAiConnection(client) {
  _react.useEffect.call(void 0, () => {
    client[_core.kInternal].ai.connectInitially();
  }, [client]);
}
function makeLiveblocksExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  const notificationsPoller = _core.makePoller.call(void 0, 
    async (signal) => {
      try {
        return await store.fetchNotificationsDeltaUpdate(signal);
      } catch (err) {
        _core.console.warn(`Polling new inbox notifications failed: ${String(err)}`);
        throw err;
      }
    },
    config.NOTIFICATIONS_POLL_INTERVAL,
    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }
  );
  const userThreadsPoller = _core.makePoller.call(void 0, 
    async (signal) => {
      try {
        return await store.fetchUserThreadsDeltaUpdate(signal);
      } catch (err) {
        _core.console.warn(`Polling new user threads failed: ${String(err)}`);
        throw err;
      }
    },
    config.USER_THREADS_POLL_INTERVAL,
    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }
  );
  const notificationSettingsPoller = _core.makePoller.call(void 0, 
    async (signal) => {
      try {
        return await store.refreshNotificationSettings(signal);
      } catch (err) {
        _core.console.warn(
          `Polling new notification settings failed: ${String(err)}`
        );
        throw err;
      }
    },
    config.USER_NOTIFICATION_SETTINGS_INTERVAL,
    { maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME }
  );
  return {
    store,
    notificationsPoller,
    userThreadsPoller,
    notificationSettingsPoller
  };
}
function makeLiveblocksContextBundle(client) {
  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);
  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);
  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);
  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);
  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);
  const useUpdateNotificationSettings2 = () => useUpdateNotificationSettings_withClient(client);
  function LiveblocksProvider2(props) {
    useEnsureNoLiveblocksProvider();
    return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, ClientContext.Provider, { value: client, children: props.children });
  }
  const shared = createSharedContext(client);
  const bundle = {
    LiveblocksProvider: LiveblocksProvider2,
    useInboxNotifications: (options) => useInboxNotifications_withClient(client, identity2, _core.shallow, options),
    useUnreadInboxNotificationsCount: (options) => useUnreadInboxNotificationsCount_withClient(client, options),
    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
    useDeleteInboxNotification: useDeleteInboxNotification2,
    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
    useNotificationSettings: () => useNotificationSettings_withClient(client),
    useUpdateNotificationSettings: useUpdateNotificationSettings2,
    useInboxNotificationThread: useInboxNotificationThread2,
    useUserThreads_experimental,
    useAiChats,
    useAiChat,
    useAiChatMessages,
    useCreateAiChat,
    useDeleteAiChat,
    useSendAiMessage,
    ...shared.classic,
    suspense: {
      LiveblocksProvider: LiveblocksProvider2,
      useInboxNotifications: (options) => useInboxNotificationsSuspense_withClient(client, options),
      useUnreadInboxNotificationsCount: (options) => useUnreadInboxNotificationsCountSuspense_withClient(client, options),
      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
      useDeleteInboxNotification: useDeleteInboxNotification2,
      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
      useInboxNotificationThread: useInboxNotificationThread2,
      useNotificationSettings: () => useNotificationSettingsSuspense_withClient(client),
      useUpdateNotificationSettings: useUpdateNotificationSettings2,
      useUserThreads_experimental: useUserThreadsSuspense_experimental,
      useAiChats: useAiChatsSuspense,
      useAiChat: useAiChatSuspense,
      useAiChatMessages: useAiChatMessagesSuspense,
      useCreateAiChat,
      useDeleteAiChat,
      useSendAiMessage,
      ...shared.suspense
    }
  };
  return bundle;
}
function useInboxNotifications_withClient(client, selector, isEqual, options) {
  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);
  const queryKey = makeInboxNotificationsQueryKey(_optionalChain([options, 'optionalAccess', _13 => _13.query]));
  _react.useEffect.call(void 0, 
    () => void store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  _react.useEffect.call(void 0, () => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  return useSignal(
    store.outputs.loadingNotifications.getOrCreate(queryKey).signal,
    selector,
    isEqual
  );
}
function useInboxNotificationsSuspense_withClient(client, options) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  const queryKey = makeInboxNotificationsQueryKey(_optionalChain([options, 'optionalAccess', _14 => _14.query]));
  use(
    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()
  );
  const result = useInboxNotifications_withClient(
    client,
    identity2,
    _core.shallow,
    options
  );
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useUnreadInboxNotificationsCount_withClient(client, options) {
  return useInboxNotifications_withClient(
    client,
    selectorFor_useUnreadInboxNotificationsCount,
    _core.shallow,
    options
  );
}
function useUnreadInboxNotificationsCountSuspense_withClient(client, options) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  const queryKey = makeInboxNotificationsQueryKey(_optionalChain([options, 'optionalAccess', _15 => _15.query]));
  use(
    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()
  );
  const result = useUnreadInboxNotificationsCount_withClient(client, options);
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  _core.assert.call(void 0, !result.error, "Did not expect error");
  return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
  return _react.useCallback.call(void 0, 
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const readAt = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId,
        readAt
      });
      client.markInboxNotificationAsRead(inboxNotificationId).then(
        () => {
          store.markInboxNotificationRead(
            inboxNotificationId,
            readAt,
            optimisticId
          );
        },
        (err) => {
          store.optimisticUpdates.remove(optimisticId);
          client[_core.kInternal].emitError(
            {
              type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
              inboxNotificationId
            },
            err
          );
        }
      );
    },
    [client]
  );
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
  return _react.useCallback.call(void 0, () => {
    const { store } = getLiveblocksExtrasForClient(client);
    const readAt = /* @__PURE__ */ new Date();
    const optimisticId = store.optimisticUpdates.add({
      type: "mark-all-inbox-notifications-as-read",
      readAt
    });
    client.markAllInboxNotificationsAsRead().then(
      () => {
        store.markAllInboxNotificationsRead(optimisticId, readAt);
      },
      (err) => {
        store.optimisticUpdates.remove(optimisticId);
        client[_core.kInternal].emitError(
          // No roomId, threadId, commentId to include for this error
          { type: "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR" },
          err
        );
      }
    );
  }, [client]);
}
function useDeleteInboxNotification_withClient(client) {
  return _react.useCallback.call(void 0, 
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const deletedAt = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-inbox-notification",
        inboxNotificationId,
        deletedAt
      });
      client.deleteInboxNotification(inboxNotificationId).then(
        () => {
          store.deleteInboxNotification(inboxNotificationId, optimisticId);
        },
        (err) => {
          store.optimisticUpdates.remove(optimisticId);
          client[_core.kInternal].emitError(
            { type: "DELETE_INBOX_NOTIFICATION_ERROR", inboxNotificationId },
            err
          );
        }
      );
    },
    [client]
  );
}
function useDeleteAllInboxNotifications_withClient(client) {
  return _react.useCallback.call(void 0, () => {
    const { store } = getLiveblocksExtrasForClient(client);
    const deletedAt = /* @__PURE__ */ new Date();
    const optimisticId = store.optimisticUpdates.add({
      type: "delete-all-inbox-notifications",
      deletedAt
    });
    client.deleteAllInboxNotifications().then(
      () => {
        store.deleteAllInboxNotifications(optimisticId);
      },
      (err) => {
        store.optimisticUpdates.remove(optimisticId);
        client[_core.kInternal].emitError(
          { type: "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR" },
          err
        );
      }
    );
  }, [client]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
  const { store } = getLiveblocksExtrasForClient(client);
  return useSignal(
    store.outputs.threadifications,
    _react.useCallback.call(void 0, 
      (state) => {
        const inboxNotification = _nullishCoalesce(state.notificationsById[inboxNotificationId], () => ( _core.raise.call(void 0, 
          `Inbox notification with ID "${inboxNotificationId}" not found`
        )));
        if (inboxNotification.kind !== "thread") {
          _core.raise.call(void 0, 
            `Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`
          );
        }
        const thread = _nullishCoalesce(state.threadsDB.get(inboxNotification.threadId), () => ( _core.raise.call(void 0, 
          `Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`
        )));
        return thread;
      },
      [inboxNotificationId]
    )
  );
}
function useUpdateNotificationSettings_withClient(client) {
  return _react.useCallback.call(void 0, 
    (settings) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const optimisticUpdateId = store.optimisticUpdates.add({
        type: "update-notification-settings",
        settings
      });
      client.updateNotificationSettings(settings).then(
        (settings2) => {
          store.updateNotificationSettings_confirmOptimisticUpdate(
            settings2,
            optimisticUpdateId
          );
        },
        (err) => {
          store.optimisticUpdates.remove(optimisticUpdateId);
          if (err instanceof _core.HttpError) {
            if (err.status === 422) {
              const msg = [_optionalChain([err, 'access', _16 => _16.details, 'optionalAccess', _17 => _17.error]), _optionalChain([err, 'access', _18 => _18.details, 'optionalAccess', _19 => _19.reason])].filter(Boolean).join("\n");
              _core.console.error(msg);
            }
            client[_core.kInternal].emitError(
              {
                type: "UPDATE_NOTIFICATION_SETTINGS_ERROR"
              },
              err
            );
          } else {
            throw err;
          }
        }
      );
    },
    [client]
  );
}
function useNotificationSettings_withClient(client) {
  const updateNotificationSettings = useUpdateNotificationSettings_withClient(client);
  const { store, notificationSettingsPoller: poller } = getLiveblocksExtrasForClient(client);
  _react.useEffect.call(void 0, () => {
    void store.outputs.notificationSettings.waitUntilLoaded();
  });
  _react.useEffect.call(void 0, () => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  const result = useSignal(store.outputs.notificationSettings.signal);
  return _react.useMemo.call(void 0, () => {
    return [result, updateNotificationSettings];
  }, [result, updateNotificationSettings]);
}
function useNotificationSettingsSuspense_withClient(client) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  use(store.outputs.notificationSettings.waitUntilLoaded());
  const [result, updateNotificationSettings] = useNotificationSettings_withClient(client);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return _react.useMemo.call(void 0, () => {
    return [result, updateNotificationSettings];
  }, [result, updateNotificationSettings]);
}
function useUser_withClient(client, userId) {
  const usersStore = client[_core.kInternal].usersStore;
  const getUserState = _react.useCallback.call(void 0, 
    () => usersStore.getItemState(userId),
    [usersStore, userId]
  );
  const selector = _react.useCallback.call(void 0, 
    (state) => selectorFor_useUser(state, userId),
    [userId]
  );
  const result = useSyncExternalStoreWithSelector(
    usersStore.subscribe,
    getUserState,
    getUserState,
    selector,
    _core.shallow
  );
  _react.useEffect.call(void 0, 
    () => void usersStore.enqueue(userId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call usersStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the userId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the userId gets invalidated, the user would be fetched again.
  );
  return result;
}
function useUserSuspense_withClient(client, userId) {
  const usersStore = client[_core.kInternal].usersStore;
  const getUserState = _react.useCallback.call(void 0, 
    () => usersStore.getItemState(userId),
    [usersStore, userId]
  );
  const userState = getUserState();
  if (!userState || userState.isLoading) {
    throw usersStore.enqueue(userId);
  }
  if (userState.error) {
    throw userState.error;
  }
  if (!userState.data) {
    throw missingUserError(userId);
  }
  const state = _react.useSyncExternalStore.call(void 0, 
    usersStore.subscribe,
    getUserState,
    getUserState
  );
  _core.assert.call(void 0, state !== void 0, "Unexpected missing state");
  _core.assert.call(void 0, !state.isLoading, "Unexpected loading state");
  _core.assert.call(void 0, !state.error, "Unexpected error state");
  return {
    isLoading: false,
    user: state.data,
    error: void 0
  };
}
function useRoomInfo_withClient(client, roomId) {
  const roomsInfoStore = client[_core.kInternal].roomsInfoStore;
  const getRoomInfoState = _react.useCallback.call(void 0, 
    () => roomsInfoStore.getItemState(roomId),
    [roomsInfoStore, roomId]
  );
  const selector = _react.useCallback.call(void 0, 
    (state) => selectorFor_useRoomInfo(state, roomId),
    [roomId]
  );
  const result = useSyncExternalStoreWithSelector(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState,
    selector,
    _core.shallow
  );
  _react.useEffect.call(void 0, 
    () => void roomsInfoStore.enqueue(roomId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call roomsInfoStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the roomId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the roomId gets invalidated, the room info would be fetched again.
  );
  return result;
}
function useRoomInfoSuspense_withClient(client, roomId) {
  const roomsInfoStore = client[_core.kInternal].roomsInfoStore;
  const getRoomInfoState = _react.useCallback.call(void 0, 
    () => roomsInfoStore.getItemState(roomId),
    [roomsInfoStore, roomId]
  );
  const roomInfoState = getRoomInfoState();
  if (!roomInfoState || roomInfoState.isLoading) {
    throw roomsInfoStore.enqueue(roomId);
  }
  if (roomInfoState.error) {
    throw roomInfoState.error;
  }
  if (!roomInfoState.data) {
    throw missingRoomInfoError(roomId);
  }
  const state = _react.useSyncExternalStore.call(void 0, 
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState
  );
  _core.assert.call(void 0, state !== void 0, "Unexpected missing state");
  _core.assert.call(void 0, !state.isLoading, "Unexpected loading state");
  _core.assert.call(void 0, !state.error, "Unexpected error state");
  _core.assert.call(void 0, state.data !== void 0, "Unexpected missing room info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function useGroupInfo_withClient(client, groupId) {
  const groupsInfoStore = client[_core.kInternal].groupsInfoStore;
  const getGroupInfoState = _react.useCallback.call(void 0, 
    () => groupsInfoStore.getItemState(groupId),
    [groupsInfoStore, groupId]
  );
  const selector = _react.useCallback.call(void 0, 
    (state) => selectorFor_useGroupInfo(state, groupId),
    [groupId]
  );
  const result = useSyncExternalStoreWithSelector(
    groupsInfoStore.subscribe,
    getGroupInfoState,
    getGroupInfoState,
    selector,
    _core.shallow
  );
  _react.useEffect.call(void 0, 
    () => void groupsInfoStore.enqueue(groupId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call groupsInfoStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the groupId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the groupId gets invalidated, the group info would be fetched again.
  );
  return result;
}
function useGroupInfoSuspense_withClient(client, groupId) {
  const groupsInfoStore = client[_core.kInternal].groupsInfoStore;
  const getGroupInfoState = _react.useCallback.call(void 0, 
    () => groupsInfoStore.getItemState(groupId),
    [groupsInfoStore, groupId]
  );
  const groupInfoState = getGroupInfoState();
  if (!groupInfoState || groupInfoState.isLoading) {
    throw groupsInfoStore.enqueue(groupId);
  }
  if (groupInfoState.error) {
    throw groupInfoState.error;
  }
  if (!groupInfoState.data) {
    throw missingGroupInfoError(groupId);
  }
  const state = _react.useSyncExternalStore.call(void 0, 
    groupsInfoStore.subscribe,
    getGroupInfoState,
    getGroupInfoState
  );
  _core.assert.call(void 0, state !== void 0, "Unexpected missing state");
  _core.assert.call(void 0, !state.isLoading, "Unexpected loading state");
  _core.assert.call(void 0, !state.error, "Unexpected error state");
  _core.assert.call(void 0, state.data !== void 0, "Unexpected missing group info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function useAiChats(options) {
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  const queryKey = makeAiChatsQueryKey(_optionalChain([options, 'optionalAccess', _20 => _20.query]));
  useEnsureAiConnection(client);
  _react.useEffect.call(void 0, 
    () => void store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(
    store.outputs.aiChats.getOrCreate(queryKey).signal,
    identity2,
    _core.shallow
  );
}
function useAiChatsSuspense(options) {
  ensureNotServerSide();
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  const queryKey = makeAiChatsQueryKey(_optionalChain([options, 'optionalAccess', _21 => _21.query]));
  use(store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded());
  const result = useAiChats(options);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useAiChatMessages(chatId, options) {
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  _react.useEffect.call(void 0, 
    () => void store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _22 => _22.branchId]), () => ( null))).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(
    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _23 => _23.branchId]), () => ( null))).signal
  );
}
function useAiChatMessagesSuspense(chatId, options) {
  ensureNotServerSide();
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  use(
    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _24 => _24.branchId]), () => ( null))).waitUntilLoaded()
  );
  const result = useAiChatMessages(chatId, options);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useAiChat(chatId) {
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  _react.useEffect.call(void 0, 
    () => void store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(store.outputs.aiChatById.getOrCreate(chatId).signal);
}
function useAiChatSuspense(chatId) {
  ensureNotServerSide();
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  use(store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded());
  const result = useAiChat(chatId);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useCreateAiChat() {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (options) => {
      if (typeof options === "string") {
        options = { id: options };
      }
      client[_core.kInternal].ai.getOrCreateChat(options.id, {
        title: options.title,
        metadata: options.metadata
      }).catch((err) => {
        _core.console.error(
          `Failed to create chat with ID "${options.id}": ${String(err)}`
        );
      });
    },
    [client]
  );
}
function useDeleteAiChat() {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (chatId) => {
      client[_core.kInternal].ai.deleteChat(chatId).catch((err) => {
        _core.console.error(
          `Failed to delete chat with ID "${chatId}": ${String(err)}`
        );
      });
    },
    [client]
  );
}
function useSendAiMessage(chatId, options) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (message) => {
      const {
        text: messageText,
        chatId: messageOptionsChatId,
        copilotId: messageOptionsCopilotId,
        ...messageOptions
      } = typeof message === "string" ? { text: message } : message;
      const resolvedChatId = _nullishCoalesce(_nullishCoalesce(messageOptionsChatId, () => ( chatId)), () => ( // The `useSendAiMessage` overloads prevent this scenario from happening
      // at the type level, and this error prevents it from happening at runtime.
      _core.raise.call(void 0, 
        "chatId must be provided to either `useSendAiMessage` or its returned function."
      )));
      const messages = client[_core.kInternal].ai.signals.getChatMessagesForBranch\u03A3(resolvedChatId).get();
      if (process.env.NODE_ENV !== "production" && !messageOptionsCopilotId && !_optionalChain([options, 'optionalAccess', _25 => _25.copilotId])) {
        _core.console.warn(
          `No copilot ID was provided to useSendAiMessage when sending the message "${messageText.slice(
            0,
            20
          )}\u2026". As a result, the message will use the chat's previous copilot ID, which could lead to unexpected behavior.
To ensure the correct copilot ID is used, specify it either through the hook as 'useSendAiMessage("${resolvedChatId}", { copilotId: "co_xxx" })' or via the function as 'sendAiMessage({ text: "${messageText.slice(
            0,
            20
          )}\u2026", copilotId: "co_xxx" })'`
        );
      }
      const resolvedCopilotId = _nullishCoalesce(_nullishCoalesce(messageOptionsCopilotId, () => ( _optionalChain([options, 'optionalAccess', _26 => _26.copilotId]))), () => ( client[_core.kInternal].ai.getLastUsedCopilotId(resolvedChatId)));
      const lastMessageId = _nullishCoalesce(_optionalChain([messages, 'access', _27 => _27[messages.length - 1], 'optionalAccess', _28 => _28.id]), () => ( null));
      const content = [{ type: "text", text: messageText }];
      const newMessageId = client[_core.kInternal].ai[_core.kInternal].context.messagesStore.createOptimistically(
        resolvedChatId,
        "user",
        lastMessageId,
        content
      );
      const newMessage = client[_core.kInternal].ai[_core.kInternal].context.messagesStore.getMessageById(newMessageId);
      const targetMessageId = client[_core.kInternal].ai[_core.kInternal].context.messagesStore.createOptimistically(
        resolvedChatId,
        "assistant",
        newMessageId,
        resolvedCopilotId
      );
      void client[_core.kInternal].ai.askUserMessageInChat(
        resolvedChatId,
        { id: newMessageId, parentMessageId: lastMessageId, content },
        targetMessageId,
        {
          stream: _nullishCoalesce(messageOptions.stream, () => ( _optionalChain([options, 'optionalAccess', _29 => _29.stream]))),
          copilotId: resolvedCopilotId,
          timeout: _nullishCoalesce(messageOptions.timeout, () => ( _optionalChain([options, 'optionalAccess', _30 => _30.timeout]))),
          knowledge: _nullishCoalesce(messageOptions.knowledge, () => ( _optionalChain([options, 'optionalAccess', _31 => _31.knowledge])))
        }
      );
      return newMessage;
    },
    [
      client,
      chatId,
      _optionalChain([options, 'optionalAccess', _32 => _32.copilotId]),
      _optionalChain([options, 'optionalAccess', _33 => _33.stream]),
      _optionalChain([options, 'optionalAccess', _34 => _34.timeout]),
      _optionalChain([options, 'optionalAccess', _35 => _35.knowledge])
    ]
  );
}
function createSharedContext(client) {
  const useClient2 = () => client;
  function useSyncStatus2(options) {
    return useSyncStatus_withClient(client, options);
  }
  return {
    classic: {
      useClient: useClient2,
      useUser: (userId) => useUser_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),
      useGroupInfo: (groupId) => useGroupInfo_withClient(client, groupId),
      useIsInsideRoom,
      useErrorListener,
      useSyncStatus: useSyncStatus2,
      RegisterAiKnowledge,
      RegisterAiTool
    },
    suspense: {
      useClient: useClient2,
      useUser: (userId) => useUserSuspense_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),
      useGroupInfo: (groupId) => useGroupInfoSuspense_withClient(client, groupId),
      useIsInsideRoom,
      useErrorListener,
      useSyncStatus: useSyncStatus2,
      RegisterAiKnowledge,
      RegisterAiTool
    }
  };
}
function useEnsureNoLiveblocksProvider(options) {
  const existing = useClientOrNull();
  if (!_optionalChain([options, 'optionalAccess', _36 => _36.allowNesting]) && existing !== null) {
    throw new Error(
      "You cannot nest multiple LiveblocksProvider instances in the same React tree."
    );
  }
}
function LiveblocksProviderWithClient(props) {
  useEnsureNoLiveblocksProvider(props);
  return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, ClientContext.Provider, { value: props.client, children: props.children });
}
function LiveblocksProvider(props) {
  const { children, ...o } = props;
  const options = {
    publicApiKey: useInitial(o.publicApiKey),
    throttle: useInitial(o.throttle),
    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
    polyfills: useInitial(o.polyfills),
    largeMessageStrategy: useInitial(o.largeMessageStrategy),
    unstable_streamData: useInitial(o.unstable_streamData),
    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),
    authEndpoint: useInitialUnlessFunction(o.authEndpoint),
    resolveMentionSuggestions: useInitialUnlessFunction(
      o.resolveMentionSuggestions
    ),
    resolveUsers: useInitialUnlessFunction(o.resolveUsers),
    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
    resolveGroupsInfo: useInitialUnlessFunction(o.resolveGroupsInfo),
    baseUrl: useInitial(
      // @ts-expect-error - Hidden config options
      o.baseUrl
    ),
    enableDebugLogging: useInitial(
      // @ts-expect-error - Hidden config options
      o.enableDebugLogging
    )
  };
  const client = _react.useMemo.call(void 0, () => _core.createClient.call(void 0, options), []);
  _react.useEffect.call(void 0, () => {
    return () => {
      client[_core.kInternal].ai.disconnect();
    };
  }, [client]);
  return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, LiveblocksProviderWithClient, { client, children });
}
function createLiveblocksContext(client) {
  return getOrCreateContextBundle(client);
}
function useUserThreads_experimental(options = {}) {
  const client = useClient();
  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);
  const queryKey = makeUserThreadsQueryKey(options.query);
  _react.useEffect.call(void 0, 
    () => void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  _react.useEffect.call(void 0, () => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  return useSignal(
    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal
  );
}
function useUserThreadsSuspense_experimental(options = {}) {
  ensureNotServerSide();
  const client = useClient();
  const { store } = getLiveblocksExtrasForClient(client);
  const queryKey = makeUserThreadsQueryKey(options.query);
  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());
  const result = useUserThreads_experimental(options);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useInboxNotifications(options) {
  return useInboxNotifications_withClient(
    useClient(),
    identity2,
    _core.shallow,
    options
  );
}
function useInboxNotificationsSuspense(options) {
  return useInboxNotificationsSuspense_withClient(useClient(), options);
}
function useInboxNotificationThread(inboxNotificationId) {
  return useInboxNotificationThread_withClient(
    useClient(),
    inboxNotificationId
  );
}
function useMarkAllInboxNotificationsAsRead() {
  return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
  return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
  return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
  return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount(options) {
  return useUnreadInboxNotificationsCount_withClient(useClient(), options);
}
function useUnreadInboxNotificationsCountSuspense(options) {
  return useUnreadInboxNotificationsCountSuspense_withClient(
    useClient(),
    options
  );
}
function useNotificationSettings() {
  return useNotificationSettings_withClient(useClient());
}
function useNotificationSettingsSuspense() {
  return useNotificationSettingsSuspense_withClient(useClient());
}
function useUpdateNotificationSettings() {
  return useUpdateNotificationSettings_withClient(useClient());
}
function useUser(userId) {
  const client = useClient();
  return useUser_withClient(client, userId);
}
function useUserSuspense(userId) {
  const client = useClient();
  return useUserSuspense_withClient(client, userId);
}
function useRoomInfo(roomId) {
  return useRoomInfo_withClient(useClient(), roomId);
}
function useRoomInfoSuspense(roomId) {
  return useRoomInfoSuspense_withClient(useClient(), roomId);
}
function useGroupInfo(groupId) {
  return useGroupInfo_withClient(useClient(), groupId);
}
function useGroupInfoSuspense(groupId) {
  return useGroupInfoSuspense_withClient(useClient(), groupId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserSuspense = useUserSuspense;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;
var _useAiChats = useAiChats;
var _useAiChatsSuspense = useAiChatsSuspense;
var _useAiChat = useAiChat;
var _useAiChatSuspense = useAiChatSuspense;
var _useAiChatMessages = useAiChatMessages;
var _useAiChatMessagesSuspense = useAiChatMessagesSuspense;
function useSyncStatus_withClient(client, options) {
  const smooth = useInitial(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _37 => _37.smooth]), () => ( false)));
  if (smooth) {
    return useSyncStatusSmooth_withClient(client);
  } else {
    return useSyncStatusImmediate_withClient(client);
  }
}
function useSyncStatusImmediate_withClient(client) {
  return _react.useSyncExternalStore.call(void 0, 
    client.events.syncStatus.subscribe,
    client.getSyncStatus,
    client.getSyncStatus
  );
}
function useSyncStatusSmooth_withClient(client) {
  const getter = client.getSyncStatus;
  const [status, setStatus] = _react.useState.call(void 0, getter);
  const oldStatus = useLatest(getter());
  _react.useEffect.call(void 0, () => {
    let timeoutId;
    const unsub = client.events.syncStatus.subscribe(() => {
      const newStatus = getter();
      if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);
      } else {
        clearTimeout(timeoutId);
        setStatus(newStatus);
      }
    });
    return () => {
      clearTimeout(timeoutId);
      unsub();
    };
  }, [client, getter, oldStatus]);
  return status;
}
function useSyncStatus(options) {
  return useSyncStatus_withClient(useClient(), options);
}
function useErrorListener(callback) {
  const client = useClient();
  const savedCallback = useLatest(callback);
  _react.useEffect.call(void 0, 
    () => client.events.error.subscribe((e) => savedCallback.current(e)),
    [client, savedCallback]
  );
}

// src/room.tsx
var _client = require('@liveblocks/client');























// src/use-scroll-to-comment-on-load-effect.ts

function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
  if (shouldScrollOnLoad === false) return;
  if (!state.threads) return;
  const isWindowDefined = typeof window !== "undefined";
  if (!isWindowDefined) return;
  const hash = window.location.hash;
  const commentId = hash.slice(1);
  if (!commentId.startsWith("cm_")) return;
  const comment = document.getElementById(commentId);
  if (comment === null) return;
  const comments = state.threads.flatMap((thread) => thread.comments);
  const isCommentInThreads = comments.some(
    (comment2) => comment2.id === commentId
  );
  if (!isCommentInThreads) return;
  comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
  _react.useEffect.call(void 0, 
    () => {
      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [state.isLoading]
  );
}

// src/room.tsx

var noop2 = () => {
};
var identity3 = (x) => x;
var STABLE_EMPTY_LIST = Object.freeze([]);
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function selectorFor_useOthersConnectionIds(others) {
  return others.map((user) => user.connectionId);
}
function makeMutationContext(room) {
  const cannotUseUntil = "This mutation cannot be used until";
  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
  const needsStorage = `${cannotUseUntil} storage has been loaded`;
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(needsStorage);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(needsPresence);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(needsPresence);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
function getCurrentUserId(client) {
  const userId = client[_core.kInternal].currentUserId.get();
  if (userId === void 0) {
    return "anonymous";
  }
  return userId;
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
  let bundle = _bundles2.get(client);
  if (!bundle) {
    bundle = makeRoomContextBundle(client);
    _bundles2.set(client, bundle);
  }
  return bundle;
}
function getRoomExtrasForClient(client) {
  let extras = _extras2.get(client);
  if (!extras) {
    extras = makeRoomExtrasForClient(client);
    _extras2.set(client, extras);
  }
  return extras;
}
function makeRoomExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  function onMutationFailure(optimisticId, context, innerError) {
    store.optimisticUpdates.remove(optimisticId);
    if (innerError instanceof _core.HttpError) {
      if (innerError.status === 403) {
        const detailedMessage = [
          innerError.message,
          _optionalChain([innerError, 'access', _38 => _38.details, 'optionalAccess', _39 => _39.suggestion]),
          _optionalChain([innerError, 'access', _40 => _40.details, 'optionalAccess', _41 => _41.docs])
        ].filter(Boolean).join("\n");
        _core.console.error(detailedMessage);
      }
      client[_core.kInternal].emitError(context, innerError);
    } else {
      throw innerError;
    }
  }
  const threadsPollersByRoomId = new (0, _core.DefaultMap)(
    (roomId) => _core.makePoller.call(void 0, 
      async (signal) => {
        try {
          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);
        } catch (err) {
          _core.console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.ROOM_THREADS_POLL_INTERVAL,
      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }
    )
  );
  const versionsPollersByRoomId = new (0, _core.DefaultMap)(
    (roomId) => _core.makePoller.call(void 0, 
      async (signal) => {
        try {
          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);
        } catch (err) {
          _core.console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.HISTORY_VERSIONS_POLL_INTERVAL,
      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }
    )
  );
  const roomSubscriptionSettingsPollersByRoomId = new (0, _core.DefaultMap)(
    (roomId) => _core.makePoller.call(void 0, 
      async (signal) => {
        try {
          return await store.refreshRoomSubscriptionSettings(roomId, signal);
        } catch (err) {
          _core.console.warn(`Polling subscription settings for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL,
      { maxStaleTimeMs: config.ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME }
    )
  );
  return {
    store,
    onMutationFailure,
    pollThreadsForRoomId: (roomId) => {
      const threadsPoller = threadsPollersByRoomId.getOrCreate(roomId);
      if (threadsPoller) {
        threadsPoller.markAsStale();
        threadsPoller.pollNowIfStale();
      }
    },
    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(
      threadsPollersByRoomId
    ),
    getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),
    getOrCreateSubscriptionSettingsPollerForRoomId: roomSubscriptionSettingsPollersByRoomId.getOrCreate.bind(
      roomSubscriptionSettingsPollersByRoomId
    )
  };
}
function makeRoomContextBundle(client) {
  function RoomProvider_withImplicitLiveblocksProvider(props) {
    return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, LiveblocksProviderWithClient, { client, allowNesting: true, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, RoomProvider, { ...props }) });
  }
  const shared = createSharedContext(client);
  const bundle = {
    RoomContext,
    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
    useRoom,
    useStatus,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useCreateThread,
    useDeleteThread,
    useEditThreadMetadata,
    useMarkThreadAsResolved,
    useMarkThreadAsUnresolved,
    useSubscribeToThread,
    useUnsubscribeFromThread,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    useMarkThreadAsRead,
    useThreadSubscription,
    useAttachmentUrl,
    useHistoryVersions,
    useHistoryVersionData,
    useRoomSubscriptionSettings,
    useUpdateRoomSubscriptionSettings,
    ...shared.classic,
    suspense: {
      RoomContext,
      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
      useRoom,
      useStatus,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useCreateThread,
      useDeleteThread,
      useEditThreadMetadata,
      useMarkThreadAsResolved,
      useMarkThreadAsUnresolved,
      useSubscribeToThread,
      useUnsubscribeFromThread,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction,
      useMarkThreadAsRead,
      useThreadSubscription,
      useAttachmentUrl: useAttachmentUrlSuspense,
      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,
      useHistoryVersions: useHistoryVersionsSuspense,
      useRoomSubscriptionSettings: useRoomSubscriptionSettingsSuspense,
      useUpdateRoomSubscriptionSettings,
      ...shared.suspense
    }
  };
  return Object.defineProperty(bundle, _core.kInternal, {
    enumerable: false
  });
}
function RoomProvider(props) {
  const client = useClient();
  const [cache] = _react.useState.call(void 0, 
    () => /* @__PURE__ */ new Map()
  );
  const stableEnterRoom = _react.useCallback.call(void 0, 
    (roomId, options) => {
      const cached = cache.get(roomId);
      if (cached) return cached;
      const rv = client.enterRoom(roomId, options);
      const origLeave = rv.leave;
      rv.leave = () => {
        origLeave();
        cache.delete(roomId);
      };
      cache.set(roomId, rv);
      return rv;
    },
    [client, cache]
  );
  return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
    RoomProviderInner,
    {
      ...props,
      stableEnterRoom
    }
  );
}
function RoomProviderInner(props) {
  const client = useClient();
  const { id: roomId, stableEnterRoom } = props;
  if (process.env.NODE_ENV !== "production") {
    if (!roomId) {
      throw new Error(
        "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
      );
    }
    if (typeof roomId !== "string") {
      throw new Error("RoomProvider id property should be a string.");
    }
    const majorReactVersion = parseInt(_react.version) || 1;
    const requiredVersion = 18;
    _core.errorIf.call(void 0, 
      majorReactVersion < requiredVersion,
      `React ${requiredVersion} or higher is required (you\u2019re on ${_react.version})`
    );
  }
  const frozenProps = useInitial(
    {
      initialPresence: props.initialPresence,
      initialStorage: props.initialStorage,
      autoConnect: _nullishCoalesce(props.autoConnect, () => ( typeof window !== "undefined"))
    },
    roomId
  );
  const [{ room }, setRoomLeavePair] = _react.useState.call(void 0, 
    () => stableEnterRoom(roomId, {
      ...frozenProps,
      autoConnect: false
      // Deliberately using false here on the first render, see below
    })
  );
  _react.useEffect.call(void 0, () => {
    const { store } = getRoomExtrasForClient(client);
    async function handleCommentEvent(message) {
      if (message.type === _core.ServerMsgCode.THREAD_DELETED) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const info = await room.getThread(message.threadId);
      if (!info.thread) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const {
        thread,
        inboxNotification: maybeNotification,
        subscription: maybeSubscription
      } = info;
      const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);
      switch (message.type) {
        case _core.ServerMsgCode.COMMENT_EDITED:
        case _core.ServerMsgCode.THREAD_METADATA_UPDATED:
        case _core.ServerMsgCode.THREAD_UPDATED:
        case _core.ServerMsgCode.COMMENT_REACTION_ADDED:
        case _core.ServerMsgCode.COMMENT_REACTION_REMOVED:
        case _core.ServerMsgCode.COMMENT_DELETED:
          if (!existingThread) break;
          store.updateThreadifications(
            [thread],
            maybeNotification ? [maybeNotification] : [],
            maybeSubscription ? [maybeSubscription] : []
          );
          break;
        case _core.ServerMsgCode.COMMENT_CREATED:
          store.updateThreadifications(
            [thread],
            maybeNotification ? [maybeNotification] : [],
            maybeSubscription ? [maybeSubscription] : []
          );
          break;
        default:
          break;
      }
    }
    return room.events.comments.subscribe(
      (message) => void handleCommentEvent(message)
    );
  }, [client, room]);
  _react.useEffect.call(void 0, () => {
    const pair = stableEnterRoom(roomId, frozenProps);
    setRoomLeavePair(pair);
    const { room: room2, leave } = pair;
    if (frozenProps.autoConnect) {
      room2.connect();
    }
    return () => {
      leave();
    };
  }, [roomId, frozenProps, stableEnterRoom]);
  return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, RoomContext.Provider, { value: room, children: props.children });
}
function useRoom(options) {
  const room = useRoomOrNull();
  if (room === null && !_optionalChain([options, 'optionalAccess', _42 => _42.allowOutsideRoom])) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return room;
}
function useStatus() {
  const room = useRoom();
  const subscribe = room.events.status.subscribe;
  const getSnapshot = room.getStatus;
  const getServerSnapshot = room.getStatus;
  return _react.useSyncExternalStore.call(void 0, subscribe, getSnapshot, getServerSnapshot);
}
function useReportTextEditor(editor, rootKey) {
  const isReported = _react.useRef.call(void 0, false);
  const room = useRoom();
  _react.useEffect.call(void 0, () => {
    if (isReported.current) {
      return;
    }
    const unsubscribe = room.events.status.subscribe((status) => {
      if (status === "connected" && !isReported.current) {
        isReported.current = true;
        void room[_core.kInternal].reportTextEditor(editor, rootKey);
      }
    });
    return unsubscribe;
  }, [room, editor, rootKey]);
}
function useYjsProvider() {
  const room = useRoom();
  const subscribe = _react.useCallback.call(void 0, 
    (onStoreChange) => {
      return room[_core.kInternal].yjsProviderDidChange.subscribe(onStoreChange);
    },
    [room]
  );
  const getSnapshot = _react.useCallback.call(void 0, () => {
    return room[_core.kInternal].getYjsProvider();
  }, [room]);
  return _react.useSyncExternalStore.call(void 0, subscribe, getSnapshot, getSnapshot);
}
function useCreateTextMention() {
  const room = useRoom();
  return _react.useCallback.call(void 0, 
    (mentionId, mention) => {
      room[_core.kInternal].createTextMention(mentionId, mention).catch((err) => {
        _core.console.error(
          `Cannot create text mention for mention '${mentionId}'`,
          err
        );
      });
    },
    [room]
  );
}
function useDeleteTextMention() {
  const room = useRoom();
  return _react.useCallback.call(void 0, 
    (mentionId) => {
      room[_core.kInternal].deleteTextMention(mentionId).catch((err) => {
        _core.console.error(`Cannot delete text mention '${mentionId}'`, err);
      });
    },
    [room]
  );
}
function useResolveMentionSuggestions() {
  const client = useClient();
  return client[_core.kInternal].resolveMentionSuggestions;
}
function useMentionSuggestionsCache() {
  const client = useClient();
  return client[_core.kInternal].mentionSuggestionsCache;
}
function useBroadcastEvent() {
  const room = useRoom();
  return _react.useCallback.call(void 0, 
    (event, options = { shouldQueueEventIfNotReady: false }) => {
      room.broadcastEvent(event, options);
    },
    [room]
  );
}
function useOthersListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  _react.useEffect.call(void 0, 
    () => room.events.others.subscribe((event) => savedCallback.current(event)),
    [room, savedCallback]
  );
}
function useLostConnectionListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  _react.useEffect.call(void 0, 
    () => room.events.lostConnection.subscribe(
      (event) => savedCallback.current(event)
    ),
    [room, savedCallback]
  );
}
function useEventListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  _react.useEffect.call(void 0, () => {
    const listener = (eventData) => {
      savedCallback.current(eventData);
    };
    return room.events.customEvent.subscribe(listener);
  }, [room, savedCallback]);
}
function useHistory() {
  return useRoom().history;
}
function useUndo() {
  return useHistory().undo;
}
function useRedo() {
  return useHistory().redo;
}
function useCanUndo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canUndo = room.history.canUndo;
  return _react.useSyncExternalStore.call(void 0, subscribe, canUndo, canUndo);
}
function useCanRedo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canRedo = room.history.canRedo;
  return _react.useSyncExternalStore.call(void 0, subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.self.subscribe;
  const getSnapshot = room.getSelf;
  const selector = _nullishCoalesce(maybeSelector, () => ( identity3));
  const wrappedSelector = _react.useCallback.call(void 0, 
    (me) => me !== null ? selector(me) : null,
    [selector]
  );
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMyPresence() {
  const room = useRoom();
  const subscribe = room.events.myPresence.subscribe;
  const getSnapshot = room.getPresence;
  const presence = _react.useSyncExternalStore.call(void 0, subscribe, getSnapshot, getSnapshot);
  const setPresence = room.updatePresence;
  return [presence, setPresence];
}
function useUpdateMyPresence() {
  return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.others.subscribe;
  const getSnapshot = room.getOthers;
  const getServerSnapshot = alwaysEmptyList;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    _nullishCoalesce(selector, () => ( identity3)),
    isEqual
  );
}
function useOthersMapped(itemSelector, itemIsEqual) {
  const wrappedSelector = _react.useCallback.call(void 0, 
    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),
    [itemSelector]
  );
  const wrappedIsEqual = _react.useCallback.call(void 0, 
    (a, b) => {
      const eq = _nullishCoalesce(itemIsEqual, () => ( Object.is));
      return a.length === b.length && a.every((atuple, index) => {
        const btuple = b[index];
        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
      });
    },
    [itemIsEqual]
  );
  return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
  return useOthers(selectorFor_useOthersConnectionIds, _client.shallow);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
  const wrappedSelector = _react.useCallback.call(void 0, 
    (others) => {
      const other2 = others.find((other3) => other3.connectionId === connectionId);
      return other2 !== void 0 ? selector(other2) : NOT_FOUND;
    },
    [connectionId, selector]
  );
  const wrappedIsEqual = _react.useCallback.call(void 0, 
    (prev, curr) => {
      if (prev === NOT_FOUND || curr === NOT_FOUND) {
        return prev === curr;
      }
      const eq = _nullishCoalesce(isEqual, () => ( Object.is));
      return eq(prev, curr);
    },
    [isEqual]
  );
  const other = useOthers(wrappedSelector, wrappedIsEqual);
  if (other === NOT_FOUND) {
    throw new Error(
      `No such other user with connection id ${connectionId} exists`
    );
  }
  return other;
}
function useMutableStorageRoot() {
  const room = useRoom();
  const subscribe = room.events.storageDidLoad.subscribeOnce;
  const getSnapshot = room.getStorageSnapshot;
  const getServerSnapshot = alwaysNull;
  return _react.useSyncExternalStore.call(void 0, subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
  return [useMutableStorageRoot()];
}
function useStorage(selector, isEqual) {
  const room = useRoom();
  const rootOrNull = useMutableStorageRoot();
  const wrappedSelector = _react.useCallback.call(void 0, 
    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
    [selector]
  );
  const subscribe = _react.useCallback.call(void 0, 
    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,
    [room, rootOrNull]
  );
  const getSnapshot = _react.useCallback.call(void 0, () => {
    if (rootOrNull === null) {
      return null;
    } else {
      const root = rootOrNull;
      const imm = root.toImmutable();
      return imm;
    }
  }, [rootOrNull]);
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMutation(callback, deps) {
  const room = useRoom();
  return _react.useMemo.call(void 0, 
    () => {
      return (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        room.batch(
          () => (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            callback(
              makeMutationContext(room),
              ...args
            )
          )
        )
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [room, ...deps]
  );
}
function useThreads(options = {}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);
  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
  const poller = getOrCreateThreadsPollerForRoomId(room.id);
  _react.useEffect.call(void 0, 
    () => void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  _react.useEffect.call(void 0, () => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  const result = useSignal(
    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, result);
  return result;
}
function useCreateThread() {
  return useCreateRoomThread(useRoom().id);
}
function useCreateRoomThread(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (options) => {
      const body = options.body;
      const metadata = _nullishCoalesce(options.metadata, () => ( {}));
      const attachments = options.attachments;
      const threadId = _core.createThreadId.call(void 0, );
      const commentId = _core.createCommentId.call(void 0, );
      const createdAt = /* @__PURE__ */ new Date();
      const newComment = {
        id: commentId,
        threadId,
        roomId,
        createdAt,
        type: "comment",
        userId: getCurrentUserId(client),
        body,
        reactions: [],
        attachments: _nullishCoalesce(attachments, () => ( []))
      };
      const newThread = {
        id: threadId,
        type: "thread",
        createdAt,
        updatedAt: createdAt,
        roomId,
        metadata,
        comments: [newComment],
        resolved: false
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "create-thread",
        thread: newThread,
        roomId
      });
      const attachmentIds = _optionalChain([attachments, 'optionalAccess', _43 => _43.map, 'call', _44 => _44((attachment) => attachment.id)]);
      client[_core.kInternal].httpClient.createThread({
        roomId,
        threadId,
        commentId,
        body,
        metadata,
        attachmentIds
      }).then(
        (thread) => {
          store.createThread(optimisticId, thread);
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "CREATE_THREAD_ERROR",
            roomId,
            threadId,
            commentId,
            body,
            metadata
          },
          err
        )
      );
      return newThread;
    },
    [client, roomId]
  );
}
function useDeleteThread() {
  return useDeleteRoomThread(useRoom().id);
}
function useDeleteRoomThread(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (threadId) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const userId = getCurrentUserId(client);
      const existing = store.outputs.threads.get().get(threadId);
      if (_optionalChain([existing, 'optionalAccess', _45 => _45.comments, 'optionalAccess', _46 => _46[0], 'optionalAccess', _47 => _47.userId]) !== userId) {
        throw new Error("Only the thread creator can delete the thread");
      }
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-thread",
        roomId,
        threadId,
        deletedAt: /* @__PURE__ */ new Date()
      });
      client[_core.kInternal].httpClient.deleteThread({ roomId, threadId }).then(
        () => {
          store.deleteThread(threadId, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "DELETE_THREAD_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useEditThreadMetadata() {
  return useEditRoomThreadMetadata(useRoom().id);
}
function useEditRoomThreadMetadata(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (options) => {
      if (!options.metadata) {
        return;
      }
      const threadId = options.threadId;
      const metadata = options.metadata;
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "edit-thread-metadata",
        metadata,
        threadId,
        updatedAt
      });
      client[_core.kInternal].httpClient.editThreadMetadata({ roomId, threadId, metadata }).then(
        (metadata2) => (
          // Replace the optimistic update by the real thing
          store.patchThread(threadId, optimisticId, { metadata: metadata2 }, updatedAt)
        ),
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "EDIT_THREAD_METADATA_ERROR",
            roomId,
            threadId,
            metadata
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useCreateComment() {
  return useCreateRoomComment(useRoom().id);
}
function useCreateRoomComment(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    ({ threadId, body, attachments }) => {
      const commentId = _core.createCommentId.call(void 0, );
      const createdAt = /* @__PURE__ */ new Date();
      const comment = {
        id: commentId,
        threadId,
        roomId,
        type: "comment",
        createdAt,
        userId: getCurrentUserId(client),
        body,
        reactions: [],
        attachments: _nullishCoalesce(attachments, () => ( []))
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "create-comment",
        comment
      });
      const attachmentIds = _optionalChain([attachments, 'optionalAccess', _48 => _48.map, 'call', _49 => _49((attachment) => attachment.id)]);
      client[_core.kInternal].httpClient.createComment({ roomId, threadId, commentId, body, attachmentIds }).then(
        (newComment) => {
          store.createComment(newComment, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "CREATE_COMMENT_ERROR",
            roomId,
            threadId,
            commentId,
            body
          },
          err
        )
      );
      return comment;
    },
    [client, roomId]
  );
}
function useEditComment() {
  return useEditRoomComment(useRoom().id);
}
function useEditRoomComment(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    ({ threadId, commentId, body, attachments }) => {
      const editedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);
      if (existing === void 0) {
        _core.console.warn(
          `Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`
        );
        return;
      }
      const comment = existing.comments.find(
        (comment2) => comment2.id === commentId
      );
      if (comment === void 0 || comment.deletedAt !== void 0) {
        _core.console.warn(
          `Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`
        );
        return;
      }
      const optimisticId = store.optimisticUpdates.add({
        type: "edit-comment",
        comment: {
          ...comment,
          editedAt,
          body,
          attachments: _nullishCoalesce(attachments, () => ( []))
        }
      });
      const attachmentIds = _optionalChain([attachments, 'optionalAccess', _50 => _50.map, 'call', _51 => _51((attachment) => attachment.id)]);
      client[_core.kInternal].httpClient.editComment({ roomId, threadId, commentId, body, attachmentIds }).then(
        (editedComment) => {
          store.editComment(threadId, optimisticId, editedComment);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "EDIT_COMMENT_ERROR", roomId, threadId, commentId, body },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useDeleteComment() {
  return useDeleteRoomComment(useRoom().id);
}
function useDeleteRoomComment(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    ({ threadId, commentId }) => {
      const deletedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-comment",
        threadId,
        commentId,
        deletedAt,
        roomId
      });
      client[_core.kInternal].httpClient.deleteComment({ roomId, threadId, commentId }).then(
        () => {
          store.deleteComment(threadId, optimisticId, commentId, deletedAt);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "DELETE_COMMENT_ERROR", roomId, threadId, commentId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useAddReaction() {
  return useAddRoomCommentReaction(useRoom().id);
}
function useAddRoomCommentReaction(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    ({ threadId, commentId, emoji }) => {
      const createdAt = /* @__PURE__ */ new Date();
      const userId = getCurrentUserId(client);
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "add-reaction",
        threadId,
        commentId,
        reaction: {
          emoji,
          userId,
          createdAt
        }
      });
      client[_core.kInternal].httpClient.addReaction({ roomId, threadId, commentId, emoji }).then(
        (addedReaction) => {
          store.addReaction(
            threadId,
            optimisticId,
            commentId,
            addedReaction,
            createdAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "ADD_REACTION_ERROR",
            roomId,
            threadId,
            commentId,
            emoji
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useRemoveReaction() {
  return useRemoveRoomCommentReaction(useRoom().id);
}
function useRemoveRoomCommentReaction(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    ({ threadId, commentId, emoji }) => {
      const userId = getCurrentUserId(client);
      const removedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "remove-reaction",
        threadId,
        commentId,
        emoji,
        userId,
        removedAt
      });
      client[_core.kInternal].httpClient.removeReaction({ roomId, threadId, commentId, emoji }).then(
        () => {
          store.removeReaction(
            threadId,
            optimisticId,
            commentId,
            emoji,
            userId,
            removedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "REMOVE_REACTION_ERROR",
            roomId,
            threadId,
            commentId,
            emoji
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsRead() {
  return useMarkRoomThreadAsRead(useRoom().id);
}
function useMarkRoomThreadAsRead(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (threadId) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const inboxNotification = Object.values(
        store.outputs.notifications.get().notificationsById
      ).find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      if (!inboxNotification) return;
      const now = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId: inboxNotification.id,
        readAt: now
      });
      client[_core.kInternal].httpClient.markRoomInboxNotificationAsRead({
        roomId,
        inboxNotificationId: inboxNotification.id
      }).then(
        () => {
          store.markInboxNotificationRead(
            inboxNotification.id,
            now,
            optimisticId
          );
        },
        (err) => {
          onMutationFailure(
            optimisticId,
            {
              type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
              roomId,
              inboxNotificationId: inboxNotification.id
            },
            err
          );
          return;
        }
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsResolved() {
  return useMarkRoomThreadAsResolved(useRoom().id);
}
function useMarkRoomThreadAsResolved(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-thread-as-resolved",
        threadId,
        updatedAt
      });
      client[_core.kInternal].httpClient.markThreadAsResolved({ roomId, threadId }).then(
        () => {
          store.patchThread(
            threadId,
            optimisticId,
            { resolved: true },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "MARK_THREAD_AS_RESOLVED_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsUnresolved() {
  return useMarkRoomThreadAsUnresolved(useRoom().id);
}
function useMarkRoomThreadAsUnresolved(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-thread-as-unresolved",
        threadId,
        updatedAt
      });
      client[_core.kInternal].httpClient.markThreadAsUnresolved({ roomId, threadId }).then(
        () => {
          store.patchThread(
            threadId,
            optimisticId,
            { resolved: false },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "MARK_THREAD_AS_UNRESOLVED_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useSubscribeToThread() {
  return useSubscribeToRoomThread(useRoom().id);
}
function useSubscribeToRoomThread(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (threadId) => {
      const subscribedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "subscribe-to-thread",
        threadId,
        subscribedAt
      });
      client[_core.kInternal].httpClient.subscribeToThread({ roomId, threadId }).then(
        (subscription) => {
          store.createSubscription(subscription, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "SUBSCRIBE_TO_THREAD_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useUnsubscribeFromThread() {
  return useUnsubscribeFromRoomThread(useRoom().id);
}
function useUnsubscribeFromRoomThread(roomId) {
  const client = useClient();
  return _react.useCallback.call(void 0, 
    (threadId) => {
      const unsubscribedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "unsubscribe-from-thread",
        threadId,
        unsubscribedAt
      });
      client[_core.kInternal].httpClient.unsubscribeFromThread({ roomId, threadId }).then(
        () => {
          store.deleteSubscription(
            _core.getSubscriptionKey.call(void 0, "thread", threadId),
            optimisticId
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "UNSUBSCRIBE_FROM_THREAD_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useThreadSubscription(threadId) {
  return useRoomThreadSubscription(useRoom().id, threadId);
}
function useRoomThreadSubscription(roomId, threadId) {
  const client = useClient();
  const { store } = getRoomExtrasForClient(client);
  const subscriptionKey = _react.useMemo.call(void 0, 
    () => _core.getSubscriptionKey.call(void 0, "thread", threadId),
    [threadId]
  );
  const subscribeToThread = useSubscribeToRoomThread(roomId);
  const unsubscribeFromThread = useUnsubscribeFromRoomThread(roomId);
  const subscribe = _react.useCallback.call(void 0, 
    () => subscribeToThread(threadId),
    [subscribeToThread, threadId]
  );
  const unsubscribe = _react.useCallback.call(void 0, 
    () => unsubscribeFromThread(threadId),
    [unsubscribeFromThread, threadId]
  );
  const signal = store.outputs.threadSubscriptions;
  const selector = _react.useCallback.call(void 0, 
    (state) => {
      const subscription = state.subscriptions[subscriptionKey];
      const notification = state.notifications.find(
        (inboxNotification) => inboxNotification.kind === "thread" && inboxNotification.threadId === threadId
      );
      if (subscription === void 0) {
        return { status: "not-subscribed", subscribe, unsubscribe };
      }
      return {
        status: "subscribed",
        unreadSince: _nullishCoalesce(_optionalChain([notification, 'optionalAccess', _52 => _52.readAt]), () => ( null)),
        subscribe,
        unsubscribe
      };
    },
    [subscriptionKey, threadId, subscribe, unsubscribe]
  );
  return useSignal(signal, selector, _client.shallow);
}
function useRoomSubscriptionSettings() {
  const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateSubscriptionSettingsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateSubscriptionSettingsPollerForRoomId(room.id);
  _react.useEffect.call(void 0, 
    () => void store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  _react.useEffect.call(void 0, () => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  const settings = useSignal(
    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).signal
  );
  return _react.useMemo.call(void 0, () => {
    return [settings, updateRoomSubscriptionSettings];
  }, [settings, updateRoomSubscriptionSettings]);
}
function useRoomSubscriptionSettingsSuspense() {
  ensureNotServerSide();
  const client = useClient();
  const store = getRoomExtrasForClient(client).store;
  const room = useRoom();
  use(
    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded()
  );
  const [settings, updateRoomSubscriptionSettings] = useRoomSubscriptionSettings();
  _core.assert.call(void 0, !settings.error, "Did not expect error");
  _core.assert.call(void 0, !settings.isLoading, "Did not expect loading");
  return _react.useMemo.call(void 0, () => {
    return [settings, updateRoomSubscriptionSettings];
  }, [settings, updateRoomSubscriptionSettings]);
}
function useHistoryVersionData(versionId) {
  const [state, setState] = _react.useState.call(void 0, {
    isLoading: true
  });
  const room = useRoom();
  _react.useEffect.call(void 0, () => {
    setState({ isLoading: true });
    const load = async () => {
      try {
        const response = await room[_core.kInternal].getTextVersion(versionId);
        const buffer = await response.arrayBuffer();
        const data = new Uint8Array(buffer);
        setState({
          isLoading: false,
          data
        });
      } catch (error) {
        setState({
          isLoading: false,
          error: error instanceof Error ? error : new Error(
            "An unknown error occurred while loading this version"
          )
        });
      }
    };
    void load();
  }, [room, versionId]);
  return state;
}
function useHistoryVersions() {
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateVersionsPollerForRoomId(room.id);
  _react.useEffect.call(void 0, () => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  _react.useEffect.call(void 0, 
    () => void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);
}
function useHistoryVersionsSuspense() {
  ensureNotServerSide();
  const client = useClient();
  const room = useRoom();
  const store = getRoomExtrasForClient(client).store;
  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());
  const result = useHistoryVersions();
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useUpdateRoomSubscriptionSettings() {
  const client = useClient();
  const room = useRoom();
  return _react.useCallback.call(void 0, 
    (settings) => {
      const { store, onMutationFailure, pollThreadsForRoomId } = getRoomExtrasForClient(client);
      const userId = getCurrentUserId(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "update-room-subscription-settings",
        roomId: room.id,
        userId,
        settings
      });
      room.updateSubscriptionSettings(settings).then(
        (udpatedSettings) => {
          store.updateRoomSubscriptionSettings(
            room.id,
            optimisticId,
            udpatedSettings
          );
          if (settings.threads) {
            pollThreadsForRoomId(room.id);
          }
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR",
            roomId: room.id
          },
          err
        )
      );
    },
    [client, room]
  );
}
function useSuspendUntilPresenceReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useSelf(
    selector,
    isEqual
  );
}
function useOthersSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOthers(
    selector,
    isEqual
  );
}
function useOthersConnectionIdsSuspense() {
  useSuspendUntilPresenceReady();
  return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
  useSuspendUntilPresenceReady();
  return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
  useSuspendUntilStorageReady();
  return useStorage(
    selector,
    isEqual
  );
}
function useThreadsSuspense(options = {}) {
  ensureNotServerSide();
  const client = useClient();
  const room = useRoom();
  const { store } = getRoomExtrasForClient(client);
  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());
  const result = useThreads(options);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function selectorFor_useAttachmentUrl(state) {
  if (state === void 0 || _optionalChain([state, 'optionalAccess', _53 => _53.isLoading])) {
    return _nullishCoalesce(state, () => ( { isLoading: true }));
  }
  if (state.error) {
    return state;
  }
  _core.assert.call(void 0, state.data !== void 0, "Unexpected missing attachment URL");
  return {
    isLoading: false,
    url: state.data
  };
}
function useAttachmentUrl(attachmentId) {
  const room = useRoom();
  return useRoomAttachmentUrl(attachmentId, room.id);
}
function useRoomAttachmentUrl(attachmentId, roomId) {
  const client = useClient();
  const store = client[_core.kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);
  const getAttachmentUrlState = _react.useCallback.call(void 0, 
    () => store.getItemState(attachmentId),
    [store, attachmentId]
  );
  _react.useEffect.call(void 0, () => {
    void store.enqueue(attachmentId);
  }, [store, attachmentId]);
  return useSyncExternalStoreWithSelector(
    store.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState,
    selectorFor_useAttachmentUrl,
    _client.shallow
  );
}
function useAttachmentUrlSuspense(attachmentId) {
  const room = useRoom();
  const { attachmentUrlsStore } = room[_core.kInternal];
  const getAttachmentUrlState = _react.useCallback.call(void 0, 
    () => attachmentUrlsStore.getItemState(attachmentId),
    [attachmentUrlsStore, attachmentId]
  );
  const attachmentUrlState = getAttachmentUrlState();
  if (!attachmentUrlState || attachmentUrlState.isLoading) {
    throw attachmentUrlsStore.enqueue(attachmentId);
  }
  if (attachmentUrlState.error) {
    throw attachmentUrlState.error;
  }
  const state = _react.useSyncExternalStore.call(void 0, 
    attachmentUrlsStore.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState
  );
  _core.assert.call(void 0, state !== void 0, "Unexpected missing state");
  _core.assert.call(void 0, !state.isLoading, "Unexpected loading state");
  _core.assert.call(void 0, !state.error, "Unexpected error state");
  return {
    isLoading: false,
    url: state.data,
    error: void 0
  };
}
function useRoomPermissions(roomId) {
  const client = useClient();
  const store = getRoomExtrasForClient(client).store;
  return useSignal(store.permissionHints.getPermissionForRoom\u03A3(roomId));
}
function createRoomContext(client) {
  return getOrCreateRoomContextBundle(client);
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useOthersMappedSuspense = useOthersMappedSuspense;
var _useThreads = useThreads;
var _useThreadsSuspense = useThreadsSuspense;
var _useRoomSubscriptionSettings = useRoomSubscriptionSettings;
var _useRoomSubscriptionSettingsSuspense = useRoomSubscriptionSettingsSuspense;
var _useHistoryVersions = useHistoryVersions;
var _useHistoryVersionsSuspense = useHistoryVersionsSuspense;
var _useOther = useOther;
function _useOthers(...args) {
  return useOthers(...args);
}
var _useOtherSuspense = useOtherSuspense;
function _useOthersSuspense(...args) {
  return useOthersSuspense(...args);
}
var _useStorage = useStorage;
var _useStorageSuspense = useStorageSuspense;
function _useSelf(...args) {
  return useSelf(...args);
}
function _useSelfSuspense(...args) {
  return useSelfSuspense(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;























































































































exports.ClientContext = ClientContext; exports.useClientOrNull = useClientOrNull; exports.useClient = useClient; exports.RoomContext = RoomContext; exports.useLatest = useLatest; exports.RegisterAiKnowledge = RegisterAiKnowledge; exports.RegisterAiTool = RegisterAiTool; exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector; exports.useSignal = useSignal; exports.getUmbrellaStoreForClient = getUmbrellaStoreForClient; exports.useCreateAiChat = useCreateAiChat; exports.useDeleteAiChat = useDeleteAiChat; exports.useSendAiMessage = useSendAiMessage; exports.LiveblocksProvider = LiveblocksProvider; exports.createLiveblocksContext = createLiveblocksContext; exports.useInboxNotifications = useInboxNotifications; exports.useInboxNotificationsSuspense = useInboxNotificationsSuspense; exports.useMarkAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead; exports.useMarkInboxNotificationAsRead = useMarkInboxNotificationAsRead; exports.useDeleteAllInboxNotifications = useDeleteAllInboxNotifications; exports.useDeleteInboxNotification = useDeleteInboxNotification; exports.useUnreadInboxNotificationsCount = useUnreadInboxNotificationsCount; exports.useUnreadInboxNotificationsCountSuspense = useUnreadInboxNotificationsCountSuspense; exports.useNotificationSettings = useNotificationSettings; exports.useNotificationSettingsSuspense = useNotificationSettingsSuspense; exports.useUpdateNotificationSettings = useUpdateNotificationSettings; exports.useRoomInfo = useRoomInfo; exports.useRoomInfoSuspense = useRoomInfoSuspense; exports.useGroupInfo = useGroupInfo; exports.useGroupInfoSuspense = useGroupInfoSuspense; exports._useInboxNotificationThread = _useInboxNotificationThread; exports._useUser = _useUser; exports._useUserSuspense = _useUserSuspense; exports._useUserThreads_experimental = _useUserThreads_experimental; exports._useUserThreadsSuspense_experimental = _useUserThreadsSuspense_experimental; exports._useAiChats = _useAiChats; exports._useAiChatsSuspense = _useAiChatsSuspense; exports._useAiChat = _useAiChat; exports._useAiChatSuspense = _useAiChatSuspense; exports._useAiChatMessages = _useAiChatMessages; exports._useAiChatMessagesSuspense = _useAiChatMessagesSuspense; exports.useSyncStatus = useSyncStatus; exports.useErrorListener = useErrorListener; exports.useStatus = useStatus; exports.useReportTextEditor = useReportTextEditor; exports.useYjsProvider = useYjsProvider; exports.useCreateTextMention = useCreateTextMention; exports.useDeleteTextMention = useDeleteTextMention; exports.useResolveMentionSuggestions = useResolveMentionSuggestions; exports.useMentionSuggestionsCache = useMentionSuggestionsCache; exports.useLostConnectionListener = useLostConnectionListener; exports.useHistory = useHistory; exports.useUndo = useUndo; exports.useRedo = useRedo; exports.useCanUndo = useCanUndo; exports.useCanRedo = useCanRedo; exports.useOthersConnectionIds = useOthersConnectionIds; exports.useCreateRoomThread = useCreateRoomThread; exports.useDeleteRoomThread = useDeleteRoomThread; exports.useEditRoomThreadMetadata = useEditRoomThreadMetadata; exports.useCreateComment = useCreateComment; exports.useCreateRoomComment = useCreateRoomComment; exports.useEditComment = useEditComment; exports.useEditRoomComment = useEditRoomComment; exports.useDeleteComment = useDeleteComment; exports.useDeleteRoomComment = useDeleteRoomComment; exports.useAddRoomCommentReaction = useAddRoomCommentReaction; exports.useRemoveReaction = useRemoveReaction; exports.useRemoveRoomCommentReaction = useRemoveRoomCommentReaction; exports.useMarkThreadAsRead = useMarkThreadAsRead; exports.useMarkRoomThreadAsRead = useMarkRoomThreadAsRead; exports.useMarkThreadAsResolved = useMarkThreadAsResolved; exports.useMarkRoomThreadAsResolved = useMarkRoomThreadAsResolved; exports.useMarkThreadAsUnresolved = useMarkThreadAsUnresolved; exports.useMarkRoomThreadAsUnresolved = useMarkRoomThreadAsUnresolved; exports.useSubscribeToThread = useSubscribeToThread; exports.useUnsubscribeFromThread = useUnsubscribeFromThread; exports.useThreadSubscription = useThreadSubscription; exports.useRoomThreadSubscription = useRoomThreadSubscription; exports.useHistoryVersionData = useHistoryVersionData; exports.useUpdateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings; exports.useOthersConnectionIdsSuspense = useOthersConnectionIdsSuspense; exports.useAttachmentUrl = useAttachmentUrl; exports.useRoomAttachmentUrl = useRoomAttachmentUrl; exports.useAttachmentUrlSuspense = useAttachmentUrlSuspense; exports.useRoomPermissions = useRoomPermissions; exports.createRoomContext = createRoomContext; exports._RoomProvider = _RoomProvider; exports._useBroadcastEvent = _useBroadcastEvent; exports._useOthersListener = _useOthersListener; exports._useRoom = _useRoom; exports._useIsInsideRoom = _useIsInsideRoom; exports._useAddReaction = _useAddReaction; exports._useMutation = _useMutation; exports._useCreateThread = _useCreateThread; exports._useDeleteThread = _useDeleteThread; exports._useEditThreadMetadata = _useEditThreadMetadata; exports._useEventListener = _useEventListener; exports._useMyPresence = _useMyPresence; exports._useOthersMapped = _useOthersMapped; exports._useOthersMappedSuspense = _useOthersMappedSuspense; exports._useThreads = _useThreads; exports._useThreadsSuspense = _useThreadsSuspense; exports._useRoomSubscriptionSettings = _useRoomSubscriptionSettings; exports._useRoomSubscriptionSettingsSuspense = _useRoomSubscriptionSettingsSuspense; exports._useHistoryVersions = _useHistoryVersions; exports._useHistoryVersionsSuspense = _useHistoryVersionsSuspense; exports._useOther = _useOther; exports._useOthers = _useOthers; exports._useOtherSuspense = _useOtherSuspense; exports._useOthersSuspense = _useOthersSuspense; exports._useStorage = _useStorage; exports._useStorageSuspense = _useStorageSuspense; exports._useSelf = _useSelf; exports._useSelfSuspense = _useSelfSuspense; exports._useStorageRoot = _useStorageRoot; exports._useUpdateMyPresence = _useUpdateMyPresence;
//# sourceMappingURL=chunk-4GCS3365.cjs.map