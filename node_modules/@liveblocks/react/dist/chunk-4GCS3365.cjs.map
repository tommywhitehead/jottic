{"version":3,"sources":["/home/runner/work/liveblocks/liveblocks/packages/liveblocks-react/dist/chunk-4GCS3365.cjs","../src/contexts.ts","../src/lib/use-latest.ts","../src/ai.tsx","../src/use-sync-external-store-with-selector.ts","../src/use-signal.ts","../src/liveblocks.tsx","../src/config.ts","../src/lib/AsyncResult.ts","../src/lib/itertools.ts","../src/lib/ssr.ts","../src/lib/use-initial.ts","../src/lib/use-polyfill.ts","../src/umbrella-store.ts","../src/lib/autobind.ts","../src/lib/querying.ts","../src/ThreadDB.ts","../src/room.tsx","../src/use-scroll-to-comment-on-load-effect.ts"],"names":["RegisterAiKnowledge","useEffect","layerKey","RegisterAiTool","useRef","nextSelection","useMemo","MutableSignal","updates","batch","kInternal","nanoid","threads"],"mappings":"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B,IAAA;AACS,IAAA;AACjB,EAAA;AAGtB,EAAA;AACE,IAAA;AAA+B,EAAA;AAGjC,EAAA;AAAO,IAAA;AACC,IAAA;AACN,IAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AAEJ;AAQA;AACE,EAAA;AACA,EAAA;AAEA,EAAA;AAA8B,IAAA;AACuB,IAAA;AACjB,EAAA;AAEpC,EAAA;AAEA,EAAA;AACE,IAAA;AAA8C,EAAA;AAGhD,EAAA;AACE,IAAA;AAAyB,EAAA;AAG3B,EAAA;AAAc,IAAA;AACQ,IAAA;AACpB,IAAA;AACA,EAAA;AAEF,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AAAO,IAAA;AACM,IAAA;AACA,IAAA;AACJ,EAAA;AAEX;AAKA;AACE,EAAA;AACA,EAAA;AACA,EAAA;AACF;AAwCO;AAOL,EAAA;AACF;AASA;AAUA;AAcA;AAMA;AAQA;AASA;AA6CA;AASA;AAUA;AAUA;AAmBA;AAcA;AA0BA;AA0BA;AASA;AAQA;AAUA;AAUA;AASA;AASA;AAYA;AA+CA;AACE,EAAA;AACF;AAWA;AA+CA;AACE,EAAA;AACF;AAqBA;AAqBA;AAwCA;AACE,EAAA;AACF;AAiCA;AACE,EAAA;AACF;AASA;AAaA;AjB8gDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/liveblocks/liveblocks/packages/liveblocks-react/dist/chunk-4GCS3365.cjs","sourcesContent":[null,"import type {\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  Json,\n  JsonObject,\n  LsonObject,\n  Room,\n} from \"@liveblocks/client\";\nimport type { OpaqueClient, OpaqueRoom } from \"@liveblocks/core\";\nimport { raise } from \"@liveblocks/core\";\nimport { createContext, useContext } from \"react\";\n\n/**\n * Raw access to the React context where the LiveblocksProvider stores the\n * current client. Exposed for advanced use cases only.\n *\n * @private This is a private/advanced API. Do not rely on it.\n */\nexport const ClientContext = createContext<OpaqueClient | null>(null);\n\n/**\n * @private This is an internal API.\n */\nexport function useClientOrNull<U extends BaseUserMeta>() {\n  return useContext(ClientContext) as Client<U> | null;\n}\n\n/**\n * Obtains a reference to the current Liveblocks client.\n */\nexport function useClient<U extends BaseUserMeta>() {\n  return (\n    useClientOrNull<U>() ??\n    raise(\"LiveblocksProvider is missing from the React tree.\")\n  );\n}\n\n/**\n * Raw access to the React context where the RoomProvider stores the current\n * room. Exposed for advanced use cases only.\n *\n * @private This is a private/advanced API. Do not rely on it.\n */\nexport const RoomContext = createContext<OpaqueRoom | null>(null);\n\n/** @private */\nexport function useRoomOrNull<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(): Room<P, S, U, E, M> | null {\n  return useContext(RoomContext) as Room<P, S, U, E, M> | null;\n}\n\n/**\n * Returns whether the hook is called within a RoomProvider context.\n *\n * @example\n * const isInsideRoom = useIsInsideRoom();\n */\nexport function useIsInsideRoom(): boolean {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n","import type { MutableRefObject } from \"react\";\nimport { useEffect, useRef } from \"react\";\n\n/**\n * Keeps a ref in sync with a given value that may or may not change on\n * every render.\n *\n * The purpose of this hook is to return a stable ref that can be passed\n * to a callback function so the callback can be registered but still can\n * access the latest value at a later point in time.\n */\nexport function useLatest<T>(value: T): MutableRefObject<T> {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n","import { kInternal, nanoid } from \"@liveblocks/core\";\nimport { memo, useEffect, useId, useState } from \"react\";\n\nimport { useClient } from \"./contexts\";\nimport type { RegisterAiKnowledgeProps, RegisterAiToolProps } from \"./types/ai\";\n\nfunction useAi() {\n  return useClient()[kInternal].ai;\n}\n\nfunction useRandom() {\n  return useState(nanoid)[0];\n}\n\n/**\n * Make knowledge about your application state available to any AI used in\n * a chat or a one-off request.\n *\n * For example:\n *\n *     <RegisterAiKnowledge\n *        description=\"The current mode of my application\"\n *        value=\"dark\" />\n *\n *     <RegisterAiKnowledge\n *        description=\"The current list of todos\"\n *        value={todos} />\n *\n * By mounting this component, the AI will get access to this knwoledge.\n * By unmounting this component, the AI will no longer have access to it.\n * It can choose to use or ignore this knowledge in its responses.\n */\nexport const RegisterAiKnowledge = memo(function RegisterAiKnowledge(\n  props: RegisterAiKnowledgeProps\n) {\n  const layerId = useId();\n  const ai = useAi();\n  const { description, value } = props;\n\n  const [layerKey, setLayerKey] = useState<\n    ReturnType<typeof ai.registerKnowledgeLayer> | undefined\n  >();\n\n  // Executes at mount / unmount\n  useEffect(() => {\n    const layerKey = ai.registerKnowledgeLayer(layerId);\n    setLayerKey(layerKey);\n    return () => {\n      ai.deregisterKnowledgeLayer(layerKey);\n      setLayerKey(undefined);\n    };\n  }, [ai, layerId]);\n\n  // Executes every render (if the props have changed)\n  const randomKey = useRandom();\n  const knowledgeKey = props.id ?? randomKey;\n  useEffect(() => {\n    if (layerKey !== undefined) {\n      ai.updateKnowledge(layerKey, { description, value }, knowledgeKey);\n    }\n  }, [ai, layerKey, knowledgeKey, description, value]);\n\n  return null;\n});\n\n/**\n * Make a tool available to your AI chat or a one-off request.\n * A tool is a piece of functionality that the AI can call to perform an action\n * or look up information on the user's behalf.\n *\n * Also, tools are used to render custom UIs for tool invocations, which are\n * embedded inside the AI chat.\n *\n * For example:\n *\n *   <RegisterAiTool\n *     name=\"list-todos\"\n *     tool={defineAiTool()({ ... })}\n *     />\n *\n * Or scoped to a specific chat:\n *\n *   <RegisterAiTool\n *     name=\"list-todos\"\n *     tool={defineAiTool()({ ... })}\n *     chatId=\"chat-1234\"\n *     />\n *\n * By mounting this component, the tool is made available.\n * By unmounting this component, the tool will no longer be available.\n */\nexport const RegisterAiTool = memo(function RegisterAiTool({\n  chatId,\n  name,\n  tool,\n  enabled,\n}: RegisterAiToolProps) {\n  // Register the provided tools to the chat on mount and unregister them on unmount\n  const client = useClient();\n  const ai = client[kInternal].ai;\n  useEffect(() => {\n    // The `enabled` prop, when specified, will take precedence over the\n    // `enabled` property of the tool itself. This allows enabling or disabling\n    // the tool dynamically.\n    const toolWithEnabled = enabled !== undefined ? { ...tool, enabled } : tool;\n    return ai.registerTool(name, toolWithEnabled, chatId);\n  }, [ai, chatId, name, tool, enabled]);\n\n  return null;\n});\n","/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable react-hooks/exhaustive-deps */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {\n  useDebugValue,\n  useEffect,\n  useMemo,\n  useRef,\n  useSyncExternalStore,\n} from \"react\";\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  );\n}\n\n// Same as useSyncExternalStore, but supports selector and isEqual arguments.\nexport function useSyncExternalStoreWithSelector<Snapshot, Selection>(\n  subscribe: (callback: () => void) => () => void,\n  getSnapshot: () => Snapshot,\n  getServerSnapshot: void | null | (() => Snapshot),\n  selector: (snapshot: Snapshot) => Selection,\n  isEqual?: (a: Selection, b: Selection) => boolean\n): Selection {\n  type X =\n    | { hasValue: true; value: Selection }\n    | { hasValue: false; value: null }\n    | null;\n\n  // Use this to track the rendered snapshot.\n  const instRef = useRef<X>(null);\n\n  let inst: X;\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null,\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  const [getSelection, getServerSelection] = useMemo(() => {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    let hasMemo = false;\n    let memoizedSnapshot: unknown;\n    let memoizedSelection: Selection;\n    const memoizedSelector = (nextSnapshot: Snapshot) => {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n        const nextSelection = selector(nextSnapshot);\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            const currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSelection)) {\n              memoizedSelection = currentSelection!;\n              return currentSelection;\n            }\n          }\n        }\n        memoizedSelection = nextSelection;\n        return nextSelection;\n      }\n\n      // We may be able to reuse the previous invocation's result.\n      const prevSnapshot: Snapshot = memoizedSnapshot as any;\n      const prevSelection: Selection = memoizedSelection as any;\n\n      if (is(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      }\n\n      // The snapshot has changed, so we need to compute a new selection.\n      const nextSelection = selector(nextSnapshot);\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        // The snapshot still has changed, so make sure to update to not keep\n        // old references alive\n        memoizedSnapshot = nextSnapshot;\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    };\n\n    const maybeGetServerSnapshot =\n      getServerSnapshot === undefined ? null : getServerSnapshot;\n    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());\n    const getServerSnapshotWithSelector =\n      maybeGetServerSnapshot === null\n        ? undefined\n        : () => memoizedSelector(maybeGetServerSnapshot());\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]);\n\n  const value = useSyncExternalStore(\n    subscribe,\n    getSelection,\n    getServerSelection\n  );\n\n  useEffect(() => {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n\n  useDebugValue(value);\n  return value;\n}\n","import type { ISignal } from \"@liveblocks/core\";\nimport { MutableSignal } from \"@liveblocks/core\";\n\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nconst identity = <T>(value: T): T => value;\n\nexport function useSignal<T>(signal: ISignal<T>): T;\nexport function useSignal<T, V>(\n  signal: ISignal<T>,\n  selector: (value: T) => V,\n  isEqual?: (a: V, b: V) => boolean\n): V;\nexport function useSignal<T, V>(\n  signal: ISignal<T>,\n  selector?: (value: T) => V,\n  isEqual?: (a: V, b: V) => boolean\n): T | V {\n  if (signal instanceof MutableSignal) {\n    throw new Error(\n      \"Using a mutable Signal with useSignal will likely not work as expected.\"\n    );\n  }\n  return useSyncExternalStoreWithSelector(\n    signal.subscribe,\n    signal.get,\n    signal.get,\n    selector ?? (identity as (value: T) => V),\n    isEqual\n  );\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  ClientOptions,\n  ThreadData,\n} from \"@liveblocks/client\";\nimport type {\n  AiUserMessage,\n  AsyncResult,\n  BaseGroupInfo,\n  BaseRoomInfo,\n  CopilotId,\n  DM,\n  DU,\n  LiveblocksError,\n  MessageId,\n  OpaqueClient,\n  PartialNotificationSettings,\n  SyncStatus,\n  WithRequired,\n} from \"@liveblocks/core\";\nimport {\n  assert,\n  console,\n  createClient,\n  HttpError,\n  kInternal,\n  makePoller,\n  raise,\n  shallow,\n} from \"@liveblocks/core\";\nimport type { PropsWithChildren } from \"react\";\nimport {\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n  useSyncExternalStore,\n} from \"react\";\n\nimport { RegisterAiKnowledge, RegisterAiTool } from \"./ai\";\nimport { config } from \"./config\";\nimport {\n  ClientContext,\n  useClient,\n  useClientOrNull,\n  useIsInsideRoom,\n} from \"./contexts\";\nimport { ASYNC_OK } from \"./lib/AsyncResult\";\nimport { count } from \"./lib/itertools\";\nimport { ensureNotServerSide } from \"./lib/ssr\";\nimport { useInitial, useInitialUnlessFunction } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { use } from \"./lib/use-polyfill\";\nimport type {\n  AiChatAsyncResult,\n  AiChatAsyncSuccess,\n  AiChatMessagesAsyncResult,\n  AiChatMessagesAsyncSuccess,\n  AiChatsAsyncResult,\n  AiChatsAsyncSuccess,\n  CreateAiChatOptions,\n  GroupInfoAsyncResult,\n  GroupInfoAsyncSuccess,\n  InboxNotificationsAsyncResult,\n  LiveblocksContextBundle,\n  NotificationSettingsAsyncResult,\n  NotificationSettingsAsyncSuccess,\n  RoomInfoAsyncResult,\n  RoomInfoAsyncSuccess,\n  SendAiMessageOptions,\n  SharedContextBundle,\n  ThreadsAsyncResult,\n  ThreadsAsyncSuccess,\n  UnreadInboxNotificationsCountAsyncResult,\n  UseAiChatsOptions,\n  UseInboxNotificationsOptions,\n  UserAsyncResult,\n  UserAsyncSuccess,\n  UseSendAiMessageOptions,\n  UseSyncStatusOptions,\n  UseUserThreadsOptions,\n} from \"./types\";\nimport {\n  makeAiChatsQueryKey,\n  makeInboxNotificationsQueryKey,\n  makeUserThreadsQueryKey,\n  UmbrellaStore,\n} from \"./umbrella-store\";\nimport { useSignal } from \"./use-signal\";\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nfunction missingUserError(userId: string) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\n\nfunction missingRoomInfoError(roomId: string) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\n\nfunction missingGroupInfoError(groupId: string) {\n  return new Error(\n    `resolveGroupsInfo didn't return anything for group '${groupId}'`\n  );\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n\nconst _umbrellaStores = new WeakMap<\n  OpaqueClient,\n  UmbrellaStore<BaseMetadata>\n>();\nconst _extras = new WeakMap<\n  OpaqueClient,\n  ReturnType<typeof makeLiveblocksExtrasForClient>\n>();\nconst _bundles = new WeakMap<\n  OpaqueClient,\n  LiveblocksContextBundle<BaseUserMeta, BaseMetadata>\n>();\n\nfunction selectorFor_useUnreadInboxNotificationsCount(\n  result: InboxNotificationsAsyncResult\n): UnreadInboxNotificationsCountAsyncResult {\n  if (!result.inboxNotifications) {\n    // Can be loading or error states\n    return result;\n  }\n\n  return ASYNC_OK(\n    \"count\",\n    count(\n      result.inboxNotifications,\n      (n) => n.readAt === null || n.readAt < n.notifiedAt\n    )\n  );\n}\n\nfunction selectorFor_useUser<U extends BaseUserMeta>(\n  state: AsyncResult<U[\"info\"] | undefined> | undefined,\n  userId: string\n): UserAsyncResult<U[\"info\"]> {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this user\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    user: state.data,\n  };\n}\n\nfunction selectorFor_useRoomInfo(\n  state: AsyncResult<BaseRoomInfo | undefined> | undefined,\n  roomId: string\n): RoomInfoAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this room info\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    info: state.data,\n  };\n}\n\nfunction selectorFor_useGroupInfo(\n  state: AsyncResult<BaseGroupInfo | undefined> | undefined,\n  groupId: string\n): GroupInfoAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this group info\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingGroupInfoError(groupId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    info: state.data,\n  };\n}\n\nfunction getOrCreateContextBundle<\n  U extends BaseUserMeta,\n  M extends BaseMetadata,\n>(client: OpaqueClient): LiveblocksContextBundle<U, M> {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle as LiveblocksContextBundle<U, M>;\n}\n\n/**\n * Gets or creates a unique Umbrella store for each unique client instance.\n *\n * @private\n */\nexport function getUmbrellaStoreForClient<M extends BaseMetadata>(\n  client: OpaqueClient\n): UmbrellaStore<M> {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store as unknown as UmbrellaStore<M>;\n}\n\n// TODO: Likely a better / more clear name for this helper will arise. I'll\n// rename this later. All of these are implementation details to support inbox\n// notifications on a per-client basis.\n/** @internal Only exported for unit tests. */\nexport function getLiveblocksExtrasForClient<M extends BaseMetadata>(\n  client: OpaqueClient\n) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n\n  return extras as unknown as Omit<typeof extras, \"store\"> & {\n    store: UmbrellaStore<M>;\n  };\n}\n\n// Connect to the AI socket whenever this hook is called, to use in all AI-related hooks.\n//\n// The internal `ManagedSocket` no-ops when calling `connect()` if it is already connected,\n// so we don't need any conditional logic here. And we don't call `disconnect()` in cleanup\n// here because we don't want to disconnect whenever a single hook unmounts, instead we\n// disconnect when `LiveblocksProvider` unmounts.\n//\n// This is a short-term solution to avoid always asking for an auth token on mount\n// even when AI isn't used.\n//\n// - We maybe could disconnect whenever the last AI-related hook unmounts\n// - We maybe could avoid connecting if we already have a token (from another Liveblocks feature),\n//   and already know that the user doesn't have AI enabled\nfunction useEnsureAiConnection(client: OpaqueClient) {\n  useEffect(() => {\n    client[kInternal].ai.connectInitially();\n  }, [client]);\n}\n\nfunction makeLiveblocksExtrasForClient(client: OpaqueClient) {\n  const store = getUmbrellaStoreForClient(client);\n  // TODO                                ^ Bind to M type param here\n\n  //\n  // How pagination and delta updates work\n  // =====================================\n  //\n  // Suppose we call fetchInboxNotifications() for the first time. Then,\n  // eventually we'll see this timeline of notifications:\n  //\n  // <-- Newer                        Older -->\n  //       |---o---------o----------o---|\n  //\n  //       o = an inbox notification\n  //\n  // In this array, there are three entries, ordered from latest to oldest.\n  //\n  // Now if we call fetchInboxNotifications() again (which is what the\n  // periodic poller does), then the array may get updated with newer inbox\n  // notifications, meaning entries will appear at the head end of the array.\n  // This is a so called \"delta update\".\n  //\n  // <-- Newer                                 Older -->\n  //       |--o---o-|---o---------o----------o---|\n  //          delta\n  //\n  // Here, two new entries have appeared at the start.\n  //\n  // Another way to update this array is to use \"pagination\". Pagination will\n  // update this list at the _tail_ end.\n  //\n  // After calling fetchMore():\n  //\n  // <-- Newer                                                  Older -->\n  //       |--o---o-|---o---------o----------o---|--o--o-o-o-o-o--|\n  //                                                   page 2\n  //\n  // And calling fetchMore() another time:\n  //\n  // <-- Newer                                                                  Older -->\n  //       |--o---o-|---o---------o----------o---|--o--o-o-o-o-o--|--o-o---o---o--|\n  //                                                   page 2           page 3\n  //\n  // In terms of HTTP requests:\n  // - A delta update will perform a GET /v2/c/inbox-notifications?since=...\n  // - Pagination will perform a GET /v2/c/inbox-notifications?cursor=...\n  //\n\n  const notificationsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n\n  const userThreadsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n\n  const notificationSettingsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.refreshNotificationSettings(signal);\n      } catch (err) {\n        console.warn(\n          `Polling new notification settings failed: ${String(err)}`\n        );\n        throw err;\n      }\n    },\n    config.USER_NOTIFICATION_SETTINGS_INTERVAL,\n    { maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n  );\n\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller,\n    notificationSettingsPoller,\n  };\n}\n\nfunction makeLiveblocksContextBundle<\n  U extends BaseUserMeta,\n  M extends BaseMetadata,\n>(client: Client<U>): LiveblocksContextBundle<U, M> {\n  // Bind all hooks to the current client instance\n  const useInboxNotificationThread = (inboxNotificationId: string) =>\n    useInboxNotificationThread_withClient<M>(client, inboxNotificationId);\n\n  const useMarkInboxNotificationAsRead = () =>\n    useMarkInboxNotificationAsRead_withClient(client);\n\n  const useMarkAllInboxNotificationsAsRead = () =>\n    useMarkAllInboxNotificationsAsRead_withClient(client);\n\n  const useDeleteInboxNotification = () =>\n    useDeleteInboxNotification_withClient(client);\n\n  const useDeleteAllInboxNotifications = () =>\n    useDeleteAllInboxNotifications_withClient(client);\n\n  const useUpdateNotificationSettings = () =>\n    useUpdateNotificationSettings_withClient(client);\n\n  // NOTE: This version of the LiveblocksProvider does _not_ take any props.\n  // This is because we already have a client bound to it.\n  function LiveblocksProvider(props: PropsWithChildren) {\n    useEnsureNoLiveblocksProvider();\n    return (\n      <ClientContext.Provider value={client}>\n        {props.children}\n      </ClientContext.Provider>\n    );\n  }\n\n  const shared = createSharedContext<U>(client);\n\n  const bundle: LiveblocksContextBundle<U, M> = {\n    LiveblocksProvider,\n\n    useInboxNotifications: (options?: UseInboxNotificationsOptions) =>\n      useInboxNotifications_withClient(client, identity, shallow, options),\n    useUnreadInboxNotificationsCount: (\n      options?: UseInboxNotificationsOptions\n    ) => useUnreadInboxNotificationsCount_withClient(client, options),\n\n    useMarkInboxNotificationAsRead,\n    useMarkAllInboxNotificationsAsRead,\n\n    useDeleteInboxNotification,\n    useDeleteAllInboxNotifications,\n\n    useNotificationSettings: () => useNotificationSettings_withClient(client),\n    useUpdateNotificationSettings,\n\n    useInboxNotificationThread,\n    useUserThreads_experimental,\n\n    useAiChats,\n    useAiChat,\n    useAiChatMessages,\n    useCreateAiChat,\n    useDeleteAiChat,\n    useSendAiMessage,\n\n    ...shared.classic,\n\n    suspense: {\n      LiveblocksProvider,\n\n      useInboxNotifications: (options?: UseInboxNotificationsOptions) =>\n        useInboxNotificationsSuspense_withClient(client, options),\n      useUnreadInboxNotificationsCount: (\n        options?: UseInboxNotificationsOptions\n      ) => useUnreadInboxNotificationsCountSuspense_withClient(client, options),\n\n      useMarkInboxNotificationAsRead,\n      useMarkAllInboxNotificationsAsRead,\n\n      useDeleteInboxNotification,\n      useDeleteAllInboxNotifications,\n\n      useInboxNotificationThread,\n\n      useNotificationSettings: () =>\n        useNotificationSettingsSuspense_withClient(client),\n      useUpdateNotificationSettings,\n\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n\n      useAiChats: useAiChatsSuspense,\n      useAiChat: useAiChatSuspense,\n      useAiChatMessages: useAiChatMessagesSuspense,\n      useCreateAiChat,\n      useDeleteAiChat,\n      useSendAiMessage,\n\n      ...shared.suspense,\n    },\n  };\n  return bundle;\n}\n\nfunction useInboxNotifications_withClient<T>(\n  client: OpaqueClient,\n  selector: (result: InboxNotificationsAsyncResult) => T,\n  isEqual: (a: T, b: T) => boolean,\n  options?: UseInboxNotificationsOptions\n): T {\n  const { store, notificationsPoller: poller } =\n    getLiveblocksExtrasForClient(client);\n\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n\n  // Trigger initial loading of inbox notifications if it hasn't started\n  // already, but don't await its promise.\n  useEffect(\n    () =>\n      void store.outputs.loadingNotifications\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  return useSignal(\n    store.outputs.loadingNotifications.getOrCreate(queryKey).signal,\n    selector,\n    isEqual\n  );\n}\n\nfunction useInboxNotificationsSuspense_withClient(\n  client: OpaqueClient,\n  options?: UseInboxNotificationsOptions\n) {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n\n  // Suspend until there are at least some inbox notifications\n  use(\n    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()\n  );\n\n  // We're in a Suspense world here, and as such, the useInboxNotifications()\n  // hook is expected to only return success results when we're here.\n  const result = useInboxNotifications_withClient(\n    client,\n    identity,\n    shallow,\n    options\n  );\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction useUnreadInboxNotificationsCount_withClient(\n  client: OpaqueClient,\n  options?: UseInboxNotificationsOptions\n) {\n  return useInboxNotifications_withClient(\n    client,\n    selectorFor_useUnreadInboxNotificationsCount,\n    shallow,\n    options\n  );\n}\n\nfunction useUnreadInboxNotificationsCountSuspense_withClient(\n  client: OpaqueClient,\n  options?: UseInboxNotificationsOptions\n) {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n\n  // Suspend until there are at least some inbox notifications\n  use(\n    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()\n  );\n\n  const result = useUnreadInboxNotificationsCount_withClient(client, options);\n  assert(!result.isLoading, \"Did not expect loading\");\n  assert(!result.error, \"Did not expect error\");\n  return result;\n}\n\nfunction useMarkInboxNotificationAsRead_withClient(client: OpaqueClient) {\n  return useCallback(\n    (inboxNotificationId: string) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n\n      const readAt = new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt,\n      });\n\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.markInboxNotificationRead(\n            inboxNotificationId,\n            readAt,\n            optimisticId\n          );\n        },\n        (err: Error) => {\n          store.optimisticUpdates.remove(optimisticId);\n          // XXX_vincent Add unit test for this error\n          client[kInternal].emitError(\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              inboxNotificationId,\n            },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useMarkAllInboxNotificationsAsRead_withClient(client: OpaqueClient) {\n  return useCallback(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const readAt = new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt,\n    });\n\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        // Replace the optimistic update by the real thing\n        store.markAllInboxNotificationsRead(optimisticId, readAt);\n      },\n      (err: Error) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[kInternal].emitError(\n          // No roomId, threadId, commentId to include for this error\n          { type: \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\n\nfunction useDeleteInboxNotification_withClient(client: OpaqueClient) {\n  return useCallback(\n    (inboxNotificationId: string) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n\n      const deletedAt = new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt,\n      });\n\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.deleteInboxNotification(inboxNotificationId, optimisticId);\n        },\n        (err: Error) => {\n          store.optimisticUpdates.remove(optimisticId);\n          // XXX_vincent Add unit test for this error\n          client[kInternal].emitError(\n            { type: \"DELETE_INBOX_NOTIFICATION_ERROR\", inboxNotificationId },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useDeleteAllInboxNotifications_withClient(client: OpaqueClient) {\n  return useCallback(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const deletedAt = new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt,\n    });\n\n    client.deleteAllInboxNotifications().then(\n      () => {\n        // Replace the optimistic update by the real thing\n        store.deleteAllInboxNotifications(optimisticId);\n      },\n      (err: Error) => {\n        store.optimisticUpdates.remove(optimisticId);\n        // XXX_vincent Add unit test for this error\n        client[kInternal].emitError(\n          { type: \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\n\nfunction useInboxNotificationThread_withClient<M extends BaseMetadata>(\n  client: OpaqueClient,\n  inboxNotificationId: string\n): ThreadData<M> {\n  const { store } = getLiveblocksExtrasForClient<M>(client);\n  return useSignal(\n    store.outputs.threadifications,\n    useCallback(\n      (state) => {\n        const inboxNotification =\n          state.notificationsById[inboxNotificationId] ??\n          raise(\n            `Inbox notification with ID \"${inboxNotificationId}\" not found`\n          );\n\n        if (inboxNotification.kind !== \"thread\") {\n          raise(\n            `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n          );\n        }\n\n        const thread =\n          state.threadsDB.get(inboxNotification.threadId) ??\n          raise(\n            `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n          );\n\n        return thread;\n      },\n      [inboxNotificationId]\n    )\n  );\n}\n\nfunction useUpdateNotificationSettings_withClient(\n  client: OpaqueClient\n): (settings: PartialNotificationSettings) => void {\n  return useCallback(\n    (settings: PartialNotificationSettings): void => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const optimisticUpdateId = store.optimisticUpdates.add({\n        type: \"update-notification-settings\",\n        settings,\n      });\n\n      client.updateNotificationSettings(settings).then(\n        (settings) => {\n          // Replace the optimistic update by the real thing\n          store.updateNotificationSettings_confirmOptimisticUpdate(\n            settings,\n            optimisticUpdateId\n          );\n        },\n        (err: Error) => {\n          // Remove optimistic update when it fails\n          store.optimisticUpdates.remove(optimisticUpdateId);\n          // Check if the error is an HTTP error\n          if (err instanceof HttpError) {\n            if (err.status === 422) {\n              const msg = [err.details?.error, err.details?.reason]\n                .filter(Boolean)\n                .join(\"\\n\");\n              console.error(msg);\n            }\n\n            client[kInternal].emitError(\n              {\n                type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\",\n              },\n              err\n            );\n          }\n          // A non-HTTP error is unexpected and must be considered as a bug.\n          // We should fix it and do not notify users about it.\n          else {\n            throw err;\n          }\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useNotificationSettings_withClient(\n  client: OpaqueClient\n): [\n  NotificationSettingsAsyncResult,\n  (settings: PartialNotificationSettings) => void,\n] {\n  const updateNotificationSettings =\n    useUpdateNotificationSettings_withClient(client);\n\n  const { store, notificationSettingsPoller: poller } =\n    getLiveblocksExtrasForClient(client);\n\n  useEffect(() => {\n    void store.outputs.notificationSettings.waitUntilLoaded();\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  });\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  const result = useSignal(store.outputs.notificationSettings.signal);\n\n  return useMemo(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\n\nfunction useNotificationSettingsSuspense_withClient(\n  client: OpaqueClient\n): [\n  NotificationSettingsAsyncSuccess,\n  (settings: PartialNotificationSettings) => void,\n] {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  // Suspend until there are at least some notification settings\n  use(store.outputs.notificationSettings.waitUntilLoaded());\n\n  // We're in a Suspense world here, and as such, the useNotificationSettings()\n  // hook is expected to only return success results when we're here.\n  const [result, updateNotificationSettings] =\n    useNotificationSettings_withClient(client);\n\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n\n  return useMemo(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\n\nfunction useUser_withClient<U extends BaseUserMeta>(\n  client: Client<U>,\n  userId: string\n): UserAsyncResult<U[\"info\"]> {\n  const usersStore = client[kInternal].usersStore;\n\n  const getUserState = useCallback(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getUserState>) =>\n      selectorFor_useUser(state, userId),\n    [userId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void usersStore.enqueue(userId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call usersStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the userId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the userId gets invalidated, the user would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useUserSuspense_withClient<U extends BaseUserMeta>(\n  client: Client<U>,\n  userId: string\n) {\n  const usersStore = client[kInternal].usersStore;\n\n  const getUserState = useCallback(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n\n  if (!userState || userState.isLoading) {\n    throw usersStore.enqueue(userId);\n  }\n\n  if (userState.error) {\n    throw userState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveUsers` for this user ID\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n\n  const state = useSyncExternalStore(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: undefined,\n  } as const;\n}\n\nfunction useRoomInfo_withClient(\n  client: OpaqueClient,\n  roomId: string\n): RoomInfoAsyncResult {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n\n  const getRoomInfoState = useCallback(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getRoomInfoState>) =>\n      selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void roomsInfoStore.enqueue(roomId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call roomsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the roomId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the roomId gets invalidated, the room info would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useRoomInfoSuspense_withClient(client: OpaqueClient, roomId: string) {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n\n  const getRoomInfoState = useCallback(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.enqueue(roomId);\n  }\n\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveRoomsInfo` for this room ID\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n\n  const state = useSyncExternalStore(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  assert(state.data !== undefined, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: undefined,\n  } as const;\n}\n\nfunction useGroupInfo_withClient(\n  client: OpaqueClient,\n  groupId: string\n): GroupInfoAsyncResult {\n  const groupsInfoStore = client[kInternal].groupsInfoStore;\n\n  const getGroupInfoState = useCallback(\n    () => groupsInfoStore.getItemState(groupId),\n    [groupsInfoStore, groupId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getGroupInfoState>) =>\n      selectorFor_useGroupInfo(state, groupId),\n    [groupId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    groupsInfoStore.subscribe,\n    getGroupInfoState,\n    getGroupInfoState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void groupsInfoStore.enqueue(groupId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call groupsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the groupId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the groupId gets invalidated, the group info would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useGroupInfoSuspense_withClient(\n  client: OpaqueClient,\n  groupId: string\n) {\n  const groupsInfoStore = client[kInternal].groupsInfoStore;\n\n  const getGroupInfoState = useCallback(\n    () => groupsInfoStore.getItemState(groupId),\n    [groupsInfoStore, groupId]\n  );\n  const groupInfoState = getGroupInfoState();\n\n  if (!groupInfoState || groupInfoState.isLoading) {\n    throw groupsInfoStore.enqueue(groupId);\n  }\n\n  if (groupInfoState.error) {\n    throw groupInfoState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveGroupsInfo` for this group ID\n  if (!groupInfoState.data) {\n    throw missingGroupInfoError(groupId);\n  }\n\n  const state = useSyncExternalStore(\n    groupsInfoStore.subscribe,\n    getGroupInfoState,\n    getGroupInfoState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  assert(state.data !== undefined, \"Unexpected missing group info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: undefined,\n  } as const;\n}\n\n/**\n * (Private beta)  Returns the chats for the current user.\n *\n * @example\n * const { chats } = useAiChats();\n */\nfunction useAiChats(options?: UseAiChatsOptions): AiChatsAsyncResult {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  const queryKey = makeAiChatsQueryKey(options?.query);\n\n  useEnsureAiConnection(client);\n\n  useEffect(\n    () => void store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(\n    store.outputs.aiChats.getOrCreate(queryKey).signal,\n    identity,\n    shallow\n  );\n}\n\nfunction useAiChatsSuspense(options?: UseAiChatsOptions): AiChatsAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  const queryKey = makeAiChatsQueryKey(options?.query);\n\n  use(store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useAiChats(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction useAiChatMessages(\n  chatId: string,\n  /** @internal */\n  options?: { branchId?: MessageId }\n): AiChatMessagesAsyncResult {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  useEffect(\n    () =>\n      void store.outputs.messagesByChatId\n        .getOrCreate(chatId)\n        .getOrCreate(options?.branchId ?? null)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(\n    store.outputs.messagesByChatId\n      .getOrCreate(chatId)\n      .getOrCreate(options?.branchId ?? null).signal\n  );\n}\n\nfunction useAiChatMessagesSuspense(\n  chatId: string,\n  /** @internal */\n  options?: { branchId?: MessageId }\n): AiChatMessagesAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  use(\n    store.outputs.messagesByChatId\n      .getOrCreate(chatId)\n      .getOrCreate(options?.branchId ?? null)\n      .waitUntilLoaded()\n  );\n\n  const result = useAiChatMessages(chatId, options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction useAiChat(chatId: string): AiChatAsyncResult {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  useEffect(\n    () => void store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(store.outputs.aiChatById.getOrCreate(chatId).signal);\n}\n\nfunction useAiChatSuspense(chatId: string): AiChatAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  use(store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded());\n\n  const result = useAiChat(chatId);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns a function that creates an AI chat.\n *\n * If you do not pass a title for the chat, it will be automatically computed\n * after the first AI response.\n *\n * @example\n * const createAiChat = useCreateAiChat();\n *\n * // Create a chat with an automatically generated title\n * createAiChat(\"ai-chat-id\");\n *\n * // Create a chat with a custom title\n * createAiChat({ id: \"ai-chat-id\", title: \"My AI chat\" });\n */\nfunction useCreateAiChat(): {\n  (chatId: string): void;\n  (options: CreateAiChatOptions): void;\n} {\n  const client = useClient();\n\n  return useCallback(\n    (options: string | CreateAiChatOptions) => {\n      if (typeof options === \"string\") {\n        options = { id: options };\n      }\n\n      client[kInternal].ai\n        .getOrCreateChat(options.id, {\n          title: options.title,\n          metadata: options.metadata,\n        })\n        .catch((err) => {\n          console.error(\n            `Failed to create chat with ID \"${options.id}\": ${String(err)}`\n          );\n        });\n    },\n    [client]\n  );\n}\n\n/**\n * Returns a function that deletes the AI chat with the specified id.\n *\n * @example\n * const deleteAiChat = useDeleteAiChat();\n * deleteAiChat(\"ai-chat-id\");\n */\nfunction useDeleteAiChat() {\n  const client = useClient();\n\n  return useCallback(\n    (chatId: string) => {\n      client[kInternal].ai.deleteChat(chatId).catch((err) => {\n        console.error(\n          `Failed to delete chat with ID \"${chatId}\": ${String(err)}`\n        );\n      });\n    },\n    [client]\n  );\n}\n\n/**\n * Returns a function to send a message in an AI chat.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(\"chat-id\");\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * You can set options related to the message being sent, such as the copilot ID to use.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(\"chat-id\", { copilotId: \"co_xxx\" });\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * @example\n * const sendAiMessage = useSendAiMessage(\"chat-id\", { copilotId: \"co_xxx\" });\n * sendAiMessage({ text: \"Hello, Liveblocks AI!\", copilotId: \"co_yyy\" });\n */\nfunction useSendAiMessage(\n  chatId: string,\n  options?: UseSendAiMessageOptions\n): {\n  (text: string): AiUserMessage;\n  (options: SendAiMessageOptions): AiUserMessage;\n};\n\n/**\n * Returns a function to send a message in an AI chat.\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\" });\n *\n * You can set options related to the message being sent, such as the copilot ID to use.\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\", copilotId: \"co_xxx\" });\n */\nfunction useSendAiMessage(): (\n  options: WithRequired<SendAiMessageOptions, \"chatId\">\n) => AiUserMessage;\n\n/**\n * Returns a function to send a message in an AI chat.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(chatId);\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * You can set options related to the message being sent, such as the copilot ID to use.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(chatId, { copilotId: \"co_xxx\" });\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * You can also pass the chat ID dynamically if it's not known when calling the hook.\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\" });\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\", copilotId: \"co_xxx\" });\n */\nfunction useSendAiMessage(\n  chatId?: string,\n  options?: UseSendAiMessageOptions\n): {\n  (text: string): AiUserMessage;\n  (options: SendAiMessageOptions): AiUserMessage;\n  (options: WithRequired<SendAiMessageOptions, \"chatId\">): AiUserMessage;\n} {\n  const client = useClient();\n\n  return useCallback(\n    (message: string | SendAiMessageOptions) => {\n      const {\n        text: messageText,\n        chatId: messageOptionsChatId,\n        copilotId: messageOptionsCopilotId,\n        ...messageOptions\n      } = typeof message === \"string\" ? { text: message } : message;\n      const resolvedChatId =\n        messageOptionsChatId ??\n        chatId ??\n        // The `useSendAiMessage` overloads prevent this scenario from happening\n        // at the type level, and this error prevents it from happening at runtime.\n        raise(\n          \"chatId must be provided to either `useSendAiMessage` or its returned function.\"\n        );\n\n      const messages = client[kInternal].ai.signals\n        .getChatMessagesForBranch(resolvedChatId)\n        .get();\n\n      if (\n        process.env.NODE_ENV !== \"production\" &&\n        !messageOptionsCopilotId &&\n        !options?.copilotId\n      ) {\n        console.warn(\n          `No copilot ID was provided to useSendAiMessage when sending the message \"${messageText.slice(\n            0,\n            20\n          )}\". As a result, the message will use the chat's previous copilot ID, which could lead to unexpected behavior.\\nTo ensure the correct copilot ID is used, specify it either through the hook as 'useSendAiMessage(\"${resolvedChatId}\", { copilotId: \"co_xxx\" })' or via the function as 'sendAiMessage({ text: \"${messageText.slice(\n            0,\n            20\n          )}\", copilotId: \"co_xxx\" })'`\n        );\n      }\n      const resolvedCopilotId = (messageOptionsCopilotId ??\n        options?.copilotId ??\n        client[kInternal].ai.getLastUsedCopilotId(resolvedChatId)) as\n        | CopilotId\n        | undefined;\n\n      const lastMessageId = messages[messages.length - 1]?.id ?? null;\n\n      const content = [{ type: \"text\" as const, text: messageText }];\n      const newMessageId = client[kInternal].ai[\n        kInternal\n      ].context.messagesStore.createOptimistically(\n        resolvedChatId,\n        \"user\",\n        lastMessageId,\n        content\n      );\n      const newMessage = client[kInternal].ai[\n        kInternal\n      ].context.messagesStore.getMessageById(newMessageId) as AiUserMessage;\n\n      const targetMessageId = client[kInternal].ai[\n        kInternal\n      ].context.messagesStore.createOptimistically(\n        resolvedChatId,\n        \"assistant\",\n        newMessageId,\n        resolvedCopilotId as CopilotId\n      );\n\n      void client[kInternal].ai.askUserMessageInChat(\n        resolvedChatId,\n        { id: newMessageId, parentMessageId: lastMessageId, content },\n        targetMessageId,\n        {\n          stream: messageOptions.stream ?? options?.stream,\n          copilotId: resolvedCopilotId,\n          timeout: messageOptions.timeout ?? options?.timeout,\n          knowledge: messageOptions.knowledge ?? options?.knowledge,\n        }\n      );\n\n      return newMessage;\n    },\n    [\n      client,\n      chatId,\n      options?.copilotId,\n      options?.stream,\n      options?.timeout,\n      options?.knowledge,\n    ]\n  );\n}\n\n/** @internal */\nexport function createSharedContext<U extends BaseUserMeta>(\n  client: Client<U>\n): SharedContextBundle<U> {\n  const useClient = () => client;\n\n  function useSyncStatus(options?: UseSyncStatusOptions) {\n    return useSyncStatus_withClient(client, options);\n  }\n\n  return {\n    classic: {\n      useClient,\n      useUser: (userId: string) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId: string) => useRoomInfo_withClient(client, roomId),\n      useGroupInfo: (groupId: string) =>\n        useGroupInfo_withClient(client, groupId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus,\n      RegisterAiKnowledge,\n      RegisterAiTool,\n    },\n    suspense: {\n      useClient,\n      useUser: (userId: string) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId: string) =>\n        useRoomInfoSuspense_withClient(client, roomId),\n      useGroupInfo: (groupId: string) =>\n        useGroupInfoSuspense_withClient(client, groupId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus,\n      RegisterAiKnowledge,\n      RegisterAiTool,\n    },\n  };\n}\n\n/**\n * @private This is an internal API.\n */\nfunction useEnsureNoLiveblocksProvider(options?: { allowNesting?: boolean }) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\n\n/**\n * @private This is a private API.\n */\nexport function LiveblocksProviderWithClient(\n  props: PropsWithChildren<{\n    client: OpaqueClient;\n\n    // Private flag, used only to skip the nesting check if this is\n    // a LiveblocksProvider created implicitly by a factory-bound RoomProvider.\n    allowNesting?: boolean;\n  }>\n) {\n  useEnsureNoLiveblocksProvider(props);\n  return (\n    <ClientContext.Provider value={props.client}>\n      {props.children}\n    </ClientContext.Provider>\n  );\n}\n\n/**\n * Sets up a client for connecting to Liveblocks, and is the recommended way to do\n * this for React apps. You must define either `authEndpoint` or `publicApiKey`.\n * Resolver functions should be placed inside here, and a number of other options\n * are available, which correspond with those passed to `createClient`.\n * Unlike `RoomProvider`, `LiveblocksProvider` doesnt call Liveblocks servers when mounted,\n * and it should be placed higher in your apps component tree.\n */\nexport function LiveblocksProvider<U extends BaseUserMeta = DU>(\n  props: PropsWithChildren<ClientOptions<U>>\n) {\n  const { children, ...o } = props;\n\n  // It's important that the static options remain stable, otherwise we'd be\n  // creating new client instances on every render.\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    largeMessageStrategy: useInitial(o.largeMessageStrategy),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),\n\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    resolveGroupsInfo: useInitialUnlessFunction(o.resolveGroupsInfo),\n\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl as string | undefined\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging as boolean | undefined\n    ),\n  } as ClientOptions<U>;\n\n  // NOTE: Deliberately not passing any deps here, because we'll _never_ want\n  // to recreate a client instance after the first render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const client = useMemo(() => createClient<U>(options), []);\n\n  // The AI socket is connected to via `useEnsureAiConnection` whenever at least one\n  // AI-related hook is used. We only handle disconnecting here when `LiveblocksProvider` unmounts.\n  useEffect(() => {\n    return () => {\n      client[kInternal].ai.disconnect();\n    };\n  }, [client]);\n\n  return (\n    <LiveblocksProviderWithClient client={client}>\n      {children}\n    </LiveblocksProviderWithClient>\n  );\n}\n\n/**\n * Creates a LiveblocksProvider and a set of typed hooks. Note that any\n * LiveblocksProvider created in this way takes no props, because it uses\n * settings from the given client instead.\n */\nexport function createLiveblocksContext<\n  U extends BaseUserMeta = DU,\n  M extends BaseMetadata = DM,\n>(client: OpaqueClient): LiveblocksContextBundle<U, M> {\n  return getOrCreateContextBundle<U, M>(client);\n}\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n *\n */\nfunction useUserThreads_experimental<M extends BaseMetadata>(\n  options: UseUserThreadsOptions<M> = {}\n): ThreadsAsyncResult<M> {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } =\n    getLiveblocksExtrasForClient<M>(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n\n  useEffect(\n    () =>\n      void store.outputs.loadingUserThreads\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  return useSignal(\n    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal\n  );\n}\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nfunction useUserThreadsSuspense_experimental<M extends BaseMetadata>(\n  options: UseUserThreadsOptions<M> = {}\n): ThreadsAsyncSuccess<M> {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient<M>(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n\n  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useUserThreads_experimental(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns the inbox notifications for the current user.\n *\n * @example\n * const { inboxNotifications, error, isLoading } = useInboxNotifications();\n */\nfunction useInboxNotifications(options?: UseInboxNotificationsOptions) {\n  return useInboxNotifications_withClient(\n    useClient(),\n    identity,\n    shallow,\n    options\n  );\n}\n\n/**\n * Returns the inbox notifications for the current user.\n *\n * @example\n * const { inboxNotifications } = useInboxNotifications();\n */\nfunction useInboxNotificationsSuspense(options?: UseInboxNotificationsOptions) {\n  return useInboxNotificationsSuspense_withClient(useClient(), options);\n}\n\nfunction useInboxNotificationThread<M extends BaseMetadata>(\n  inboxNotificationId: string\n) {\n  return useInboxNotificationThread_withClient<M>(\n    useClient(),\n    inboxNotificationId\n  );\n}\n\n/**\n * Returns a function that marks all of the current user's inbox notifications as read.\n *\n * @example\n * const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();\n * markAllInboxNotificationsAsRead();\n */\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\n\n/**\n * Returns a function that marks an inbox notification as read for the current user.\n *\n * @example\n * const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();\n * markInboxNotificationAsRead(\"in_xxx\");\n */\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\n\n/**\n * Returns a function that deletes all of the current user's inbox notifications.\n *\n * @example\n * const deleteAllInboxNotifications = useDeleteAllInboxNotifications();\n * deleteAllInboxNotifications();\n */\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\n\n/**\n * Returns a function that deletes an inbox notification for the current user.\n *\n * @example\n * const deleteInboxNotification = useDeleteInboxNotification();\n * deleteInboxNotification(\"in_xxx\");\n */\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\n\n/**\n * Returns the number of unread inbox notifications for the current user.\n *\n * @example\n * const { count, error, isLoading } = useUnreadInboxNotificationsCount();\n */\nfunction useUnreadInboxNotificationsCount(\n  options?: UseInboxNotificationsOptions\n) {\n  return useUnreadInboxNotificationsCount_withClient(useClient(), options);\n}\n\n/**\n * Returns the number of unread inbox notifications for the current user.\n *\n * @example\n * const { count } = useUnreadInboxNotificationsCount();\n */\nfunction useUnreadInboxNotificationsCountSuspense(\n  options?: UseInboxNotificationsOptions\n) {\n  return useUnreadInboxNotificationsCountSuspense_withClient(\n    useClient(),\n    options\n  );\n}\n\n/**\n * Returns notification settings for the current user.\n *\n * @example\n * const [{ settings }, updateNotificationSettings] = useNotificationSettings()\n */\nfunction useNotificationSettings() {\n  return useNotificationSettings_withClient(useClient());\n}\n\n/**\n * Returns notification settings for the current user.\n *\n * @example\n * const [{ settings }, updateNotificationSettings] = useNotificationSettings()\n */\nfunction useNotificationSettingsSuspense() {\n  return useNotificationSettingsSuspense_withClient(useClient());\n}\n\n/**\n * Returns a function that updates the user's notification\n * settings for a project.\n *\n * @example\n * const updateNotificationSettings = useUpdateNotificationSettings()\n */\nfunction useUpdateNotificationSettings() {\n  return useUpdateNotificationSettings_withClient(useClient());\n}\n\nfunction useUser<U extends BaseUserMeta>(userId: string) {\n  const client = useClient<U>();\n  return useUser_withClient(client, userId);\n}\n\nfunction useUserSuspense<U extends BaseUserMeta>(\n  userId: string\n): UserAsyncSuccess<U[\"info\"]> {\n  const client = useClient<U>();\n  return useUserSuspense_withClient(client, userId);\n}\n\n/**\n * Returns room info from a given room ID.\n *\n * @example\n * const { info, error, isLoading } = useRoomInfo(\"room-id\");\n */\nfunction useRoomInfo(roomId: string): RoomInfoAsyncResult {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\n\n/**\n * Returns room info from a given room ID.\n *\n * @example\n * const { info } = useRoomInfo(\"room-id\");\n */\nfunction useRoomInfoSuspense(roomId: string): RoomInfoAsyncSuccess {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\n\n/**\n * Returns group info from a given group ID.\n *\n * @example\n * const { info, error, isLoading } = useGroupInfo(\"group-id\");\n */\nfunction useGroupInfo(groupId: string): GroupInfoAsyncResult {\n  return useGroupInfo_withClient(useClient(), groupId);\n}\n\n/**\n * Returns group info from a given group ID.\n *\n * @example\n * const { info } = useGroupInfo(\"group-id\");\n */\nfunction useGroupInfoSuspense(groupId: string): GroupInfoAsyncSuccess {\n  return useGroupInfoSuspense_withClient(useClient(), groupId);\n}\n\ntype TypedBundle = LiveblocksContextBundle<DU, DM>;\n\n/**\n * Returns the thread associated with a `\"thread\"` inbox notification.\n *\n * It can **only** be called with IDs of `\"thread\"` inbox notifications,\n * so we recommend only using it when customizing the rendering or in other\n * situations where you can guarantee the kind of the notification.\n *\n * When `useInboxNotifications` returns `\"thread\"` inbox notifications,\n * it also receives the associated threads and caches them behind the scenes.\n * When you call `useInboxNotificationThread`, it simply returns the cached thread\n * for the inbox notification ID you passed to it, without any fetching or waterfalls.\n *\n * @example\n * const thread = useInboxNotificationThread(\"in_xxx\");\n */\nconst _useInboxNotificationThread: TypedBundle[\"useInboxNotificationThread\"] =\n  useInboxNotificationThread;\n\n/**\n * Returns user info from a given user ID.\n *\n * @example\n * const { user, error, isLoading } = useUser(\"user-id\");\n */\nconst _useUser: TypedBundle[\"useUser\"] = useUser;\n\n/**\n * Returns user info from a given user ID.\n *\n * @example\n * const { user } = useUser(\"user-id\");\n */\nconst _useUserSuspense: TypedBundle[\"suspense\"][\"useUser\"] = useUserSuspense;\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nconst _useUserThreads_experimental: TypedBundle[\"useUserThreads_experimental\"] =\n  useUserThreads_experimental;\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nconst _useUserThreadsSuspense_experimental: TypedBundle[\"suspense\"][\"useUserThreads_experimental\"] =\n  useUserThreadsSuspense_experimental;\n\n/**\n * (Private beta)  Returns the chats for the current user.\n *\n * @example\n * const { chats, error, isLoading } = useAiChats();\n */\nconst _useAiChats: TypedBundle[\"useAiChats\"] = useAiChats;\n\n/**\n * (Private beta)  Returns the chats for the current user.\n *\n * @example\n * const { chats, error, isLoading } = useAiChats();\n */\nconst _useAiChatsSuspense: TypedBundle[\"suspense\"][\"useAiChats\"] =\n  useAiChatsSuspense;\n\n/**\n * (Private beta)  Returns the information of the given chat.\n *\n * @example\n * const { chat, error, isLoading } = useAiChat(\"my-chat\");\n */\nconst _useAiChat: TypedBundle[\"useAiChat\"] = useAiChat;\n\n/**\n * (Private beta)  Returns the information of the given chat.\n *\n * @example\n * const { chat, error, isLoading } = useAiChat(\"my-chat\");\n */\nconst _useAiChatSuspense: TypedBundle[\"suspense\"][\"useAiChat\"] =\n  useAiChatSuspense;\n\n/**\n * (Private beta)  Returns the messages in the given chat.\n *\n * @example\n * const { messages, error, isLoading } = useAiChatMessages(\"my-chat\");\n */\nconst _useAiChatMessages: TypedBundle[\"useAiChatMessages\"] = useAiChatMessages;\n\n/**\n * (Private beta)  Returns the messages in the given chat.\n *\n * @example\n * const { messages, error, isLoading } = useAiChatMessages(\"my-chat\");\n */\nconst _useAiChatMessagesSuspense: TypedBundle[\"suspense\"][\"useAiChatMessages\"] =\n  useAiChatMessagesSuspense;\n\nfunction useSyncStatus_withClient(\n  client: OpaqueClient,\n  options?: UseSyncStatusOptions\n): SyncStatus {\n  // Normally the Rules of Hooks dictate that you should not call hooks\n  // conditionally. In this case, we're good here, because the same code path\n  // will always be taken on every subsequent render here, because we've frozen\n  // the value.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useSyncStatusSmooth_withClient(client);\n  } else {\n    return useSyncStatusImmediate_withClient(client);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n}\n\nfunction useSyncStatusImmediate_withClient(client: OpaqueClient): SyncStatus {\n  return useSyncExternalStore(\n    client.events.syncStatus.subscribe,\n    client.getSyncStatus,\n    client.getSyncStatus\n  );\n}\n\nfunction useSyncStatusSmooth_withClient(client: OpaqueClient): SyncStatus {\n  const getter = client.getSyncStatus;\n  const [status, setStatus] = useState(getter);\n  const oldStatus = useLatest(getter());\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const unsub = client.events.syncStatus.subscribe(() => {\n      const newStatus = getter();\n      if (\n        oldStatus.current === \"synchronizing\" &&\n        newStatus === \"synchronized\"\n      ) {\n        // Delay delivery of the \"synchronized\" event\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n\n    // Clean up\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [client, getter, oldStatus]);\n\n  return status;\n}\n\n/**\n * Returns the current Liveblocks sync status, and triggers a re-render\n * whenever it changes. Can be used to render a \"Saving...\" indicator, or for\n * preventing that a browser tab can be closed until all changes have been\n * synchronized with the server.\n *\n * @example\n * const syncStatus = useSyncStatus();  // \"synchronizing\" | \"synchronized\"\n * const syncStatus = useSyncStatus({ smooth: true });\n */\nfunction useSyncStatus(options?: UseSyncStatusOptions): SyncStatus {\n  return useSyncStatus_withClient(useClient(), options);\n}\n\n/**\n * useErrorListener is a React hook that allows you to respond to any\n * Liveblocks error, for example room connection errors, errors\n * creating/editing/deleting threads, etc.\n *\n * @example\n * useErrorListener(err => {\n *   console.error(err);\n * })\n */\nfunction useErrorListener(callback: (err: LiveblocksError) => void): void {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () => client.events.error.subscribe((e) => savedCallback.current(e)),\n    [client, savedCallback]\n  );\n}\n\n// eslint-disable-next-line simple-import-sort/exports\nexport {\n  _useInboxNotificationThread as useInboxNotificationThread,\n  _useUser as useUser,\n  _useUserSuspense as useUserSuspense,\n  useInboxNotifications,\n  useInboxNotificationsSuspense,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useDeleteAllInboxNotifications,\n  useDeleteInboxNotification,\n  useErrorListener,\n  useRoomInfo,\n  useRoomInfoSuspense,\n  useGroupInfo,\n  useGroupInfoSuspense,\n  useSyncStatus,\n  useUnreadInboxNotificationsCount,\n  useUnreadInboxNotificationsCountSuspense,\n  useNotificationSettings,\n  useNotificationSettingsSuspense,\n  useUpdateNotificationSettings,\n  _useUserThreads_experimental as useUserThreads_experimental,\n  _useUserThreadsSuspense_experimental as useUserThreadsSuspense_experimental,\n  _useAiChats as useAiChats,\n  _useAiChatsSuspense as useAiChatsSuspense,\n  _useAiChat as useAiChat,\n  _useAiChatSuspense as useAiChatSuspense,\n  _useAiChatMessages as useAiChatMessages,\n  _useAiChatMessagesSuspense as useAiChatMessagesSuspense,\n  useCreateAiChat,\n  useDeleteAiChat,\n  useSendAiMessage,\n};\n","const SECONDS = 1000;\nconst MINUTES = 60 * SECONDS;\n\n// Poller config\nexport const config = {\n  SMOOTH_DELAY: 1 * SECONDS,\n\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,\n\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n\n  ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,\n\n  USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,\n  USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES,\n};\n","import type { AsyncError, AsyncLoading, AsyncSuccess } from \"@liveblocks/core\";\n\n// TODO Maybe move these into @liveblocks/core if they are useful?\n\nexport const ASYNC_LOADING: AsyncLoading = Object.freeze({ isLoading: true });\n\nexport const ASYNC_ERR = (error: Error): AsyncError =>\n  Object.freeze({ isLoading: false, error });\n\nexport function ASYNC_OK<T>(data: T): AsyncSuccess<T>;\nexport function ASYNC_OK<T, F extends string>(\n  field: F,\n  data: T\n): AsyncSuccess<T, F>;\nexport function ASYNC_OK<T, F extends string>(\n  fieldOrData: F | T,\n  data?: T\n): AsyncSuccess<T, F> {\n  if (arguments.length === 1) {\n    // @ts-expect-error too dynamic to type\n    return Object.freeze({ isLoading: false, data: fieldOrData });\n  } else {\n    // @ts-expect-error too dynamic to type\n    return Object.freeze({ isLoading: false, [fieldOrData as F]: data });\n  }\n}\n","/**\n * Like Array.prototype.find(), but for iterables.\n *\n * Returns the first item in the iterable for which the predicate holds.\n * Returns undefined if item matches the predicate.\n */\nexport function find<T>(\n  it: Iterable<T>,\n  predicate: (value: T) => boolean\n): T | undefined {\n  for (const item of it) {\n    if (predicate(item)) return item;\n  }\n  return undefined;\n}\n\n/**\n * Counts the number of items in an iterable that match the predicate.\n */\nexport function count<T>(\n  it: Iterable<T>,\n  predicate: (value: T) => boolean\n): number {\n  let total = 0;\n  for (const item of it) {\n    if (predicate(item)) total++;\n  }\n  return total;\n}\n","export function ensureNotServerSide(): void {\n  // Error early if suspense is used in a server-side context\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense\"\n    );\n  }\n}\n","import { useCallback, useMemo } from \"react\";\n\nimport { useLatest } from \"./use-latest\";\n\n/**\n * \"Freezes\" a given value, so that it will return the same value/instance on\n * each subsequent render. This can be used to freeze \"initial\" values for\n * custom hooks, much like how `useState(initialState)` or\n * `useRef(initialValue)` works.\n */\nexport function useInitial<T>(value: T, roomId?: string): T {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => value, [roomId]);\n}\n\n/**\n * Like `useInitial`, but if the provided value is a function instance, will\n * instead return a stable wrapper that _is_ a stable reference itself between\n * re-renders, but one which will always call the _latest_ provided callback\n * instance.\n */\nexport function useInitialUnlessFunction<T>(\n  latestValue: T,\n  roomId?: string\n): T {\n  const frozenValue = useInitial(latestValue, roomId);\n\n  type Fn = T & ((...args: unknown[]) => unknown);\n  const ref = useLatest(latestValue as Fn);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const wrapper = useCallback(\n    ((...args: unknown[]) => ref.current(...args)) as Fn,\n    [ref]\n  );\n\n  // Return the wrapper only if the frozen value is a function\n  if (typeof frozenValue === \"function\") {\n    return wrapper;\n  } else {\n    return frozenValue;\n  }\n}\n","import * as React from \"react\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n\n// Prevent bundlers from trying to `import { use } from \"react\";`\nconst reactUse = React[\" use \".trim().toString() as keyof typeof React] as\n  | Use\n  | undefined;\n\n/**\n * Drop-in replacement for React 19's `use` hook,\n * with a partial polyfill for older versions of React.\n *\n *  Only supports `use(promise)`, not `use(context)`.\n */\nexport const use =\n  reactUse ??\n  (<T>(\n    promise: Promise<T> & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\";\n      value?: T;\n      reason?: unknown;\n    }\n  ): T => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value as T;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  });\n","import type {\n  AiChatsQuery,\n  AsyncResult,\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  CommentData,\n  CommentReaction,\n  CommentUserReaction,\n  Cursor,\n  DistributiveOmit,\n  HistoryVersion,\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n  ISignal,\n  MessageId,\n  NotificationSettings,\n  OpaqueClient,\n  PartialNotificationSettings,\n  Patchable,\n  Permission,\n  Resolve,\n  RoomSubscriptionSettings,\n  SubscriptionData,\n  SubscriptionDeleteInfo,\n  SubscriptionKey,\n  ThreadData,\n  ThreadDataWithDeleteInfo,\n  ThreadDeleteInfo,\n} from \"@liveblocks/core\";\nimport {\n  assertNever,\n  autoRetry,\n  batch,\n  compactObject,\n  console,\n  createNotificationSettings,\n  DefaultMap,\n  DerivedSignal,\n  getSubscriptionKey,\n  kInternal,\n  MutableSignal,\n  nanoid,\n  nn,\n  patchNotificationSettings,\n  shallow,\n  shallow2,\n  Signal,\n  stableStringify,\n} from \"@liveblocks/core\";\n\nimport { ASYNC_ERR, ASYNC_LOADING, ASYNC_OK } from \"./lib/AsyncResult\";\nimport { autobind } from \"./lib/autobind\";\nimport { find } from \"./lib/itertools\";\nimport { makeInboxNotificationsFilter } from \"./lib/querying\";\nimport type { ReadonlyThreadDB } from \"./ThreadDB\";\nimport { ThreadDB } from \"./ThreadDB\";\nimport type {\n  AiChatAsyncResult,\n  AiChatMessagesAsyncResult,\n  AiChatsAsyncResult,\n  HistoryVersionsAsyncResult,\n  InboxNotificationsAsyncResult,\n  InboxNotificationsQuery,\n  NotificationSettingsAsyncResult,\n  RoomSubscriptionSettingsAsyncResult,\n  ThreadsAsyncResult,\n  ThreadsQuery,\n} from \"./types\";\n\ntype OptimisticUpdate<M extends BaseMetadata> =\n  | CreateThreadOptimisticUpdate<M>\n  | DeleteThreadOptimisticUpdate\n  | EditThreadMetadataOptimisticUpdate<M>\n  | MarkThreadAsResolvedOptimisticUpdate\n  | MarkThreadAsUnresolvedOptimisticUpdate\n  | SubscribeToThreadOptimisticUpdate\n  | UnsubscribeFromThreadOptimisticUpdate\n  | CreateCommentOptimisticUpdate\n  | EditCommentOptimisticUpdate\n  | DeleteCommentOptimisticUpdate\n  | AddReactionOptimisticUpdate\n  | RemoveReactionOptimisticUpdate\n  | MarkInboxNotificationAsReadOptimisticUpdate\n  | MarkAllInboxNotificationsAsReadOptimisticUpdate\n  | DeleteInboxNotificationOptimisticUpdate\n  | DeleteAllInboxNotificationsOptimisticUpdate\n  | UpdateRoomSubscriptionSettingsOptimisticUpdate\n  | UpdateNotificationSettingsOptimisticUpdate;\n\ntype CreateThreadOptimisticUpdate<M extends BaseMetadata> = {\n  type: \"create-thread\";\n  id: string;\n  roomId: string;\n  thread: ThreadData<M>;\n};\n\ntype DeleteThreadOptimisticUpdate = {\n  type: \"delete-thread\";\n  id: string;\n  roomId: string;\n  threadId: string;\n  deletedAt: Date;\n};\n\ntype EditThreadMetadataOptimisticUpdate<M extends BaseMetadata> = {\n  type: \"edit-thread-metadata\";\n  id: string;\n  threadId: string;\n  metadata: Resolve<Patchable<M>>;\n  updatedAt: Date;\n};\n\ntype MarkThreadAsResolvedOptimisticUpdate = {\n  type: \"mark-thread-as-resolved\";\n  id: string;\n  threadId: string;\n  updatedAt: Date;\n};\n\ntype MarkThreadAsUnresolvedOptimisticUpdate = {\n  type: \"mark-thread-as-unresolved\";\n  id: string;\n  threadId: string;\n  updatedAt: Date;\n};\n\ntype SubscribeToThreadOptimisticUpdate = {\n  type: \"subscribe-to-thread\";\n  id: string;\n  threadId: string;\n  subscribedAt: Date;\n};\n\ntype UnsubscribeFromThreadOptimisticUpdate = {\n  type: \"unsubscribe-from-thread\";\n  id: string;\n  threadId: string;\n  unsubscribedAt: Date;\n};\n\ntype CreateCommentOptimisticUpdate = {\n  type: \"create-comment\";\n  id: string;\n  comment: CommentData;\n};\n\ntype EditCommentOptimisticUpdate = {\n  type: \"edit-comment\";\n  id: string;\n  comment: CommentData;\n};\n\ntype DeleteCommentOptimisticUpdate = {\n  type: \"delete-comment\";\n  id: string;\n  roomId: string;\n  threadId: string;\n  deletedAt: Date;\n  commentId: string;\n};\n\ntype AddReactionOptimisticUpdate = {\n  type: \"add-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  reaction: CommentUserReaction;\n};\n\ntype RemoveReactionOptimisticUpdate = {\n  type: \"remove-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n  userId: string;\n  removedAt: Date;\n};\n\ntype MarkInboxNotificationAsReadOptimisticUpdate = {\n  type: \"mark-inbox-notification-as-read\";\n  id: string;\n  inboxNotificationId: string;\n  readAt: Date;\n};\n\ntype MarkAllInboxNotificationsAsReadOptimisticUpdate = {\n  type: \"mark-all-inbox-notifications-as-read\";\n  id: string;\n  readAt: Date;\n};\n\ntype DeleteInboxNotificationOptimisticUpdate = {\n  type: \"delete-inbox-notification\";\n  id: string;\n  inboxNotificationId: string;\n  deletedAt: Date;\n};\n\ntype DeleteAllInboxNotificationsOptimisticUpdate = {\n  type: \"delete-all-inbox-notifications\";\n  id: string;\n  deletedAt: Date;\n};\n\ntype UpdateRoomSubscriptionSettingsOptimisticUpdate = {\n  type: \"update-room-subscription-settings\";\n  id: string;\n  roomId: string;\n  userId: string;\n  settings: Partial<RoomSubscriptionSettings>;\n};\n\ntype UpdateNotificationSettingsOptimisticUpdate = {\n  type: \"update-notification-settings\";\n  id: string;\n  settings: PartialNotificationSettings;\n};\n\ntype PaginationState = {\n  cursor: string | null; // If `null`, it's the last page\n  hasFetchedAll: boolean;\n  isFetchingMore: boolean;\n  fetchMoreError?: Error;\n  fetchMore: () => void;\n};\n\n/**\n * Valid combinations of field patches to the pagination state.\n */\ntype PaginationStatePatch =\n  | { isFetchingMore: true }\n  | {\n      hasFetchedAll: boolean;\n      isFetchingMore: false;\n      cursor: string | null;\n      fetchMoreError: undefined;\n    }\n  | { isFetchingMore: false; fetchMoreError: Error };\n\n/**\n * Example:\n * makeRoomThreadsQueryKey('room-abc', { xyz: 123, abc: \"red\" })\n *  '[\"room-abc\",{\"color\":\"red\",\"xyz\":123}]'\n */\nexport function makeRoomThreadsQueryKey(\n  roomId: string,\n  query: ThreadsQuery<BaseMetadata> | undefined\n) {\n  return stableStringify([roomId, query ?? {}]);\n}\n\nexport function makeUserThreadsQueryKey(\n  query: ThreadsQuery<BaseMetadata> | undefined\n) {\n  return stableStringify(query ?? {});\n}\n\nexport function makeAiChatsQueryKey(\n  query: AiChatsQuery | undefined\n): AiChatsQueryKey {\n  return stableStringify(query ?? {});\n}\n\nexport function makeInboxNotificationsQueryKey(\n  query: InboxNotificationsQuery | undefined\n) {\n  return stableStringify(query ?? {});\n}\n\n/**\n * Like Promise<T>, except it will have a synchronously readable `status`\n * field, indicating the status of the promise.\n * This is compatible with React's `use()` promises, hence the name.\n */\ntype UsablePromise<T> = Promise<T> &\n  (\n    | { status: \"pending\" }\n    | { status: \"rejected\"; reason: Error }\n    | { status: \"fulfilled\"; value: T }\n  );\n\n/**\n * Given any Promise<T>, monkey-patches it to a UsablePromise<T>, whose\n * asynchronous status can be synchronously observed.\n */\nfunction usify<T>(promise: Promise<T>): UsablePromise<T> {\n  if (\"status\" in promise) {\n    // Already a usable promise\n    return promise as UsablePromise<T>;\n  }\n\n  const usable: UsablePromise<T> = promise as UsablePromise<T>;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      (usable as UsablePromise<T> & { status: \"fulfilled\" }).value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      (usable as UsablePromise<T> & { status: \"rejected\" }).reason =\n        err as Error;\n    }\n  );\n  return usable;\n}\n\nconst noop = Promise.resolve();\n\n/**\n * The PaginatedResource helper class is responsible for and abstracts away the\n * following:\n *\n * - It receives a \"page fetch\" function of the following signature:\n *     (cursor?: Cursor) => Promise<Cursor | null>\n *\n * - Note that there is no data in the returned value!!! Storing or handling\n *   the data is NOT the responsibility of this helper class. This may be a bit\n *   counter-intuitive at first. The provided page fetcher callback function\n *   should store the data elsewhere, outside of the PaginatedResource state\n *   machine, as a side-effect of this \"page fetch\" function, but it can always\n *   assume the happy path. This class will deal with all the required\n *   complexity for handling the non-happy path conditions.\n *\n * - This class exposes a \"getter\" that you can call synchronously to get the\n *   current fetching/paginationo status for this resource. It will look like\n *   the pagination hooks, except it will not contain any data. In other words,\n *   it can return any of these shapes:\n *\n *   - { isLoading: true }\n *   - {\n *       isLoading: false,\n *       error: new Error('error while fetching'),\n *     }\n *   - {\n *       isLoading: false,\n *       data: {\n *         cursor: string | null;\n *         isFetchingMore: boolean;\n *         fetchMoreError?: Error;\n *       }\n *     }\n *\n * - When calling the getter multiple times, the return value is always\n *   referentially equal to the previous call.\n *\n * - When in this error state, the error will remain in error state for\n *   5 seconds. After those 5 seconds, the resource status gets reset, and the\n *   next time the \"getter\" is accessed, the resource will re-initiate the\n *   initial fetching process.\n *\n * - This class exposes an Observable that is notified whenever the state\n *   changes. For now, this observable can be used to call a no-op update to\n *   the Store (eg `.set(state => ({...state})`), to trigger a re-render for\n *   all React components.\n *\n * - This class will also expose a function that can be exposed as the\n *   `fetchMore` function which can be called externally.\n *\n * - This nicely bundles the internal state that should always be mutated\n *   together to manage all the pagination state.\n *\n * - For InboxNotifications we will have one instance of this class.\n *\n * - For Threads we will have one for each query.\n *\n * ---------------------------------------------------------------------------\n *\n * NOT 100% SURE ABOUT THE FOLLOWING YET:\n *\n * - Maybe we could eventually also let this manage the \"delta updates\" and the\n *   \"last requested at\" for this resource? Seems nice to add it here somehow.\n *   Need to think about the exact implications though.\n *\n * @internal Only exported for unit tests.\n */\nexport class PaginatedResource {\n  readonly #signal: Signal<AsyncResult<PaginationState>>;\n  public readonly signal: ISignal<AsyncResult<PaginationState>>;\n\n  #fetchPage: (cursor?: string) => Promise<string | null>;\n  #pendingFetchMore: Promise<void> | null;\n\n  constructor(fetchPage: (cursor?: string) => Promise<string | null>) {\n    this.#signal = new Signal<AsyncResult<PaginationState>>(ASYNC_LOADING);\n    this.#fetchPage = fetchPage;\n    this.#pendingFetchMore = null;\n    this.signal = this.#signal.asReadonly();\n\n    autobind(this);\n  }\n\n  get(): AsyncResult<PaginationState> {\n    return this.#signal.get();\n  }\n\n  #patch(patch: PaginationStatePatch): void {\n    const state = this.#signal.get();\n    if (state.data === undefined) return;\n    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));\n  }\n\n  async #fetchMore(): Promise<void> {\n    const state = this.#signal.get();\n    if (!state.data?.cursor || state.data.isFetchingMore) {\n      // Either:\n      // - We don't have a cursor yet (first fetch not happened successfully yet)\n      // - We don't have a cursor any longer (we're on the last page)\n      return;\n    }\n\n    this.#patch({ isFetchingMore: true });\n    try {\n      const nextCursor = await this.#fetchPage(state.data.cursor);\n      this.#patch({\n        cursor: nextCursor,\n        hasFetchedAll: nextCursor === null,\n        fetchMoreError: undefined,\n        isFetchingMore: false,\n      });\n    } catch (err) {\n      this.#patch({\n        isFetchingMore: false,\n        fetchMoreError: err as Error,\n      });\n    }\n  }\n\n  public fetchMore(): Promise<void> {\n    // We do not proceed with fetching more if any of the following is true:\n    // 1) the pagination state has not be initialized\n    // 2) the cursor is null, i.e., there are no more pages to fetch\n    // 3) a request to fetch more is currently in progress\n    const state = this.#signal.get();\n    if (!state.data?.cursor) return noop;\n\n    // Case (3)\n    if (!this.#pendingFetchMore) {\n      this.#pendingFetchMore = this.#fetchMore().finally(() => {\n        this.#pendingFetchMore = null;\n      });\n    }\n    return this.#pendingFetchMore;\n  }\n\n  #cachedPromise: UsablePromise<void> | null = null;\n\n  public waitUntilLoaded(): UsablePromise<void> {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n\n    // Wrap the request to load room threads (and notifications) in an auto-retry function so that if the request fails,\n    // we retry for at most 5 times with incremental backoff delays. If all retries fail, the auto-retry function throws an error\n    const initialPageFetch$ = autoRetry(\n      () => this.#fetchPage(/* cursor */ undefined),\n      5,\n      [5000, 5000, 10000, 15000]\n    );\n\n    const promise = usify(initialPageFetch$);\n\n    // NOTE: However tempting it may be, we cannot simply move this block into\n    // the promise definition above. The reason is that we should not call\n    // notify() before the UsablePromise is actually in resolved status. While\n    // still inside the .then() block, the UsablePromise is still in pending status.\n    promise.then(\n      (cursor) => {\n        this.#signal.set(\n          ASYNC_OK({\n            cursor,\n            hasFetchedAll: cursor === null,\n            isFetchingMore: false,\n            fetchMoreError: undefined,\n            fetchMore: this.fetchMore,\n          })\n        );\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err as Error));\n\n        // Wait for 5 seconds before removing the request\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5_000);\n      }\n    );\n\n    this.#cachedPromise =\n      promise as UsablePromise<unknown> as UsablePromise<void>;\n    return this.#cachedPromise;\n  }\n}\n\n// TODO Find better name?\ntype LoadableResource<T> = {\n  signal: ISignal<T>;\n  waitUntilLoaded: () => UsablePromise<void>;\n};\n\nclass SinglePageResource {\n  readonly #signal: Signal<AsyncResult<void>>;\n  public readonly signal: ISignal<AsyncResult<void>>;\n\n  #fetchPage: () => Promise<void>;\n\n  constructor(fetchPage: () => Promise<void>) {\n    this.#signal = new Signal<AsyncResult<void>>(ASYNC_LOADING);\n    this.signal = this.#signal.asReadonly();\n    this.#fetchPage = fetchPage;\n\n    autobind(this);\n  }\n\n  get(): AsyncResult<void> {\n    return this.#signal.get();\n  }\n\n  #cachedPromise: UsablePromise<void> | null = null;\n\n  public waitUntilLoaded(): UsablePromise<void> {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n\n    // Wrap the request to load room threads (and notifications) in an auto-retry function so that if the request fails,\n    // we retry for at most 5 times with incremental backoff delays. If all retries fail, the auto-retry function throws an error\n    const initialFetcher$ = autoRetry(\n      () => this.#fetchPage(),\n      5,\n      [5000, 5000, 10000, 15000]\n    );\n\n    const promise = usify(initialFetcher$);\n\n    // NOTE: However tempting it may be, we cannot simply move this block into\n    // the promise definition above. The reason is that we should not call\n    // notify() before the UsablePromise is actually in resolved status. While\n    // still inside the .then() block, the UsablePromise is still in pending status.\n    promise.then(\n      () => {\n        this.#signal.set(ASYNC_OK(undefined));\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err as Error));\n\n        // Wait for 5 seconds before removing the request\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5_000);\n      }\n    );\n\n    this.#cachedPromise = promise;\n    return promise;\n  }\n}\n\ntype RoomId = string;\ntype UserQueryKey = string;\ntype RoomQueryKey = string;\ntype InboxNotificationsQueryKey = string;\n\ntype AiChatsQueryKey = string;\n\n/**\n * A lookup table (LUT) for all the history versions.\n */\ntype VersionsLUT = DefaultMap<RoomId, Map<string, HistoryVersion>>;\n\n/**\n * A lookup table (LUT) for all the inbox notifications.\n */\ntype NotificationsLUT = Map<string, InboxNotificationData>;\n\n/**\n * A lookup table (LUT) for all the subscriptions.\n */\ntype SubscriptionsLUT = Map<SubscriptionKey, SubscriptionData>;\n\n/**\n * A lookup table (LUT) for all the room subscription settings.\n */\ntype RoomSubscriptionSettingsLUT = Map<RoomId, RoomSubscriptionSettings>;\n\n/**\n * Room subscription settings by room ID.\n * e.g. { 'room-abc': { threads: \"all\" },\n *        'room-def': { threads: \"replies_and_mentions\" },\n *        'room-xyz': { threads: \"none\" },\n *      }\n */\ntype RoomSubscriptionSettingsByRoomId = Record<\n  RoomId,\n  RoomSubscriptionSettings\n>;\n\ntype SubscriptionsByKey = Record<SubscriptionKey, SubscriptionData>;\n\nexport type CleanThreadifications<M extends BaseMetadata> =\n  // Threads + Notifications = Threadifications\n  CleanThreads<M> &\n    //\n    CleanNotifications;\n\nexport type CleanThreads<M extends BaseMetadata> = {\n  /**\n   * Keep track of loading and error status of all the queries made by the client.\n   * e.g. 'room-abc-{\"color\":\"red\"}'  - ok\n   * e.g. 'room-abc-{}'               - loading\n   */\n  threadsDB: ReadonlyThreadDB<M>;\n};\n\nexport type CleanNotifications = {\n  /**\n   * All inbox notifications in a sorted array, optimistic updates applied.\n   */\n  sortedNotifications: InboxNotificationData[];\n\n  /**\n   * Inbox notifications by ID.\n   * e.g. `in_${string}`\n   */\n  notificationsById: Record<string, InboxNotificationData>;\n};\n\nexport type CleanThreadSubscriptions = {\n  /**\n   * Thread subscriptions by key (kind + subject ID).\n   * e.g. `thread:${string}`, `$custom:${string}`, etc\n   */\n  subscriptions: SubscriptionsByKey;\n\n  /**\n   * All inbox notifications in a sorted array, optimistic updates applied.\n   *\n   * `useThreadSubscription` returns the subscription status based on subscriptions\n   * but also the `readAt` value of the associated notification, so we need to\n   * expose the notifications here as well.\n   */\n  notifications: InboxNotificationData[];\n};\n\nfunction createStore_forNotifications() {\n  const signal = new MutableSignal<NotificationsLUT>(new Map());\n\n  function markRead(notificationId: string, readAt: Date) {\n    signal.mutate((lut) => {\n      const existing = lut.get(notificationId);\n      if (!existing) {\n        return false;\n      }\n      lut.set(notificationId, { ...existing, readAt });\n      return true;\n    });\n  }\n\n  function markAllRead(readAt: Date) {\n    signal.mutate((lut) => {\n      for (const n of lut.values()) {\n        n.readAt = readAt;\n      }\n    });\n  }\n\n  function deleteOne(inboxNotificationId: string) {\n    signal.mutate((lut) => lut.delete(inboxNotificationId));\n  }\n\n  function clear() {\n    signal.mutate((lut) => lut.clear());\n  }\n\n  function applyDelta(\n    newNotifications: InboxNotificationData[],\n    deletedNotifications: InboxNotificationDeleteInfo[]\n  ) {\n    signal.mutate((lut) => {\n      let mutated = false;\n\n      // Add new notifications or update existing notifications if the existing notification is older than the new notification.\n      for (const n of newNotifications) {\n        const existing = lut.get(n.id);\n        // If the notification already exists, we need to compare the two notifications to determine which one is newer.\n        if (existing) {\n          const result = compareInboxNotifications(existing, n);\n          // If the existing notification is newer than the new notification, we do not update the existing notification.\n          if (result === 1) continue;\n        }\n\n        // If the new notification is newer than the existing notification, we update the existing notification.\n        lut.set(n.id, n);\n        mutated = true;\n      }\n\n      for (const n of deletedNotifications) {\n        lut.delete(n.id);\n        mutated = true;\n      }\n      return mutated;\n    });\n  }\n\n  function updateAssociatedNotification(newComment: CommentData) {\n    signal.mutate((lut) => {\n      const existing = find(\n        lut.values(),\n        (notification) =>\n          notification.kind === \"thread\" &&\n          notification.threadId === newComment.threadId\n      );\n      if (!existing) return false; // Nothing to udate here\n\n      // If the thread has an inbox notification associated with it, we update the notification's `notifiedAt` and `readAt` values\n      lut.set(existing.id, {\n        ...existing,\n        notifiedAt: newComment.createdAt,\n        readAt: newComment.createdAt,\n      });\n      return true;\n    });\n  }\n\n  function upsert(notification: InboxNotificationData) {\n    signal.mutate((lut) => {\n      lut.set(notification.id, notification);\n    });\n  }\n\n  return {\n    signal: signal.asReadonly(),\n\n    // Mutations\n    markAllRead,\n    markRead,\n    delete: deleteOne,\n    applyDelta,\n    clear,\n    updateAssociatedNotification,\n    upsert,\n  };\n}\n\nfunction createStore_forSubscriptions(\n  updates: ISignal<readonly OptimisticUpdate<BaseMetadata>[]>,\n  threads: ReadonlyThreadDB<BaseMetadata>\n) {\n  const baseSignal = new MutableSignal<SubscriptionsLUT>(new Map());\n\n  function applyDelta(\n    newSubscriptions: SubscriptionData[],\n    deletedSubscriptions: SubscriptionDeleteInfo[]\n  ) {\n    baseSignal.mutate((lut) => {\n      let mutated = false;\n\n      for (const s of newSubscriptions) {\n        lut.set(getSubscriptionKey(s), s);\n        mutated = true;\n      }\n\n      for (const s of deletedSubscriptions) {\n        lut.delete(getSubscriptionKey(s));\n        mutated = true;\n      }\n\n      return mutated;\n    });\n  }\n\n  function create(subscription: SubscriptionData) {\n    baseSignal.mutate((lut) => {\n      lut.set(getSubscriptionKey(subscription), subscription);\n    });\n  }\n\n  function deleteOne(subscriptionKey: SubscriptionKey) {\n    baseSignal.mutate((lut) => {\n      lut.delete(subscriptionKey);\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, updates, (base, updates) =>\n      applyOptimisticUpdates_forSubscriptions(base, threads, updates)\n    ),\n\n    // Mutations\n    applyDelta,\n    create,\n    delete: deleteOne,\n  };\n}\n\nfunction createStore_forRoomSubscriptionSettings(\n  updates: ISignal<readonly OptimisticUpdate<BaseMetadata>[]>\n) {\n  const baseSignal = new MutableSignal<RoomSubscriptionSettingsLUT>(new Map());\n\n  function update(roomId: string, settings: RoomSubscriptionSettings): void {\n    baseSignal.mutate((lut) => {\n      lut.set(roomId, settings);\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, updates, (base, updates) =>\n      applyOptimisticUpdates_forRoomSubscriptionSettings(base, updates)\n    ),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forHistoryVersions() {\n  const baseSignal = new MutableSignal(\n    new DefaultMap(() => new Map()) as VersionsLUT\n  );\n\n  function update(roomId: string, versions: HistoryVersion[]): void {\n    baseSignal.mutate((lut) => {\n      const versionsById = lut.getOrCreate(roomId);\n      for (const version of versions) {\n        versionsById.set(version.id, version);\n      }\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, (hv) =>\n      Object.fromEntries(\n        [...hv].map(([roomId, versions]) => [\n          roomId,\n          Object.fromEntries(versions),\n        ])\n      )\n    ),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forPermissionHints() {\n  const permissionsByRoomId = new DefaultMap(\n    () => new Signal<Set<Permission>>(new Set())\n  );\n\n  function update(newHints: Record<string, Permission[]>) {\n    batch(() => {\n      for (const [roomId, permissions] of Object.entries(newHints)) {\n        const signal = permissionsByRoomId.getOrCreate(roomId);\n        // Get the existing set of permissions for the room and only ever add permission to this set\n        const existingPermissions = new Set(signal.get());\n        for (const permission of permissions) {\n          existingPermissions.add(permission);\n        }\n        signal.set(existingPermissions);\n      }\n    });\n  }\n\n  function getPermissionForRoom(roomId: string): ISignal<Set<Permission>> {\n    return permissionsByRoomId.getOrCreate(roomId);\n  }\n\n  return {\n    getPermissionForRoom,\n\n    // Mutations\n    update,\n  };\n}\n\n/**\n * Notification settings\n *\n * e.g.\n *  {\n *    email: {\n *      thread: true,\n *      textMention: false,\n *      $customKind: true | false,\n *    }\n *    slack: {\n *      thread: true,\n *      textMention: false,\n *      $customKind: true | false,\n *    }\n *  }\n * e.g. {} when before the first successful fetch.\n */\nfunction createStore_forNotificationSettings(\n  updates: ISignal<readonly OptimisticUpdate<BaseMetadata>[]>\n) {\n  const signal = new Signal<NotificationSettings>(\n    createNotificationSettings({})\n  );\n\n  function update(settings: NotificationSettings) {\n    signal.set(settings);\n  }\n\n  return {\n    signal: DerivedSignal.from(signal, updates, (base, updates) =>\n      applyOptimisticUpdates_forNotificationSettings(base, updates)\n    ),\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forOptimistic<M extends BaseMetadata>(\n  client: Client<BaseUserMeta, M>\n) {\n  const signal = new Signal<readonly OptimisticUpdate<M>[]>([]);\n  const syncSource = client[kInternal].createSyncSource();\n\n  // Automatically update the global sync status as an effect whenever there\n  // are any optimistic updates\n  signal.subscribe(() =>\n    syncSource.setSyncStatus(\n      signal.get().length > 0 ? \"synchronizing\" : \"synchronized\"\n    )\n  );\n\n  function add(\n    optimisticUpdate: DistributiveOmit<OptimisticUpdate<M>, \"id\">\n  ): string {\n    const id = nanoid();\n    const newUpdate: OptimisticUpdate<M> = { ...optimisticUpdate, id };\n    signal.set((state) => [...state, newUpdate]);\n    return id;\n  }\n\n  function remove(optimisticId: string): void {\n    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));\n  }\n\n  return {\n    signal: signal.asReadonly(),\n\n    // Mutations\n    add,\n    remove,\n  };\n}\n\nexport class UmbrellaStore<M extends BaseMetadata> {\n  #client: Client<BaseUserMeta, M>;\n\n  //\n  // Internally, the UmbrellaStore keeps track of a few source signals that can\n  // be set and mutated individually. When any of those are mutated then the\n  // clean \"external state\" is recomputed.\n  //\n  //   Mutate inputs...                                             ...observe clean/consistent output!\n  //\n  //            .-> Base ThreadDB ---------+                 +-------> Clean threads by ID         (Part 1)\n  //           /                           |                 |\n  //   mutate ----> Base Notifications --+ |                 | +-----> Clean notifications         (Part 1)\n  //          \\                          | |                 | |       & notifications by ID\n  //         | \\                         | |      Apply      | |\n  //         |   `-> OptimisticUpdates --+--+--> Optimistic -+-+-+-+-> Subscriptions               (Part 2)\n  //          \\                          |        Updates    |   | |\n  //           `------- etc etc ---------+                   |   | +-> History Versions            (Part 3)\n  //                       ^                                 |   |\n  //                       |                                 |   +---> Room Subscription Settings  (Part 4)\n  //                       |                                 |\n  //                       |                                 +-------> Notification Settings       (Part 5)\n  //                       |\n  //                       |\n  //                       |                        ^                  ^\n  //                    Signal                      |                  |\n  //                      or                   DerivedSignal      DerivedSignals\n  //                  MutableSignal\n  //\n\n  //\n  // Input signals.\n  // (Can be mutated directly.)\n  //\n  // XXX_vincent Now that we have createStore_forX, we should probably also change\n  // `threads` to this pattern, ie create a createStore_forThreads helper as\n  // well. It almost works like that already anyway!\n  readonly threads: ThreadDB<M>; // Exposes its signal under `.signal` prop\n  readonly notifications: ReturnType<typeof createStore_forNotifications>;\n  readonly subscriptions: ReturnType<typeof createStore_forSubscriptions>;\n  readonly roomSubscriptionSettings: ReturnType<typeof createStore_forRoomSubscriptionSettings>; // prettier-ignore\n  readonly historyVersions: ReturnType<typeof createStore_forHistoryVersions>;\n  readonly permissionHints: ReturnType<typeof createStore_forPermissionHints>;\n  readonly notificationSettings: ReturnType<\n    typeof createStore_forNotificationSettings\n  >;\n  readonly optimisticUpdates: ReturnType<typeof createStore_forOptimistic<M>>;\n\n  //\n  // Output signals.\n  // (Readonly, clean, consistent. With optimistic updates applied.)\n  //\n  // Note that the output of threadifications signal is the same as the ones for\n  // threads and notifications separately, but the threadifications signal will\n  // be updated whenever either of them change.\n  //\n  readonly outputs: {\n    readonly threadifications: DerivedSignal<CleanThreadifications<M>>;\n    readonly threads: DerivedSignal<ReadonlyThreadDB<M>>;\n    readonly loadingRoomThreads: DefaultMap<\n      RoomQueryKey,\n      LoadableResource<ThreadsAsyncResult<M>>\n    >;\n    readonly loadingUserThreads: DefaultMap<\n      UserQueryKey,\n      LoadableResource<ThreadsAsyncResult<M>>\n    >;\n    readonly notifications: DerivedSignal<CleanNotifications>;\n    readonly threadSubscriptions: DerivedSignal<CleanThreadSubscriptions>;\n\n    readonly loadingNotifications: DefaultMap<\n      InboxNotificationsQueryKey,\n      LoadableResource<InboxNotificationsAsyncResult>\n    >;\n    readonly roomSubscriptionSettingsByRoomId: DefaultMap<\n      RoomId,\n      LoadableResource<RoomSubscriptionSettingsAsyncResult>\n    >;\n    readonly versionsByRoomId: DefaultMap<\n      RoomId,\n      LoadableResource<HistoryVersionsAsyncResult>\n    >;\n    readonly notificationSettings: LoadableResource<NotificationSettingsAsyncResult>;\n    readonly aiChats: DefaultMap<\n      AiChatsQueryKey,\n      LoadableResource<AiChatsAsyncResult>\n    >;\n    readonly messagesByChatId: DefaultMap<\n      string,\n      DefaultMap<MessageId | null, LoadableResource<AiChatMessagesAsyncResult>>\n    >;\n    readonly aiChatById: DefaultMap<\n      string,\n      LoadableResource<AiChatAsyncResult>\n    >;\n  };\n\n  // Notifications\n  #notificationsLastRequestedAt: Date | null = null; // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.\n\n  // Room Threads\n  #roomThreadsLastRequestedAtByRoom = new Map<RoomId, Date>();\n\n  // User Threads\n  #userThreadsLastRequestedAt: Date | null = null;\n\n  // Room versions\n  #roomVersionsLastRequestedAtByRoom = new Map<RoomId, Date>();\n\n  // Notification Settings\n  #notificationSettings: SinglePageResource;\n\n  constructor(client: OpaqueClient) {\n    this.#client = client[kInternal].as<M>();\n\n    this.optimisticUpdates = createStore_forOptimistic<M>(this.#client);\n    this.permissionHints = createStore_forPermissionHints();\n\n    const notificationSettingsFetcher = async (): Promise<void> => {\n      const result = await this.#client.getNotificationSettings();\n      this.notificationSettings.update(result);\n    };\n\n    this.notificationSettings = createStore_forNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n\n    this.#notificationSettings = new SinglePageResource(\n      notificationSettingsFetcher\n    );\n\n    this.threads = new ThreadDB();\n\n    this.subscriptions = createStore_forSubscriptions(\n      this.optimisticUpdates.signal,\n      this.threads\n    );\n\n    this.notifications = createStore_forNotifications();\n    this.roomSubscriptionSettings = createStore_forRoomSubscriptionSettings(\n      this.optimisticUpdates.signal\n    );\n    this.historyVersions = createStore_forHistoryVersions();\n\n    const threadifications = DerivedSignal.from(\n      this.threads.signal,\n      this.notifications.signal,\n      this.optimisticUpdates.signal,\n      (ts, ns, updates) =>\n        applyOptimisticUpdates_forThreadifications(ts, ns, updates)\n    );\n\n    const threads = DerivedSignal.from(threadifications, (s) => s.threadsDB);\n\n    const notifications = DerivedSignal.from(\n      threadifications,\n      (s) => ({\n        sortedNotifications: s.sortedNotifications,\n        notificationsById: s.notificationsById,\n      }),\n      shallow\n    );\n\n    const threadSubscriptions = DerivedSignal.from(\n      notifications,\n      this.subscriptions.signal,\n      (n, s) => ({\n        subscriptions: s,\n        notifications: n.sortedNotifications,\n      })\n    );\n\n    const loadingUserThreads = new DefaultMap(\n      (queryKey: UserQueryKey): LoadableResource<ThreadsAsyncResult<M>> => {\n        const query = JSON.parse(queryKey) as ThreadsQuery<M>;\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[\n            kInternal\n          ].httpClient.getUserThreads_experimental({\n            cursor,\n            query,\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n\n          this.permissionHints.update(result.permissionHints);\n\n          // We initialize the `_userThreadsLastRequestedAt` date using the server timestamp after we've loaded the first page of inbox notifications.\n          if (this.#userThreadsLastRequestedAt === null) {\n            this.#userThreadsLastRequestedAt = result.requestedAt;\n          }\n\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): ThreadsAsyncResult<M> => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const threads = this.outputs.threads.get().findMany(\n            undefined, // Do _not_ filter by roomId\n            query ?? {},\n            \"desc\"\n          );\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const loadingRoomThreads = new DefaultMap(\n      (queryKey: RoomQueryKey): LoadableResource<ThreadsAsyncResult<M>> => {\n        const [roomId, query] = JSON.parse(queryKey) as [\n          roomId: RoomId,\n          query: ThreadsQuery<M>,\n        ];\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[kInternal].httpClient.getThreads({\n            roomId,\n            cursor,\n            query,\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n\n          this.permissionHints.update(result.permissionHints);\n\n          const lastRequestedAt =\n            this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n\n          /**\n           * We set the `lastRequestedAt` value for the room to the timestamp returned by the current request if:\n           * 1. The `lastRequestedAt` value for the room has not been set\n           * OR\n           * 2. The `lastRequestedAt` value for the room is older than the timestamp returned by the current request\n           */\n          if (\n            lastRequestedAt === undefined ||\n            lastRequestedAt > result.requestedAt\n          ) {\n            this.#roomThreadsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): ThreadsAsyncResult<M> => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const threads = this.outputs.threads\n            .get()\n            .findMany(roomId, query ?? {}, \"asc\");\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const loadingNotifications = new DefaultMap(\n      (\n        queryKey: InboxNotificationsQueryKey\n      ): LoadableResource<InboxNotificationsAsyncResult> => {\n        const query = JSON.parse(queryKey) as InboxNotificationsQuery;\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client.getInboxNotifications({\n            cursor,\n            query,\n          });\n\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n\n          // We initialize the `_lastRequestedNotificationsAt` date using the server timestamp after we've loaded the first page of inbox notifications.\n          if (this.#notificationsLastRequestedAt === null) {\n            this.#notificationsLastRequestedAt = result.requestedAt;\n          }\n\n          const nextCursor = result.nextCursor;\n          return nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): InboxNotificationsAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const crit: ((\n            inboxNotification: InboxNotificationData\n          ) => boolean)[] = [];\n\n          if (query !== undefined) {\n            crit.push(makeInboxNotificationsFilter(query));\n          }\n          const inboxNotifications = this.outputs.notifications\n            .get()\n            .sortedNotifications.filter((inboxNotification) =>\n              crit.every((pred) => pred(inboxNotification))\n            );\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            inboxNotifications,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return {\n          signal,\n          waitUntilLoaded: resource.waitUntilLoaded,\n        };\n      }\n    );\n\n    const roomSubscriptionSettingsByRoomId = new DefaultMap(\n      (roomId: RoomId) => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n\n          const result = await room.getSubscriptionSettings();\n          this.roomSubscriptionSettings.update(roomId, result);\n        });\n\n        const signal = DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"settings\",\n              nn(this.roomSubscriptionSettings.signal.get()[roomId])\n            );\n          }\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const versionsByRoomId = new DefaultMap(\n      (roomId: RoomId): LoadableResource<HistoryVersionsAsyncResult> => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n\n          const result = await room[kInternal].listTextVersions();\n          this.historyVersions.update(roomId, result.versions);\n\n          const lastRequestedAt =\n            this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n\n          if (\n            lastRequestedAt === undefined ||\n            lastRequestedAt > result.requestedAt\n          ) {\n            this.#roomVersionsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n        });\n\n        const signal = DerivedSignal.from((): HistoryVersionsAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"versions\",\n              Object.values(this.historyVersions.signal.get()[roomId] ?? {})\n            );\n          }\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const notificationSettings: LoadableResource<NotificationSettingsAsyncResult> =\n      {\n        signal: DerivedSignal.from((): NotificationSettingsAsyncResult => {\n          const result = this.#notificationSettings.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          return ASYNC_OK(\n            \"settings\",\n            nn(this.notificationSettings.signal.get())\n          );\n        }, shallow),\n        waitUntilLoaded: this.#notificationSettings.waitUntilLoaded,\n      };\n\n    const aiChats = new DefaultMap(\n      (queryKey: AiChatsQueryKey): LoadableResource<AiChatsAsyncResult> => {\n        const query = JSON.parse(queryKey) as AiChatsQuery;\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[kInternal].ai.getChats({\n            cursor: cursor as Cursor,\n            query,\n          });\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): AiChatsAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const chats = this.#client[kInternal].ai.queryChats(query);\n\n          return {\n            isLoading: false,\n            chats,\n            hasFetchedAll: result.data.hasFetchedAll,\n            isFetchingMore: result.data.isFetchingMore,\n            fetchMore: result.data.fetchMore,\n            fetchMoreError: result.data.fetchMoreError,\n          };\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const messagesByChatId = new DefaultMap((chatId: string) => {\n      const resource = new SinglePageResource(async () => {\n        await this.#client[kInternal].ai.getMessageTree(chatId);\n      });\n\n      return new DefaultMap(\n        (\n          branch: MessageId | null\n        ): LoadableResource<AiChatMessagesAsyncResult> => {\n          const signal = DerivedSignal.from((): AiChatMessagesAsyncResult => {\n            const result = resource.get();\n            if (result.isLoading || result.error) {\n              return result;\n            }\n\n            return ASYNC_OK(\n              \"messages\",\n              this.#client[kInternal].ai.signals\n                .getChatMessagesForBranch(chatId, branch ?? undefined)\n                .get()\n            );\n          });\n\n          return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n        }\n      );\n    });\n\n    const aiChatById = new DefaultMap((chatId: string) => {\n      const resource = new SinglePageResource(async () => {\n        await this.#client[kInternal].ai.getOrCreateChat(chatId);\n      });\n\n      const signal = DerivedSignal.from(() => {\n        const chat = this.#client[kInternal].ai.getChatById(chatId);\n        if (chat === undefined) {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"chat\",\n              nn(this.#client[kInternal].ai.getChatById(chatId))\n            );\n          }\n        } else {\n          return ASYNC_OK(\n            \"chat\",\n            nn(this.#client[kInternal].ai.getChatById(chatId))\n          );\n        }\n      }, shallow);\n\n      return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n    });\n\n    this.outputs = {\n      threadifications,\n      threads,\n      loadingRoomThreads,\n      loadingUserThreads,\n      notifications,\n      loadingNotifications,\n      roomSubscriptionSettingsByRoomId,\n      versionsByRoomId,\n      notificationSettings,\n      threadSubscriptions,\n      aiChats,\n      messagesByChatId,\n      aiChatById,\n    };\n\n    // Auto-bind all of this class' methods here, so we can use stable\n    // references to them (most important for use in useSyncExternalStore)\n    autobind(this);\n  }\n\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found.\n   */\n  public markInboxNotificationRead(\n    inboxNotificationId: string,\n    readAt: Date,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markRead(inboxNotificationId, readAt);\n    });\n  }\n\n  public markAllInboxNotificationsRead(\n    optimisticId: string,\n    readAt: Date\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markAllRead(readAt);\n    });\n  }\n\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  public deleteInboxNotification(\n    inboxNotificationId: string,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.delete(inboxNotificationId);\n    });\n  }\n\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  public deleteAllInboxNotifications(optimisticId: string): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.clear();\n    });\n  }\n\n  /**\n   * Creates an existing subscription, replacing the corresponding\n   * optimistic update.\n   */\n  public createSubscription(\n    subscription: SubscriptionData,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.subscriptions.create(subscription);\n    });\n  }\n\n  /**\n   * Deletes an existing subscription, replacing the corresponding\n   * optimistic update.\n   */\n  public deleteSubscription(\n    subscriptionKey: SubscriptionKey,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.subscriptions.delete(subscriptionKey);\n    });\n  }\n\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  public createThread(\n    optimisticId: string,\n    thread: Readonly<ThreadDataWithDeleteInfo<M>>\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.threads.upsert(thread);\n    });\n  }\n\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted; or\n   * - The thread ID was updated more recently than the optimistic update's\n   *   timestamp (if given)\n   */\n  #updateThread(\n    threadId: string,\n    optimisticId: string | null,\n    callback: (\n      thread: Readonly<ThreadDataWithDeleteInfo<M>>\n    ) => Readonly<ThreadDataWithDeleteInfo<M>>,\n    updatedAt?: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    batch(() => {\n      if (optimisticId !== null) {\n        this.optimisticUpdates.remove(optimisticId);\n      }\n\n      const db = this.threads;\n      const existing = db.get(threadId);\n      if (!existing) return;\n      if (!!updatedAt && existing.updatedAt > updatedAt) return;\n      db.upsert(callback(existing));\n    });\n  }\n\n  public patchThread(\n    threadId: string,\n    optimisticId: string | null,\n    patch: {\n      // Only these fields are currently supported to patch\n      metadata?: M;\n      resolved?: boolean;\n    },\n    updatedAt: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => ({ ...thread, ...compactObject(patch) }),\n      updatedAt\n    );\n  }\n\n  public addReaction(\n    threadId: string,\n    optimisticId: string | null,\n    commentId: string,\n    reaction: CommentUserReaction,\n    createdAt: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n\n  public removeReaction(\n    threadId: string,\n    optimisticId: string | null,\n    commentId: string,\n    emoji: string,\n    userId: string,\n    removedAt: Date\n  ): void {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) =>\n        applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted\n   */\n  public deleteThread(threadId: string, optimisticId: string | null): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: new Date(), deletedAt: new Date() })\n    );\n  }\n\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  public createComment(newComment: CommentData, optimisticId: string): void {\n    // Batch 1 + 2 + 3\n    batch(() => {\n      // 1\n      this.optimisticUpdates.remove(optimisticId);\n\n      // If the associated thread is not found, we cannot create a comment under it\n      const existingThread = this.threads.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n\n      // 2 Update the thread instance by adding a comment under it\n      this.threads.upsert(applyUpsertComment(existingThread, newComment));\n\n      // 3 Update the associated inbox notification (if any)\n      this.notifications.updateAssociatedNotification(newComment);\n    });\n  }\n\n  public editComment(\n    threadId: string,\n    optimisticId: string,\n    editedComment: CommentData\n  ): void {\n    return this.#updateThread(threadId, optimisticId, (thread) =>\n      applyUpsertComment(thread, editedComment)\n    );\n  }\n\n  public deleteComment(\n    threadId: string,\n    optimisticId: string,\n    commentId: string,\n    deletedAt: Date\n  ): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n\n  public updateThreadifications(\n    threads: ThreadData<M>[],\n    notifications: InboxNotificationData[],\n    subscriptions: SubscriptionData[],\n    deletedThreads: ThreadDeleteInfo[] = [],\n    deletedNotifications: InboxNotificationDeleteInfo[] = [],\n    deletedSubscriptions: SubscriptionDeleteInfo[] = []\n  ): void {\n    batch(() => {\n      this.threads.applyDelta(threads, deletedThreads);\n      this.notifications.applyDelta(notifications, deletedNotifications);\n      this.subscriptions.applyDelta(subscriptions, deletedSubscriptions);\n    });\n  }\n\n  /**\n   * Updates existing subscription settings for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  public updateRoomSubscriptionSettings(\n    roomId: string,\n    optimisticId: string,\n    settings: Readonly<RoomSubscriptionSettings>\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.roomSubscriptionSettings.update(roomId, settings);\n    });\n  }\n\n  public async fetchNotificationsDeltaUpdate(signal: AbortSignal) {\n    const lastRequestedAt = this.#notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n\n    const result = await this.#client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.subscriptions.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted,\n      result.subscriptions.deleted\n    );\n  }\n\n  public async fetchRoomThreadsDeltaUpdate(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === undefined) {\n      return;\n    }\n\n    const updates = await this.#client[kInternal].httpClient.getThreadsSince({\n      roomId,\n      since: lastRequestedAt,\n      signal,\n    });\n\n    this.updateThreadifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.subscriptions.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted,\n      updates.subscriptions.deleted\n    );\n\n    this.permissionHints.update(updates.permissionHints);\n\n    if (lastRequestedAt < updates.requestedAt) {\n      // Update the `lastRequestedAt` value for the room to the timestamp returned by the current request\n      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n\n  public async fetchUserThreadsDeltaUpdate(signal: AbortSignal) {\n    const lastRequestedAt = this.#userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n\n    const result = await this.#client[\n      kInternal\n    ].httpClient.getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.subscriptions.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted,\n      result.subscriptions.deleted\n    );\n\n    this.permissionHints.update(result.permissionHints);\n  }\n\n  public async fetchRoomVersionsDeltaUpdate(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === undefined) {\n      return;\n    }\n\n    const room = nn(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n\n    const updates = await room[kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    this.historyVersions.update(roomId, updates.versions);\n\n    if (lastRequestedAt < updates.requestedAt) {\n      // Update the `lastRequestedAt` value for the room to the timestamp returned by the current request\n      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n\n  public async refreshRoomSubscriptionSettings(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const room = nn(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getSubscriptionSettings({ signal });\n    this.roomSubscriptionSettings.update(roomId, result);\n  }\n\n  /**\n   * Refresh notification settings from poller\n   */\n  public async refreshNotificationSettings(signal: AbortSignal) {\n    const result = await this.#client.getNotificationSettings({\n      signal,\n    });\n    this.notificationSettings.update(result);\n  }\n\n  /**\n   * Updates notification settings with a new value, replacing the\n   * corresponding optimistic update.\n   */\n  public updateNotificationSettings_confirmOptimisticUpdate(\n    settings: NotificationSettings,\n    optimisticUpdateId: string\n  ): void {\n    // Batch 1 + 2\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticUpdateId); // 1\n      this.notificationSettings.update(settings); // 2\n    });\n  }\n}\n\n/**\n * Applies optimistic updates, removes deleted threads, sorts results in\n * a stable way, removes internal fields that should not be exposed publicly.\n */\nfunction applyOptimisticUpdates_forThreadifications<M extends BaseMetadata>(\n  baseThreadsDB: ThreadDB<M>,\n  notificationsLUT: NotificationsLUT,\n  optimisticUpdates: readonly OptimisticUpdate<M>[]\n): CleanThreadifications<M> {\n  const threadsDB = baseThreadsDB.clone();\n  let notificationsById = Object.fromEntries(notificationsLUT);\n\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        // If the thread has been updated since the optimistic update, we do not apply the update\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata,\n          },\n        });\n        break;\n      }\n\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n\n        const inboxNotification = Object.values(notificationsById).find(\n          (notification) =>\n            notification.kind === \"thread\" &&\n            notification.threadId === thread.id\n        );\n\n        if (inboxNotification === undefined) {\n          break;\n        }\n\n        notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt,\n        };\n\n        break;\n      }\n\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: [],\n        });\n        break;\n      }\n\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];\n\n        // If the inbox notification doesn't exist, we do not apply the update\n        if (ibn === undefined) {\n          break;\n        }\n\n        notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt,\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in notificationsById) {\n          const ibn = notificationsById[id];\n\n          // If the inbox notification doesn't exist, we do not apply the update\n          if (ibn === undefined) {\n            break;\n          }\n\n          notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt,\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        notificationsById = {};\n        break;\n      }\n    }\n  }\n\n  // TODO Maybe consider also removing these from the inboxNotificationsById registry?\n  const sortedNotifications =\n    // Sort so that the most recent notifications are first\n    Object.values(notificationsById)\n      .filter((ibn) =>\n        ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== undefined : true\n      )\n      .sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime());\n\n  return {\n    sortedNotifications,\n    notificationsById,\n    threadsDB,\n  };\n}\n\n/**\n * Applies optimistic updates to room subscription settings in a stable way.\n */\nfunction applyOptimisticUpdates_forRoomSubscriptionSettings(\n  settingsLUT: RoomSubscriptionSettingsLUT,\n  optimisticUpdates: readonly OptimisticUpdate<BaseMetadata>[]\n): RoomSubscriptionSettingsByRoomId {\n  const roomSubscriptionSettingsByRoomId = Object.fromEntries(settingsLUT);\n\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"update-room-subscription-settings\": {\n        const settings =\n          roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId];\n\n        // If the settings don't exist, we do not apply the update\n        if (settings === undefined) {\n          break;\n        }\n\n        roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings,\n        };\n      }\n    }\n  }\n  return roomSubscriptionSettingsByRoomId;\n}\n\n/**\n * Applies optimistic updates to subscriptions in a stable way.\n */\nfunction applyOptimisticUpdates_forSubscriptions(\n  subscriptionsLUT: SubscriptionsLUT,\n  threads: ReadonlyThreadDB<BaseMetadata>,\n  optimisticUpdates: readonly OptimisticUpdate<BaseMetadata>[]\n): SubscriptionsByKey {\n  const subscriptions = Object.fromEntries(subscriptionsLUT);\n\n  for (const update of optimisticUpdates) {\n    switch (update.type) {\n      case \"update-room-subscription-settings\": {\n        // Other room subscription settings don't affect optimistic updates at the moment\n        if (!update.settings.threads) {\n          continue;\n        }\n\n        const roomThreads = threads.findMany(update.roomId, undefined, \"desc\");\n\n        for (const thread of roomThreads) {\n          const subscriptionKey = getSubscriptionKey(\"thread\", thread.id);\n\n          switch (update.settings.threads) {\n            // Create subscriptions for all existing threads in the room\n            case \"all\": {\n              subscriptions[subscriptionKey] = {\n                kind: \"thread\",\n                subjectId: thread.id,\n                createdAt: new Date(),\n              };\n              break;\n            }\n\n            // Delete subscriptions for all existing threads in the room\n            case \"none\": {\n              delete subscriptions[subscriptionKey];\n              break;\n            }\n\n            case \"replies_and_mentions\": {\n              // TODO: We can't go through the comments and create subscriptions optimistically because\n              //       we might not have group members for all group IDs which means we can't reliably\n              //       know if the user was mentioned with a group mention.\n              break;\n            }\n\n            default:\n              assertNever(\n                update.settings.threads,\n                \"Unexpected thread subscription settings.\"\n              );\n          }\n        }\n      }\n\n      // TODO: We can't do the following pseudo-code yet because we don't have the room subscription settings\n      // in the umbrella store when `useRoomSubscriptionSettings` isn't used.\n      //\n      // case \"create-thread\":\n      // case \"create-comment\":\n      //  // Create a subscription (if it doesn't exist yet) for the thread optimistically, unless the `\"thread\"`\n      //  // room subscription settings for the user and the thread's room are set to `\"none\"`.\n    }\n  }\n\n  return subscriptions;\n}\n\n/**\n * Applies optimistic update to notification settings in a stable way.\n * It's a deep update, and remove potential `undefined` properties from the final\n * output object because we update with a deep partial of `NotificationSettings`.\n *\n * Exported for unit tests only.\n */\nexport function applyOptimisticUpdates_forNotificationSettings(\n  settings: NotificationSettings,\n  optimisticUpdates: readonly OptimisticUpdate<BaseMetadata>[]\n): NotificationSettings {\n  let outcoming: NotificationSettings = settings;\n\n  for (const update of optimisticUpdates) {\n    if (update.type === \"update-notification-settings\") {\n      outcoming = patchNotificationSettings(outcoming, update.settings);\n    }\n  }\n\n  return outcoming;\n}\n\n/**\n * Compares two inbox notifications to determine which one is newer.\n * @param inboxNotificationA The first inbox notification to compare.\n * @param inboxNotificationB The second inbox notification to compare.\n * @returns 1 if inboxNotificationA is newer, -1 if inboxNotificationB is newer, or 0 if they are the same age or can't be compared.\n */\nexport function compareInboxNotifications(\n  inboxNotificationA: InboxNotificationData,\n  inboxNotificationB: InboxNotificationData\n): number {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n\n  // notifiedAt times are the same, compare readAt times if both are not null\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt\n      ? 1\n      : inboxNotificationA.readAt < inboxNotificationB.readAt\n        ? -1\n        : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n\n  // If all dates are equal, return 0\n  return 0;\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyUpsertComment<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  comment: CommentData\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not apply the update\n  if (thread.deletedAt !== undefined) {\n    // Note: only the unit tests are passing in deleted threads here. In all\n    // production code, this is never invoked for deleted threads.\n    return thread;\n  }\n\n  // Validate that the comment belongs to the thread\n  if (comment.threadId !== thread.id) {\n    console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (existingComment) => existingComment.id === comment.id\n  );\n\n  // If the comment doesn't exist in the thread, add the comment\n  if (existingComment === undefined) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment],\n    };\n\n    return updatedThread;\n  }\n\n  // If the comment exists in the thread and has been deleted, do not apply the update\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  // Proceed to update the comment if:\n  // 1. The existing comment has not been edited\n  // 2. The incoming comment has not been edited (i.e. it's a new comment)\n  // 3. The incoming comment has been edited more recently than the existing comment\n  if (\n    existingComment.editedAt === undefined ||\n    comment.editedAt === undefined ||\n    existingComment.editedAt <= comment.editedAt\n  ) {\n    const updatedComments = thread.comments.map((existingComment) =>\n      existingComment.id === comment.id ? comment : existingComment\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments,\n    };\n    return updatedThread;\n  }\n\n  return thread;\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyDeleteComment<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  commentId: string,\n  deletedAt: Date\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not delete the comment\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we cannot perform the deletion\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the deletion request, we do not delete the comment\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          deletedAt,\n          // We optimistically remove the comment body and attachments when marking it as deleted\n          body: undefined,\n          attachments: [],\n        }\n      : comment\n  );\n\n  // If all comments have been deleted (or there are no comments in the first\n  // place), we mark the thread as deleted.\n  if (updatedComments.every((comment) => comment.deletedAt !== undefined)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n    };\n  }\n\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments,\n  };\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyAddReaction<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  commentId: string,\n  reaction: CommentUserReaction\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not add the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not add the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction addition request, we do not add the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: upsertReaction(comment.reactions, reaction),\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments,\n  };\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyRemoveReaction<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>,\n  commentId: string,\n  emoji: string,\n  userId: string,\n  removedAt: Date\n): ThreadDataWithDeleteInfo<M> {\n  // If the thread has been deleted, we do not remove the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not remove the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction removal request, we do not remove the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: comment.reactions\n            .map((reaction) =>\n              reaction.emoji === emoji\n                ? {\n                    ...reaction,\n                    users: reaction.users.filter((user) => user.id !== userId),\n                  }\n                : reaction\n            )\n            .filter((reaction) => reaction.users.length > 0), // Remove reactions with no users left\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments,\n  };\n}\n\nfunction upsertReaction(\n  reactions: CommentReaction[],\n  reaction: CommentUserReaction\n): CommentReaction[] {\n  const existingReaction = reactions.find(\n    (existingReaction) => existingReaction.emoji === reaction.emoji\n  );\n\n  // If the reaction doesn't exist in the comment, we add it\n  if (existingReaction === undefined) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }],\n      },\n    ];\n  }\n\n  // If the reaction exists in the comment, we add the user to the reaction if they are not already in it\n  if (\n    existingReaction.users.some((user) => user.id === reaction.userId) === false\n  ) {\n    return reactions.map((existingReaction) =>\n      existingReaction.emoji === reaction.emoji\n        ? {\n            ...existingReaction,\n            users: [...existingReaction.users, { id: reaction.userId }],\n          }\n        : existingReaction\n    );\n  }\n\n  return reactions;\n}\n","/**\n * Binds all methods on a class instance to \"this\". Call this from the\n * constructor if you want to be able to reference the methods like this:\n *\n * ------------------------------------------------------------------------\n *\n *   class MyClass {}\n *   const thing = new MyClass();\n *   const getter1 = thing.someMethod;     //  Cannot refer to someMethod this way, because \"this\" will not be bound to \"thing\" here\n *   const getter2 = thing.anotherMethod;  // \n *\n * ------------------------------------------------------------------------\n *\n *   class MyClass {\n *     constructor() {\n *       // ...\n *       autobind(this);                   // \n *     }\n *   }\n *   const thing = new MyClass();\n *   const getter1 = thing.someMethod;     //  Now \"this\" will be correctly bound to \"thing\" inside someMethod()\n *   const getter2 = thing.anotherMethod;  //  Now\n *\n */\nexport function autobind(self: object): void {\n  const seen = new Set<string | symbol>();\n  seen.add(\"constructor\"); // We'll never want to bind the constructor\n\n  let obj = self.constructor.prototype as object;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n        (self as any)[key] = (self as any)[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)!) && obj !== Object.prototype);\n}\n","import type {\n  BaseMetadata,\n  InboxNotificationData,\n  ThreadData,\n} from \"@liveblocks/client\";\nimport { isStartsWithOperator } from \"@liveblocks/core\";\n\nimport type { InboxNotificationsQuery, ThreadsQuery } from \"../types\";\n\n/**\n * Creates a predicate function that will filter all ThreadData instances that\n * match the given query.\n */\nexport function makeThreadsFilter<M extends BaseMetadata>(\n  query: ThreadsQuery<M>\n): (thread: ThreadData<M>) => boolean {\n  return (thread: ThreadData<M>) =>\n    matchesThreadsQuery(thread, query) && matchesMetadata(thread, query);\n}\n\nfunction matchesThreadsQuery(\n  thread: ThreadData<BaseMetadata>,\n  q: ThreadsQuery<BaseMetadata>\n) {\n  // Boolean logic: query.resolved? => q.resolved === t.resolved\n  return q.resolved === undefined || thread.resolved === q.resolved;\n}\n\nfunction matchesMetadata(\n  thread: ThreadData<BaseMetadata>,\n  q: ThreadsQuery<BaseMetadata>\n) {\n  // Boolean logic: query.metadata? => all metadata matches\n  const metadata = thread.metadata;\n  return (\n    q.metadata === undefined ||\n    Object.entries(q.metadata).every(\n      ([key, op]) =>\n        // Ignore explicit-undefined filters\n        // Boolean logic: op? => value matches the operator\n        op === undefined || matchesOperator(metadata[key], op)\n    )\n  );\n}\n\nfunction matchesOperator(\n  value: BaseMetadata[string],\n  op: Exclude<BaseMetadata[string], undefined> | { startsWith: string } | null\n) {\n  if (op === null) {\n    // If the operator is `null`, we're doing an explicit query for absence\n    return value === undefined;\n  } else if (isStartsWithOperator(op)) {\n    return typeof value === \"string\" && value.startsWith(op.startsWith);\n  } else {\n    return value === op;\n  }\n}\n\nexport function makeInboxNotificationsFilter(\n  query: InboxNotificationsQuery\n): (inboxNotification: InboxNotificationData) => boolean {\n  return (inboxNotification: InboxNotificationData) =>\n    matchesInboxNotificationsQuery(inboxNotification, query);\n}\n\nfunction matchesInboxNotificationsQuery(\n  inboxNotification: InboxNotificationData,\n  q: InboxNotificationsQuery\n) {\n  return (\n    (q.roomId === undefined || q.roomId === inboxNotification.roomId) &&\n    (q.kind === undefined || q.kind === inboxNotification.kind)\n  );\n}\n","import type {\n  BaseMetadata,\n  ThreadData,\n  ThreadDataWithDeleteInfo,\n  ThreadDeleteInfo,\n} from \"@liveblocks/core\";\nimport { batch, MutableSignal, SortedList } from \"@liveblocks/core\";\n\nimport { makeThreadsFilter } from \"./lib/querying\";\nimport type { ThreadsQuery } from \"./types\";\n\nfunction sanitizeThread<M extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<M>\n): ThreadDataWithDeleteInfo<M> {\n  // First, if a thread has a deletedAt date, it should not have any comments\n  if (thread.deletedAt) {\n    // Thread is deleted, it should wipe all comments\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n\n  // Otherwise, if a thread is not deleted, it _should_ have at least one non-deleted comment\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    // Delete it after all if it doesn't have at least one comment\n    return { ...thread, deletedAt: new Date(), comments: [] };\n  }\n\n  return thread;\n}\n\nexport type ReadonlyThreadDB<M extends BaseMetadata> = Omit<\n  ThreadDB<M>,\n  \"upsert\" | \"delete\" | \"signal\"\n>;\n\n/**\n * This class implements a lightweight, in-memory, \"database\" for all Thread\n * instances.\n *\n * It exposes the following methods:\n *\n * - upsert: To add/update a thread\n * - upsertIfNewer: To add/update a thread. Only update an existing thread if\n *                  its newer\n * - delete: To mark existing threads as deleted\n * - get: To get any non-deleted thread\n * - getEvenIfDeleted: To get a thread which is possibly deleted\n * - findMany: To filter an ordered list of non-deleted threads\n * - clone: To clone the DB to mutate it further. This is used to mix in\n *          optimistic updates without losing the original thread contents.\n *\n */\nexport class ThreadDB<M extends BaseMetadata> {\n  #byId: Map<string, ThreadDataWithDeleteInfo<M>>;\n  #asc: SortedList<ThreadData<M>>;\n  #desc: SortedList<ThreadData<M>>;\n\n  // This signal will be notified on every mutation\n  public readonly signal: MutableSignal<this>;\n\n  constructor() {\n    this.#asc = SortedList.from<ThreadData<M>>([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n\n    this.#desc = SortedList.from<ThreadData<M>>([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n\n    this.#byId = new Map();\n\n    this.signal = new MutableSignal(this);\n  }\n\n  //\n  // Public APIs\n  //\n\n  public clone(): ThreadDB<M> {\n    const newPool = new ThreadDB<M>();\n    newPool.#byId = new Map(this.#byId);\n    newPool.#asc = this.#asc.clone();\n    newPool.#desc = this.#desc.clone();\n    return newPool;\n  }\n\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  public get(threadId: string): ThreadData<M> | undefined {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? undefined : thread;\n  }\n\n  /** Returns the (possibly deleted) thread by ID. */\n  public getEvenIfDeleted(\n    threadId: string\n  ): ThreadDataWithDeleteInfo<M> | undefined {\n    return this.#byId.get(threadId);\n  }\n\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  public upsert(thread: ThreadDataWithDeleteInfo<M>): void {\n    this.signal.mutate(() => {\n      thread = sanitizeThread(thread);\n\n      const id = thread.id;\n\n      const toRemove = this.#byId.get(id);\n      if (toRemove) {\n        // Don't do anything if the existing thread is already deleted!\n        if (toRemove.deletedAt) return false;\n\n        this.#asc.remove(toRemove);\n        this.#desc.remove(toRemove);\n      }\n\n      if (!thread.deletedAt) {\n        this.#asc.add(thread);\n        this.#desc.add(thread);\n      }\n      this.#byId.set(id, thread);\n      return true;\n    });\n  }\n\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  public upsertIfNewer(thread: ThreadDataWithDeleteInfo<M>): void {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n\n  public applyDelta(\n    newThreads: ThreadData<M>[],\n    deletedThreads: ThreadDeleteInfo[]\n  ): void {\n    batch(() => {\n      // Add new threads or update existing threads if the existing thread is older than the new thread.\n      for (const thread of newThreads) {\n        this.upsertIfNewer(thread);\n      }\n\n      // Mark threads in the deletedThreads list as deleted\n      for (const { id, deletedAt } of deletedThreads) {\n        const existing = this.getEvenIfDeleted(id);\n        if (!existing) continue;\n        this.delete(id, deletedAt);\n      }\n    });\n  }\n\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  public delete(threadId: string, deletedAt: Date): void {\n    const existing = this.#byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   */\n  public findMany(\n    // TODO: Implement caching here\n    roomId: string | undefined,\n    query: ThreadsQuery<M> | undefined,\n    direction: \"asc\" | \"desc\"\n  ): ThreadData<M>[] {\n    const index = direction === \"desc\" ? this.#desc : this.#asc;\n    const crit: ((thread: ThreadData<M>) => boolean)[] = [];\n    if (roomId !== undefined) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    if (query !== undefined) {\n      crit.push(makeThreadsFilter(query));\n    }\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  BroadcastOptions,\n  Client,\n  CommentData,\n  History,\n  Json,\n  JsonObject,\n  LiveObject,\n  LostConnectionEvent,\n  LsonObject,\n  OthersEvent,\n  Room,\n  Status,\n  ThreadData,\n  User,\n} from \"@liveblocks/client\";\nimport { shallow } from \"@liveblocks/client\";\nimport type {\n  AsyncResult,\n  CommentsEventServerMsg,\n  DE,\n  DM,\n  DP,\n  DS,\n  DU,\n  EnterOptions,\n  IYjsProvider,\n  LiveblocksErrorContext,\n  MentionData,\n  OpaqueClient,\n  RoomEventMessage,\n  RoomSubscriptionSettings,\n  SignalType,\n  TextEditorType,\n  ToImmutable,\n  UnsubscribeCallback,\n} from \"@liveblocks/core\";\nimport {\n  assert,\n  console,\n  createCommentId,\n  createThreadId,\n  DefaultMap,\n  errorIf,\n  getSubscriptionKey,\n  HttpError,\n  kInternal,\n  makePoller,\n  ServerMsgCode,\n} from \"@liveblocks/core\";\nimport type { Context } from \"react\";\nimport {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  useSyncExternalStore,\n  version as reactVersion,\n} from \"react\";\n\nimport { config } from \"./config\";\nimport {\n  RoomContext,\n  useClient,\n  useClientOrNull,\n  useIsInsideRoom,\n  useRoomOrNull,\n} from \"./contexts\";\nimport { ensureNotServerSide } from \"./lib/ssr\";\nimport { useInitial } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { use } from \"./lib/use-polyfill\";\nimport {\n  createSharedContext,\n  getUmbrellaStoreForClient,\n  LiveblocksProviderWithClient,\n} from \"./liveblocks\";\nimport type {\n  AttachmentUrlAsyncResult,\n  CommentReactionOptions,\n  CreateCommentOptions,\n  CreateThreadOptions,\n  DeleteCommentOptions,\n  EditCommentOptions,\n  EditThreadMetadataOptions,\n  HistoryVersionDataAsyncResult,\n  HistoryVersionsAsyncResult,\n  HistoryVersionsAsyncSuccess,\n  MutationContext,\n  OmitFirstArg,\n  RoomContextBundle,\n  RoomProviderProps,\n  RoomSubscriptionSettingsAsyncResult,\n  RoomSubscriptionSettingsAsyncSuccess,\n  ThreadsAsyncResult,\n  ThreadsAsyncSuccess,\n  ThreadSubscription,\n  UseThreadsOptions,\n} from \"./types\";\nimport type { UmbrellaStore } from \"./umbrella-store\";\nimport { makeRoomThreadsQueryKey } from \"./umbrella-store\";\nimport { useScrollToCommentOnLoadEffect } from \"./use-scroll-to-comment-on-load-effect\";\nimport { useSignal } from \"./use-signal\";\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nconst noop = () => {};\nconst identity: <T>(x: T) => T = (x) => x;\n\nconst STABLE_EMPTY_LIST = Object.freeze([]);\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a useCallback() wrapper.\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a useCallback() wrapper.\nfunction alwaysNull() {\n  return null;\n}\n\nfunction selectorFor_useOthersConnectionIds(\n  others: readonly User<JsonObject, BaseUserMeta>[]\n): number[] {\n  return others.map((user) => user.connectionId);\n}\n\nfunction makeMutationContext<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(room: Room<P, S, U, E, M>): MutationContext<P, S, U> {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n\n    setMyPresence: room.updatePresence,\n  };\n}\n\nfunction getCurrentUserId(client: Client): string {\n  const userId = client[kInternal].currentUserId.get();\n  if (userId === undefined) {\n    return \"anonymous\";\n  }\n  return userId;\n}\n\nconst _extras = new WeakMap<\n  OpaqueClient,\n  ReturnType<typeof makeRoomExtrasForClient>\n>();\nconst _bundles = new WeakMap<\n  OpaqueClient,\n  RoomContextBundle<JsonObject, LsonObject, BaseUserMeta, Json, BaseMetadata>\n>();\n\nfunction getOrCreateRoomContextBundle<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(client: OpaqueClient): RoomContextBundle<P, S, U, E, M> {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle as unknown as RoomContextBundle<P, S, U, E, M>;\n}\n\n// TODO: Likely a better / more clear name for this helper will arise. I'll\n// rename this later. All of these are implementation details to support inbox\n// notifications on a per-client basis.\nfunction getRoomExtrasForClient<M extends BaseMetadata>(client: OpaqueClient) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n\n  return extras as unknown as Omit<typeof extras, \"store\"> & {\n    store: UmbrellaStore<M>;\n  };\n}\n\nfunction makeRoomExtrasForClient(client: OpaqueClient) {\n  const store = getUmbrellaStoreForClient(client);\n\n  function onMutationFailure(\n    optimisticId: string,\n    context: LiveblocksErrorContext & { roomId: string },\n    innerError: Error\n  ): void {\n    store.optimisticUpdates.remove(optimisticId);\n\n    // All mutation failures are expected to be HTTP errors ultimately - only\n    // ever notify the user about those.\n    if (innerError instanceof HttpError) {\n      // Always log details about 403 Forbidden errors to the console as well\n      if (innerError.status === 403) {\n        const detailedMessage = [\n          innerError.message,\n          innerError.details?.suggestion,\n          innerError.details?.docs,\n        ]\n          .filter(Boolean)\n          .join(\"\\n\");\n\n        console.error(detailedMessage);\n      }\n\n      client[kInternal].emitError(context, innerError);\n    } else {\n      // In this context, a non-HTTP error is unexpected and should be\n      // considered a bug we should get fixed. Don't notify the user about it.\n      throw innerError;\n    }\n  }\n\n  const threadsPollersByRoomId = new DefaultMap((roomId: string) =>\n    makePoller(\n      async (signal) => {\n        try {\n          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n          throw err;\n        }\n      },\n      config.ROOM_THREADS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n    )\n  );\n\n  const versionsPollersByRoomId = new DefaultMap((roomId: string) =>\n    makePoller(\n      async (signal) => {\n        try {\n          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n          throw err;\n        }\n      },\n      config.HISTORY_VERSIONS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n    )\n  );\n\n  const roomSubscriptionSettingsPollersByRoomId = new DefaultMap(\n    (roomId: string) =>\n      makePoller(\n        async (signal) => {\n          try {\n            return await store.refreshRoomSubscriptionSettings(roomId, signal);\n          } catch (err) {\n            console.warn(`Polling subscription settings for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n            throw err;\n          }\n        },\n        config.ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME }\n      )\n  );\n\n  return {\n    store,\n    onMutationFailure,\n    pollThreadsForRoomId: (roomId: string) => {\n      const threadsPoller = threadsPollersByRoomId.getOrCreate(roomId);\n\n      // If there's a threads poller for this room, immediately trigger it\n      if (threadsPoller) {\n        threadsPoller.markAsStale();\n        threadsPoller.pollNowIfStale();\n      }\n    },\n    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(\n      threadsPollersByRoomId\n    ),\n    getOrCreateVersionsPollerForRoomId:\n      versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),\n    getOrCreateSubscriptionSettingsPollerForRoomId:\n      roomSubscriptionSettingsPollersByRoomId.getOrCreate.bind(\n        roomSubscriptionSettingsPollersByRoomId\n      ),\n  };\n}\n\ntype RoomLeavePair<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n> = {\n  room: Room<P, S, U, E, M>;\n  leave: () => void;\n};\n\nfunction makeRoomContextBundle<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(client: Client<U>): RoomContextBundle<P, S, U, E, M> {\n  type TRoom = Room<P, S, U, E, M>;\n\n  function RoomProvider_withImplicitLiveblocksProvider(\n    props: RoomProviderProps<P, S>\n  ) {\n    // NOTE: Normally, nesting LiveblocksProvider is not allowed. This\n    // factory-bound version of the RoomProvider will create an implicit\n    // LiveblocksProvider. This means that if an end user nests this\n    // RoomProvider under a LiveblocksProvider context, that would be an error.\n    // However, we'll allow that nesting only in this specific situation, and\n    // only because this wrapper will keep the Liveblocks context and the Room\n    // context consistent internally.\n    return (\n      <LiveblocksProviderWithClient client={client} allowNesting>\n        {/* @ts-expect-error {...props} is the same type as props */}\n        <RoomProvider {...props} />\n      </LiveblocksProviderWithClient>\n    );\n  }\n\n  const shared = createSharedContext<U>(client);\n\n  const bundle: RoomContextBundle<P, S, U, E, M> = {\n    RoomContext: RoomContext as Context<TRoom | null>,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n\n    useRoom,\n    useStatus,\n\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useEventListener,\n\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n\n    useStorageRoot,\n    useStorage,\n\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n\n    useMutation: useMutation as RoomContextBundle<P, S, U, E, M>[\"useMutation\"],\n\n    useThreads,\n\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useSubscribeToThread,\n    useUnsubscribeFromThread,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n\n    useHistoryVersions,\n    useHistoryVersionData,\n\n    useRoomSubscriptionSettings,\n    useUpdateRoomSubscriptionSettings,\n\n    ...shared.classic,\n\n    suspense: {\n      RoomContext: RoomContext as Context<TRoom | null>,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n\n      useRoom,\n      useStatus,\n\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useEventListener,\n\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n\n      useMutation: useMutation as RoomContextBundle<\n        P,\n        S,\n        U,\n        E,\n        M\n      >[\"suspense\"][\"useMutation\"],\n\n      useThreads: useThreadsSuspense,\n\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useSubscribeToThread,\n      useUnsubscribeFromThread,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n\n      useRoomSubscriptionSettings: useRoomSubscriptionSettingsSuspense,\n      useUpdateRoomSubscriptionSettings,\n\n      ...shared.suspense,\n    },\n  };\n\n  return Object.defineProperty(bundle, kInternal, {\n    enumerable: false,\n  });\n}\n\nfunction RoomProvider<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(props: RoomProviderProps<P, S>) {\n  const client = useClient<U>();\n  const [cache] = useState(\n    () => new Map<string, RoomLeavePair<P, S, U, E, M>>()\n  );\n\n  // Produce a version of client.enterRoom() that when called for the same\n  // room ID multiple times, will not keep producing multiple leave\n  // functions, but instead return the cached one.\n  const stableEnterRoom: typeof client.enterRoom<P, S, E, M> = useCallback(\n    (\n      roomId: string,\n      options: EnterOptions<P, S>\n    ): RoomLeavePair<P, S, U, E, M> => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n\n      const rv = client.enterRoom<P, S, E, M>(roomId, options);\n\n      // Wrap the leave function to also delete the cached value\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n\n  //\n  // RATIONALE:\n  // At the \"Outer\" RoomProvider level, we keep a cache and produce\n  // a stableEnterRoom function, which we pass down to the real \"Inner\"\n  // RoomProvider level.\n  //\n  // The purpose is to ensure that if `stableEnterRoom(\"my-room\")` is called\n  // multiple times for the same room ID, it will always return the exact same\n  // (cached) value, so that in total only a single \"leave\" function gets\n  // produced and registered in the client.\n  //\n  // If we didn't use this cache, then in React StrictMode\n  // stableEnterRoom(\"my-room\") might get called multiple (at least 4) times,\n  // causing more leave functions to be produced in the client, some of which\n  // we cannot get a hold on (because StrictMode would discard those results by\n  // design). This would make it appear to the Client that the Room is still in\n  // use by some party that hasn't called `leave()` on it yet, thus causing the\n  // Room to not be freed and destroyed when the component unmounts later.\n  //\n  return (\n    <RoomProviderInner<P, S, U, E, M>\n      {...(props as any)}\n      stableEnterRoom={stableEnterRoom}\n    />\n  );\n}\n\ntype EnterRoomType<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n> = (\n  roomId: string,\n  options: EnterOptions<P, S>\n) => RoomLeavePair<P, S, U, E, M>;\n\n/** @internal */\nfunction RoomProviderInner<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(\n  props: RoomProviderProps<P, S> & {\n    stableEnterRoom: EnterRoomType<P, S, U, E, M>;\n  }\n) {\n  const client = useClient<U>();\n  const { id: roomId, stableEnterRoom } = props;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n\n    const majorReactVersion = parseInt(reactVersion) || 1;\n    const requiredVersion = 18;\n    errorIf(\n      majorReactVersion < requiredVersion,\n      `React ${requiredVersion} or higher is required (youre on ${reactVersion})`\n    );\n  }\n\n  // Note: We'll hold on to the initial value given here, and ignore any\n  // changes to this argument in subsequent renders, except when roomId changes\n  const frozenProps = useInitial(\n    {\n      initialPresence: props.initialPresence,\n      initialStorage: props.initialStorage,\n      autoConnect: props.autoConnect ?? typeof window !== \"undefined\",\n    },\n    roomId\n  ) as EnterOptions<P, S>;\n\n  const [{ room }, setRoomLeavePair] = useState(() =>\n    stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false, // Deliberately using false here on the first render, see below\n    })\n  );\n\n  useEffect(() => {\n    const { store } = getRoomExtrasForClient(client);\n\n    async function handleCommentEvent(message: CommentsEventServerMsg) {\n      // If thread deleted event is received, we remove the thread from the local cache\n      // no need for more processing\n      if (message.type === ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n\n      // TODO: Error handling\n      const info = await room.getThread(message.threadId);\n\n      // If no thread info was returned (i.e., 404), we remove the thread and relevant inbox notifications from local cache.\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const {\n        thread,\n        inboxNotification: maybeNotification,\n        subscription: maybeSubscription,\n      } = info;\n\n      const existingThread = store.outputs.threads\n        .get()\n        .getEvenIfDeleted(message.threadId);\n\n      switch (message.type) {\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.THREAD_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_DELETED:\n          // If the thread doesn't exist in the local cache, we do not update it with the server data as an optimistic update could have deleted the thread locally.\n          if (!existingThread) break;\n\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : [],\n            maybeSubscription ? [maybeSubscription] : []\n          );\n          break;\n\n        case ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : [],\n            maybeSubscription ? [maybeSubscription] : []\n          );\n          break;\n        default:\n          break;\n      }\n    }\n\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n\n  useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n\n    setRoomLeavePair(pair);\n    const { room, leave } = pair;\n\n    // In React, it's important to start connecting to the room as an effect,\n    // rather than doing this during the initial render. This means that\n    // during the initial render (both on the server-side, and on the first\n    // hydration on the client-side), the value of the `useStatus()` hook\n    // will correctly be \"initial\", and transition to \"connecting\" as an\n    // effect.\n    if (frozenProps.autoConnect) {\n      room.connect();\n    }\n\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n\n  return (\n    <RoomContext.Provider value={room}>{props.children}</RoomContext.Provider>\n  );\n}\n\nfunction useRoom<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n>(options?: { allowOutsideRoom: false }): Room<P, S, U, E, M>;\nfunction useRoom<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n>(options: { allowOutsideRoom: boolean }): Room<P, S, U, E, M> | null;\nfunction useRoom<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n>(options?: { allowOutsideRoom: boolean }): Room<P, S, U, E, M> | null {\n  const room = useRoomOrNull<P, S, U, E, M>();\n  if (room === null && !options?.allowOutsideRoom) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\n\n/**\n * Returns the current connection status for the Room, and triggers\n * a re-render whenever it changes. Can be used to render a status badge.\n */\nfunction useStatus(): Status {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useReportTextEditor(editor: TextEditorType, rootKey: string): void {\n  const isReported = useRef<boolean>(false);\n  const room = useRoom();\n\n  useEffect(() => {\n    // We use a \"locker\" reference to avoid to spam / harass our backend\n    // and to not add / remove subscribers in case when the text editor type\n    // has been already reported.\n    if (isReported.current) {\n      return;\n    }\n\n    const unsubscribe = room.events.status.subscribe((status: Status): void => {\n      if (status === \"connected\" && !isReported.current) {\n        isReported.current = true;\n        // We do not catch because this method never throw (e.g `rawPost`)\n        void room[kInternal].reportTextEditor(editor, rootKey);\n      }\n    });\n\n    return unsubscribe;\n  }, [room, editor, rootKey]);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useYjsProvider(): IYjsProvider | undefined {\n  const room = useRoom();\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void): UnsubscribeCallback => {\n      return room[kInternal].yjsProviderDidChange.subscribe(onStoreChange);\n    },\n    [room]\n  );\n\n  const getSnapshot = useCallback((): IYjsProvider | undefined => {\n    return room[kInternal].getYjsProvider();\n  }, [room]);\n\n  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useCreateTextMention(): (\n  mentionId: string,\n  mention: MentionData\n) => void {\n  const room = useRoom();\n  return useCallback(\n    (mentionId: string, mention: MentionData): void => {\n      room[kInternal]\n        .createTextMention(mentionId, mention)\n        .catch((err): void => {\n          console.error(\n            `Cannot create text mention for mention '${mentionId}'`,\n            err\n          );\n        });\n    },\n    [room]\n  );\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useDeleteTextMention(): (mentionId: string) => void {\n  const room = useRoom();\n  return useCallback(\n    (mentionId: string): void => {\n      room[kInternal].deleteTextMention(mentionId).catch((err): void => {\n        console.error(`Cannot delete text mention '${mentionId}'`, err);\n      });\n    },\n    [room]\n  );\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useResolveMentionSuggestions() {\n  const client = useClient();\n  return client[kInternal].resolveMentionSuggestions;\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useMentionSuggestionsCache() {\n  const client = useClient();\n  return client[kInternal].mentionSuggestionsCache;\n}\n\nfunction useBroadcastEvent<E extends Json>(): (\n  event: E,\n  options?: BroadcastOptions\n) => void {\n  const room = useRoom<never, never, never, E, never>();\n  return useCallback(\n    (\n      event: E,\n      options: BroadcastOptions = { shouldQueueEventIfNotReady: false }\n    ) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\n\nfunction useOthersListener<P extends JsonObject, U extends BaseUserMeta>(\n  callback: (event: OthersEvent<P, U>) => void\n) {\n  const room = useRoom<P, never, U, never, never>();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\n\n/**\n * Get informed when reconnecting to the Liveblocks servers is taking\n * longer than usual. This typically is a sign of a client that has lost\n * internet connectivity.\n *\n * This isn't problematic (because the Liveblocks client is still trying to\n * reconnect), but it's typically a good idea to inform users about it if\n * the connection takes too long to recover.\n *\n * @example\n * useLostConnectionListener(event => {\n *   if (event === 'lost') {\n *     toast.warn('Reconnecting to the Liveblocks servers is taking longer than usual...')\n *   } else if (event === 'failed') {\n *     toast.warn('Reconnecting to the Liveblocks servers failed.')\n *   } else if (event === 'restored') {\n *     toast.clear();\n *   }\n * })\n */\nfunction useLostConnectionListener(\n  callback: (event: LostConnectionEvent) => void\n): void {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () =>\n      room.events.lostConnection.subscribe((event) =>\n        savedCallback.current(event)\n      ),\n    [room, savedCallback]\n  );\n}\n\nfunction useEventListener<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n>(callback: (data: RoomEventMessage<P, U, E>) => void): void {\n  const room = useRoom<P, never, U, E, never>();\n  const savedCallback = useLatest(callback);\n  useEffect(() => {\n    const listener = (eventData: RoomEventMessage<P, U, E>) => {\n      savedCallback.current(eventData);\n    };\n\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\n\n/**\n * Returns the room.history\n */\nfunction useHistory(): History {\n  return useRoom().history;\n}\n\n/**\n * Returns a function that undoes the last operation executed by the current\n * client. It does not impact operations made by other clients.\n */\nfunction useUndo(): () => void {\n  return useHistory().undo;\n}\n\n/**\n * Returns a function that redoes the last operation executed by the current\n * client. It does not impact operations made by other clients.\n */\nfunction useRedo(): () => void {\n  return useHistory().redo;\n}\n\n/**\n * Returns whether there are any operations to undo.\n */\nfunction useCanUndo(): boolean {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore(subscribe, canUndo, canUndo);\n}\n\n/**\n * Returns whether there are any operations to redo.\n */\nfunction useCanRedo(): boolean {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore(subscribe, canRedo, canRedo);\n}\n\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta>(): User<\n  P,\n  U\n> | null;\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (me: User<P, U>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | null;\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta, T>(\n  maybeSelector?: (me: User<P, U>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | User<P, U> | null {\n  type Snapshot = User<P, U> | null;\n  type Selection = T | null;\n\n  const room = useRoom<P, never, U, never, never>();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot: () => Snapshot = room.getSelf;\n\n  const selector = maybeSelector ?? (identity as (me: User<P, U>) => T);\n  const wrappedSelector = useCallback(\n    (me: Snapshot): Selection => (me !== null ? selector(me) : null),\n    [selector]\n  );\n\n  const getServerSnapshot = alwaysNull;\n\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\n\nfunction useMyPresence<P extends JsonObject>(): [\n  P,\n  (patch: Partial<P>, options?: { addToHistory: boolean }) => void,\n] {\n  const room = useRoom<P, never, never, never, never>();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\n\nfunction useUpdateMyPresence<P extends JsonObject>(): (\n  patch: Partial<P>,\n  options?: { addToHistory: boolean }\n) => void {\n  return useRoom<P, never, never, never, never>().updatePresence;\n}\n\nfunction useOthers<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n>(): readonly User<P, U>[];\nfunction useOthers<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useOthers<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | readonly User<P, U>[] {\n  const room = useRoom<P, never, U, never, never>();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? (identity as (others: readonly User<P, U>[]) => T),\n    isEqual\n  );\n}\n\nfunction useOthersMapped<P extends JsonObject, U extends BaseUserMeta, T>(\n  itemSelector: (other: User<P, U>) => T,\n  itemIsEqual?: (prev: T, curr: T) => boolean\n): ReadonlyArray<readonly [connectionId: number, data: T]> {\n  const wrappedSelector = useCallback(\n    (others: readonly User<P, U>[]) =>\n      others.map((other) => [other.connectionId, itemSelector(other)] as const),\n    [itemSelector]\n  );\n\n  const wrappedIsEqual = useCallback(\n    (\n      a: ReadonlyArray<readonly [connectionId: number, data: T]>,\n      b: ReadonlyArray<readonly [connectionId: number, data: T]>\n    ): boolean => {\n      const eq = itemIsEqual ?? Object.is;\n      return (\n        a.length === b.length &&\n        a.every((atuple, index) => {\n          // We know btuple always exist because we checked the array length on the previous line\n          const btuple = b[index]!;\n          return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n        })\n      );\n    },\n    [itemIsEqual]\n  );\n\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\n\n/**\n * Returns an array of connection IDs. This matches the values you'll get by\n * using the `useOthers()` hook.\n *\n * Roughly equivalent to:\n *   useOthers((others) => others.map(other => other.connectionId), shallow)\n *\n * This is useful in particular to implement efficiently rendering components\n * for each user in the room, e.g. cursors.\n *\n * @example\n * const ids = useOthersConnectionIds();\n * // [2, 4, 7]\n */\nfunction useOthersConnectionIds(): readonly number[] {\n  return useOthers(selectorFor_useOthersConnectionIds, shallow);\n}\n\nconst NOT_FOUND = Symbol();\n\ntype NotFound = typeof NOT_FOUND;\n\nfunction useOther<P extends JsonObject, U extends BaseUserMeta, T>(\n  connectionId: number,\n  selector: (other: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  const wrappedSelector = useCallback(\n    (others: readonly User<P, U>[]) => {\n      // TODO: Make this O(1) instead of O(n)?\n      const other = others.find((other) => other.connectionId === connectionId);\n      return other !== undefined ? selector(other) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n\n  const wrappedIsEqual = useCallback(\n    (prev: T | NotFound, curr: T | NotFound): boolean => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n\n  return other;\n}\n\n/** @internal */\nfunction useMutableStorageRoot<S extends LsonObject>(): LiveObject<S> | null {\n  const room = useRoom<never, S, never, never, never>();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n// NOTE: This API exists for backward compatible reasons\nfunction useStorageRoot<S extends LsonObject>(): [root: LiveObject<S> | null] {\n  return [useMutableStorageRoot<S>()];\n}\n\nfunction useStorage<S extends LsonObject, T>(\n  selector: (root: ToImmutable<S>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | null {\n  type Snapshot = ToImmutable<S> | null;\n  type Selection = T | null;\n\n  const room = useRoom<never, S, never, never, never>();\n  const rootOrNull = useMutableStorageRoot<S>();\n\n  const wrappedSelector = useCallback(\n    (rootOrNull: Snapshot): Selection =>\n      rootOrNull !== null ? selector(rootOrNull) : null,\n    [selector]\n  );\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void) =>\n      rootOrNull !== null\n        ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true })\n        : noop,\n    [room, rootOrNull]\n  );\n\n  const getSnapshot = useCallback((): Snapshot => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n\n  const getServerSnapshot = alwaysNull;\n\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\n\nfunction useMutation<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n  F extends (context: MutationContext<P, S, U>, ...args: any[]) => any,\n>(callback: F, deps: readonly unknown[]): OmitFirstArg<F> {\n  const room = useRoom<P, S, U, E, M>();\n  return useMemo(\n    () => {\n      return ((...args) =>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(() =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          callback(\n            makeMutationContext<P, S, U, E, M>(room),\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            ...args\n          )\n        )) as OmitFirstArg<F>;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\n\nfunction useThreads<M extends BaseMetadata>(\n  options: UseThreadsOptions<M> = {}\n): ThreadsAsyncResult<M> {\n  const { scrollOnLoad = true } = options;\n\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } =\n    getRoomExtrasForClient<M>(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n\n  useEffect(\n    () =>\n      void store.outputs.loadingRoomThreads\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n\n  const result = useSignal(\n    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal\n  );\n\n  useScrollToCommentOnLoadEffect(scrollOnLoad, result);\n  return result;\n}\n\nfunction useCreateThread<M extends BaseMetadata>(): (\n  options: CreateThreadOptions<M>\n) => ThreadData<M> {\n  return useCreateRoomThread(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useCreateRoomThread<M extends BaseMetadata>(\n  roomId: string\n): (options: CreateThreadOptions<M>) => ThreadData<M> {\n  const client = useClient();\n\n  return useCallback(\n    (options: CreateThreadOptions<M>): ThreadData<M> => {\n      const body = options.body;\n      const metadata = options.metadata ?? ({} as M);\n      const attachments = options.attachments;\n\n      const threadId = createThreadId();\n      const commentId = createCommentId();\n      const createdAt = new Date();\n\n      const newComment: CommentData = {\n        id: commentId,\n        threadId,\n        roomId,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? [],\n      };\n      const newThread: ThreadData<M> = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId,\n        metadata,\n        comments: [newComment],\n        resolved: false,\n      };\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId,\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .createThread({\n          roomId,\n          threadId,\n          commentId,\n          body,\n          metadata,\n          attachmentIds,\n        })\n        .then(\n          (thread) => {\n            // Replace the optimistic update by the real thing\n            store.createThread(optimisticId, thread);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"CREATE_THREAD_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                body,\n                metadata,\n              },\n              err\n            )\n        );\n\n      return newThread;\n    },\n    [client, roomId]\n  );\n}\n\nfunction useDeleteThread(): (threadId: string) => void {\n  return useDeleteRoomThread(useRoom().id);\n}\n\nfunction useDeleteRoomThread(roomId: string): (threadId: string) => void {\n  const client = useClient();\n  return useCallback(\n    (threadId: string): void => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n\n      const userId = getCurrentUserId(client);\n\n      const existing = store.outputs.threads.get().get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-thread\",\n        roomId,\n        threadId,\n        deletedAt: new Date(),\n      });\n\n      client[kInternal].httpClient.deleteThread({ roomId, threadId }).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.deleteThread(threadId, optimisticId);\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            { type: \"DELETE_THREAD_ERROR\", roomId, threadId },\n            err\n          )\n      );\n    },\n    [client, roomId]\n  );\n}\n\nfunction useEditThreadMetadata<M extends BaseMetadata>() {\n  return useEditRoomThreadMetadata<M>(useRoom().id);\n}\n\nfunction useEditRoomThreadMetadata<M extends BaseMetadata>(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (options: EditThreadMetadataOptions<M>): void => {\n      if (!options.metadata) {\n        return;\n      }\n\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .editThreadMetadata({ roomId, threadId, metadata })\n        .then(\n          (metadata) =>\n            // Replace the optimistic update by the real thing\n            store.patchThread(threadId, optimisticId, { metadata }, updatedAt),\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"EDIT_THREAD_METADATA_ERROR\",\n                roomId,\n                threadId,\n                metadata,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that adds a comment to a thread.\n *\n * @example\n * const createComment = useCreateComment();\n * createComment({ threadId: \"th_xxx\", body: {} });\n */\nfunction useCreateComment(): (options: CreateCommentOptions) => CommentData {\n  return useCreateRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useCreateRoomComment(\n  roomId: string\n): (options: CreateCommentOptions) => CommentData {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, body, attachments }: CreateCommentOptions): CommentData => {\n      const commentId = createCommentId();\n      const createdAt = new Date();\n\n      const comment: CommentData = {\n        id: commentId,\n        threadId,\n        roomId,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? [],\n      };\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-comment\",\n        comment,\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .createComment({ roomId, threadId, commentId, body, attachmentIds })\n        .then(\n          (newComment) => {\n            // Replace the optimistic update by the real thing\n            store.createComment(newComment, optimisticId);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"CREATE_COMMENT_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                body,\n              },\n              err\n            )\n        );\n\n      return comment;\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that edits a comment's body.\n *\n * @example\n * const editComment = useEditComment()\n * editComment({ threadId: \"th_xxx\", commentId: \"cm_xxx\", body: {} })\n */\nfunction useEditComment(): (options: EditCommentOptions) => void {\n  return useEditRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useEditRoomComment(\n  roomId: string\n): (options: EditCommentOptions) => void {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, body, attachments }: EditCommentOptions): void => {\n      const editedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);\n\n      if (existing === undefined) {\n        console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n\n      const comment = existing.comments.find(\n        (comment) => comment.id === commentId\n      );\n\n      if (comment === undefined || comment.deletedAt !== undefined) {\n        console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? [],\n        },\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .editComment({ roomId, threadId, commentId, body, attachmentIds })\n        .then(\n          (editedComment) => {\n            // Replace the optimistic update by the real thing\n            store.editComment(threadId, optimisticId, editedComment);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"EDIT_COMMENT_ERROR\", roomId, threadId, commentId, body },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that deletes a comment.\n * If it is the last non-deleted comment, the thread also gets deleted.\n *\n * @example\n * const deleteComment = useDeleteComment();\n * deleteComment({ threadId: \"th_xxx\", commentId: \"cm_xxx\" })\n */\nfunction useDeleteComment() {\n  return useDeleteRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useDeleteRoomComment(roomId: string) {\n  const client = useClient();\n\n  return useCallback(\n    ({ threadId, commentId }: DeleteCommentOptions): void => {\n      const deletedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId,\n      });\n\n      client[kInternal].httpClient\n        .deleteComment({ roomId, threadId, commentId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.deleteComment(threadId, optimisticId, commentId, deletedAt);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"DELETE_COMMENT_ERROR\", roomId, threadId, commentId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\nfunction useAddReaction<M extends BaseMetadata>() {\n  return useAddRoomCommentReaction<M>(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useAddRoomCommentReaction<M extends BaseMetadata>(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n      const createdAt = new Date();\n      const userId = getCurrentUserId(client);\n\n      const { store, onMutationFailure } = getRoomExtrasForClient<M>(client);\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt,\n        },\n      });\n\n      client[kInternal].httpClient\n        .addReaction({ roomId, threadId, commentId, emoji })\n        .then(\n          (addedReaction) => {\n            // Replace the optimistic update by the real thing\n            store.addReaction(\n              threadId,\n              optimisticId,\n              commentId,\n              addedReaction,\n              createdAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"ADD_REACTION_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                emoji,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that removes a reaction on a comment.\n *\n * @example\n * const removeReaction = useRemoveReaction();\n * removeReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"\" })\n */\nfunction useRemoveReaction() {\n  return useRemoveRoomCommentReaction(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useRemoveRoomCommentReaction(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n      const userId = getCurrentUserId(client);\n\n      const removedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt,\n      });\n\n      client[kInternal].httpClient\n        .removeReaction({ roomId, threadId, commentId, emoji })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.removeReaction(\n              threadId,\n              optimisticId,\n              commentId,\n              emoji,\n              userId,\n              removedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"REMOVE_REACTION_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                emoji,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n/**\n * Returns a function that marks a thread as read.\n *\n * @example\n * const markThreadAsRead = useMarkThreadAsRead();\n * markThreadAsRead(\"th_xxx\");\n */\nfunction useMarkThreadAsRead() {\n  return useMarkRoomThreadAsRead(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsRead(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.outputs.notifications.get().notificationsById\n      ).find(\n        (inboxNotification) =>\n          inboxNotification.kind === \"thread\" &&\n          inboxNotification.threadId === threadId\n      );\n\n      if (!inboxNotification) return;\n\n      const now = new Date();\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now,\n      });\n\n      client[kInternal].httpClient\n        .markRoomInboxNotificationAsRead({\n          roomId,\n          inboxNotificationId: inboxNotification.id,\n        })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.markInboxNotificationRead(\n              inboxNotification.id,\n              now,\n              optimisticId\n            );\n          },\n          (err: Error) => {\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n                roomId,\n                inboxNotificationId: inboxNotification.id,\n              },\n              err\n            );\n            return;\n          }\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that marks a thread as resolved.\n *\n * @example\n * const markThreadAsResolved = useMarkThreadAsResolved();\n * markThreadAsResolved(\"th_xxx\");\n */\nfunction useMarkThreadAsResolved() {\n  return useMarkRoomThreadAsResolved(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsResolved(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .markThreadAsResolved({ roomId, threadId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.patchThread(\n              threadId,\n              optimisticId,\n              { resolved: true },\n              updatedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"MARK_THREAD_AS_RESOLVED_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that marks a thread as unresolved.\n *\n * @example\n * const markThreadAsUnresolved = useMarkThreadAsUnresolved();\n * markThreadAsUnresolved(\"th_xxx\");\n */\nfunction useMarkThreadAsUnresolved() {\n  return useMarkRoomThreadAsUnresolved(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsUnresolved(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .markThreadAsUnresolved({ roomId, threadId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.patchThread(\n              threadId,\n              optimisticId,\n              { resolved: false },\n              updatedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"MARK_THREAD_AS_UNRESOLVED_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that subscribes the user to a thread.\n *\n * @example\n * const subscribeToThread = useSubscribeToThread();\n * subscribeToThread(\"th_xxx\");\n */\nfunction useSubscribeToThread() {\n  return useSubscribeToRoomThread(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useSubscribeToRoomThread(roomId: string) {\n  const client = useClient();\n\n  return useCallback(\n    (threadId: string) => {\n      const subscribedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"subscribe-to-thread\",\n        threadId,\n        subscribedAt,\n      });\n\n      client[kInternal].httpClient.subscribeToThread({ roomId, threadId }).then(\n        (subscription) => {\n          store.createSubscription(subscription, optimisticId);\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            { type: \"SUBSCRIBE_TO_THREAD_ERROR\", roomId, threadId },\n            err\n          )\n      );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that unsubscribes the user from a thread.\n *\n * @example\n * const unsubscribeFromThread = useUnsubscribeFromThread();\n * unsubscribeFromThread(\"th_xxx\");\n */\nfunction useUnsubscribeFromThread() {\n  return useUnsubscribeFromRoomThread(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useUnsubscribeFromRoomThread(roomId: string) {\n  const client = useClient();\n\n  return useCallback(\n    (threadId: string) => {\n      const unsubscribedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"unsubscribe-from-thread\",\n        threadId,\n        unsubscribedAt,\n      });\n\n      client[kInternal].httpClient\n        .unsubscribeFromThread({ roomId, threadId })\n        .then(\n          () => {\n            store.deleteSubscription(\n              getSubscriptionKey(\"thread\", threadId),\n              optimisticId\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"UNSUBSCRIBE_FROM_THREAD_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns the subscription status of a thread, methods to update it, and when\n * the thread was last read.\n *\n * @example\n * const { status, subscribe, unsubscribe, unreadSince } = useThreadSubscription(\"th_xxx\");\n */\nfunction useThreadSubscription(threadId: string): ThreadSubscription {\n  return useRoomThreadSubscription(useRoom().id, threadId);\n}\n\n/**\n * @private\n */\nfunction useRoomThreadSubscription(\n  roomId: string,\n  threadId: string\n): ThreadSubscription {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const subscriptionKey = useMemo(\n    () => getSubscriptionKey(\"thread\", threadId),\n    [threadId]\n  );\n  const subscribeToThread = useSubscribeToRoomThread(roomId);\n  const unsubscribeFromThread = useUnsubscribeFromRoomThread(roomId);\n  const subscribe = useCallback(\n    () => subscribeToThread(threadId),\n    [subscribeToThread, threadId]\n  );\n  const unsubscribe = useCallback(\n    () => unsubscribeFromThread(threadId),\n    [unsubscribeFromThread, threadId]\n  );\n\n  const signal = store.outputs.threadSubscriptions;\n\n  const selector = useCallback(\n    (state: SignalType<typeof signal>): ThreadSubscription => {\n      const subscription = state.subscriptions[subscriptionKey];\n      const notification = state.notifications.find(\n        (inboxNotification) =>\n          inboxNotification.kind === \"thread\" &&\n          inboxNotification.threadId === threadId\n      );\n\n      if (subscription === undefined) {\n        return { status: \"not-subscribed\", subscribe, unsubscribe };\n      }\n\n      return {\n        status: \"subscribed\",\n        unreadSince: notification?.readAt ?? null,\n        subscribe,\n        unsubscribe,\n      };\n    },\n    [subscriptionKey, threadId, subscribe, unsubscribe]\n  );\n\n  return useSignal(signal, selector, shallow);\n}\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nfunction useRoomSubscriptionSettings(): [\n  RoomSubscriptionSettingsAsyncResult,\n  (settings: Partial<RoomSubscriptionSettings>) => void,\n] {\n  const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateSubscriptionSettingsPollerForRoomId } =\n    getRoomExtrasForClient(client);\n\n  const poller = getOrCreateSubscriptionSettingsPollerForRoomId(room.id);\n\n  useEffect(\n    () =>\n      void store.outputs.roomSubscriptionSettingsByRoomId\n        .getOrCreate(room.id)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  const settings = useSignal(\n    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).signal\n  );\n\n  return useMemo(() => {\n    return [settings, updateRoomSubscriptionSettings];\n  }, [settings, updateRoomSubscriptionSettings]);\n}\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nfunction useRoomSubscriptionSettingsSuspense(): [\n  RoomSubscriptionSettingsAsyncSuccess,\n  (settings: Partial<RoomSubscriptionSettings>) => void,\n] {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n\n  // Suspend until there are at least some inbox notifications\n  use(\n    store.outputs.roomSubscriptionSettingsByRoomId\n      .getOrCreate(room.id)\n      .waitUntilLoaded()\n  );\n\n  // We're in a Suspense world here, and as such, the useRoomSubscriptionSettings()\n  // hook is expected to only return success results when we're here.\n  const [settings, updateRoomSubscriptionSettings] =\n    useRoomSubscriptionSettings();\n  assert(!settings.error, \"Did not expect error\");\n  assert(!settings.isLoading, \"Did not expect loading\");\n\n  return useMemo(() => {\n    return [settings, updateRoomSubscriptionSettings];\n  }, [settings, updateRoomSubscriptionSettings]);\n}\n\n/**\n * Returns the version data bianry for a given version\n *\n * @example\n * const {data} = useHistoryVersionData(versionId);\n */\nfunction useHistoryVersionData(\n  versionId: string\n): HistoryVersionDataAsyncResult {\n  const [state, setState] = useState<HistoryVersionDataAsyncResult>({\n    isLoading: true,\n  });\n  const room = useRoom();\n  useEffect(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data,\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error:\n            error instanceof Error\n              ? error\n              : new Error(\n                  \"An unknown error occurred while loading this version\"\n                ),\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions, error, isLoading } = useHistoryVersions();\n */\nfunction useHistoryVersions(): HistoryVersionsAsyncResult {\n  const client = useClient();\n  const room = useRoom();\n\n  const { store, getOrCreateVersionsPollerForRoomId } =\n    getRoomExtrasForClient(client);\n\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n\n  useEffect(\n    () =>\n      void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);\n}\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions } = useHistoryVersions();\n */\nfunction useHistoryVersionsSuspense(): HistoryVersionsAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n\n  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n\n  const result = useHistoryVersions();\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns a function that updates the user's subscription settings\n * for the current room.\n *\n * @example\n * const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();\n * updateRoomSubscriptionSettings({ threads: \"all\" });\n */\nfunction useUpdateRoomSubscriptionSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return useCallback(\n    (settings: Partial<RoomSubscriptionSettings>) => {\n      const { store, onMutationFailure, pollThreadsForRoomId } =\n        getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"update-room-subscription-settings\",\n        roomId: room.id,\n        userId,\n        settings,\n      });\n\n      room.updateSubscriptionSettings(settings).then(\n        (udpatedSettings) => {\n          // Replace the optimistic update by the real thing\n          store.updateRoomSubscriptionSettings(\n            room.id,\n            optimisticId,\n            udpatedSettings\n          );\n\n          // If the `threads` settings are changed, trigger a polling to update thread subscriptions\n          if (settings.threads) {\n            pollThreadsForRoomId(room.id);\n          }\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            {\n              type: \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\",\n              roomId: room.id,\n            },\n            err\n          )\n      );\n    },\n    [client, room]\n  );\n}\n\nfunction useSuspendUntilPresenceReady(): void {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\n\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta>(): User<\n  P,\n  U\n>;\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (me: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (me: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | User<P, U> {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector as (me: User<P, U>) => T,\n    isEqual as (prev: T | null, curr: T | null) => boolean\n  ) as T | User<P, U>;\n}\n\nfunction useOthersSuspense<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n>(): readonly User<P, U>[];\nfunction useOthersSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useOthersSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | readonly User<P, U>[] {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector as (others: readonly User<P, U>[]) => T,\n    isEqual as (prev: T, curr: T) => boolean\n  ) as T | readonly User<P, U>[];\n}\n\n/**\n * Returns an array of connection IDs. This matches the values you'll get by\n * using the `useOthers()` hook.\n *\n * Roughly equivalent to:\n *   useOthers((others) => others.map(other => other.connectionId), shallow)\n *\n * This is useful in particular to implement efficiently rendering components\n * for each user in the room, e.g. cursors.\n *\n * @example\n * const ids = useOthersConnectionIds();\n * // [2, 4, 7]\n */\nfunction useOthersConnectionIdsSuspense(): readonly number[] {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\n\nfunction useOthersMappedSuspense<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  T,\n>(\n  itemSelector: (other: User<P, U>) => T,\n  itemIsEqual?: (prev: T, curr: T) => boolean\n): ReadonlyArray<readonly [connectionId: number, data: T]> {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\n\nfunction useOtherSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  connectionId: number,\n  selector: (other: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\n\nfunction useSuspendUntilStorageReady(): void {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\n\nfunction useStorageSuspense<S extends LsonObject, T>(\n  selector: (root: ToImmutable<S>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual as (prev: T | null, curr: T | null) => boolean\n  ) as T;\n}\n\nfunction useThreadsSuspense<M extends BaseMetadata>(\n  options: UseThreadsOptions<M> = {}\n): ThreadsAsyncSuccess<M> {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const room = useRoom();\n\n  const { store } = getRoomExtrasForClient<M>(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n\n  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useThreads(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction selectorFor_useAttachmentUrl(\n  state: AsyncResult<string | undefined> | undefined\n): AttachmentUrlAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // For now `useAttachmentUrl` doesn't support a custom resolver so this case\n  // will never happen as `getAttachmentUrl` will either return a URL or throw.\n  // But we might decide to offer a custom resolver in the future to allow\n  // self-hosting attachments.\n  assert(state.data !== undefined, \"Unexpected missing attachment URL\");\n\n  return {\n    isLoading: false,\n    url: state.data,\n  };\n}\n\n/**\n * Returns a presigned URL for an attachment by its ID.\n *\n * @example\n * const { url, error, isLoading } = useAttachmentUrl(\"at_xxx\");\n */\nfunction useAttachmentUrl(attachmentId: string): AttachmentUrlAsyncResult {\n  const room = useRoom();\n  return useRoomAttachmentUrl(attachmentId, room.id);\n}\n\n/**\n * @private For internal use only. Do not rely on this hook. Use `useAttachmentUrl` instead.\n */\nfunction useRoomAttachmentUrl(\n  attachmentId: string,\n  roomId: string\n): AttachmentUrlAsyncResult {\n  const client = useClient();\n  const store =\n    client[kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);\n\n  const getAttachmentUrlState = useCallback(\n    () => store.getItemState(attachmentId),\n    [store, attachmentId]\n  );\n\n  useEffect(() => {\n    void store.enqueue(attachmentId);\n  }, [store, attachmentId]);\n\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    shallow\n  );\n}\n\n/**\n * Returns a presigned URL for an attachment by its ID.\n *\n * @example\n * const { url } = useAttachmentUrl(\"at_xxx\");\n */\nfunction useAttachmentUrlSuspense(attachmentId: string) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[kInternal];\n\n  const getAttachmentUrlState = useCallback(\n    () => attachmentUrlsStore.getItemState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.enqueue(attachmentId);\n  }\n\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n\n  const state = useSyncExternalStore(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: undefined,\n  } as const;\n}\n\n/**\n * @private For internal use only. Do not rely on this hook.\n */\nfunction useRoomPermissions(roomId: string) {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  return useSignal(store.permissionHints.getPermissionForRoom(roomId));\n}\n\n/**\n * @private\n *\n * This is an internal API, use `createRoomContext` instead.\n */\nexport function useRoomContextBundleOrNull(): RoomContextBundle<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  Json,\n  BaseMetadata\n> | null {\n  const client = useClientOrNull();\n  const room = useRoomOrNull<never, never, never, never, never>();\n  return client && room ? getOrCreateRoomContextBundle(client) : null;\n}\n\n/**\n * @private\n *\n * This is an internal API, use `createRoomContext` instead.\n */\nexport function useRoomContextBundle(): RoomContextBundle<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  Json,\n  BaseMetadata\n> {\n  const client = useClient();\n  return getOrCreateRoomContextBundle(client);\n}\n\n/**\n * Creates a RoomProvider and a set of typed hooks to use in your app. Note\n * that any RoomProvider created in this way does not need to be nested in\n * LiveblocksProvider, as it already has access to the client.\n */\nexport function createRoomContext<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n>(client: OpaqueClient): RoomContextBundle<P, S, U, E, M> {\n  return getOrCreateRoomContextBundle<P, S, U, E, M>(client);\n}\n\ntype TypedBundle = RoomContextBundle<DP, DS, DU, DE, DM>;\n\n/**\n * Makes a Room available in the component hierarchy below.\n * Joins the room when the component is mounted, and automatically leaves\n * the room when the component is unmounted.\n */\nconst _RoomProvider: TypedBundle[\"RoomProvider\"] = RoomProvider;\n\n/**\n * Returns a callback that lets you broadcast custom events to other users in the room\n *\n * @example\n * const broadcast = useBroadcastEvent();\n *\n * broadcast({ type: \"CUSTOM_EVENT\", data: { x: 0, y: 0 } });\n */\nconst _useBroadcastEvent: TypedBundle[\"useBroadcastEvent\"] = useBroadcastEvent;\n\n/**\n * Get informed when users enter or leave the room, as an event.\n *\n * @example\n * useOthersListener({ type, user, others }) => {\n *   if (type === 'enter') {\n *     // `user` has joined the room\n *   } else if (type === 'leave') {\n *     // `user` has left the room\n *   }\n * })\n */\nconst _useOthersListener: TypedBundle[\"useOthersListener\"] = useOthersListener;\n\n/**\n * Returns the Room of the nearest RoomProvider above in the React component\n * tree.\n */\nconst _useRoom: TypedBundle[\"useRoom\"] = useRoom;\n\n/**\n * Returns whether the hook is called within a RoomProvider context.\n *\n * @example\n * const isInsideRoom = useIsInsideRoom();\n */\nconst _useIsInsideRoom: TypedBundle[\"useIsInsideRoom\"] = useIsInsideRoom;\n\n/**\n * Returns a function that adds a reaction from a comment.\n *\n * @example\n * const addReaction = useAddReaction();\n * addReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"\" })\n */\nconst _useAddReaction: TypedBundle[\"useAddReaction\"] = useAddReaction;\n\n/**\n * Create a callback function that lets you mutate Liveblocks state.\n *\n * The first argument that gets passed into your callback will be\n * a \"mutation context\", which exposes the following:\n *\n *   - `storage` - The mutable Storage root.\n *                 You can mutate any Live structures with this, for example:\n *                 `storage.get('layers').get('layer1').set('fill', 'red')`\n *\n *   - `setMyPresence` - Call this with a new (partial) Presence value.\n *\n *   - `self` - A read-only version of the latest self, if you need it to\n *              compute the next state.\n *\n *   - `others` - A read-only version of the latest others list, if you\n *                need it to compute the next state.\n *\n * useMutation is like React's useCallback, except that the first argument\n * that gets passed into your callback will be a \"mutation context\".\n *\n * If you want get access to the immutable root somewhere in your mutation,\n * you can use `storage.ToImmutable()`.\n *\n * @example\n * const fillLayers = useMutation(\n *   ({ storage }, color: Color) => {\n *     ...\n *   },\n *   [],\n * );\n *\n * fillLayers('red');\n *\n * const deleteLayers = useMutation(\n *   ({ storage }) => {\n *     ...\n *   },\n *   [],\n * );\n *\n * deleteLayers();\n */\nconst _useMutation: TypedBundle[\"useMutation\"] = useMutation;\n\n/**\n * Returns a function that creates a thread with an initial comment, and optionally some metadata.\n *\n * @example\n * const createThread = useCreateThread();\n * createThread({ body: {}, metadata: {} });\n */\nconst _useCreateThread: TypedBundle[\"useCreateThread\"] = useCreateThread;\n\n/**\n * Returns a function that deletes a thread and its associated comments.\n * Only the thread creator can delete a thread, it will throw otherwise.\n *\n * @example\n * const deleteThread = useDeleteThread();\n * deleteThread(\"th_xxx\");\n */\nconst _useDeleteThread: TypedBundle[\"useDeleteThread\"] = useDeleteThread;\n\n/**\n * Returns a function that edits a thread's metadata.\n * To delete an existing metadata property, set its value to `null`.\n *\n * @example\n * const editThreadMetadata = useEditThreadMetadata();\n * editThreadMetadata({ threadId: \"th_xxx\", metadata: {} })\n */\nconst _useEditThreadMetadata: TypedBundle[\"useEditThreadMetadata\"] =\n  useEditThreadMetadata;\n\n/**\n * useEventListener is a React hook that allows you to respond to events broadcast\n * by other users in the room.\n *\n * The `user` argument will indicate which `User` instance sent the message.\n * This will be equal to one of the others in the room, but it can be `null`\n * in case this event was broadcasted from the server.\n *\n * @example\n * useEventListener(({ event, user, connectionId }) => {\n * //                         ^^^^ Will be Client A\n *   if (event.type === \"CUSTOM_EVENT\") {\n *     // Do something\n *   }\n * });\n */\nconst _useEventListener: TypedBundle[\"useEventListener\"] = useEventListener;\n\n/**\n * Returns the presence of the current user of the current room, and a function to update it.\n * It is different from the setState function returned by the useState hook from\n * You don't need to pass the full presence object to update it.\n *\n * @example\n * const [myPresence, updateMyPresence] = useMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, \"myPresence\" will be equal to \"{ x: 0, y: 0 }\"\n */\nconst _useMyPresence: TypedBundle[\"useMyPresence\"] = useMyPresence;\n\n/**\n * Related to useOthers(), but optimized for selecting only \"subsets\" of\n * others. This is useful for performance reasons in particular, because\n * selecting only a subset of users also means limiting the number of\n * re-renders that will be triggered.\n *\n * @example\n * const avatars = useOthersMapped(user => user.info.avatar);\n * //    ^^^^^^^\n * //    { connectionId: number; data: string }[]\n *\n * The selector function you pass to useOthersMapped() is called an \"item\n * selector\", and operates on a single user at a time. If you provide an\n * (optional) \"item comparison\" function, it will be used to compare each\n * item pairwise.\n *\n * For example, to select multiple properties:\n *\n * @example\n * const avatarsAndCursors = useOthersMapped(\n *   user => [u.info.avatar, u.presence.cursor],\n *   shallow,  // \n * );\n */\nconst _useOthersMapped: TypedBundle[\"useOthersMapped\"] = useOthersMapped;\n\n/**\n * Related to useOthers(), but optimized for selecting only \"subsets\" of\n * others. This is useful for performance reasons in particular, because\n * selecting only a subset of users also means limiting the number of\n * re-renders that will be triggered.\n *\n * @example\n * const avatars = useOthersMapped(user => user.info.avatar);\n * //    ^^^^^^^\n * //    { connectionId: number; data: string }[]\n *\n * The selector function you pass to useOthersMapped() is called an \"item\n * selector\", and operates on a single user at a time. If you provide an\n * (optional) \"item comparison\" function, it will be used to compare each\n * item pairwise.\n *\n * For example, to select multiple properties:\n *\n * @example\n * const avatarsAndCursors = useOthersMapped(\n *   user => [u.info.avatar, u.presence.cursor],\n *   shallow,  // \n * );\n */\nconst _useOthersMappedSuspense: TypedBundle[\"suspense\"][\"useOthersMapped\"] =\n  useOthersMappedSuspense;\n\n/**\n * Returns the threads within the current room.\n *\n * @example\n * const { threads, error, isLoading } = useThreads();\n */\nconst _useThreads: TypedBundle[\"useThreads\"] = useThreads;\n\n/**\n * Returns the threads within the current room.\n *\n * @example\n * const { threads } = useThreads();\n */\nconst _useThreadsSuspense: TypedBundle[\"suspense\"][\"useThreads\"] =\n  useThreadsSuspense;\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nconst _useRoomSubscriptionSettings: TypedBundle[\"useRoomSubscriptionSettings\"] =\n  useRoomSubscriptionSettings;\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nconst _useRoomSubscriptionSettingsSuspense: TypedBundle[\"suspense\"][\"useRoomSubscriptionSettings\"] =\n  useRoomSubscriptionSettingsSuspense;\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions, error, isLoading } = useHistoryVersions();\n */\nconst _useHistoryVersions: TypedBundle[\"useHistoryVersions\"] =\n  useHistoryVersions;\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions } = useHistoryVersions();\n */\nconst _useHistoryVersionsSuspense: TypedBundle[\"suspense\"][\"useHistoryVersions\"] =\n  useHistoryVersionsSuspense;\n\n/**\n * Given a connection ID (as obtained by using `useOthersConnectionIds`), you\n * can call this selector deep down in your component stack to only have the\n * component re-render if properties for this particular user change.\n *\n * @example\n * // Returns only the selected values re-renders whenever that selection changes)\n * const { x, y } = useOther(2, user => user.presence.cursor);\n */\nconst _useOther: TypedBundle[\"useOther\"] = useOther;\n\n/**\n * Returns an array with information about all the users currently connected in\n * the room (except yourself).\n *\n * @example\n * const others = useOthers();\n *\n * // Example to map all cursors in JSX\n * return (\n *   <>\n *     {others.map((user) => {\n *        if (user.presence.cursor == null) {\n *          return null;\n *        }\n *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />\n *      })}\n *   </>\n * )\n */\nfunction _useOthers(): readonly User<DP, DU>[];\n/**\n * Extract arbitrary data based on all the users currently connected in the\n * room (except yourself).\n *\n * The selector function will get re-evaluated any time a user enters or\n * leaves the room, as well as whenever their presence data changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useOthers()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);\n * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);\n * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));\n *\n */\nfunction _useOthers<T>(\n  selector: (others: readonly User<DP, DU>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useOthers(...args: any[]) {\n  return useOthers(...(args as []));\n}\n\n/**\n * Given a connection ID (as obtained by using `useOthersConnectionIds`), you\n * can call this selector deep down in your component stack to only have the\n * component re-render if properties for this particular user change.\n *\n * @example\n * // Returns only the selected values re-renders whenever that selection changes)\n * const { x, y } = useOther(2, user => user.presence.cursor);\n */\nconst _useOtherSuspense: TypedBundle[\"suspense\"][\"useOther\"] = useOtherSuspense;\n\n/**\n * Returns an array with information about all the users currently connected in\n * the room (except yourself).\n *\n * @example\n * const others = useOthers();\n *\n * // Example to map all cursors in JSX\n * return (\n *   <>\n *     {others.map((user) => {\n *        if (user.presence.cursor == null) {\n *          return null;\n *        }\n *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />\n *      })}\n *   </>\n * )\n */\nfunction _useOthersSuspense(): readonly User<DP, DU>[];\n/**\n * Extract arbitrary data based on all the users currently connected in the\n * room (except yourself).\n *\n * The selector function will get re-evaluated any time a user enters or\n * leaves the room, as well as whenever their presence data changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useOthers()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);\n * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);\n * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));\n *\n */\nfunction _useOthersSuspense<T>(\n  selector: (others: readonly User<DP, DU>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useOthersSuspense(...args: any[]) {\n  return useOthersSuspense(...(args as []));\n}\n\n/**\n * Extract arbitrary data from the Liveblocks Storage state, using an\n * arbitrary selector function.\n *\n * The selector function will get re-evaluated any time something changes in\n * Storage. The value returned by your selector function will also be the\n * value returned by the hook.\n *\n * The `root` value that gets passed to your selector function is\n * a immutable/readonly version of your Liveblocks storage root.\n *\n * The component that uses this hook will automatically re-render if the\n * returned value changes.\n *\n * By default `useStorage()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n */\nconst _useStorage: TypedBundle[\"useStorage\"] = useStorage;\n\n/**\n * Extract arbitrary data from the Liveblocks Storage state, using an\n * arbitrary selector function.\n *\n * The selector function will get re-evaluated any time something changes in\n * Storage. The value returned by your selector function will also be the\n * value returned by the hook.\n *\n * The `root` value that gets passed to your selector function is\n * a immutable/readonly version of your Liveblocks storage root.\n *\n * The component that uses this hook will automatically re-render if the\n * returned value changes.\n *\n * By default `useStorage()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n */\nconst _useStorageSuspense: TypedBundle[\"suspense\"][\"useStorage\"] =\n  useStorageSuspense;\n\n/**\n * Gets the current user once it is connected to the room.\n *\n * @example\n * const me = useSelf();\n * if (me !== null) {\n *   const { x, y } = me.presence.cursor;\n * }\n */\nfunction _useSelf(): User<DP, DU> | null;\n/**\n * Extract arbitrary data based on the current user.\n *\n * The selector function will get re-evaluated any time your presence data\n * changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useSelf()` uses strict `===` to check for equality. Take extra\n * care when returning a computed object or list, for example when you return\n * the result of a .map() or .filter() call from the selector. In those\n * cases, you'll probably want to use a `shallow` comparison check.\n *\n * Will return `null` while Liveblocks isn't connected to a room yet.\n *\n * @example\n * const cursor = useSelf(me => me.presence.cursor);\n * if (cursor !== null) {\n *   const { x, y } = cursor;\n * }\n *\n */\nfunction _useSelf<T>(\n  selector: (me: User<DP, DU>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | null;\nfunction _useSelf(...args: any[]) {\n  return useSelf(...(args as []));\n}\n\n/**\n * Gets the current user once it is connected to the room.\n *\n * @example\n * const me = useSelf();\n * const { x, y } = me.presence.cursor;\n */\nfunction _useSelfSuspense(): User<DP, DU>;\n/**\n * Extract arbitrary data based on the current user.\n *\n * The selector function will get re-evaluated any time your presence data\n * changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useSelf()` uses strict `===` to check for equality. Take extra\n * care when returning a computed object or list, for example when you return\n * the result of a .map() or .filter() call from the selector. In those\n * cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const cursor = useSelf(me => me.presence.cursor);\n * const { x, y } = cursor;\n *\n */\nfunction _useSelfSuspense<T>(\n  selector: (me: User<DP, DU>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useSelfSuspense(...args: any[]) {\n  return useSelfSuspense(...(args as []));\n}\n\n/**\n * Returns the mutable (!) Storage root. This hook exists for\n * backward-compatible reasons.\n *\n * @example\n * const [root] = useStorageRoot();\n */\nconst _useStorageRoot: TypedBundle[\"useStorageRoot\"] = useStorageRoot;\n\n/**\n * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.\n * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.\n *\n * @example\n * const updateMyPresence = useUpdateMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, the presence of the current user will be equal to \"{ x: 0, y: 0 }\"\n */\nconst _useUpdateMyPresence: TypedBundle[\"useUpdateMyPresence\"] =\n  useUpdateMyPresence;\n\nexport {\n  _RoomProvider as RoomProvider,\n  _useAddReaction as useAddReaction,\n  useAddRoomCommentReaction,\n  useAttachmentUrl,\n  useAttachmentUrlSuspense,\n  _useBroadcastEvent as useBroadcastEvent,\n  useCanRedo,\n  useCanUndo,\n  useCreateComment,\n  useCreateRoomComment,\n  useCreateRoomThread,\n  useCreateTextMention,\n  _useCreateThread as useCreateThread,\n  useDeleteComment,\n  useDeleteRoomComment,\n  useDeleteRoomThread,\n  useDeleteTextMention,\n  _useDeleteThread as useDeleteThread,\n  useEditComment,\n  useEditRoomComment,\n  useEditRoomThreadMetadata,\n  _useEditThreadMetadata as useEditThreadMetadata,\n  _useEventListener as useEventListener,\n  useHistory,\n  useHistoryVersionData,\n  _useHistoryVersions as useHistoryVersions,\n  _useHistoryVersionsSuspense as useHistoryVersionsSuspense,\n  _useIsInsideRoom as useIsInsideRoom,\n  useLostConnectionListener,\n  useMarkRoomThreadAsRead,\n  useMarkRoomThreadAsResolved,\n  useMarkRoomThreadAsUnresolved,\n  useMarkThreadAsRead,\n  useMarkThreadAsResolved,\n  useMarkThreadAsUnresolved,\n  useMentionSuggestionsCache,\n  _useMutation as useMutation,\n  _useMyPresence as useMyPresence,\n  _useOther as useOther,\n  _useOthers as useOthers,\n  useOthersConnectionIds,\n  useOthersConnectionIdsSuspense,\n  _useOthersListener as useOthersListener,\n  _useOthersMapped as useOthersMapped,\n  _useOthersMappedSuspense as useOthersMappedSuspense,\n  _useOthersSuspense as useOthersSuspense,\n  _useOtherSuspense as useOtherSuspense,\n  useRedo,\n  useRemoveReaction,\n  useRemoveRoomCommentReaction,\n  useReportTextEditor,\n  useResolveMentionSuggestions,\n  _useRoom as useRoom,\n  useRoomAttachmentUrl,\n  useRoomPermissions,\n  _useRoomSubscriptionSettings as useRoomSubscriptionSettings,\n  _useRoomSubscriptionSettingsSuspense as useRoomSubscriptionSettingsSuspense,\n  useRoomThreadSubscription,\n  _useSelf as useSelf,\n  _useSelfSuspense as useSelfSuspense,\n  useStatus,\n  _useStorage as useStorage,\n  _useStorageRoot as useStorageRoot,\n  _useStorageSuspense as useStorageSuspense,\n  useSubscribeToRoomThread,\n  useSubscribeToThread,\n  _useThreads as useThreads,\n  _useThreadsSuspense as useThreadsSuspense,\n  useThreadSubscription,\n  useUndo,\n  useUnsubscribeFromRoomThread,\n  useUnsubscribeFromThread,\n  _useUpdateMyPresence as useUpdateMyPresence,\n  useUpdateRoomSubscriptionSettings,\n  useYjsProvider,\n};\n","import type { BaseMetadata } from \"@liveblocks/client\";\nimport { useEffect } from \"react\";\n\nimport type { ThreadsAsyncResult } from \"./types\";\n\nfunction handleScrollToCommentOnLoad(\n  shouldScrollOnLoad: boolean,\n  state: ThreadsAsyncResult<BaseMetadata>\n) {\n  if (shouldScrollOnLoad === false) return;\n\n  if (!state.threads) return;\n\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n\n  // If the hash is not a comment ID, we do not scroll to it\n  if (!commentId.startsWith(\"cm_\")) return;\n\n  // If a comment with the ID does not exist in the DOM, we do not scroll to it\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment is not in the threads for this hook, we do not scroll to it\n  if (!isCommentInThreads) return;\n\n  comment.scrollIntoView();\n}\n\n/**\n * Scroll to the comment with the ID in the hash of the URL based on whether\n * the query is loading and whether the hook should scroll to the comment on load.\n */\nexport function useScrollToCommentOnLoadEffect(\n  shouldScrollOnLoad: boolean,\n  state: ThreadsAsyncResult<BaseMetadata>\n) {\n  useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n"]}