'use strict';

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');

const ErrorBoundaryContext = react.createContext(null);
class ErrorBoundary extends react.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error, errorInfo) {
    console.error(error, errorInfo);
  }
  reset() {
    this.setState({ error: null });
  }
  render() {
    if (this.state.error === null)
      return this.props.children;
    const error = this.state.error;
    const reset = this.reset.bind(this);
    const fallback = this.props.fallback;
    const Fallback = typeof fallback === "function" ? fallback : () => fallback ?? null;
    return /* @__PURE__ */ jsxRuntime.jsx(ErrorBoundaryContext.Provider, {
      value: { error, reset },
      children: /* @__PURE__ */ jsxRuntime.jsx(Fallback, {
        error: this.state.error
      })
    });
  }
}
function useErrorBoundary() {
  const context = react.useContext(ErrorBoundaryContext);
  if (context === null) {
    throw new Error(
      "useErrorBoundary must be used within an ErrorBoundary component"
    );
  }
  return context;
}

exports.ErrorBoundary = ErrorBoundary;
exports.useErrorBoundary = useErrorBoundary;
//# sourceMappingURL=ErrorBoundary.cjs.map
