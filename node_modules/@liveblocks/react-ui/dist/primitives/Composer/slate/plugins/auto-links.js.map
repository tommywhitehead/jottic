{"version":3,"file":"auto-links.js","sources":["../../../../../src/primitives/Composer/slate/plugins/auto-links.ts"],"sourcesContent":["import type { NodeEntry as SlateNodeEntry, Text as SlateText } from \"slate\";\nimport {\n  Editor as SlateEditor,\n  Element as SlateElement,\n  Node as SlateNode,\n  Path as SlatePath,\n  Range as SlateRange,\n  Transforms as SlateTransforms,\n} from \"slate\";\n\nimport type { ComposerBodyAutoLink } from \"../../../../types\";\nimport { isPlainText, isText } from \"../../../slate/utils/is-text\";\nimport { filterActiveMarks } from \"../../../slate/utils/marks\";\nimport { isComposerBodyCustomLink } from \"./custom-links\";\n\n/**\n * This implementation is inspired by Lexical's AutoLink plugin.\n * Additional modifications and features were added to adapt it to our specific needs.\n *\n * Original Lexical AutoLink plugin can be found at [Lexical's Github Repository](https://github.com/facebook/lexical/blob/main/packages/lexical-react/src/LexicalAutoLinkPlugin.ts)\n */\nexport function withAutoLinks(editor: SlateEditor): SlateEditor {\n  const { isInline, normalizeNode, deleteBackward } = editor;\n\n  editor.isInline = (element) => {\n    return element.type === \"auto-link\" ? true : isInline(element);\n  };\n\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n\n    // Prevent auto links from being created inside custom links\n    if (isComposerBodyCustomLink(node)) {\n      return;\n    }\n\n    // Prevent nested or empty auto links\n    if (SlateElement.isElement(node) && node.type === \"auto-link\") {\n      if (\n        node.children.length === 0 ||\n        (node.children.length === 1 && node.children[0]?.text === \"\")\n      ) {\n        SlateTransforms.removeNodes(editor, { at: path });\n      }\n    }\n\n    if (isText(node)) {\n      const parentNode = SlateNode.parent(editor, path);\n\n      // Prevent auto links from being created inside custom links\n      if (isComposerBodyCustomLink(parentNode)) {\n        return;\n      } else if (isComposerBodyAutoLink(parentNode)) {\n        const parentPath = SlatePath.parent(path);\n        handleLinkEdit(editor, [parentNode, parentPath]);\n\n        // Prevent rich text within auto links by removing all marks of inner text nodes\n        if (!isPlainText(node)) {\n          const marks = filterActiveMarks(node);\n\n          SlateTransforms.unsetNodes(editor, marks, { at: path });\n        }\n      } else {\n        handleLinkCreate(editor, [node, path]);\n        handleNeighbours(editor, [node, path]);\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  editor.deleteBackward = (unit) => {\n    deleteBackward(unit);\n    const { selection } = editor;\n    if (!selection) return;\n\n    if (!SlateRange.isCollapsed(selection)) return;\n\n    const [match] = SlateEditor.nodes(editor, {\n      at: selection,\n      match: isComposerBodyAutoLink,\n      mode: \"lowest\",\n    });\n\n    if (!match) return;\n\n    SlateTransforms.unwrapNodes(editor, {\n      match: isComposerBodyAutoLink,\n    });\n  };\n\n  return editor;\n}\n\nexport function isComposerBodyAutoLink(\n  node: SlateNode\n): node is ComposerBodyAutoLink {\n  return SlateElement.isElement(node) && node.type === \"auto-link\";\n}\n\n/**\n * 1. ((https?:\\/\\/(www\\.)?)|(www\\.))\n * - Matches 'http://' or 'https://' optionally followed by 'www.', or just 'www.'\n *\n * 2. [-a-zA-Z0-9@:%._+~#=]{1,256}\n * - Matches any character in the set [-a-zA-Z0-9@:%._+~#=] between 1 and 256 times, often found in the domain and subdomain part of the URL\n *\n * 3. \\.[a-zA-Z0-9()]{1,6}\n * - Matches a period followed by any character in the set [a-zA-Z0-9()] between 1 and 6 times, usually indicating the domain extension like .com, .org, etc.\n *\n * 4. \\b\n * - Represents a word boundary, ensuring that the characters following cannot be part of a different word\n *\n * 5. ([-a-zA-Z0-9().@:%_+~#?&//=]*)\n * - Matches any character in the set [-a-zA-Z0-9().@:%_+~#?&//=] between 0 and unlimited times, often found in the path, query parameters, or anchor part of the URL\n *\n * Matching URLs:\n * - http://www.example.com\n * - https://www.example.com\n * - www.example.com\n * - https://example.com/path?query=param#anchor\n *\n * Non-Matching URLs:\n * - http:/example.com (malformed scheme)\n * - example (missing scheme and domain extension)\n * - ftp://example.com (ftp scheme is not supported)\n * - example.com (missing scheme)\n */\nconst URL_REGEX =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9().@:%_+~#?&//=]*)/;\n\nconst PUNCTUATION_OR_SPACE = /[.,;!?\\s()]/;\n\nconst PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC = /^[.?][a-zA-Z0-9]+/;\n\nconst PARENTHESES = /[()]/;\n\n/**\n * Helper function to check if a character is a separator (punctuation or space)\n * @param char The character to check\n * @returns Whether the character is a separator or not\n */\nfunction isSeparator(char: string): boolean {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\n\n/**\n * Helper function to check if a text content ends with a separator (punctuation or space)\n * @param textContent The text content to check\n * @returns Whether the text content ends with a separator or not\n */\nfunction endsWithSeparator(textContent: string): boolean {\n  const lastCharacter = textContent[textContent.length - 1];\n\n  return lastCharacter !== undefined ? isSeparator(lastCharacter) : false;\n}\n\n/**\n * Helper function to check if a text content starts with a separator (punctuation or space)\n * @param textContent The text content to check\n * @returns Whether the text content starts with a separator or not\n */\nfunction startsWithSeparator(textContent: string): boolean {\n  const firstCharacter = textContent[0];\n\n  return firstCharacter !== undefined ? isSeparator(firstCharacter) : false;\n}\n\n/**\n * Helper function to check if a text content ends with a period or question mark\n * @param textContent The text content to check\n * @returns Whether the text content ends with a period or not\n */\nfunction endsWithPeriodOrQuestionMark(textContent: string): boolean {\n  return (\n    textContent[textContent.length - 1] === \".\" ||\n    textContent[textContent.length - 1] === \"?\"\n  );\n}\n\n/**\n * Helper function to get the \"logical length\" of a URL, taking into account things like opening/closing parentheses\n * @param url The URL to check\n * @returns The \"logical length\" of the URL\n */\nfunction getUrlLogicalLength(url: string): number {\n  if (!PARENTHESES.test(url)) {\n    return url.length;\n  }\n\n  let logicalLength = 0;\n  let parenthesesCount = 0;\n\n  for (const character of url) {\n    if (character === \"(\") {\n      parenthesesCount++;\n    }\n\n    if (character === \")\") {\n      parenthesesCount--;\n\n      if (parenthesesCount < 0) {\n        break;\n      }\n    }\n\n    logicalLength++;\n  }\n\n  return logicalLength;\n}\n\n/**\n * Helper function to check if the previous node is valid (text node that ends with a separator or is empty)\n */\nfunction isPreviousNodeValid(editor: SlateEditor, path: SlatePath): boolean {\n  const entry = SlateEditor.previous(editor, { at: path });\n  if (!entry) return true;\n\n  return (\n    isText(entry[0]) &&\n    (endsWithSeparator(entry[0].text) || entry[0].text === \"\")\n  );\n}\n\n/**\n * Helper function to check if the next node is valid (text node that starts with a separator or is empty)\n */\nfunction isNextNodeValid(editor: SlateEditor, path: SlatePath): boolean {\n  const entry = SlateEditor.next(editor, { at: path });\n  if (!entry) return true;\n\n  return (\n    isText(entry[0]) &&\n    (startsWithSeparator(entry[0].text) || entry[0].text === \"\")\n  );\n}\n\n/**\n * Helper function to check if the content around a text node is valid.\n * @param editor\n * @param entry\n * @param start\n * @param end\n * @returns\n */\nfunction isContentAroundValid(\n  editor: SlateEditor,\n  entry: SlateNodeEntry<SlateText>,\n  start: number,\n  end: number\n): boolean {\n  const [node, path] = entry;\n  const text = node.text;\n\n  const contentBefore = text[start - 1];\n  const contentBeforeIsValid =\n    start > 0 && contentBefore\n      ? isSeparator(contentBefore)\n      : isPreviousNodeValid(editor, path);\n\n  const contentAfter = text[end];\n  const contentAfterIsValid =\n    end < text.length && contentAfter\n      ? isSeparator(contentAfter)\n      : isNextNodeValid(editor, path);\n\n  return contentBeforeIsValid && contentAfterIsValid;\n}\n\nconst handleLinkEdit = (\n  editor: SlateEditor,\n  entry: SlateNodeEntry<ComposerBodyAutoLink>\n) => {\n  const [node, path] = entry;\n\n  // Step 1: Ensure that the Link node only contains text nodes as children\n  const children = SlateNode.children(editor, path);\n  for (const [child] of children) {\n    if (isText(child)) continue;\n    SlateTransforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n  // Attempt to match the text content (of the Link node) against the URL regex\n  const text = SlateNode.string(node);\n  const match = URL_REGEX.exec(text);\n  const matchContent = match?.[0];\n\n  // Step 2: Ensure that the text content of the Link node matches the URL regex and is identical to the match\n  if (!match || matchContent !== text) {\n    SlateTransforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n\n  // Step 3: Ensure that if the text content of the Link node ends with a period, we unwrap the Link node and wrap the text before the period in a new Link node\n  if (endsWithPeriodOrQuestionMark(text)) {\n    SlateTransforms.unwrapNodes(editor, { at: path });\n\n    const textBeforePeriod = text.slice(0, text.length - 1);\n\n    // Remove the last character from the link text and wrap the remaining text in a new link node\n    SlateTransforms.wrapNodes<ComposerBodyAutoLink>(\n      editor,\n      {\n        type: \"auto-link\",\n        url: textBeforePeriod,\n        children: [],\n      },\n      {\n        at: {\n          anchor: { path, offset: 0 },\n          focus: { path, offset: textBeforePeriod.length },\n        },\n        split: true,\n      }\n    );\n    return;\n  }\n\n  // Step 4: Allow some conditions to shorten the URL (e.g. supporting parentheses but only if they are balanced)\n  const logicalLength = getUrlLogicalLength(text);\n\n  if (logicalLength < text.length) {\n    SlateTransforms.unwrapNodes(editor, { at: path });\n\n    const logicalText = text.slice(0, logicalLength);\n\n    // Keep the \"logical\" text and wrap it in a new link node\n    SlateTransforms.wrapNodes<ComposerBodyAutoLink>(\n      editor,\n      {\n        type: \"auto-link\",\n        url: logicalText,\n        children: [],\n      },\n      {\n        at: {\n          anchor: { path, offset: 0 },\n          focus: { path, offset: logicalText.length },\n        },\n        split: true,\n      }\n    );\n    return;\n  }\n\n  // Step 5: Ensure that the text content of the Link node is surrounded by separators or the start/end of the text content\n  if (!isPreviousNodeValid(editor, path) || !isNextNodeValid(editor, path)) {\n    SlateTransforms.unwrapNodes(editor, { at: path });\n    return;\n  }\n\n  // Step 6: Ensure that the url attribute of the Link node is identical to its text content\n  if (node.url !== text) {\n    SlateTransforms.setNodes(editor, { url: matchContent }, { at: path });\n    return;\n  }\n};\n\nconst handleLinkCreate = (\n  editor: SlateEditor,\n  entry: SlateNodeEntry<SlateText>\n) => {\n  const [node, path] = entry;\n\n  // Step 1: Ensure that the text content of the node matches the URL regex\n  const match = URL_REGEX.exec(node.text);\n  const matchContent = match?.[0];\n\n  if (!match || matchContent === undefined) {\n    return;\n  }\n\n  const start = match.index;\n  const end = start + matchContent.length;\n\n  // Step 2: Ensure that the content around the node is valid\n  if (!isContentAroundValid(editor, entry, start, end)) return;\n\n  SlateTransforms.wrapNodes<ComposerBodyAutoLink>(\n    editor,\n    {\n      type: \"auto-link\",\n      url: matchContent,\n      children: [],\n    },\n    {\n      at: {\n        anchor: { path, offset: start },\n        focus: { path, offset: end },\n      },\n      split: true,\n    }\n  );\n  return;\n};\n\nconst handleNeighbours = (\n  editor: SlateEditor,\n  entry: SlateNodeEntry<SlateText>\n) => {\n  const [node, path] = entry;\n  const text = node.text;\n\n  const previousSibling = SlateEditor.previous(editor, { at: path });\n\n  if (previousSibling && isComposerBodyAutoLink(previousSibling[0])) {\n    if (PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC.test(text)) {\n      SlateTransforms.unwrapNodes(editor, { at: previousSibling[1] });\n      SlateTransforms.mergeNodes(editor, { at: path });\n      return;\n    }\n\n    if (!startsWithSeparator(text)) {\n      SlateTransforms.unwrapNodes(editor, { at: previousSibling[1] });\n      return;\n    }\n  }\n\n  const nextSibling = SlateEditor.next(editor, { at: path });\n  if (\n    nextSibling &&\n    isComposerBodyAutoLink(nextSibling[0]) &&\n    !endsWithSeparator(text)\n  ) {\n    SlateTransforms.unwrapNodes(editor, { at: nextSibling[1] });\n    return;\n  }\n};\n"],"names":["SlateElement","SlateTransforms","SlateNode","SlatePath","SlateRange","SlateEditor"],"mappings":"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"}