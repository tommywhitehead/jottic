import { jsx } from 'react/jsx-runtime';
import { kInternal } from '@liveblocks/core';
import { useClient } from '@liveblocks/react';
import { useSignal } from '@liveblocks/react/_private';
import { useCallback, useMemo } from 'react';
import { AiToolInvocationContext } from './contexts.js';

function StableRenderFn(props) {
  return props.renderFn(props.props);
}
function AiMessageToolInvocation({
  message,
  part
}) {
  const client = useClient();
  const ai = client[kInternal].ai;
  const tool = useSignal(ai.signals.getTool\u03A3(part.name, message.chatId));
  const respond = useCallback(
    (result) => {
      if (message.status !== "awaiting-tool") {
      } else if (part.stage === "receiving") {
      } else if (part.stage === "executed") {
        console.log(
          `Ignoring respond(): tool '${part.name}' (${part.invocationId}) has already executed`
        );
      } else {
        ai.setToolResult(
          message.chatId,
          message.id,
          part.invocationId,
          result ?? { data: {} },
          { copilotId: message.copilotId }
        );
      }
    },
    [
      ai,
      message.chatId,
      message.id,
      message.status,
      part.invocationId,
      part.name,
      part.stage,
      message.copilotId
    ]
  );
  const partialArgs = part?.partialArgs;
  const props = useMemo(() => {
    partialArgs;
    const { type: _, ...rest } = part;
    return {
      ...rest,
      respond,
      types: void 0,
      [kInternal]: {
        execute: tool?.execute,
        messageStatus: message.status
      }
    };
  }, [part, respond, tool?.execute, message.status, partialArgs]);
  if (tool?.render === void 0)
    return null;
  return /* @__PURE__ */ jsx(AiToolInvocationContext.Provider, {
    value: props,
    children: /* @__PURE__ */ jsx(StableRenderFn, {
      renderFn: tool.render,
      props
    })
  });
}

export { AiMessageToolInvocation };
//# sourceMappingURL=tool-invocation.js.map
