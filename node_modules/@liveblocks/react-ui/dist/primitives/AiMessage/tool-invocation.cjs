'use strict';

var jsxRuntime = require('react/jsx-runtime');
var core = require('@liveblocks/core');
var react = require('@liveblocks/react');
var _private = require('@liveblocks/react/_private');
var react$1 = require('react');
var contexts = require('./contexts.cjs');

function StableRenderFn(props) {
  return props.renderFn(props.props);
}
function AiMessageToolInvocation({
  message,
  part
}) {
  const client = react.useClient();
  const ai = client[core.kInternal].ai;
  const tool = _private.useSignal(ai.signals.getTool\u03A3(part.name, message.chatId));
  const respond = react$1.useCallback(
    (result) => {
      if (message.status !== "awaiting-tool") {
      } else if (part.stage === "receiving") {
      } else if (part.stage === "executed") {
        console.log(
          `Ignoring respond(): tool '${part.name}' (${part.invocationId}) has already executed`
        );
      } else {
        ai.setToolResult(
          message.chatId,
          message.id,
          part.invocationId,
          result ?? { data: {} },
          { copilotId: message.copilotId }
        );
      }
    },
    [
      ai,
      message.chatId,
      message.id,
      message.status,
      part.invocationId,
      part.name,
      part.stage,
      message.copilotId
    ]
  );
  const partialArgs = part?.partialArgs;
  const props = react$1.useMemo(() => {
    partialArgs;
    const { type: _, ...rest } = part;
    return {
      ...rest,
      respond,
      types: void 0,
      [core.kInternal]: {
        execute: tool?.execute,
        messageStatus: message.status
      }
    };
  }, [part, respond, tool?.execute, message.status, partialArgs]);
  if (tool?.render === void 0)
    return null;
  return /* @__PURE__ */ jsxRuntime.jsx(contexts.AiToolInvocationContext.Provider, {
    value: props,
    children: /* @__PURE__ */ jsxRuntime.jsx(StableRenderFn, {
      renderFn: tool.render,
      props
    })
  });
}

exports.AiMessageToolInvocation = AiMessageToolInvocation;
//# sourceMappingURL=tool-invocation.cjs.map
