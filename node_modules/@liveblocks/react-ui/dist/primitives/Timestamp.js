"use client";
import { jsx } from 'react/jsx-runtime';
import { Slot } from '@radix-ui/react-slot';
import { forwardRef, useMemo } from 'react';
import { capitalize } from '../utils/capitalize.js';
import { dateTimeFormat, relativeTimeFormat } from '../utils/intl.js';
import { useInterval } from '../utils/use-interval.js';
import { useRerender } from '../utils/use-rerender.js';


const DYNAMIC_DATE_THRESHOLD = 3 * 24 * 60 * 60 * 1e3;
const RENDER_INTERVAL = 30 * 1e3;
const TIMESTAMP_NAME = "Timestamp";
const relativeUnits = {
  seconds: 60,
  minutes: 60,
  hours: 24,
  days: 7,
  weeks: 4.34524,
  months: 12
};
function formatVerboseDate(date, locale) {
  const formatter = dateTimeFormat(locale, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric"
  });
  return capitalize(formatter.format(date));
}
function formatShortDate(date, locale) {
  const formatter = dateTimeFormat(locale, {
    month: "short",
    day: "numeric"
  });
  return capitalize(formatter.format(date));
}
const localesWithBrokenNarrowRelativeFormatting = [
  "br",
  "fr",
  "nb",
  "nn",
  "no",
  "ro",
  "sv"
];
function formatRelativeDate(date, locale) {
  let resolvedLocale;
  if (locale) {
    resolvedLocale = locale;
  } else {
    const formatter2 = relativeTimeFormat();
    resolvedLocale = formatter2.resolvedOptions().locale;
  }
  const isBrokenWhenNarrow = localesWithBrokenNarrowRelativeFormatting.some(
    (locale2) => resolvedLocale === locale2 || resolvedLocale.startsWith(`${locale2}-`)
  );
  const formatter = relativeTimeFormat(resolvedLocale, {
    style: isBrokenWhenNarrow ? "short" : "narrow",
    numeric: "auto"
  });
  let difference = (date.getTime() - Date.now()) / 1e3;
  if (difference > -relativeUnits.seconds && difference < relativeUnits.seconds) {
    return formatter.format(0, "seconds");
  }
  for (const [unit, length] of Object.entries(relativeUnits)) {
    if (Math.abs(difference) < length) {
      return formatter.format(
        Math.round(difference),
        unit
      );
    }
    difference /= length;
  }
  return capitalize(formatter.format(Math.round(difference), "years"));
}
function formatDynamicDate(date, locale) {
  return Math.abs(date.getTime() - Date.now()) <= DYNAMIC_DATE_THRESHOLD ? formatRelativeDate(date, locale) : formatShortDate(date, locale);
}
const Timestamp = forwardRef(
  ({
    date,
    locale,
    children: renderChildren = formatDynamicDate,
    title: renderTitle = formatVerboseDate,
    dateTime,
    interval = RENDER_INTERVAL,
    asChild,
    ...props
  }, forwardedRef) => {
    const Component = asChild ? Slot : "time";
    const [rerender, key] = useRerender();
    const parsedDate = useMemo(() => new Date(date), [date]);
    const normalizedDate = useMemo(
      () => parsedDate.toISOString(),
      [parsedDate]
    );
    const title = useMemo(
      () => typeof renderTitle === "function" ? renderTitle(parsedDate, locale) : renderTitle,
      [renderTitle, parsedDate, locale, key]
    );
    const children = useMemo(
      () => typeof renderChildren === "function" ? renderChildren(parsedDate, locale) : renderChildren,
      [renderChildren, parsedDate, locale, key]
    );
    useInterval(rerender, interval);
    return /* @__PURE__ */ jsx(Component, {
      ...props,
      ref: forwardedRef,
      dateTime: dateTime ?? normalizedDate,
      title,
      children
    });
  }
);
if (process.env.NODE_ENV !== "production") {
  Timestamp.displayName = TIMESTAMP_NAME;
}

export { Timestamp, formatRelativeDate };
//# sourceMappingURL=Timestamp.js.map
