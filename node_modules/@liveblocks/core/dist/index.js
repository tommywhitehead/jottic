var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/version.ts
var PKG_NAME = "@liveblocks/core";
var PKG_VERSION = "3.7.1";
var PKG_FORMAT = "esm";

// src/dupe-detection.ts
var g = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var crossLinkedDocs = "https://liveblocks.io/docs/errors/cross-linked";
var dupesDocs = "https://liveblocks.io/docs/errors/dupes";
var SPACE = " ";
function error(msg) {
  if (process.env.NODE_ENV === "production") {
    console.error(msg);
  } else {
    throw new Error(msg);
  }
}
function detectDupes(pkgName, pkgVersion, pkgFormat) {
  const pkgId = Symbol.for(pkgName);
  const pkgBuildInfo = pkgFormat ? `${pkgVersion || "dev"} (${pkgFormat})` : pkgVersion || "dev";
  if (!g[pkgId]) {
    g[pkgId] = pkgBuildInfo;
  } else if (g[pkgId] === pkgBuildInfo) {
  } else {
    const msg = [
      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,
      "",
      "Conflicts:",
      `- ${pkgName} ${g[pkgId]} (already loaded)`,
      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`
    ].join("\n");
    error(msg);
  }
  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {
    error(
      [
        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,
        "",
        "Conflicts:",
        `- ${PKG_NAME} is at ${PKG_VERSION}`,
        `- ${pkgName} is at ${pkgVersion}`,
        "",
        "Always upgrade all Liveblocks packages to the same version number."
      ].join("\n")
    );
  }
}

// src/lib/EventSource.ts
function makeEventSource() {
  const _observers = /* @__PURE__ */ new Set();
  function subscribe(callback) {
    _observers.add(callback);
    return () => _observers.delete(callback);
  }
  function subscribeOnce(callback) {
    const unsub = subscribe((event) => {
      unsub();
      return callback(event);
    });
    return unsub;
  }
  async function waitUntil(predicate) {
    let unsub;
    return new Promise((res) => {
      unsub = subscribe((event) => {
        if (predicate === void 0 || predicate(event)) {
          res(event);
        }
      });
    }).finally(() => unsub?.());
  }
  function notify(event) {
    let called = false;
    for (const callback of _observers) {
      callback(event);
      called = true;
    }
    return called;
  }
  function count() {
    return _observers.size;
  }
  return {
    // Private/internal control over event emission
    notify,
    subscribe,
    subscribeOnce,
    count,
    waitUntil,
    dispose() {
      _observers.clear();
    },
    // Publicly exposable subscription API
    observable: {
      subscribe,
      subscribeOnce,
      waitUntil
    }
  };
}
function makeBufferableEventSource() {
  const eventSource2 = makeEventSource();
  let _buffer = null;
  function pause() {
    _buffer = [];
  }
  function unpause() {
    if (_buffer === null) {
      return;
    }
    for (const event of _buffer) {
      eventSource2.notify(event);
    }
    _buffer = null;
  }
  function notifyOrBuffer(event) {
    if (_buffer !== null) {
      _buffer.push(event);
      return false;
    } else {
      return eventSource2.notify(event);
    }
  }
  return {
    ...eventSource2,
    notify: notifyOrBuffer,
    pause,
    unpause,
    dispose() {
      eventSource2.dispose();
      if (_buffer !== null) {
        _buffer.length = 0;
      }
    }
  };
}

// src/lib/freeze.ts
var freeze = process.env.NODE_ENV === "production" ? (
  /* istanbul ignore next */
  (x) => x
) : Object.freeze;

// src/lib/utils.ts
function raise(msg) {
  throw new Error(msg);
}
function entries(obj) {
  return Object.entries(obj);
}
function keys(obj) {
  return Object.keys(obj);
}
function values(obj) {
  return Object.values(obj);
}
function create(obj, descriptors) {
  if (typeof descriptors !== "undefined") {
    return Object.create(obj, descriptors);
  }
  return Object.create(obj);
}
function mapValues(obj, mapFn) {
  const result = {};
  for (const pair of Object.entries(obj)) {
    const key = pair[0];
    if (key === "__proto__") {
      continue;
    }
    const value = pair[1];
    result[key] = mapFn(value, key);
  }
  return result;
}
function tryParseJson(rawMessage) {
  try {
    return JSON.parse(rawMessage);
  } catch (e) {
    return void 0;
  }
}
function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}
function b64decode(b64value) {
  try {
    const formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
    const decodedValue = decodeURIComponent(
      atob(formattedValue).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join("")
    );
    return decodedValue;
  } catch (err) {
    return atob(b64value);
  }
}
function compact(items) {
  return items.filter(
    (item) => item !== null && item !== void 0
  );
}
function compactObject(obj) {
  const newObj = { ...obj };
  Object.keys(obj).forEach((k) => {
    const key = k;
    if (newObj[key] === void 0) {
      delete newObj[key];
    }
  });
  return newObj;
}
function wait(millis) {
  return new Promise((res) => setTimeout(res, millis));
}
async function withTimeout(promise, millis, errmsg) {
  let timerID;
  const timer$ = new Promise((_, reject) => {
    timerID = setTimeout(() => {
      reject(new Error(errmsg));
    }, millis);
  });
  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));
}
function memoizeOnSuccess(factoryFn) {
  let cached = null;
  return () => {
    if (cached === null) {
      cached = factoryFn().catch((err) => {
        setTimeout(() => {
          cached = null;
        }, 5e3);
        throw err;
      });
    }
    return cached;
  };
}
function findLastIndex(arr, predicate) {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (predicate(arr[i], i, arr)) {
      return i;
    }
  }
  return -1;
}

// src/lib/signals.ts
var kSinks = Symbol("kSinks");
var kTrigger = Symbol("kTrigger");
var signalsToTrigger = null;
var trackedReads = null;
function batch(callback) {
  if (signalsToTrigger !== null) {
    callback();
    return;
  }
  signalsToTrigger = /* @__PURE__ */ new Set();
  try {
    callback();
  } finally {
    for (const signal of signalsToTrigger) {
      signal[kTrigger]();
    }
    signalsToTrigger = null;
  }
}
function enqueueTrigger(signal) {
  if (!signalsToTrigger) raise("Expected to be in an active batch");
  signalsToTrigger.add(signal);
}
function merge(target, patch) {
  let updated = false;
  const newValue = { ...target };
  Object.keys(patch).forEach((k) => {
    const key = k;
    const val = patch[key];
    if (newValue[key] !== val) {
      if (val === void 0) {
        delete newValue[key];
      } else {
        newValue[key] = val;
      }
      updated = true;
    }
  });
  return updated ? newValue : target;
}
var AbstractSignal = class {
  /** @internal */
  equals;
  #eventSource;
  /** @internal */
  [kSinks];
  constructor(equals) {
    this.equals = equals ?? Object.is;
    this.#eventSource = makeEventSource();
    this[kSinks] = /* @__PURE__ */ new Set();
    this.get = this.get.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.subscribeOnce = this.subscribeOnce.bind(this);
  }
  dispose() {
    this.#eventSource.dispose();
    this.#eventSource = "(disposed)";
    this.equals = "(disposed)";
  }
  get hasWatchers() {
    if (this.#eventSource.count() > 0) return true;
    for (const sink of this[kSinks]) {
      if (sink.hasWatchers) {
        return true;
      }
    }
    return false;
  }
  [kTrigger]() {
    this.#eventSource.notify();
    for (const sink of this[kSinks]) {
      enqueueTrigger(sink);
    }
  }
  subscribe(callback) {
    if (this.#eventSource.count() === 0) {
      this.get();
    }
    return this.#eventSource.subscribe(callback);
  }
  subscribeOnce(callback) {
    const unsub = this.subscribe(() => {
      unsub();
      return callback();
    });
    return unsub;
  }
  waitUntil() {
    throw new Error("waitUntil not supported on Signals");
  }
  markSinksDirty() {
    for (const sink of this[kSinks]) {
      sink.markDirty();
    }
  }
  addSink(sink) {
    this[kSinks].add(sink);
  }
  removeSink(sink) {
    this[kSinks].delete(sink);
  }
  asReadonly() {
    return this;
  }
};
var Signal = class extends AbstractSignal {
  #value;
  constructor(value, equals) {
    super(equals);
    this.#value = freeze(value);
  }
  dispose() {
    super.dispose();
    this.#value = "(disposed)";
  }
  get() {
    trackedReads?.add(this);
    return this.#value;
  }
  set(newValue) {
    batch(() => {
      if (typeof newValue === "function") {
        newValue = newValue(this.#value);
      }
      if (!this.equals(this.#value, newValue)) {
        this.#value = freeze(newValue);
        this.markSinksDirty();
        enqueueTrigger(this);
      }
    });
  }
};
var PatchableSignal = class extends Signal {
  constructor(data) {
    super(freeze(compactObject(data)));
  }
  set() {
    throw new Error("Don't call .set() directly, use .patch()");
  }
  /**
   * Patches the current object.
   */
  patch(patch) {
    super.set((old) => merge(old, patch));
  }
};
var INITIAL = Symbol();
var DerivedSignal = class _DerivedSignal extends AbstractSignal {
  #prevValue;
  #dirty;
  // When true, the value in #value may not be up-to-date and needs re-checking
  #sources;
  #deps;
  #transform;
  // prettier-ignore
  static from(...args) {
    const last = args.pop();
    if (typeof last !== "function")
      raise("Invalid .from() call, last argument expected to be a function");
    if (typeof args[args.length - 1] === "function") {
      const equals = last;
      const transform = args.pop();
      return new _DerivedSignal(args, transform, equals);
    } else {
      const transform = last;
      return new _DerivedSignal(args, transform);
    }
  }
  constructor(deps, transform, equals) {
    super(equals);
    this.#dirty = true;
    this.#prevValue = INITIAL;
    this.#deps = deps;
    this.#sources = /* @__PURE__ */ new Set();
    this.#transform = transform;
  }
  dispose() {
    for (const src of this.#sources) {
      src.removeSink(this);
    }
    this.#prevValue = "(disposed)";
    this.#sources = "(disposed)";
    this.#deps = "(disposed)";
    this.#transform = "(disposed)";
  }
  get isDirty() {
    return this.#dirty;
  }
  #recompute() {
    const oldTrackedReads = trackedReads;
    let derived;
    trackedReads = /* @__PURE__ */ new Set();
    try {
      derived = this.#transform(...this.#deps.map((p) => p.get()));
    } finally {
      const oldSources = this.#sources;
      this.#sources = /* @__PURE__ */ new Set();
      for (const sig of trackedReads) {
        this.#sources.add(sig);
        oldSources.delete(sig);
      }
      for (const oldSource of oldSources) {
        oldSource.removeSink(this);
      }
      for (const newSource of this.#sources) {
        newSource.addSink(this);
      }
      trackedReads = oldTrackedReads;
    }
    this.#dirty = false;
    if (!this.equals(this.#prevValue, derived)) {
      this.#prevValue = derived;
      return true;
    }
    return false;
  }
  markDirty() {
    if (!this.#dirty) {
      this.#dirty = true;
      this.markSinksDirty();
    }
  }
  get() {
    if (this.#dirty) {
      this.#recompute();
    }
    trackedReads?.add(this);
    return this.#prevValue;
  }
  /**
   * Called by the Signal system if one or more of the dependent signals have
   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate
   * the actual value if it's being watched, or any of their sinks are being
   * watched actively.
   */
  [kTrigger]() {
    if (!this.hasWatchers) {
      return;
    }
    const updated = this.#recompute();
    if (updated) {
      super[kTrigger]();
    }
  }
};
var MutableSignal = class extends AbstractSignal {
  #state;
  constructor(initialState) {
    super();
    this.#state = initialState;
  }
  dispose() {
    super.dispose();
    this.#state = "(disposed)";
  }
  get() {
    trackedReads?.add(this);
    return this.#state;
  }
  /**
   * Invokes a callback function that is allowed to mutate the given state
   * value. Do not change the value outside of the callback.
   *
   * If the callback explicitly returns `false`, it's assumed that the state
   * was not changed.
   */
  mutate(callback) {
    batch(() => {
      const result = callback ? callback(this.#state) : true;
      if (result !== null && typeof result === "object" && "then" in result) {
        raise("MutableSignal.mutate() does not support async callbacks");
      }
      if (result !== false) {
        this.markSinksDirty();
        enqueueTrigger(this);
      }
    });
  }
};

// src/lib/SortedList.ts
function bisectRight(arr, x, lt) {
  let lo = 0;
  let hi = arr.length;
  while (lo < hi) {
    const mid = lo + (hi - lo >> 1);
    if (lt(x, arr[mid])) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return lo;
}
var SortedList = class _SortedList {
  #data;
  #lt;
  constructor(alreadySortedList, lt) {
    this.#lt = lt;
    this.#data = alreadySortedList;
  }
  static with(lt) {
    return _SortedList.fromAlreadySorted([], lt);
  }
  static from(arr, lt) {
    const sorted = new _SortedList([], lt);
    for (const item of arr) {
      sorted.add(item);
    }
    return sorted;
  }
  static fromAlreadySorted(alreadySorted, lt) {
    return new _SortedList(alreadySorted, lt);
  }
  /**
   * Clones the sorted list to a new instance.
   */
  clone() {
    return new _SortedList(this.#data.slice(), this.#lt);
  }
  /**
   * Adds a new item to the sorted list, such that it remains sorted.
   */
  add(value) {
    const idx = bisectRight(this.#data, value, this.#lt);
    this.#data.splice(idx, 0, value);
  }
  /**
   * Removes all values from the sorted list, making it empty again.
   * Returns whether the list was mutated or not.
   */
  clear() {
    const hadData = this.#data.length > 0;
    this.#data.length = 0;
    return hadData;
  }
  /**
   * Removes the first value matching the predicate.
   * Returns whether the list was mutated or not.
   */
  removeBy(predicate, limit = Number.POSITIVE_INFINITY) {
    let deleted = 0;
    for (let i = 0; i < this.#data.length; i++) {
      if (predicate(this.#data[i])) {
        this.#data.splice(i, 1);
        deleted++;
        if (deleted >= limit) {
          break;
        } else {
          i--;
        }
      }
    }
    return deleted > 0;
  }
  /**
   * Removes the given value from the sorted list, if it exists. The given
   * value must be `===` to one of the list items. Only the first entry will be
   * removed if the element exists in the sorted list multiple times.
   *
   * Returns whether the list was mutated or not.
   */
  remove(value) {
    const idx = this.#data.indexOf(value);
    if (idx >= 0) {
      this.#data.splice(idx, 1);
      return true;
    }
    return false;
  }
  at(index) {
    return this.#data[index];
  }
  get length() {
    return this.#data.length;
  }
  *filter(predicate) {
    for (const item of this.#data) {
      if (predicate(item)) {
        yield item;
      }
    }
  }
  // XXXX If we keep this, add unit tests. Or remove it.
  *findAllRight(predicate) {
    for (let i = this.#data.length - 1; i >= 0; i--) {
      const item = this.#data[i];
      if (predicate(item, i)) {
        yield item;
      }
    }
  }
  [Symbol.iterator]() {
    return this.#data[Symbol.iterator]();
  }
  *iterReversed() {
    for (let i = this.#data.length - 1; i >= 0; i--) {
      yield this.#data[i];
    }
  }
  /** Finds the leftmost item that matches the predicate. */
  find(predicate, start) {
    const idx = this.findIndex(predicate, start);
    return idx > -1 ? this.#data.at(idx) : void 0;
  }
  /** Finds the leftmost index that matches the predicate. */
  findIndex(predicate, start = 0) {
    for (let i = Math.max(0, start); i < this.#data.length; i++) {
      if (predicate(this.#data[i], i)) {
        return i;
      }
    }
    return -1;
  }
  /** Finds the rightmost item that matches the predicate. */
  findRight(predicate, start) {
    const idx = this.findIndexRight(predicate, start);
    return idx > -1 ? this.#data.at(idx) : void 0;
  }
  /** Finds the rightmost index that matches the predicate. */
  findIndexRight(predicate, start = this.#data.length - 1) {
    for (let i = Math.min(start, this.#data.length - 1); i >= 0; i--) {
      if (predicate(this.#data[i], i)) {
        return i;
      }
    }
    return -1;
  }
  get rawArray() {
    return this.#data;
  }
};

// src/AiChatDB.ts
var AiChatDB = class {
  #byId;
  // A map of chat id to chat details
  #chats;
  // Sorted list of non-deleted chats, most recent first
  signal;
  constructor() {
    this.#byId = /* @__PURE__ */ new Map();
    this.#chats = SortedList.from([], (c1, c2) => {
      const d2 = c2.lastMessageAt ?? c2.createdAt;
      const d1 = c1.lastMessageAt ?? c1.createdAt;
      return d2 < d1 ? true : d2 === d1 ? c2.id < c1.id : false;
    });
    this.signal = new MutableSignal(this);
  }
  getEvenIfDeleted(chatId) {
    return this.#byId.get(chatId);
  }
  markDeleted(chatId) {
    const chat = this.#byId.get(chatId);
    if (chat === void 0 || chat.deletedAt !== void 0) return;
    this.upsert({
      ...chat,
      deletedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  upsert(chat) {
    this.signal.mutate(() => {
      const existingThread = this.#byId.get(chat.id);
      if (existingThread !== void 0) {
        if (existingThread.deletedAt !== void 0) return false;
        this.#chats.remove(existingThread);
        this.#byId.delete(existingThread.id);
      }
      if (chat.deletedAt === void 0) {
        this.#chats.add(chat);
      }
      this.#byId.set(chat.id, chat);
      return true;
    });
  }
  findMany(query) {
    return Array.from(
      this.#chats.filter((chat) => {
        if (query.metadata === void 0) return true;
        for (const [key, value] of Object.entries(query.metadata)) {
          if (value === null) {
            if (key in chat.metadata) return false;
          } else if (typeof value === "string") {
            if (chat.metadata[key] !== value) return false;
          } else {
            const chatValue = chat.metadata[key];
            if (!Array.isArray(chatValue) || !value.every((v) => chatValue.includes(v))) {
              return false;
            }
          }
        }
        return true;
      })
    );
  }
};

// src/convert-plain-data.ts
function convertToCommentData(data) {
  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;
  const createdAt = new Date(data.createdAt);
  const reactions = data.reactions.map((reaction) => ({
    ...reaction,
    createdAt: new Date(reaction.createdAt)
  }));
  if (data.body) {
    return {
      ...data,
      reactions,
      createdAt,
      editedAt
    };
  } else {
    const deletedAt = new Date(data.deletedAt);
    return {
      ...data,
      reactions,
      createdAt,
      editedAt,
      deletedAt
    };
  }
}
function convertToThreadData(data) {
  const createdAt = new Date(data.createdAt);
  const updatedAt = new Date(data.updatedAt);
  const comments = data.comments.map(
    (comment) => convertToCommentData(comment)
  );
  return {
    ...data,
    createdAt,
    updatedAt,
    comments
  };
}
function convertToCommentUserReaction(data) {
  return {
    ...data,
    createdAt: new Date(data.createdAt)
  };
}
function convertToInboxNotificationData(data) {
  const notifiedAt = new Date(data.notifiedAt);
  const readAt = data.readAt ? new Date(data.readAt) : null;
  if ("activities" in data) {
    const activities = data.activities.map((activity) => ({
      ...activity,
      createdAt: new Date(activity.createdAt)
    }));
    return {
      ...data,
      notifiedAt,
      readAt,
      activities
    };
  }
  return {
    ...data,
    notifiedAt,
    readAt
  };
}
function convertToSubscriptionData(data) {
  const createdAt = new Date(data.createdAt);
  return {
    ...data,
    createdAt
  };
}
function convertToUserSubscriptionData(data) {
  const createdAt = new Date(data.createdAt);
  return {
    ...data,
    createdAt
  };
}
function convertToThreadDeleteInfo(data) {
  const deletedAt = new Date(data.deletedAt);
  return {
    ...data,
    deletedAt
  };
}
function convertToInboxNotificationDeleteInfo(data) {
  const deletedAt = new Date(data.deletedAt);
  return {
    ...data,
    deletedAt
  };
}
function convertToSubscriptionDeleteInfo(data) {
  const deletedAt = new Date(data.deletedAt);
  return {
    ...data,
    deletedAt
  };
}
function convertToGroupData(data) {
  const createdAt = new Date(data.createdAt);
  const updatedAt = new Date(data.updatedAt);
  const members = data.members.map((member) => ({
    ...member,
    addedAt: new Date(member.addedAt)
  }));
  return {
    ...data,
    createdAt,
    updatedAt,
    members
  };
}

// src/lib/assert.ts
function assertNever(_value, errmsg) {
  throw new Error(errmsg);
}
function assert(condition, errmsg) {
  if (process.env.NODE_ENV !== "production") {
    if (!condition) {
      const err = new Error(errmsg);
      err.name = "Assertion failure";
      throw err;
    }
  }
}
function nn(value, errmsg = "Expected value to be non-nullable") {
  assert(value !== null && value !== void 0, errmsg);
  return value;
}

// src/lib/fancy-console.ts
var fancy_console_exports = {};
__export(fancy_console_exports, {
  error: () => error2,
  errorWithTitle: () => errorWithTitle,
  warn: () => warn,
  warnWithTitle: () => warnWithTitle
});
var badge = "background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;";
var bold = "font-weight:600";
function wrap(method) {
  return typeof window === "undefined" || process.env.NODE_ENV === "test" ? console[method] : (
    /* istanbul ignore next */
    (message, ...args) => console[method]("%cLiveblocks", badge, message, ...args)
  );
}
var warn = wrap("warn");
var error2 = wrap("error");
function wrapWithTitle(method) {
  return typeof window === "undefined" || process.env.NODE_ENV === "test" ? console[method] : (
    /* istanbul ignore next */
    (title, message, ...args) => console[method](
      `%cLiveblocks%c ${title}`,
      badge,
      bold,
      message,
      ...args
    )
  );
}
var warnWithTitle = wrapWithTitle("warn");
var errorWithTitle = wrapWithTitle("error");

// src/lib/guards.ts
function isDefined(value) {
  return value !== null && value !== void 0;
}
function isPlainObject(blob) {
  return blob !== null && typeof blob === "object" && Object.prototype.toString.call(blob) === "[object Object]";
}
function isStartsWithOperator(blob) {
  return isPlainObject(blob) && typeof blob.startsWith === "string";
}

// src/lib/autoRetry.ts
var HttpError = class _HttpError extends Error {
  response;
  details;
  constructor(message, response, details) {
    super(message);
    this.name = "HttpError";
    this.response = response;
    this.details = details;
  }
  static async fromResponse(response) {
    let bodyAsText;
    try {
      bodyAsText = await response.text();
    } catch {
    }
    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;
    let bodyAsJsonObject;
    if (isPlainObject(bodyAsJson)) {
      bodyAsJsonObject = bodyAsJson;
    }
    let message = "";
    message ||= typeof bodyAsJsonObject?.message === "string" ? bodyAsJsonObject.message : "";
    message ||= typeof bodyAsJsonObject?.error === "string" ? bodyAsJsonObject.error : "";
    if (bodyAsJson === void 0) {
      message ||= bodyAsText || "";
    }
    message ||= response.statusText;
    let path;
    try {
      path = new URL(response.url).pathname;
    } catch {
    }
    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;
    const details = bodyAsJsonObject;
    return new _HttpError(message, response, details);
  }
  /**
   * Convenience accessor for response.status.
   */
  get status() {
    return this.response.status;
  }
};
var DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;
async function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {
  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;
  let attempt = 0;
  while (true) {
    attempt++;
    try {
      return await promiseFn();
    } catch (err) {
      if (shouldStopRetrying(err)) {
        throw err;
      }
      if (attempt >= maxTries) {
        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);
      }
    }
    const delay = backoff[attempt - 1] ?? fallbackBackoff;
    warn(
      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`
    );
    await wait(delay);
  }
}

// src/lib/controlledPromise.ts
function controlledPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [promise, resolve, reject];
}
function Promise_withResolvers() {
  const [promise, resolve, reject] = controlledPromise();
  return { promise, resolve, reject };
}

// src/lib/stringify.ts
function replacer(_key, value) {
  return value !== null && typeof value === "object" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {
    sorted[key] = value[key];
    return sorted;
  }, {}) : value;
}
function stableStringify(value) {
  return JSON.stringify(value, replacer);
}
function stringifyOrLog(value) {
  try {
    return JSON.stringify(value);
  } catch (err) {
    console.error(`Could not stringify: ${err.message}`);
    console.error(value);
    throw err;
  }
}

// src/lib/batch.ts
var DEFAULT_SIZE = 50;
var BatchCall = class {
  input;
  resolve;
  reject;
  promise;
  constructor(input) {
    this.input = input;
    const { promise, resolve, reject } = Promise_withResolvers();
    this.promise = promise;
    this.resolve = resolve;
    this.reject = reject;
  }
};
var Batch = class {
  #queue = [];
  #callback;
  #size;
  #delay;
  #delayTimeoutId;
  error = false;
  constructor(callback, options) {
    this.#callback = callback;
    this.#size = options.size ?? DEFAULT_SIZE;
    this.#delay = options.delay;
  }
  #clearDelayTimeout() {
    if (this.#delayTimeoutId !== void 0) {
      clearTimeout(this.#delayTimeoutId);
      this.#delayTimeoutId = void 0;
    }
  }
  #schedule() {
    if (this.#queue.length === this.#size) {
      void this.#flush();
    } else if (this.#queue.length === 1) {
      this.#clearDelayTimeout();
      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);
    }
  }
  async #flush() {
    if (this.#queue.length === 0) {
      return;
    }
    const calls = this.#queue.splice(0);
    const inputs = calls.map((call) => call.input);
    try {
      const results = await this.#callback(inputs);
      this.error = false;
      calls.forEach((call, index) => {
        const result = results?.[index];
        if (!Array.isArray(results)) {
          call.reject(new Error("Callback must return an array."));
        } else if (calls.length !== results.length) {
          call.reject(
            new Error(
              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`
            )
          );
        } else if (result instanceof Error) {
          call.reject(result);
        } else {
          call.resolve(result);
        }
      });
    } catch (error3) {
      this.error = true;
      calls.forEach((call) => {
        call.reject(error3);
      });
    }
  }
  get(input) {
    const existingCall = this.#queue.find(
      (call2) => stableStringify(call2.input) === stableStringify(input)
    );
    if (existingCall) {
      return existingCall.promise;
    }
    const call = new BatchCall(input);
    this.#queue.push(call);
    this.#schedule();
    return call.promise;
  }
  clear() {
    this.#queue = [];
    this.error = false;
    this.#clearDelayTimeout();
  }
};
function createBatchStore(batch2) {
  const signal = new MutableSignal(/* @__PURE__ */ new Map());
  function getCacheKey(args) {
    return stableStringify(args);
  }
  function update(entryOrEntries) {
    signal.mutate((cache) => {
      if (Array.isArray(entryOrEntries)) {
        for (const entry of entryOrEntries) {
          cache.set(entry.key, entry.state);
        }
      } else {
        cache.set(entryOrEntries.key, entryOrEntries.state);
      }
    });
  }
  function invalidate(inputs) {
    signal.mutate((cache) => {
      if (Array.isArray(inputs)) {
        for (const input of inputs) {
          cache.delete(getCacheKey(input));
        }
      } else {
        cache.clear();
      }
    });
  }
  async function enqueue(input) {
    const cacheKey = getCacheKey(input);
    const cache = signal.get();
    if (cache.has(cacheKey)) {
      return;
    }
    try {
      update({ key: cacheKey, state: { isLoading: true } });
      const result = await batch2.get(input);
      update({ key: cacheKey, state: { isLoading: false, data: result } });
    } catch (error3) {
      update({
        key: cacheKey,
        state: { isLoading: false, error: error3 }
      });
    }
  }
  function setData(entries2) {
    update(
      entries2.map((entry) => ({
        key: getCacheKey(entry[0]),
        state: { isLoading: false, data: entry[1] }
      }))
    );
  }
  function getItemState(input) {
    const cacheKey = getCacheKey(input);
    const cache = signal.get();
    return cache.get(cacheKey);
  }
  function getData(input) {
    const cacheKey = getCacheKey(input);
    const cache = signal.get();
    return cache.get(cacheKey)?.data;
  }
  function _cacheKeys() {
    const cache = signal.get();
    return [...cache.keys()];
  }
  return {
    subscribe: signal.subscribe,
    enqueue,
    setData,
    getItemState,
    getData,
    invalidate,
    batch: batch2,
    _cacheKeys
  };
}

// src/lib/chunk.ts
function chunk(array, size) {
  const chunks = [];
  for (let i = 0, j = array.length; i < j; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

// src/lib/nanoid.ts
var nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(
  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? "_" : "-",
  ""
);

// src/lib/createIds.ts
var THREAD_ID_PREFIX = "th";
var COMMENT_ID_PREFIX = "cm";
var COMMENT_ATTACHMENT_ID_PREFIX = "at";
var INBOX_NOTIFICATION_ID_PREFIX = "in";
function createOptimisticId(prefix) {
  return `${prefix}_${nanoid()}`;
}
function createThreadId() {
  return createOptimisticId(THREAD_ID_PREFIX);
}
function createCommentId() {
  return createOptimisticId(COMMENT_ID_PREFIX);
}
function createCommentAttachmentId() {
  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);
}
function createInboxNotificationId() {
  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);
}

// src/lib/DefaultMap.ts
var DefaultMap = class extends Map {
  #defaultFn;
  /**
   * If the default function is not provided to the constructor, it has to be
   * provided in each .getOrCreate() call individually.
   */
  constructor(defaultFn, entries2) {
    super(entries2);
    this.#defaultFn = defaultFn;
  }
  /**
   * Gets the value at the given key, or creates it.
   *
   * Difference from normal Map: if the key does not exist, it will be created
   * on the fly using the factory function, and that value will get returned
   * instead of `undefined`.
   */
  getOrCreate(key, defaultFn) {
    if (super.has(key)) {
      return super.get(key);
    } else {
      const fn = defaultFn ?? this.#defaultFn ?? raise("DefaultMap used without a factory function");
      const value = fn(key);
      this.set(key, value);
      return value;
    }
  }
};

// src/lib/objectToQuery.ts
var identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
function objectToQuery(obj) {
  let filterList = [];
  const entries2 = Object.entries(obj);
  const keyValuePairs = [];
  const keyValuePairsWithOperator = [];
  const indexedKeys = [];
  entries2.forEach(([key, value]) => {
    if (!identifierRegex.test(key)) {
      throw new Error("Key must only contain letters, numbers, _");
    }
    if (isSimpleValue(value)) {
      keyValuePairs.push([key, value]);
    } else if (isPlainObject(value)) {
      if (isStartsWithOperator(value)) {
        keyValuePairsWithOperator.push([key, value]);
      } else {
        indexedKeys.push([key, value]);
      }
    }
  });
  filterList = [
    ...getFiltersFromKeyValuePairs(keyValuePairs),
    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)
  ];
  indexedKeys.forEach(([key, value]) => {
    const nestedEntries = Object.entries(value);
    const nKeyValuePairs = [];
    const nKeyValuePairsWithOperator = [];
    nestedEntries.forEach(([nestedKey, nestedValue]) => {
      if (isStringEmpty(nestedKey)) {
        throw new Error("Key cannot be empty");
      }
      if (isSimpleValue(nestedValue)) {
        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);
      } else if (isStartsWithOperator(nestedValue)) {
        nKeyValuePairsWithOperator.push([
          formatFilterKey(key, nestedKey),
          nestedValue
        ]);
      }
    });
    filterList = [
      ...filterList,
      ...getFiltersFromKeyValuePairs(nKeyValuePairs),
      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)
    ];
  });
  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(" ");
}
var getFiltersFromKeyValuePairs = (keyValuePairs) => {
  const filters = [];
  keyValuePairs.forEach(([key, value]) => {
    filters.push({
      key,
      operator: ":",
      value
    });
  });
  return filters;
};
var getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {
  const filters = [];
  keyValuePairsWithOperator.forEach(([key, value]) => {
    if ("startsWith" in value && typeof value.startsWith === "string") {
      filters.push({
        key,
        operator: "^",
        value: value.startsWith
      });
    }
  });
  return filters;
};
var isSimpleValue = (value) => {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null;
};
var formatFilterKey = (key, nestedKey) => {
  if (nestedKey) {
    return `${key}[${quote(nestedKey)}]`;
  }
  return key;
};
var isStringEmpty = (value) => {
  return !value || value.toString().trim() === "";
};
function quote(input) {
  const result = JSON.stringify(input);
  if (typeof input !== "string") {
    return result;
  }
  if (result.includes("'")) {
    return result;
  }
  return `'${result.slice(1, -1).replace(/\\"/g, '"')}'`;
}

// src/lib/url.ts
var PLACEHOLDER_BASE_URL = "https://localhost:9999";
var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
var TRAILING_SLASH_URL_REGEX = /\/(?:(?:\?|#).*)?$/;
function toURLSearchParams(params) {
  const result = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    if (value !== void 0 && value !== null) {
      result.set(key, value.toString());
    }
  }
  return result;
}
function urljoin(baseUrl, path, params) {
  const url2 = new URL(path, baseUrl);
  if (params !== void 0) {
    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();
  }
  return url2.toString();
}
function url(strings, ...values2) {
  return strings.reduce(
    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? "") + str
  );
}
function sanitizeUrl(url2) {
  if (url2.startsWith("www.")) {
    url2 = "https://" + url2;
  }
  if (url2 === "#") {
    return url2;
  }
  try {
    const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);
    const urlObject = new URL(
      url2,
      isAbsolute ? void 0 : PLACEHOLDER_BASE_URL
    );
    if (urlObject.protocol !== "http:" && urlObject.protocol !== "https:") {
      return null;
    }
    const hasTrailingSlash = TRAILING_SLASH_URL_REGEX.test(url2);
    const sanitizedUrl = (
      // 1. Origin, only for absolute URLs
      (isAbsolute ? urlObject.origin : "") + // 2. Pathname, with a trailing slash if the original URL had one
      (urlObject.pathname === "/" ? (
        // 2.a. Domain-only URLs, they always have their pathname set to "/"
        hasTrailingSlash ? "/" : ""
      ) : (
        // 2.b. URLs with a path
        hasTrailingSlash && !urlObject.pathname.endsWith("/") ? urlObject.pathname + "/" : urlObject.pathname
      )) + // 3. Search params
      urlObject.search + // 4. Hash
      urlObject.hash
    );
    return sanitizedUrl !== "" ? sanitizedUrl : null;
  } catch {
    return null;
  }
}
function generateUrl(url2, params, hash) {
  const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);
  const urlObject = new URL(url2, isAbsolute ? void 0 : PLACEHOLDER_BASE_URL);
  if (params !== void 0) {
    for (const [param, value] of Object.entries(params)) {
      if (value) {
        urlObject.searchParams.set(param, String(value));
      }
    }
  }
  if (!urlObject.hash && hash !== void 0) {
    urlObject.hash = `#${hash}`;
  }
  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, "");
}
function isUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// src/api-client.ts
function createApiClient({
  baseUrl,
  authManager,
  currentUserId,
  fetchPolyfill
}) {
  const httpClient = new HttpClient(baseUrl, fetchPolyfill);
  async function getThreadsSince(options) {
    const result = await httpClient.get(
      url`/v2/c/rooms/${options.roomId}/threads/delta`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        since: options.since.toISOString()
      },
      { signal: options.signal }
    );
    return {
      threads: {
        updated: result.data.map(convertToThreadData),
        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)
      },
      inboxNotifications: {
        updated: result.inboxNotifications.map(convertToInboxNotificationData),
        deleted: result.deletedInboxNotifications.map(
          convertToInboxNotificationDeleteInfo
        )
      },
      subscriptions: {
        updated: result.subscriptions.map(convertToSubscriptionData),
        deleted: result.deletedSubscriptions.map(
          convertToSubscriptionDeleteInfo
        )
      },
      requestedAt: new Date(result.meta.requestedAt),
      permissionHints: result.meta.permissionHints
    };
  }
  async function getThreads(options) {
    let query;
    if (options.query) {
      query = objectToQuery(options.query);
    }
    const PAGE_SIZE = 50;
    try {
      const result = await httpClient.get(
        url`/v2/c/rooms/${options.roomId}/threads`,
        await authManager.getAuthValue({
          requestedScope: "comments:read",
          roomId: options.roomId
        }),
        {
          cursor: options.cursor,
          query,
          limit: PAGE_SIZE
        }
      );
      return {
        threads: result.data.map(convertToThreadData),
        inboxNotifications: result.inboxNotifications.map(
          convertToInboxNotificationData
        ),
        subscriptions: result.subscriptions.map(convertToSubscriptionData),
        nextCursor: result.meta.nextCursor,
        requestedAt: new Date(result.meta.requestedAt),
        permissionHints: result.meta.permissionHints
      };
    } catch (err) {
      if (err instanceof HttpError && err.status === 404) {
        return {
          threads: [],
          inboxNotifications: [],
          subscriptions: [],
          nextCursor: null,
          //
          // HACK
          // requestedAt needs to be a *server* timestamp here. However, on
          // this 404 error response, there is no such timestamp. So out of
          // pure necessity we'll fall back to a local timestamp instead (and
          // allow for a possible 6 hour clock difference between client and
          // server).
          //
          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),
          permissionHints: {}
        };
      }
      throw err;
    }
  }
  async function createThread(options) {
    const commentId = options.commentId ?? createCommentId();
    const threadId = options.threadId ?? createThreadId();
    const thread = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        id: threadId,
        comment: {
          id: commentId,
          body: options.body,
          attachmentIds: options.attachmentIds
        },
        metadata: options.metadata
      }
    );
    return convertToThreadData(thread);
  }
  async function deleteThread(options) {
    await httpClient.delete(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function getThread(options) {
    const response = await httpClient.rawGet(
      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
    if (response.ok) {
      const json = await response.json();
      return {
        thread: convertToThreadData(json.thread),
        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0,
        subscription: json.subscription ? convertToSubscriptionData(json.subscription) : void 0
      };
    } else if (response.status === 404) {
      return {
        thread: void 0,
        inboxNotification: void 0,
        subscription: void 0
      };
    } else {
      throw new Error(
        `There was an error while getting thread ${options.threadId}.`
      );
    }
  }
  async function editThreadMetadata(options) {
    return await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      options.metadata
    );
  }
  async function createComment(options) {
    const commentId = options.commentId ?? createCommentId();
    const comment = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        id: commentId,
        body: options.body,
        attachmentIds: options.attachmentIds
      }
    );
    return convertToCommentData(comment);
  }
  async function editComment(options) {
    const comment = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        body: options.body,
        attachmentIds: options.attachmentIds
      }
    );
    return convertToCommentData(comment);
  }
  async function deleteComment(options) {
    await httpClient.delete(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function addReaction(options) {
    const reaction = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      { emoji: options.emoji }
    );
    return convertToCommentUserReaction(reaction);
  }
  async function removeReaction(options) {
    await httpClient.delete(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function markThreadAsResolved(options) {
    await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function markThreadAsUnresolved(options) {
    await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function subscribeToThread(options) {
    const subscription = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/subscribe`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
    return convertToSubscriptionData(subscription);
  }
  async function unsubscribeFromThread(options) {
    await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/unsubscribe`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function uploadAttachment(options) {
    const roomId = options.roomId;
    const abortSignal = options.signal;
    const attachment = options.attachment;
    const abortError = abortSignal ? new DOMException(
      `Upload of attachment ${options.attachment.id} was aborted.`,
      "AbortError"
    ) : void 0;
    if (abortSignal?.aborted) {
      throw abortError;
    }
    const handleRetryError = (err) => {
      if (abortSignal?.aborted) {
        throw abortError;
      }
      if (err instanceof HttpError && err.status === 413) {
        throw err;
      }
      return false;
    };
    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;
    const RETRY_ATTEMPTS = 10;
    const RETRY_DELAYS = [
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3
    ];
    function splitFileIntoParts(file) {
      const parts = [];
      let start = 0;
      while (start < file.size) {
        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);
        parts.push({
          partNumber: parts.length + 1,
          part: file.slice(start, end)
        });
        start = end;
      }
      return parts;
    }
    if (attachment.size <= ATTACHMENT_PART_SIZE) {
      return autoRetry(
        async () => httpClient.putBlob(
          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          attachment.file,
          { fileSize: attachment.size },
          { signal: abortSignal }
        ),
        RETRY_ATTEMPTS,
        RETRY_DELAYS,
        handleRetryError
      );
    } else {
      let uploadId;
      const uploadedParts = [];
      const createMultiPartUpload = await autoRetry(
        async () => httpClient.post(
          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          void 0,
          { signal: abortSignal },
          { fileSize: attachment.size }
        ),
        RETRY_ATTEMPTS,
        RETRY_DELAYS,
        handleRetryError
      );
      try {
        uploadId = createMultiPartUpload.uploadId;
        const parts = splitFileIntoParts(attachment.file);
        if (abortSignal?.aborted) {
          throw abortError;
        }
        const batches = chunk(parts, 5);
        for (const parts2 of batches) {
          const uploadedPartsPromises = [];
          for (const { part, partNumber } of parts2) {
            uploadedPartsPromises.push(
              autoRetry(
                async () => httpClient.putBlob(
                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,
                  await authManager.getAuthValue({
                    requestedScope: "comments:read",
                    roomId
                  }),
                  part,
                  void 0,
                  { signal: abortSignal }
                ),
                RETRY_ATTEMPTS,
                RETRY_DELAYS,
                handleRetryError
              )
            );
          }
          uploadedParts.push(...await Promise.all(uploadedPartsPromises));
        }
        if (abortSignal?.aborted) {
          throw abortError;
        }
        const sortedUploadedParts = uploadedParts.sort(
          (a, b) => a.partNumber - b.partNumber
        );
        return httpClient.post(
          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          { parts: sortedUploadedParts },
          { signal: abortSignal }
        );
      } catch (error3) {
        if (uploadId && error3?.name && (error3.name === "AbortError" || error3.name === "TimeoutError")) {
          try {
            await httpClient.rawDelete(
              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,
              await authManager.getAuthValue({
                requestedScope: "comments:read",
                roomId
              })
            );
          } catch (error4) {
          }
        }
        throw error3;
      }
    }
  }
  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {
    const batch2 = new Batch(
      async (batchedAttachmentIds) => {
        const attachmentIds = batchedAttachmentIds.flat();
        const { urls } = await httpClient.post(
          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          { attachmentIds }
        );
        return urls.map(
          (url2) => url2 ?? new Error("There was an error while getting this attachment's URL")
        );
      },
      { delay: 50 }
    );
    return createBatchStore(batch2);
  });
  function getOrCreateAttachmentUrlsStore(roomId) {
    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);
  }
  function getAttachmentUrl(options) {
    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;
    return batch2.get(options.attachmentId);
  }
  async function uploadChatAttachment(options) {
    const { chatId, attachment, signal } = options;
    const userId = currentUserId.get();
    if (userId === void 0) {
      throw new Error("Attachment upload requires an authenticated user.");
    }
    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;
    if (options.attachment.file.size <= ATTACHMENT_PART_SIZE) {
      await httpClient.putBlob(
        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.file.name)}`,
        await authManager.getAuthValue({ requestedScope: "comments:read" }),
        attachment.file,
        { fileSize: attachment.file.size },
        { signal }
      );
    } else {
      const multipartUpload = await httpClient.post(
        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.file.name)}`,
        await authManager.getAuthValue({ requestedScope: "comments:read" }),
        void 0,
        { signal },
        { fileSize: attachment.file.size }
      );
      try {
        const uploadedParts = [];
        const parts = [];
        let start = 0;
        while (start < attachment.file.size) {
          const end = Math.min(
            start + ATTACHMENT_PART_SIZE,
            attachment.file.size
          );
          parts.push({
            number: parts.length + 1,
            part: attachment.file.slice(start, end)
          });
          start = end;
        }
        uploadedParts.push(
          ...await Promise.all(
            parts.map(async ({ number, part }) => {
              return await httpClient.putBlob(
                url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/${String(number)}`,
                await authManager.getAuthValue({
                  requestedScope: "comments:read"
                }),
                part,
                void 0,
                { signal }
              );
            })
          )
        );
        await httpClient.post(
          url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/complete`,
          await authManager.getAuthValue({ requestedScope: "comments:read" }),
          { parts: uploadedParts.sort((a, b) => a.number - b.number) },
          { signal }
        );
      } catch (err) {
        try {
          await httpClient.delete(
            url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}`,
            await authManager.getAuthValue({ requestedScope: "comments:read" })
          );
        } catch (err2) {
        }
        throw err;
      }
    }
  }
  const attachmentUrlsBatchStoresByChat = new DefaultMap((chatId) => {
    const batch2 = new Batch(
      async (batchedAttachmentIds) => {
        const attachmentIds = batchedAttachmentIds.flat();
        const { urls } = await httpClient.post(
          url`/v2/c/chats/${chatId}/attachments/presigned-urls`,
          await authManager.getAuthValue({
            requestedScope: "comments:read"
          }),
          { attachmentIds }
        );
        return urls.map(
          (url2) => url2 ?? new Error("There was an error while getting this attachment's URL")
        );
      },
      { delay: 50 }
    );
    return createBatchStore(batch2);
  });
  function getOrCreateChatAttachmentUrlsStore(chatId) {
    return attachmentUrlsBatchStoresByChat.getOrCreate(chatId);
  }
  function getChatAttachmentUrl(options) {
    const batch2 = getOrCreateChatAttachmentUrlsStore(options.chatId).batch;
    return batch2.get(options.attachmentId);
  }
  async function getSubscriptionSettings(options) {
    return httpClient.get(
      url`/v2/c/rooms/${options.roomId}/subscription-settings`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      void 0,
      {
        signal: options.signal
      }
    );
  }
  async function updateSubscriptionSettings(options) {
    return httpClient.post(
      url`/v2/c/rooms/${options.roomId}/subscription-settings`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      options.settings
    );
  }
  const markAsReadBatchesByRoom = new DefaultMap(
    (roomId) => new Batch(
      async (batchedInboxNotificationIds) => {
        const inboxNotificationIds = batchedInboxNotificationIds.flat();
        await httpClient.post(
          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          { inboxNotificationIds }
        );
        return inboxNotificationIds;
      },
      { delay: 50 }
    )
  );
  async function markRoomInboxNotificationAsRead(options) {
    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);
    return batch2.get(options.inboxNotificationId);
  }
  async function createTextMention(options) {
    if (options.mention.kind !== "user" && options.mention.kind !== "group") {
      return assertNever(options.mention, "Unexpected mention kind");
    }
    await httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/text-mentions`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        userId: options.mention.kind === "user" ? options.mention.id : void 0,
        groupId: options.mention.kind === "group" ? options.mention.id : void 0,
        userIds: options.mention.kind === "group" ? options.mention.userIds : void 0,
        mentionId: options.mentionId
      }
    );
  }
  async function deleteTextMention(options) {
    await httpClient.rawDelete(
      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function getTextVersion(options) {
    return httpClient.rawGet(
      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function createTextVersion(options) {
    await httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/version`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function reportTextEditor(options) {
    await httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/text-metadata`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        type: options.type,
        rootKey: options.rootKey
      }
    );
  }
  async function executeContextualPrompt(options) {
    const result = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,
      await authManager.getAuthValue({
        requestedScope: "room:read",
        roomId: options.roomId
      }),
      {
        prompt: options.prompt,
        context: {
          beforeSelection: options.context.beforeSelection,
          selection: options.context.selection,
          afterSelection: options.context.afterSelection
        },
        previous: options.previous
      },
      { signal: options.signal }
    );
    if (!result || result.content.length === 0) {
      throw new Error("No content returned from server");
    }
    return result.content[0].text;
  }
  async function listTextVersions(options) {
    const result = await httpClient.get(
      url`/v2/c/rooms/${options.roomId}/versions`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
    return {
      versions: result.versions.map(({ createdAt, ...version }) => {
        return {
          createdAt: new Date(createdAt),
          ...version
        };
      }),
      requestedAt: new Date(result.meta.requestedAt)
    };
  }
  async function listTextVersionsSince(options) {
    const result = await httpClient.get(
      url`/v2/c/rooms/${options.roomId}/versions/delta`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      { since: options.since.toISOString() },
      { signal: options.signal }
    );
    return {
      versions: result.versions.map(({ createdAt, ...version }) => {
        return {
          createdAt: new Date(createdAt),
          ...version
        };
      }),
      requestedAt: new Date(result.meta.requestedAt)
    };
  }
  async function streamStorage(options) {
    const result = await httpClient.rawGet(
      url`/v2/c/rooms/${options.roomId}/storage`,
      await authManager.getAuthValue({
        requestedScope: "room:read",
        roomId: options.roomId
      })
    );
    return await result.json();
  }
  async function sendMessages(options) {
    return httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/send-message`,
      await authManager.getAuthValue({
        requestedScope: "room:read",
        roomId: options.roomId
      }),
      {
        nonce: options.nonce,
        messages: options.messages
      }
    );
  }
  async function getInboxNotifications(options) {
    const PAGE_SIZE = 50;
    let query;
    if (options?.query) {
      query = objectToQuery(options.query);
    }
    const json = await httpClient.get(
      url`/v2/c/inbox-notifications`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        cursor: options?.cursor,
        limit: PAGE_SIZE,
        query
      }
    );
    const groups = json.groups.map(convertToGroupData);
    groupsStore.setData(groups.map((group) => [group.id, group]));
    return {
      inboxNotifications: json.inboxNotifications.map(
        convertToInboxNotificationData
      ),
      threads: json.threads.map(convertToThreadData),
      subscriptions: json.subscriptions.map(convertToSubscriptionData),
      nextCursor: json.meta.nextCursor,
      requestedAt: new Date(json.meta.requestedAt)
    };
  }
  async function getInboxNotificationsSince(options) {
    let query;
    if (options?.query) {
      query = objectToQuery(options.query);
    }
    const json = await httpClient.get(
      url`/v2/c/inbox-notifications/delta`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      { since: options.since.toISOString(), query },
      { signal: options.signal }
    );
    return {
      inboxNotifications: {
        updated: json.inboxNotifications.map(convertToInboxNotificationData),
        deleted: json.deletedInboxNotifications.map(
          convertToInboxNotificationDeleteInfo
        )
      },
      threads: {
        updated: json.threads.map(convertToThreadData),
        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)
      },
      subscriptions: {
        updated: json.subscriptions.map(convertToSubscriptionData),
        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)
      },
      requestedAt: new Date(json.meta.requestedAt)
    };
  }
  async function getUnreadInboxNotificationsCount() {
    const { count } = await httpClient.get(
      url`/v2/c/inbox-notifications/count`,
      await authManager.getAuthValue({ requestedScope: "comments:read" })
    );
    return count;
  }
  async function markAllInboxNotificationsAsRead() {
    await httpClient.post(
      url`/v2/c/inbox-notifications/read`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        inboxNotificationIds: "all"
      }
    );
  }
  async function markInboxNotificationsAsRead(inboxNotificationIds) {
    await httpClient.post(
      url`/v2/c/inbox-notifications/read`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        inboxNotificationIds
      }
    );
  }
  const batchedMarkInboxNotificationsAsRead = new Batch(
    async (batchedInboxNotificationIds) => {
      const inboxNotificationIds = batchedInboxNotificationIds.flat();
      await markInboxNotificationsAsRead(inboxNotificationIds);
      return inboxNotificationIds;
    },
    { delay: 50 }
  );
  async function markInboxNotificationAsRead(inboxNotificationId) {
    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);
  }
  async function deleteAllInboxNotifications() {
    await httpClient.delete(
      url`/v2/c/inbox-notifications`,
      await authManager.getAuthValue({ requestedScope: "comments:read" })
    );
  }
  async function deleteInboxNotification(inboxNotificationId) {
    await httpClient.delete(
      url`/v2/c/inbox-notifications/${inboxNotificationId}`,
      await authManager.getAuthValue({ requestedScope: "comments:read" })
    );
  }
  async function getNotificationSettings(options) {
    return httpClient.get(
      url`/v2/c/notification-settings`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      void 0,
      { signal: options?.signal }
    );
  }
  async function updateNotificationSettings(settings) {
    return httpClient.post(
      url`/v2/c/notification-settings`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      settings
    );
  }
  async function getUserThreads_experimental(options) {
    let query;
    if (options?.query) {
      query = objectToQuery(options.query);
    }
    const PAGE_SIZE = 50;
    const json = await httpClient.get(
      url`/v2/c/threads`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        cursor: options?.cursor,
        query,
        limit: PAGE_SIZE
      }
    );
    return {
      threads: json.threads.map(convertToThreadData),
      inboxNotifications: json.inboxNotifications.map(
        convertToInboxNotificationData
      ),
      subscriptions: json.subscriptions.map(convertToSubscriptionData),
      nextCursor: json.meta.nextCursor,
      requestedAt: new Date(json.meta.requestedAt),
      permissionHints: json.meta.permissionHints
    };
  }
  async function getUserThreadsSince_experimental(options) {
    const json = await httpClient.get(
      url`/v2/c/threads/delta`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      { since: options.since.toISOString() },
      { signal: options.signal }
    );
    return {
      threads: {
        updated: json.threads.map(convertToThreadData),
        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)
      },
      inboxNotifications: {
        updated: json.inboxNotifications.map(convertToInboxNotificationData),
        deleted: json.deletedInboxNotifications.map(
          convertToInboxNotificationDeleteInfo
        )
      },
      subscriptions: {
        updated: json.subscriptions.map(convertToSubscriptionData),
        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)
      },
      requestedAt: new Date(json.meta.requestedAt),
      permissionHints: json.meta.permissionHints
    };
  }
  const batchedGetGroups = new Batch(
    async (batchedGroupIds) => {
      const groupIds = batchedGroupIds.flat();
      const { groups: plainGroups } = await httpClient.post(
        url`/v2/c/groups/find`,
        await authManager.getAuthValue({
          requestedScope: "comments:read"
        }),
        { groupIds }
      );
      const groups = /* @__PURE__ */ new Map();
      for (const group of plainGroups) {
        groups.set(group.id, convertToGroupData(group));
      }
      return groupIds.map((groupId) => groups.get(groupId));
    },
    { delay: 50 }
  );
  const groupsStore = createBatchStore(batchedGetGroups);
  function getGroup(groupId) {
    return batchedGetGroups.get(groupId);
  }
  return {
    // Room threads
    getThreads,
    getThreadsSince,
    createThread,
    getThread,
    deleteThread,
    editThreadMetadata,
    createComment,
    editComment,
    deleteComment,
    addReaction,
    removeReaction,
    markThreadAsResolved,
    markThreadAsUnresolved,
    subscribeToThread,
    unsubscribeFromThread,
    markRoomInboxNotificationAsRead,
    // Room subscription settings
    getSubscriptionSettings,
    updateSubscriptionSettings,
    // Room text editor
    createTextMention,
    deleteTextMention,
    getTextVersion,
    createTextVersion,
    reportTextEditor,
    listTextVersions,
    listTextVersionsSince,
    // Room attachments
    getAttachmentUrl,
    uploadAttachment,
    getOrCreateAttachmentUrlsStore,
    // User attachments
    uploadChatAttachment,
    getOrCreateChatAttachmentUrlsStore,
    getChatAttachmentUrl,
    // Room storage
    streamStorage,
    sendMessages,
    // Notifications
    getInboxNotifications,
    getInboxNotificationsSince,
    getUnreadInboxNotificationsCount,
    markAllInboxNotificationsAsRead,
    markInboxNotificationAsRead,
    deleteAllInboxNotifications,
    deleteInboxNotification,
    getNotificationSettings,
    updateNotificationSettings,
    // User threads
    getUserThreads_experimental,
    getUserThreadsSince_experimental,
    // Groups
    groupsStore,
    getGroup,
    // AI
    executeContextualPrompt
  };
}
function getBearerTokenFromAuthValue(authValue) {
  if (authValue.type === "public") {
    return authValue.publicApiKey;
  } else {
    return authValue.token.raw;
  }
}
var HttpClient = class {
  #baseUrl;
  #fetchPolyfill;
  constructor(baseUrl, fetchPolyfill) {
    this.#baseUrl = baseUrl;
    this.#fetchPolyfill = fetchPolyfill;
  }
  // ------------------------------------------------------------------
  // Public methods
  // ------------------------------------------------------------------
  /**
   * Constructs and makes the HTTP request, but does not handle the response.
   *
   * This is what .rawFetch() does:     This method!
   *   1. Set Content-Type header
   *   2. Set Authorization header
   *   3. Call the callback to obtain the `authValue` to use in the Authorization header
   *
   * This is what .fetch() does ON TOP of that:
   *   4. Parse response body as Json
   *   5. ...but silently return `{}` if that parsing fails
   *   6. Throw HttpError if response is an error
   */
  async #rawFetch(endpoint, authValue, options, params) {
    if (!endpoint.startsWith("/v2/c/")) {
      raise("This client can only be used to make /v2/c/* requests");
    }
    const url2 = urljoin(this.#baseUrl, endpoint, params);
    return await this.#fetchPolyfill(url2, {
      ...options,
      headers: {
        // These headers are default, but can be overriden by custom headers
        "Content-Type": "application/json; charset=utf-8",
        // Possible header overrides
        ...options?.headers,
        // Cannot be overriden by custom headers
        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,
        "X-LB-Client": PKG_VERSION || "dev"
      }
    });
  }
  /**
   * Constructs, makes the HTTP request, and handles the response by parsing
   * JSON and/or throwing an HttpError if it failed.
   *
   * This is what .rawFetch() does:
   *   1. Set Content-Type header
   *   2. Set Authorization header
   *   3. Call the callback to obtain the `authValue` to use in the Authorization header
   *
   * This is what .fetch() does ON TOP of that:    This method!
   *   4. Parse response body as Json
   *   5. ...but silently return `{}` if that parsing fails ()
   *   6. Throw HttpError if response is an error
   */
  async #fetch(endpoint, authValue, options, params) {
    const response = await this.#rawFetch(endpoint, authValue, options, params);
    if (!response.ok) {
      throw await HttpError.fromResponse(response);
    }
    let body;
    try {
      body = await response.json();
    } catch {
      body = {};
    }
    return body;
  }
  /**
   * Makes a GET request and returns the raw response.
   * Won't throw if the reponse is a non-2xx.
   * @deprecated Ideally, use .get() instead.
   */
  async rawGet(endpoint, authValue, params, options) {
    return await this.#rawFetch(endpoint, authValue, options, params);
  }
  /**
   * Makes a POST request and returns the raw response.
   * Won't throw if the reponse is a non-2xx.
   * @deprecated Ideally, use .post() instead.
   */
  async rawPost(endpoint, authValue, body) {
    return await this.#rawFetch(endpoint, authValue, {
      method: "POST",
      body: stringifyOrLog(body)
    });
  }
  /**
   * Makes a DELETE request and returns the raw response.
   * Won't throw if the reponse is a non-2xx.
   * @deprecated Ideally, use .delete() instead.
   */
  async rawDelete(endpoint, authValue) {
    return await this.#rawFetch(endpoint, authValue, { method: "DELETE" });
  }
  /**
   * Makes a GET request, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async get(endpoint, authValue, params, options) {
    return await this.#fetch(endpoint, authValue, options, params);
  }
  /**
   * Makes a POST request, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async post(endpoint, authValue, body, options, params) {
    return await this.#fetch(
      endpoint,
      authValue,
      {
        ...options,
        method: "POST",
        body: stringifyOrLog(body)
      },
      params
    );
  }
  /**
   * Makes a DELETE request, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async delete(endpoint, authValue) {
    return await this.#fetch(endpoint, authValue, { method: "DELETE" });
  }
  /**
   * Makes a PUT request for a Blob body, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async putBlob(endpoint, authValue, blob, params, options) {
    return await this.#fetch(
      endpoint,
      authValue,
      {
        ...options,
        method: "PUT",
        headers: {
          "Content-Type": "application/octet-stream"
        },
        body: blob
      },
      params
    );
  }
};

// src/lib/fsm.ts
function distance(state1, state2) {
  if (state1 === state2) {
    return [0, 0];
  }
  const chunks1 = state1.split(".");
  const chunks2 = state2.split(".");
  const minLen = Math.min(chunks1.length, chunks2.length);
  let shared = 0;
  for (; shared < minLen; shared++) {
    if (chunks1[shared] !== chunks2[shared]) {
      break;
    }
  }
  const up = chunks1.length - shared;
  const down = chunks2.length - shared;
  return [up, down];
}
function patterns(targetState, levels) {
  const parts = targetState.split(".");
  if (levels < 1 || levels > parts.length + 1) {
    throw new Error("Invalid number of levels");
  }
  const result = [];
  if (levels > parts.length) {
    result.push("*");
  }
  for (let i = parts.length - levels + 1; i < parts.length; i++) {
    const slice = parts.slice(0, i);
    if (slice.length > 0) {
      result.push(slice.join(".") + ".*");
    }
  }
  result.push(targetState);
  return result;
}
var SafeContext = class {
  #curr;
  constructor(initialContext) {
    this.#curr = initialContext;
  }
  get current() {
    return this.#curr;
  }
  /**
   * Call a callback function that allows patching of the context, by
   * calling `context.patch()`. Patching is only allowed for the duration
   * of this window.
   */
  allowPatching(callback) {
    const self = this;
    let allowed = true;
    const patchableContext = {
      ...this.#curr,
      patch(patch) {
        if (allowed) {
          self.#curr = Object.assign({}, self.#curr, patch);
          for (const pair of Object.entries(patch)) {
            const [key, value] = pair;
            if (key !== "patch") {
              this[key] = value;
            }
          }
        } else {
          throw new Error("Can no longer patch stale context");
        }
      }
    };
    callback(patchableContext);
    allowed = false;
    return;
  }
};
var nextId = 1;
var FSM = class {
  id;
  // Indicates whether this state machine is still being configured, has
  // started, or has terminated
  #runningState;
  #currentContext;
  #states;
  #currentStateOrNull;
  #allowedTransitions;
  #eventHub;
  events;
  //
  // The cleanup stack is a stack of (optional) callback functions that will
  // be run when exiting the current state. If a state (or state group) does
  // not have an exit handler, then the entry for that level may be
  // `undefined`, but there will be an explicit entry in the stack for it.
  //
  // This will always be true:
  //
  //   cleanupStack.length == currentState.split('.').length + 1
  //
  // Each stack level represents a different state "group".
  //
  // For example, if you are in a state named `foo.bar.qux`, then the stack
  // will contain the exit handler for `foo.bar.qux` (at the top), then
  // `foo.bar.*`, then `foo.*`, and finally, `*`.
  //
  #cleanupStack;
  #enterFns;
  // Used to provide better error messages
  #knownEventTypes;
  /**
   * Returns the initial state, which is defined by the first call made to
   * .addState().
   */
  get #initialState() {
    const result = this.#states.values()[Symbol.iterator]().next();
    if (result.done) {
      throw new Error("No states defined yet");
    } else {
      return result.value;
    }
  }
  get currentState() {
    if (this.#currentStateOrNull === null) {
      if (this.#runningState === 0 /* NOT_STARTED_YET */) {
        throw new Error("Not started yet");
      } else {
        throw new Error("Already stopped");
      }
    }
    return this.#currentStateOrNull;
  }
  /**
   * Starts the machine by entering the initial state.
   */
  start() {
    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {
      throw new Error("State machine has already started");
    }
    this.#runningState = 1 /* STARTED */;
    this.#currentStateOrNull = this.#initialState;
    this.#enter(null);
    return this;
  }
  /**
   * Stops the state machine. Stopping the state machine will call exit
   * handlers for the current state, but not enter a new state.
   */
  stop() {
    if (this.#runningState !== 1 /* STARTED */) {
      throw new Error("Cannot stop a state machine that hasn't started yet");
    }
    this.#exit(null);
    this.#runningState = 2 /* STOPPED */;
    this.#currentStateOrNull = null;
  }
  constructor(initialContext) {
    this.id = nextId++;
    this.#runningState = 0 /* NOT_STARTED_YET */;
    this.#currentStateOrNull = null;
    this.#states = /* @__PURE__ */ new Set();
    this.#enterFns = /* @__PURE__ */ new Map();
    this.#cleanupStack = [];
    this.#knownEventTypes = /* @__PURE__ */ new Set();
    this.#allowedTransitions = /* @__PURE__ */ new Map();
    this.#currentContext = new SafeContext(initialContext);
    this.#eventHub = {
      didReceiveEvent: makeEventSource(),
      willTransition: makeEventSource(),
      didIgnoreEvent: makeEventSource(),
      willExitState: makeEventSource(),
      didEnterState: makeEventSource()
    };
    this.events = {
      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,
      willTransition: this.#eventHub.willTransition.observable,
      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,
      willExitState: this.#eventHub.willExitState.observable,
      didEnterState: this.#eventHub.didEnterState.observable
    };
  }
  get context() {
    return this.#currentContext.current;
  }
  /**
   * Define an explicit finite state in the state machine.
   */
  addState(state) {
    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {
      throw new Error("Already started");
    }
    this.#states.add(state);
    return this;
  }
  onEnter(nameOrPattern, enterFn) {
    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {
      throw new Error("Already started");
    } else if (this.#enterFns.has(nameOrPattern)) {
      throw new Error(
        // TODO We _currently_ don't support multiple .onEnters() for the same
        // state, but this is not a fundamental limitation. Just not
        // implemented yet. If we wanted to, we could make this an array.
        `enter/exit function for ${nameOrPattern} already exists`
      );
    }
    this.#enterFns.set(nameOrPattern, enterFn);
    return this;
  }
  /**
   * Defines a promise-based state. When the state is entered, the promise is
   * created. When the promise resolves, the machine will transition to the
   * provided `onOK` target state. When the promise rejects, the machine will
   * transition to the `onError` target state.
   *
   * Optionally, a `maxTimeout` can be set. If the timeout happens before the
   * promise is settled, then the machine will also transition to the `onError`
   * target state.
   *
   * @param stateOrPattern  The state name, or state group pattern name.
   * @param promiseFn       The callback to be invoked when the state is entered.
   * @param onOK            The state to transition to when the promise resolves.
   * @param onError         The state to transition to when the promise
   *                        rejects, or when the timeout happens before the
   *                        promise has been settled.
   * @param maxTimeout      Optional timeout in milliseconds.
   *
   * When the promise callback function is invoked, it's provided with an
   * AbortSignal (2nd argument).
   * If a state transition happens while the promise is pending (for example,
   * an event, or a timeout happens), then an abort signal will be used to
   * indicate this. Implementers can use this abort signal to terminate the
   * in-flight promise, or ignore its results, etc.
   */
  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {
    return this.onEnter(nameOrPattern, () => {
      const abortController = new AbortController();
      const signal = abortController.signal;
      const timeoutId = maxTimeout ? setTimeout(() => {
        const reason = new Error("Timed out");
        this.#transition({ type: "ASYNC_ERROR", reason }, onError);
      }, maxTimeout) : void 0;
      let done = false;
      void promiseFn(this.#currentContext.current, signal).then(
        // On OK
        (data) => {
          if (!signal.aborted) {
            done = true;
            this.#transition({ type: "ASYNC_OK", data }, onOK);
          }
        },
        // On Error
        (reason) => {
          if (!signal.aborted) {
            done = true;
            this.#transition({ type: "ASYNC_ERROR", reason }, onError);
          }
        }
      );
      return () => {
        clearTimeout(timeoutId);
        if (!done) {
          abortController.abort();
        }
      };
    });
  }
  #getStatesMatching(nameOrPattern) {
    const matches = [];
    if (nameOrPattern === "*") {
      for (const state of this.#states) {
        matches.push(state);
      }
    } else if (nameOrPattern.endsWith(".*")) {
      const prefix = nameOrPattern.slice(0, -1);
      for (const state of this.#states) {
        if (state.startsWith(prefix)) {
          matches.push(state);
        }
      }
    } else {
      const name = nameOrPattern;
      if (this.#states.has(name)) {
        matches.push(name);
      }
    }
    if (matches.length === 0) {
      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);
    }
    return matches;
  }
  /**
   * Define all allowed outgoing transitions for a state.
   *
   * The targets for each event can be defined as a function which returns the
   * next state to transition to. These functions can look at the `event` or
   * `context` params to conditionally decide which next state to transition
   * to.
   *
   * If you set it to `null`, then the transition will be explicitly forbidden
   * and throw an error. If you don't define a target for a transition, then
   * such events will get ignored.
   */
  addTransitions(nameOrPattern, mapping) {
    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {
      throw new Error("Already started");
    }
    for (const srcState of this.#getStatesMatching(nameOrPattern)) {
      let map = this.#allowedTransitions.get(srcState);
      if (map === void 0) {
        map = /* @__PURE__ */ new Map();
        this.#allowedTransitions.set(srcState, map);
      }
      for (const [type, target_] of Object.entries(mapping)) {
        if (map.has(type)) {
          throw new Error(
            `Trying to set transition "${type}" on "${srcState}" (via "${nameOrPattern}"), but a transition already exists there.`
          );
        }
        const target = target_;
        this.#knownEventTypes.add(type);
        if (target !== void 0) {
          const targetFn = typeof target === "function" ? target : () => target;
          map.set(type, targetFn);
        }
      }
    }
    return this;
  }
  /**
   * Like `.addTransition()`, but takes an (anonymous) transition whenever the
   * timer fires.
   *
   * @param stateOrPattern  The state name, or state group pattern name.
   * @param after           Number of milliseconds after which to take the
   *                        transition. If in the mean time, another transition
   *                        is taken, the timer will get cancelled.
   * @param target          The target state to go to.
   */
  addTimedTransition(stateOrPattern, after2, target) {
    return this.onEnter(stateOrPattern, () => {
      const ms = typeof after2 === "function" ? after2(this.#currentContext.current) : after2;
      const timeoutID = setTimeout(() => {
        this.#transition({ type: "TIMER" }, target);
      }, ms);
      return () => {
        clearTimeout(timeoutID);
      };
    });
  }
  #getTargetFn(eventName) {
    return this.#allowedTransitions.get(this.currentState)?.get(eventName);
  }
  /**
   * Exits the current state, and executes any necessary cleanup functions.
   * Call this before changing the current state to the next state.
   *
   * @param levels Defines how many "levels" of nesting will be
   * exited. For example, if you transition from `foo.bar.qux` to
   * `foo.bar.baz`, then the level is 1. But if you transition from
   * `foo.bar.qux` to `bla.bla`, then the level is 3.
   * If `null`, it will exit all levels.
   */
  #exit(levels) {
    this.#eventHub.willExitState.notify(this.currentState);
    this.#currentContext.allowPatching((patchableContext) => {
      levels = levels ?? this.#cleanupStack.length;
      for (let i = 0; i < levels; i++) {
        this.#cleanupStack.pop()?.(patchableContext);
      }
    });
  }
  /**
   * Enters the current state, and executes any necessary onEnter handlers.
   * Call this directly _after_ setting the current state to the next state.
   */
  #enter(levels) {
    const enterPatterns = patterns(
      this.currentState,
      levels ?? this.currentState.split(".").length + 1
    );
    this.#currentContext.allowPatching((patchableContext) => {
      for (const pattern of enterPatterns) {
        const enterFn = this.#enterFns.get(pattern);
        const cleanupFn = enterFn?.(patchableContext);
        if (typeof cleanupFn === "function") {
          this.#cleanupStack.push(cleanupFn);
        } else {
          this.#cleanupStack.push(null);
        }
      }
    });
    this.#eventHub.didEnterState.notify(this.currentState);
  }
  /**
   * Sends an event to the machine, which may cause an internal state
   * transition to happen. When that happens, will trigger side effects.
   */
  send(event) {
    if (!this.#knownEventTypes.has(event.type)) {
      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);
    }
    if (this.#runningState === 2 /* STOPPED */) {
      return;
    }
    const targetFn = this.#getTargetFn(event.type);
    if (targetFn !== void 0) {
      return this.#transition(event, targetFn);
    } else {
      this.#eventHub.didIgnoreEvent.notify(event);
    }
  }
  #transition(event, target) {
    this.#eventHub.didReceiveEvent.notify(event);
    const oldState = this.currentState;
    const targetFn = typeof target === "function" ? target : () => target;
    const nextTarget = targetFn(event, this.#currentContext.current);
    let nextState;
    let effects = void 0;
    if (nextTarget === null) {
      this.#eventHub.didIgnoreEvent.notify(event);
      return;
    }
    if (typeof nextTarget === "string") {
      nextState = nextTarget;
    } else {
      nextState = nextTarget.target;
      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];
    }
    if (!this.#states.has(nextState)) {
      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);
    }
    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });
    const [up, down] = distance(this.currentState, nextState);
    if (up > 0) {
      this.#exit(up);
    }
    this.#currentStateOrNull = nextState;
    if (effects !== void 0) {
      const effectsToRun = effects;
      this.#currentContext.allowPatching((patchableContext) => {
        for (const effect of effectsToRun) {
          if (typeof effect === "function") {
            effect(patchableContext, event);
          } else {
            patchableContext.patch(effect);
          }
        }
      });
    }
    if (down > 0) {
      this.#enter(down);
    }
  }
};

// src/protocol/ServerMsg.ts
var ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {
  ServerMsgCode2[ServerMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ServerMsgCode2[ServerMsgCode2["USER_JOINED"] = 101] = "USER_JOINED";
  ServerMsgCode2[ServerMsgCode2["USER_LEFT"] = 102] = "USER_LEFT";
  ServerMsgCode2[ServerMsgCode2["BROADCASTED_EVENT"] = 103] = "BROADCASTED_EVENT";
  ServerMsgCode2[ServerMsgCode2["ROOM_STATE"] = 104] = "ROOM_STATE";
  ServerMsgCode2[ServerMsgCode2["INITIAL_STORAGE_STATE"] = 200] = "INITIAL_STORAGE_STATE";
  ServerMsgCode2[ServerMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  ServerMsgCode2[ServerMsgCode2["REJECT_STORAGE_OP"] = 299] = "REJECT_STORAGE_OP";
  ServerMsgCode2[ServerMsgCode2["UPDATE_YDOC"] = 300] = "UPDATE_YDOC";
  ServerMsgCode2[ServerMsgCode2["THREAD_CREATED"] = 400] = "THREAD_CREATED";
  ServerMsgCode2[ServerMsgCode2["THREAD_DELETED"] = 407] = "THREAD_DELETED";
  ServerMsgCode2[ServerMsgCode2["THREAD_METADATA_UPDATED"] = 401] = "THREAD_METADATA_UPDATED";
  ServerMsgCode2[ServerMsgCode2["THREAD_UPDATED"] = 408] = "THREAD_UPDATED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_CREATED"] = 402] = "COMMENT_CREATED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_EDITED"] = 403] = "COMMENT_EDITED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_DELETED"] = 404] = "COMMENT_DELETED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_REACTION_ADDED"] = 405] = "COMMENT_REACTION_ADDED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_REACTION_REMOVED"] = 406] = "COMMENT_REACTION_REMOVED";
  return ServerMsgCode2;
})(ServerMsgCode || {});

// src/types/IWebSocket.ts
var WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_NORMAL"] = 1e3] = "CLOSE_NORMAL";
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_ABNORMAL"] = 1006] = "CLOSE_ABNORMAL";
  WebsocketCloseCodes2[WebsocketCloseCodes2["UNEXPECTED_CONDITION"] = 1011] = "UNEXPECTED_CONDITION";
  WebsocketCloseCodes2[WebsocketCloseCodes2["TRY_AGAIN_LATER"] = 1013] = "TRY_AGAIN_LATER";
  WebsocketCloseCodes2[WebsocketCloseCodes2["INVALID_MESSAGE_FORMAT"] = 4e3] = "INVALID_MESSAGE_FORMAT";
  WebsocketCloseCodes2[WebsocketCloseCodes2["NOT_ALLOWED"] = 4001] = "NOT_ALLOWED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_SECONDS"] = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS"] = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP"] = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM"] = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM";
  WebsocketCloseCodes2[WebsocketCloseCodes2["ROOM_ID_UPDATED"] = 4006] = "ROOM_ID_UPDATED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["KICKED"] = 4100] = "KICKED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["TOKEN_EXPIRED"] = 4109] = "TOKEN_EXPIRED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_WITHOUT_RETRY"] = 4999] = "CLOSE_WITHOUT_RETRY";
  return WebsocketCloseCodes2;
})(WebsocketCloseCodes || {});
function shouldDisconnect(code) {
  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;
}
function shouldReauth(code) {
  return code >= 4100 && code < 4200;
}
function shouldRetryWithoutReauth(code) {
  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;
}

// src/connection.ts
function isIdle(status) {
  return status === "initial" || status === "disconnected";
}
function toNewConnectionStatus(machine) {
  const state = machine.currentState;
  switch (state) {
    case "@ok.connected":
    case "@ok.awaiting-pong":
      return "connected";
    case "@idle.initial":
      return "initial";
    case "@auth.busy":
    case "@auth.backoff":
    case "@connecting.busy":
    case "@connecting.backoff":
    case "@idle.zombie":
      return machine.context.successCount > 0 ? "reconnecting" : "connecting";
    case "@idle.failed":
      return "disconnected";
    // istanbul ignore next
    default:
      return assertNever(state, "Unknown state");
  }
}
var BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];
var RESET_DELAY = BACKOFF_DELAYS[0] - 1;
var BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];
var HEARTBEAT_INTERVAL = 3e4;
var PONG_TIMEOUT = 2e3;
var AUTH_TIMEOUT = 1e4;
var SOCKET_CONNECT_TIMEOUT = 1e4;
var StopRetrying = class extends Error {
  constructor(reason) {
    super(reason);
  }
};
function nextBackoffDelay(currentDelay, delays) {
  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];
}
function increaseBackoffDelay(context) {
  context.patch({
    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)
  });
}
function increaseBackoffDelayAggressively(context) {
  context.patch({
    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)
  });
}
function resetSuccessCount(context) {
  context.patch({ successCount: 0 });
}
function log(level, message) {
  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (
    /* black hole */
    () => {
    }
  );
  return () => {
    logger(message);
  };
}
function logPrematureErrorOrCloseEvent(e) {
  const conn = "Connection to Liveblocks websocket server";
  return (ctx) => {
    if (e instanceof Error) {
      warn(`${conn} could not be established. ${String(e)}`);
    } else {
      warn(
        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`
      );
    }
  };
}
function logCloseEvent(event) {
  const details = [`code: ${event.code}`];
  if (event.reason) {
    details.push(`reason: ${event.reason}`);
  }
  return (ctx) => {
    warn(
      `Connection to Liveblocks websocket server closed (${details.join(", ")}). Retrying in ${ctx.backoffDelay}ms.`
    );
  };
}
var logPermanentClose = log(
  1 /* WARN */,
  "Connection to WebSocket closed permanently. Won't retry."
);
function isCloseEvent(error3) {
  return !(error3 instanceof Error) && error3.type === "close";
}
function enableTracing(machine) {
  const start = (/* @__PURE__ */ new Date()).getTime();
  function log2(...args) {
    warn(
      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,
      ...args
    );
  }
  const unsubs = [
    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),
    machine.events.willTransition.subscribe(
      ({ from, to }) => log2("Transitioning", from, "\u2192", to)
    ),
    machine.events.didIgnoreEvent.subscribe(
      (e) => log2("Ignored event", e.type, e, "(current state won't handle it)")
    )
    // machine.events.willExitState.subscribe((s) => log("Exiting state", s)),
    // machine.events.didEnterState.subscribe((s) => log("Entering state", s)),
  ];
  return () => {
    for (const unsub of unsubs) {
      unsub();
    }
  };
}
function defineConnectivityEvents(machine) {
  const statusDidChange = makeEventSource();
  const didConnect = makeEventSource();
  const didDisconnect = makeEventSource();
  let lastStatus = null;
  const unsubscribe = machine.events.didEnterState.subscribe(() => {
    const currStatus = toNewConnectionStatus(machine);
    if (currStatus !== lastStatus) {
      statusDidChange.notify(currStatus);
    }
    if (lastStatus === "connected" && currStatus !== "connected") {
      didDisconnect.notify();
    } else if (lastStatus !== "connected" && currStatus === "connected") {
      didConnect.notify();
    }
    lastStatus = currStatus;
  });
  return {
    statusDidChange: statusDidChange.observable,
    didConnect: didConnect.observable,
    didDisconnect: didDisconnect.observable,
    unsubscribe
  };
}
var assign = (patch) => (ctx) => ctx.patch(patch);
function createConnectionStateMachine(delegates, options) {
  const onMessage = makeBufferableEventSource();
  onMessage.pause();
  const onConnectionError = makeEventSource();
  function fireErrorEvent(message, code) {
    return () => {
      onConnectionError.notify({ message, code });
    };
  }
  const initialContext = {
    successCount: 0,
    authValue: null,
    socket: null,
    backoffDelay: RESET_DELAY
  };
  const machine = new FSM(initialContext).addState("@idle.initial").addState("@idle.failed").addState("@idle.zombie").addState("@auth.busy").addState("@auth.backoff").addState("@connecting.busy").addState("@connecting.backoff").addState("@ok.connected").addState("@ok.awaiting-pong");
  machine.addTransitions("*", {
    RECONNECT: {
      target: "@auth.backoff",
      effect: [increaseBackoffDelay, resetSuccessCount]
    },
    DISCONNECT: "@idle.initial"
  });
  machine.onEnter("@idle.*", resetSuccessCount).addTransitions("@idle.*", {
    CONNECT: (_, ctx) => (
      // If we still have a known authValue, try to reconnect to the socket directly,
      // otherwise, try to obtain a new authValue
      ctx.authValue !== null ? "@connecting.busy" : "@auth.busy"
    )
  });
  machine.addTransitions("@auth.backoff", {
    NAVIGATOR_ONLINE: {
      target: "@auth.busy",
      effect: assign({ backoffDelay: RESET_DELAY })
    }
  }).addTimedTransition(
    "@auth.backoff",
    (ctx) => ctx.backoffDelay,
    "@auth.busy"
  ).onEnterAsync(
    "@auth.busy",
    () => withTimeout(
      delegates.authenticate(),
      AUTH_TIMEOUT,
      "Timed out during auth"
    ),
    // On successful authentication
    (okEvent) => ({
      target: "@connecting.busy",
      effect: assign({
        authValue: okEvent.data
      })
    }),
    // Auth failed
    (failedEvent) => {
      if (failedEvent.reason instanceof StopRetrying) {
        return {
          target: "@idle.failed",
          effect: [
            log(2 /* ERROR */, failedEvent.reason.message),
            fireErrorEvent(failedEvent.reason.message, -1)
          ]
        };
      }
      return {
        target: "@auth.backoff",
        effect: [
          increaseBackoffDelay,
          log(
            2 /* ERROR */,
            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`
          )
        ]
      };
    }
  );
  const onSocketError = (event) => machine.send({ type: "EXPLICIT_SOCKET_ERROR", event });
  const onSocketClose = (event) => machine.send({ type: "EXPLICIT_SOCKET_CLOSE", event });
  const onSocketMessage = (event) => event.data === "pong" ? machine.send({ type: "PONG" }) : onMessage.notify(event);
  function teardownSocket(socket) {
    if (socket) {
      socket.removeEventListener("error", onSocketError);
      socket.removeEventListener("close", onSocketClose);
      socket.removeEventListener("message", onSocketMessage);
      socket.close();
    }
  }
  machine.addTransitions("@connecting.backoff", {
    NAVIGATOR_ONLINE: {
      target: "@connecting.busy",
      effect: assign({ backoffDelay: RESET_DELAY })
    }
  }).addTimedTransition(
    "@connecting.backoff",
    (ctx) => ctx.backoffDelay,
    "@connecting.busy"
  ).onEnterAsync(
    "@connecting.busy",
    //
    // Use the "createSocket" delegate function (provided to the
    // ManagedSocket) to create the actual WebSocket connection instance.
    // Then, set up all the necessary event listeners, and wait for the
    // "open" event to occur.
    //
    // When the "open" event happens, we're ready to transition to the
    // OK state. This is done by resolving the Promise.
    //
    async (ctx, signal) => {
      let capturedPrematureEvent = null;
      let unconfirmedSocket = null;
      const connect$ = new Promise(
        (resolve, rej) => {
          if (ctx.authValue === null) {
            throw new Error("No auth authValue");
          }
          const socket = delegates.createSocket(ctx.authValue);
          unconfirmedSocket = socket;
          function reject(event) {
            capturedPrematureEvent = event;
            socket.removeEventListener("message", onSocketMessage);
            rej(event);
          }
          const [actor$, didReceiveActor] = controlledPromise();
          if (!options.waitForActorId) {
            didReceiveActor();
          }
          function waitForActorId(event) {
            const serverMsg = tryParseJson(event.data);
            if (serverMsg?.type === 104 /* ROOM_STATE */) {
              didReceiveActor();
            }
          }
          socket.addEventListener("message", onSocketMessage);
          if (options.waitForActorId) {
            socket.addEventListener("message", waitForActorId);
          }
          socket.addEventListener("error", reject);
          socket.addEventListener("close", reject);
          socket.addEventListener("open", () => {
            socket.addEventListener("error", onSocketError);
            socket.addEventListener("close", onSocketClose);
            const unsub = () => {
              socket.removeEventListener("error", reject);
              socket.removeEventListener("close", reject);
              socket.removeEventListener("message", waitForActorId);
            };
            void actor$.then(() => {
              resolve([socket, unsub]);
            });
          });
        }
      );
      return withTimeout(
        connect$,
        SOCKET_CONNECT_TIMEOUT,
        "Timed out during websocket connection"
      ).then(
        //
        // Part 3:
        // By now, our "open" event has fired, and the promise has been
        // resolved. Two possible scenarios:
        //
        // 1. The happy path. Most likely.
        // 2. Uh-oh. A premature close/error event has been observed. Let's
        //    reject the promise after all.
        //
        // Any close/error event that will get scheduled after this point
        // onwards, will be caught in the OK state, and dealt with
        // accordingly.
        //
        ([socket, unsub]) => {
          unsub();
          if (signal.aborted) {
            throw new Error("Aborted");
          }
          if (capturedPrematureEvent) {
            throw capturedPrematureEvent;
          }
          return socket;
        }
      ).catch((e) => {
        teardownSocket(unconfirmedSocket);
        throw e;
      });
    },
    // Only transition to OK state after a successfully opened WebSocket connection
    (okEvent) => ({
      target: "@ok.connected",
      effect: assign({
        socket: okEvent.data,
        backoffDelay: RESET_DELAY
      })
    }),
    // If the WebSocket connection cannot be established
    (failure) => {
      const err = failure.reason;
      if (err instanceof StopRetrying) {
        return {
          target: "@idle.failed",
          effect: [
            log(2 /* ERROR */, err.message),
            fireErrorEvent(err.message, -1)
          ]
        };
      }
      if (isCloseEvent(err)) {
        if (err.code === 4109 /* TOKEN_EXPIRED */) {
          return "@auth.busy";
        }
        if (shouldRetryWithoutReauth(err.code)) {
          return {
            target: "@connecting.backoff",
            effect: [
              increaseBackoffDelayAggressively,
              logPrematureErrorOrCloseEvent(err)
            ]
          };
        }
        if (shouldDisconnect(err.code)) {
          return {
            target: "@idle.failed",
            effect: [
              log(2 /* ERROR */, err.reason),
              fireErrorEvent(err.reason, err.code)
            ]
          };
        }
      }
      return {
        target: "@auth.backoff",
        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]
      };
    }
  );
  const sendHeartbeat = {
    target: "@ok.awaiting-pong",
    effect: (ctx) => {
      ctx.socket?.send("ping");
    }
  };
  const maybeHeartbeat = () => {
    const doc = typeof document !== "undefined" ? document : void 0;
    const canZombie = doc?.visibilityState === "hidden" && delegates.canZombie();
    return canZombie ? "@idle.zombie" : sendHeartbeat;
  };
  machine.addTimedTransition("@ok.connected", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions("@ok.connected", {
    NAVIGATOR_OFFLINE: maybeHeartbeat,
    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.
    WINDOW_GOT_FOCUS: sendHeartbeat
  });
  machine.addTransitions("@idle.zombie", {
    WINDOW_GOT_FOCUS: "@connecting.backoff"
    // When in zombie state, the client will try to wake up automatically when the window regains focus
  });
  machine.onEnter("@ok.*", (ctx) => {
    ctx.patch({ successCount: ctx.successCount + 1 });
    const timerID = setTimeout(
      // On the next tick, start delivering all messages that have already
      // been received, and continue synchronous delivery of all future
      // incoming messages.
      onMessage.unpause,
      0
    );
    return (ctx2) => {
      teardownSocket(ctx2.socket);
      ctx2.patch({ socket: null });
      clearTimeout(timerID);
      onMessage.pause();
    };
  }).addTransitions("@ok.awaiting-pong", { PONG: "@ok.connected" }).addTimedTransition("@ok.awaiting-pong", PONG_TIMEOUT, {
    target: "@connecting.busy",
    // Log implicit connection loss and drop the current open socket
    effect: log(
      1 /* WARN */,
      "Received no pong from server, assume implicit connection loss."
    )
  }).addTransitions("@ok.*", {
    // When a socket receives an error, this can cause the closing of the
    // socket, or not. So always check to see if the socket is still OPEN or
    // not. When still OPEN, don't transition.
    EXPLICIT_SOCKET_ERROR: (_, context) => {
      if (context.socket?.readyState === 1) {
        return null;
      }
      return {
        target: "@connecting.backoff",
        effect: increaseBackoffDelay
      };
    },
    EXPLICIT_SOCKET_CLOSE: (e) => {
      if (shouldDisconnect(e.event.code)) {
        return {
          target: "@idle.failed",
          effect: [
            logPermanentClose,
            fireErrorEvent(e.event.reason, e.event.code)
          ]
        };
      }
      if (shouldReauth(e.event.code)) {
        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {
          return "@auth.busy";
        } else {
          return {
            target: "@auth.backoff",
            effect: [increaseBackoffDelay, logCloseEvent(e.event)]
          };
        }
      }
      if (shouldRetryWithoutReauth(e.event.code)) {
        return {
          target: "@connecting.backoff",
          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]
        };
      }
      return {
        target: "@connecting.backoff",
        effect: [increaseBackoffDelay, logCloseEvent(e.event)]
      };
    }
  });
  if (typeof document !== "undefined") {
    const doc = typeof document !== "undefined" ? document : void 0;
    const win = typeof window !== "undefined" ? window : void 0;
    const root = win ?? doc;
    machine.onEnter("*", (ctx) => {
      function onNetworkOffline() {
        machine.send({ type: "NAVIGATOR_OFFLINE" });
      }
      function onNetworkBackOnline() {
        machine.send({ type: "NAVIGATOR_ONLINE" });
      }
      function onVisibilityChange() {
        if (doc?.visibilityState === "visible") {
          machine.send({ type: "WINDOW_GOT_FOCUS" });
        }
      }
      win?.addEventListener("online", onNetworkBackOnline);
      win?.addEventListener("offline", onNetworkOffline);
      root?.addEventListener("visibilitychange", onVisibilityChange);
      return () => {
        root?.removeEventListener("visibilitychange", onVisibilityChange);
        win?.removeEventListener("online", onNetworkBackOnline);
        win?.removeEventListener("offline", onNetworkOffline);
        teardownSocket(ctx.socket);
      };
    });
  }
  const cleanups = [];
  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);
  cleanups.push(unsubscribe);
  if (options.enableDebugLogging) {
    cleanups.push(enableTracing(machine));
  }
  machine.start();
  return {
    machine,
    cleanups,
    // Observable events that will be emitted by this machine
    events: {
      statusDidChange,
      didConnect,
      didDisconnect,
      onMessage: onMessage.observable,
      onConnectionError: onConnectionError.observable
    }
  };
}
var ManagedSocket = class {
  #machine;
  #cleanups;
  events;
  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {
    const { machine, events, cleanups } = createConnectionStateMachine(
      delegates,
      { waitForActorId, enableDebugLogging }
    );
    this.#machine = machine;
    this.events = events;
    this.#cleanups = cleanups;
  }
  getStatus() {
    try {
      return toNewConnectionStatus(this.#machine);
    } catch {
      return "initial";
    }
  }
  /**
   * Returns the current auth authValue.
   */
  get authValue() {
    return this.#machine.context.authValue;
  }
  /**
   * Call this method to try to connect to a WebSocket. This only has an effect
   * if the machine is idle at the moment, otherwise this is a no-op.
   */
  connect() {
    this.#machine.send({ type: "CONNECT" });
  }
  /**
   * If idle, will try to connect. Otherwise, it will attempt to reconnect to
   * the socket, potentially obtaining a new authValue first, if needed.
   */
  reconnect() {
    this.#machine.send({ type: "RECONNECT" });
  }
  /**
   * Call this method to disconnect from the current WebSocket. Is going to be
   * a no-op if there is no active connection.
   */
  disconnect() {
    this.#machine.send({ type: "DISCONNECT" });
  }
  /**
   * Call this to stop the machine and run necessary cleanup functions. After
   * calling destroy(), you can no longer use this instance. Call this before
   * letting the instance get garbage collected.
   */
  destroy() {
    this.#machine.stop();
    let cleanup;
    while (cleanup = this.#cleanups.pop()) {
      cleanup();
    }
  }
  /**
   * Safely send a message to the current WebSocket connection. Will emit a log
   * message if this is somehow impossible.
   */
  send(data) {
    const socket = this.#machine.context?.socket;
    if (socket === null) {
      warn("Cannot send: not connected yet", data);
    } else if (socket.readyState !== 1) {
      warn("Cannot send: WebSocket no longer open", data);
    } else {
      socket.send(data);
    }
  }
  /**
   * NOTE: Used by the E2E app only, to simulate explicit events.
   * Not ideal to keep exposed :(
   */
  _privateSendMachineEvent(event) {
    this.#machine.send(event);
  }
};

// src/internal.ts
var kInternal = Symbol();

// src/lib/shallow.ts
function shallowArray(xs, ys) {
  if (xs.length !== ys.length) {
    return false;
  }
  for (let i = 0; i < xs.length; i++) {
    if (!Object.is(xs[i], ys[i])) {
      return false;
    }
  }
  return true;
}
function shallowObj(objA, objB) {
  if (!isPlainObject(objA) || !isPlainObject(objB)) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])
  );
}
function shallow(a, b) {
  if (Object.is(a, b)) {
    return true;
  }
  const isArrayA = Array.isArray(a);
  const isArrayB = Array.isArray(b);
  if (isArrayA || isArrayB) {
    if (!isArrayA || !isArrayB) {
      return false;
    }
    return shallowArray(a, b);
  }
  return shallowObj(a, b);
}
function shallow2(a, b) {
  if (!isPlainObject(a) || !isPlainObject(b)) {
    return shallow(a, b);
  }
  const keysA = Object.keys(a);
  if (keysA.length !== Object.keys(b).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])
  );
}

// src/lib/TreePool.ts
var TreePool = class {
  #_items;
  #_childrenOf;
  #_sorted;
  #_primaryKey;
  #_parentKeyFn;
  #_lt;
  constructor(primaryKey, parentKey, lt) {
    this.#_primaryKey = primaryKey;
    this.#_parentKeyFn = parentKey;
    this.#_lt = lt;
    this.#_items = /* @__PURE__ */ new Map();
    this.#_childrenOf = new DefaultMap(() => /* @__PURE__ */ new Set());
    this.#_sorted = SortedList.with(lt);
  }
  get(id) {
    return this.#_items.get(id);
  }
  getOrThrow(id) {
    return this.get(id) ?? raise(`Item with id ${id} not found`);
  }
  get sorted() {
    return this.#_sorted;
  }
  getParentId(id) {
    const item = this.getOrThrow(id);
    return this.#_parentKeyFn(item);
  }
  getParent(id) {
    const parentId = this.getParentId(id);
    return parentId ? this.getOrThrow(parentId) : null;
  }
  getChildren(id) {
    const childIds = this.#_childrenOf.get(id);
    if (!childIds) return [];
    return Array.from(childIds).map(
      (id2) => this.#_items.get(id2)
      // eslint-disable-line no-restricted-syntax
    );
  }
  *walkUp(id, predicate) {
    const includeSelf = true;
    let nodeId = id;
    do {
      const item = this.getOrThrow(nodeId);
      if (includeSelf || nodeId !== id) {
        if (!predicate || predicate(item)) {
          yield item;
        }
      }
      nodeId = this.#_parentKeyFn(item);
    } while (nodeId !== null);
  }
  // XXXX Generalize
  *walkLeft(id, predicate) {
    const self = this.getOrThrow(id);
    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);
    for (const sibling of siblings.iterReversed()) {
      if (this.#_lt(self, sibling)) continue;
      if (!predicate || predicate(sibling)) {
        yield sibling;
      }
    }
  }
  // XXXX Generalize
  *walkRight(id, predicate) {
    const self = this.getOrThrow(id);
    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);
    for (const sibling of siblings) {
      if (this.#_lt(sibling, self)) continue;
      if (!predicate || predicate(sibling)) {
        yield sibling;
      }
    }
  }
  // XXXX Generalize
  *walkDown(id, predicate) {
    const children = SortedList.from(this.getChildren(id), this.#_lt).rawArray;
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      yield* this.walkDown(
        this.#_primaryKey(child),
        predicate
        // "depth-first",
        // true
      );
      if (!predicate || predicate(child)) {
        yield child;
      }
    }
  }
  /** Returns all siblings, not including the item itself. */
  getSiblings(id) {
    const self = this.getOrThrow(id);
    const parentId = this.getParentId(id);
    return this.getChildren(parentId).filter((item) => item !== self);
  }
  [Symbol.iterator]() {
    return this.#_sorted[Symbol.iterator]();
  }
  upsert(item) {
    const pk = this.#_primaryKey(item);
    const existing = this.#_items.get(pk);
    if (existing) {
      if (this.#_parentKeyFn(existing) !== this.#_parentKeyFn(item)) {
        throw new Error(
          "Cannot upsert parent ID changes that change the tree structure. Remove the entry first, and recreate it"
        );
      }
      this.#_sorted.remove(existing);
    }
    this.#_items.set(pk, item);
    this.#_sorted.add(item);
    const parentId = this.#_parentKeyFn(item);
    this.#_childrenOf.getOrCreate(parentId).add(pk);
  }
  remove(pk) {
    const item = this.#_items.get(pk);
    if (!item) return false;
    const childIds = this.#_childrenOf.get(pk);
    if (childIds) {
      throw new Error(
        `Cannot remove item '${pk}' while it still has children. Remove children first.`
      );
    }
    const parentId = this.#_parentKeyFn(item);
    const siblings = this.#_childrenOf.get(parentId);
    if (siblings) {
      siblings.delete(pk);
      if (siblings.size === 0) {
        this.#_childrenOf.delete(parentId);
      }
    }
    this.#_sorted.remove(item);
    this.#_childrenOf.delete(pk);
    this.#_items.delete(pk);
    return true;
  }
  clear() {
    if (this.#_items.size === 0) return false;
    this.#_childrenOf.clear();
    this.#_items.clear();
    this.#_sorted.clear();
    return true;
  }
};

// src/protocol/AuthToken.ts
var Permission = /* @__PURE__ */ ((Permission2) => {
  Permission2["Read"] = "room:read";
  Permission2["Write"] = "room:write";
  Permission2["PresenceWrite"] = "room:presence:write";
  Permission2["CommentsWrite"] = "comments:write";
  Permission2["CommentsRead"] = "comments:read";
  return Permission2;
})(Permission || {});
function canWriteStorage(scopes) {
  return scopes.includes("room:write" /* Write */);
}
function canComment(scopes) {
  return scopes.includes("comments:write" /* CommentsWrite */) || scopes.includes("room:write" /* Write */);
}
function isValidAuthTokenPayload(data) {
  return isPlainObject(data) && (data.k === "acc" /* ACCESS_TOKEN */ || data.k === "id" /* ID_TOKEN */ || data.k === "sec-legacy" /* SECRET_LEGACY */);
}
function parseAuthToken(rawTokenString) {
  const tokenParts = rawTokenString.split(".");
  if (tokenParts.length !== 3) {
    throw new Error("Authentication error: invalid JWT token");
  }
  const payload = tryParseJson(b64decode(tokenParts[1]));
  if (!(payload && isValidAuthTokenPayload(payload))) {
    throw new Error(
      "Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
    );
  }
  return {
    raw: rawTokenString,
    parsed: payload
  };
}

// src/lib/IncrementalJsonParser.ts
var EMPTY_OBJECT = Object.freeze({});
var NULL_KEYWORD_CHARS = Array.from(new Set("null"));
var TRUE_KEYWORD_CHARS = Array.from(new Set("true"));
var FALSE_KEYWORD_CHARS = Array.from(new Set("false"));
var ALL_KEYWORD_CHARS = Array.from(new Set("nulltruefalse"));
function stripChar(str, chars) {
  const lastChar = str[str.length - 1];
  if (chars.includes(lastChar)) {
    return str.slice(0, -1);
  }
  return str;
}
var IncrementalJsonParser = class {
  // Input
  #sourceText = "";
  // Output
  #cachedJson;
  /** How much we've already parsed */
  #scanIndex = 0;
  /** Whether the last char processed was a backslash */
  #escaped = false;
  /**
   * Start position of the last unterminated string, -1 if we're not inside
   * a string currently.
   *
   * Example: '{"a": "foo'
   *                 ^
   */
  #lastUnterminatedString = -1;
  /**
   * Start position of the last fully terminated string we've seen.
   *
   * Example: '{"a": "foo'
   *            ^
   */
  #lastTerminatedString = -1;
  /** The bracket stack of expected closing chars. For input '{"a": ["foo', the stack would be ['}', ']']. */
  #stack = [];
  constructor(text = "") {
    this.append(text);
  }
  get source() {
    return this.#sourceText;
  }
  get json() {
    if (this.#cachedJson === void 0) {
      this.#cachedJson = this.#parse();
    }
    return this.#cachedJson;
  }
  /** Whether we're currently inside an unterminated string, e.g. '{"hello' */
  get #inString() {
    return this.#lastUnterminatedString >= 0;
  }
  append(delta) {
    if (delta) {
      if (this.#sourceText === "") {
        delta = delta.trimStart();
      }
      this.#sourceText += delta;
      this.#cachedJson = void 0;
    }
  }
  #autocompleteTail(output) {
    if (this.#inString) {
      return "";
    }
    const lastChar = output.charAt(output.length - 1);
    if (lastChar === "") return "";
    if (lastChar === "-") {
      return "0";
    }
    if (!ALL_KEYWORD_CHARS.includes(lastChar)) return "";
    if (NULL_KEYWORD_CHARS.includes(lastChar)) {
      if (output.endsWith("nul")) return "l";
      if (output.endsWith("nu")) return "ll";
      if (output.endsWith("n")) return "ull";
    }
    if (TRUE_KEYWORD_CHARS.includes(lastChar)) {
      if (output.endsWith("tru")) return "e";
      if (output.endsWith("tr")) return "ue";
      if (output.endsWith("t")) return "rue";
    }
    if (FALSE_KEYWORD_CHARS.includes(lastChar)) {
      if (output.endsWith("fals")) return "e";
      if (output.endsWith("fal")) return "se";
      if (output.endsWith("fa")) return "lse";
      if (output.endsWith("f")) return "alse";
    }
    return "";
  }
  /**
   * Updates the internal parsing state by processing any new content
   * that has been appended since the last parse. This updates the state with
   * facts only. Any interpretation is left to the #parse() method.
   */
  #catchup() {
    const newContent = this.#sourceText.slice(this.#scanIndex);
    for (let i = 0; i < newContent.length; i++) {
      const ch = newContent[i];
      const absolutePos = this.#scanIndex + i;
      if (this.#inString) {
        if (this.#escaped) {
          this.#escaped = false;
        } else if (ch === "\\") {
          this.#escaped = true;
        } else if (ch === '"') {
          this.#lastTerminatedString = this.#lastUnterminatedString;
          this.#lastUnterminatedString = -1;
        }
      } else {
        if (ch === '"') {
          this.#lastUnterminatedString = absolutePos;
        } else if (ch === "{") {
          this.#stack.push("}");
        } else if (ch === "[") {
          this.#stack.push("]");
        } else if (ch === "}" && this.#stack.length > 0 && this.#stack[this.#stack.length - 1] === "}") {
          this.#stack.pop();
        } else if (ch === "]" && this.#stack.length > 0 && this.#stack[this.#stack.length - 1] === "]") {
          this.#stack.pop();
        }
      }
    }
    this.#scanIndex = this.#sourceText.length;
  }
  #parse() {
    this.#catchup();
    let result = this.#sourceText;
    if (result.charAt(0) !== "{") {
      return EMPTY_OBJECT;
    }
    if (result.endsWith("}")) {
      const quickCheck = tryParseJson(result);
      if (quickCheck) {
        return quickCheck;
      }
    }
    if (this.#inString) {
      if (this.#escaped) {
        result = result.slice(0, -1);
      }
      result += '"';
    }
    result = result.trimEnd();
    result = stripChar(result, ",.");
    result = result + this.#autocompleteTail(result);
    const suffix = this.#stack.reduceRight((acc, ch) => acc + ch, "");
    {
      const attempt = tryParseJson(result + suffix);
      if (attempt) {
        return attempt;
      }
    }
    if (this.#inString) {
      result = result.slice(0, this.#lastUnterminatedString);
    } else {
      result = stripChar(result, ":");
      if (result.endsWith('"')) {
        result = result.slice(0, this.#lastTerminatedString);
      }
    }
    result = stripChar(result, ",");
    result += suffix;
    return tryParseJson(result) ?? EMPTY_OBJECT;
  }
};

// src/types/ai.ts
function replaceOrAppend(content, newItem, keyFn, now2) {
  const existingIndex = findLastIndex(
    content,
    (item) => item.type === newItem.type && keyFn(item) === keyFn(newItem)
  );
  if (existingIndex > -1) {
    content[existingIndex] = newItem;
  } else {
    closePart(content[content.length - 1], now2);
    content.push(newItem);
  }
}
function closePart(prevPart, endedAt) {
  if (prevPart?.type === "reasoning") {
    prevPart.endedAt ??= endedAt;
  }
}
function patchContentWithDelta(content, delta) {
  if (delta === null)
    return;
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const lastPart = content[content.length - 1];
  switch (delta.type) {
    case "text-delta":
      if (lastPart?.type === "text") {
        lastPart.text += delta.textDelta;
      } else {
        closePart(lastPart, now2);
        content.push({ type: "text", text: delta.textDelta });
      }
      break;
    case "reasoning-delta":
      if (lastPart?.type === "reasoning") {
        lastPart.text += delta.textDelta;
      } else {
        closePart(lastPart, now2);
        content.push({
          type: "reasoning",
          text: delta.textDelta,
          startedAt: now2
        });
      }
      break;
    case "tool-stream": {
      const toolInvocation = createReceivingToolInvocation(
        delta.invocationId,
        delta.name
      );
      content.push(toolInvocation);
      break;
    }
    case "tool-delta": {
      if (lastPart?.type === "tool-invocation" && lastPart.stage === "receiving") {
        lastPart.__appendDelta?.(delta.delta);
      }
      break;
    }
    case "tool-invocation":
      replaceOrAppend(content, delta, (x) => x.invocationId, now2);
      break;
    case "retrieval":
      replaceOrAppend(content, delta, (x) => x.id, now2);
      break;
    default:
      return assertNever(delta, "Unhandled case");
  }
}
function createReceivingToolInvocation(invocationId, name, partialArgsText = "") {
  const parser = new IncrementalJsonParser(partialArgsText);
  return {
    type: "tool-invocation",
    stage: "receiving",
    invocationId,
    name,
    // --- Alternative implementation for FRONTEND only ------------------------
    get partialArgsText() {
      return parser.source;
    },
    // prettier-ignore
    get partialArgs() {
      return parser.json;
    },
    // prettier-ignore
    __appendDelta(delta) {
      parser.append(delta);
    }
    // prettier-ignore
    // ------------------------------------------------------------------------
  };
}

// src/ai.ts
var DEFAULT_REQUEST_TIMEOUT = 4e3;
function defineAiTool() {
  return (def) => {
    return def;
  };
}
var KnowledgeStack = class {
  #_layers;
  #stack;
  //                 /                \
  //      knowledge key               "layer" key
  //      (random, or optionally      (one entry per mounted component)
  //       set by user)
  #_cache;
  constructor() {
    this.#_layers = /* @__PURE__ */ new Set();
    this.#stack = new DefaultMap(
      () => /* @__PURE__ */ new Map()
    );
    this.#_cache = void 0;
  }
  // Typically a useId()
  registerLayer(uniqueLayerId) {
    const layerKey = uniqueLayerId;
    if (this.#_layers.has(layerKey))
      raise(`Layer '${layerKey}' already exists, provide a unique layer id`);
    this.#_layers.add(layerKey);
    return layerKey;
  }
  deregisterLayer(layerKey) {
    this.#_layers.delete(layerKey);
    let deleted = false;
    for (const [key, knowledge] of this.#stack) {
      if (knowledge.delete(layerKey)) {
        deleted = true;
      }
      if (knowledge.size === 0)
        this.#stack.delete(key);
    }
    if (deleted) {
      this.invalidate();
    }
  }
  get() {
    return this.#_cache ??= this.#recompute();
  }
  invalidate() {
    this.#_cache = void 0;
  }
  #recompute() {
    return Array.from(this.#stack.values()).flatMap(
      (layer) => (
        // Return only the last item (returns [] when empty)
        Array.from(layer.values()).slice(-1).filter(isDefined)
      )
    );
  }
  updateKnowledge(layerKey, key, data) {
    if (!this.#_layers.has(layerKey)) raise(`Unknown layer key: ${layerKey}`);
    this.#stack.getOrCreate(key).set(layerKey, data);
    this.invalidate();
  }
};
function now() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
var kWILDCARD = Symbol("*");
function createStore_forTools() {
  const toolsByChatId\u03A3 = new DefaultMap(
    (_chatId) => {
      return new DefaultMap((_name) => {
        return new Signal(void 0);
      });
    }
  );
  const globalOrScopedTool\u03A3 = new DefaultMap((nameAndChat) => {
    const [name, chatId] = tryParseJson(nameAndChat);
    return DerivedSignal.from(() => {
      return (
        // A tool that's registered and scoped to a specific chat ID...
        (chatId !== void 0 ? toolsByChatId\u03A3.getOrCreate(chatId).getOrCreate(name) : void 0)?.get() ?? // ...or a globally registered tool
        toolsByChatId\u03A3.getOrCreate(kWILDCARD).getOrCreate(name).get()
      );
    });
  });
  function getTool\u03A3(name, chatId) {
    const key = JSON.stringify(chatId !== void 0 ? [name, chatId] : [name]);
    return globalOrScopedTool\u03A3.getOrCreate(key);
  }
  function registerTool(name, tool, chatId) {
    if (!tool.execute && !tool.render) {
      throw new Error(
        "A tool definition must have an execute() function, a render() function, or both."
      );
    }
    const key = chatId ?? kWILDCARD;
    toolsByChatId\u03A3.getOrCreate(key).getOrCreate(name).set(tool);
    return () => unregisterTool(key, name);
  }
  function unregisterTool(chatId, name) {
    const tools = toolsByChatId\u03A3.get(chatId);
    if (tools === void 0) return;
    const tool = tools.get(name);
    if (tool === void 0) return;
    tool.set(void 0);
  }
  function getToolDescriptions(chatId) {
    const globalTools\u03A3 = toolsByChatId\u03A3.get(kWILDCARD);
    const scopedTools\u03A3 = toolsByChatId\u03A3.get(chatId);
    return Array.from([
      ...globalTools\u03A3?.entries() ?? [],
      ...scopedTools\u03A3?.entries() ?? []
    ]).flatMap(([name, tool\u03A3]) => {
      const tool = tool\u03A3.get();
      return tool && (tool.enabled ?? true) ? [{ name, description: tool.description, parameters: tool.parameters }] : [];
    });
  }
  return {
    getToolDescriptions,
    getTool\u03A3,
    registerTool
  };
}
function createStore_forChatMessages(toolsStore, setToolResultFn) {
  const myMessages = /* @__PURE__ */ new Set();
  const handledInvocations = /* @__PURE__ */ new Set();
  const messagePoolByChatId\u03A3 = new DefaultMap(
    (_chatId) => new MutableSignal(
      new TreePool(
        (x) => x.id,
        (x) => x.parentId,
        (x, y) => x.createdAt < y.createdAt
      )
    )
  );
  const generatingMessages\u03A3 = new MutableSignal(
    /* @__PURE__ */ new Map()
  );
  function createOptimistically(chatId, role, parentId, third) {
    const id = `ms_${nanoid()}`;
    const createdAt = now();
    if (role === "user") {
      const content = third;
      upsert({
        id,
        chatId,
        role,
        parentId,
        createdAt,
        content,
        _optimistic: true
      });
    } else {
      const copilotId = third;
      upsert({
        id,
        chatId,
        role,
        parentId,
        createdAt,
        status: "generating",
        contentSoFar: [],
        copilotId,
        _optimistic: true
      });
    }
    return id;
  }
  function upsertMany(messages) {
    batch(() => {
      for (const message of messages) {
        upsert(message);
      }
    });
  }
  function remove(chatId, messageId) {
    const chatMsgs\u03A3 = messagePoolByChatId\u03A3.get(chatId);
    if (!chatMsgs\u03A3) return;
    const existing = chatMsgs\u03A3.get().get(messageId);
    if (!existing || existing.deletedAt) return;
    if (existing.role === "assistant" && existing.status !== "completed") {
      upsert({ ...existing, deletedAt: now(), contentSoFar: [] });
    } else {
      upsert({ ...existing, deletedAt: now(), content: [] });
    }
  }
  function removeByChatId(chatId) {
    const chatMsgs\u03A3 = messagePoolByChatId\u03A3.get(chatId);
    if (chatMsgs\u03A3 === void 0) return;
    chatMsgs\u03A3.mutate((pool) => pool.clear());
  }
  function upsert(message) {
    batch(() => {
      const chatMsgs\u03A3 = messagePoolByChatId\u03A3.getOrCreate(message.chatId);
      chatMsgs\u03A3.mutate((pool) => pool.upsert(message));
      if (message.role === "assistant" && message.status === "generating") {
        generatingMessages\u03A3.mutate((lut) => {
          lut.set(message.id, structuredClone(message));
        });
      } else {
        generatingMessages\u03A3.mutate((lut) => {
          lut.delete(message.id);
        });
      }
      if (message.role === "assistant" && message.status === "awaiting-tool") {
        if (myMessages.has(message.id)) {
          for (const toolInvocation of message.contentSoFar.filter(
            (part) => part.type === "tool-invocation" && part.stage === "executing"
          )) {
            if (!handledInvocations.has(toolInvocation.invocationId)) {
              handledInvocations.add(toolInvocation.invocationId);
            } else {
              continue;
            }
            const executeFn = toolsStore.getTool\u03A3(toolInvocation.name, message.chatId).get()?.execute;
            if (executeFn) {
              (async () => {
                const result = await executeFn(toolInvocation.args, {
                  name: toolInvocation.name,
                  invocationId: toolInvocation.invocationId
                });
                return await setToolResultFn(
                  message.chatId,
                  message.id,
                  toolInvocation.invocationId,
                  result ?? { data: {} },
                  { copilotId: message.copilotId }
                  // TODO: Should we pass the other generation options (tools, knowledge) as well?
                );
              })().catch((err) => {
                error2(
                  `Error trying to respond to tool-call: ${String(err)} (in execute())`
                );
              });
            }
          }
        }
      } else {
        if (message.role === "assistant" && message.status === "generating") {
        } else {
          myMessages.delete(message.id);
        }
      }
    });
  }
  function addDelta(messageId, delta) {
    generatingMessages\u03A3.mutate((lut) => {
      const message = lut.get(messageId);
      if (message === void 0) return false;
      patchContentWithDelta(message.contentSoFar, delta);
      lut.set(messageId, message);
      return true;
    });
  }
  function* iterGeneratingMessages() {
    for (const chatMsgs\u03A3 of messagePoolByChatId\u03A3.values()) {
      for (const m of chatMsgs\u03A3.get()) {
        if (m.role === "assistant" && m.status === "generating" && !m._optimistic) {
          yield m;
        }
      }
    }
  }
  function failAllPending() {
    batch(() => {
      generatingMessages\u03A3.mutate((lut) => {
        let deleted = false;
        for (const [k, v] of lut) {
          if (!v._optimistic) {
            lut.delete(k);
            deleted = true;
          }
        }
        return deleted;
      });
      upsertMany(
        Array.from(iterGeneratingMessages()).map(
          (message) => ({
            ...message,
            status: "failed",
            errorReason: "Lost connection"
          })
        )
      );
    });
  }
  function getMessageById(messageId) {
    for (const messages\u03A3 of messagePoolByChatId\u03A3.values()) {
      const message = messages\u03A3.get().get(messageId);
      if (message) {
        return message;
      }
    }
    return void 0;
  }
  function first(iterable) {
    const result = iterable.next();
    return result.done ? void 0 : result.value;
  }
  function selectBranch(pool, preferredBranch) {
    function isAlive(message2) {
      if (!message2.deletedAt) {
        return true;
      }
      for (const _ of pool.walkDown(message2.id, (m) => !m.deletedAt)) {
        return true;
      }
      return false;
    }
    function selectSpine(leaf) {
      const spine = [];
      let lastVisitedMessage = null;
      for (const message2 of pool.walkUp(leaf.id)) {
        const prev = first(pool.walkLeft(message2.id, isAlive))?.id ?? null;
        const next = first(pool.walkRight(message2.id, isAlive))?.id ?? null;
        if (!message2.deletedAt || prev || next) {
          const node = {
            ...message2,
            navigation: { parent: null, prev, next }
          };
          if (lastVisitedMessage !== null) {
            lastVisitedMessage.navigation.parent = node.id;
          }
          lastVisitedMessage = node;
          spine.push(node);
        }
      }
      return spine.reverse();
    }
    function fallback() {
      const latest = pool.sorted.findRight((m) => !m.deletedAt);
      return latest ? selectSpine(latest) : [];
    }
    if (preferredBranch === null) {
      return fallback();
    }
    const message = pool.get(preferredBranch);
    if (!message) {
      return fallback();
    }
    for (const current of pool.walkUp(message.id)) {
      for (const desc of pool.walkDown(current.id, (m) => !m.deletedAt)) {
        return selectSpine(desc);
      }
      if (!current.deletedAt) {
        return selectSpine(current);
      }
    }
    return fallback();
  }
  const immutableMessagesByBranch = new DefaultMap((chatId) => {
    return new DefaultMap((branchId) => {
      const messages\u03A3 = DerivedSignal.from(() => {
        const pool = messagePoolByChatId\u03A3.getOrCreate(chatId).get();
        return selectBranch(pool, branchId);
      }, shallow2);
      return DerivedSignal.from(() => {
        const generatingMessages = generatingMessages\u03A3.get();
        return messages\u03A3.get().map((message) => {
          if (message.role !== "assistant" || message.status !== "generating") {
            return message;
          }
          const generatingMessage = generatingMessages.get(message.id);
          if (generatingMessage === void 0) return message;
          return {
            ...message,
            contentSoFar: generatingMessage.contentSoFar
          };
        });
      }, shallow);
    });
  });
  function getChatMessagesForBranch\u03A3(chatId, branch) {
    return immutableMessagesByBranch.getOrCreate(chatId).getOrCreate(branch || null);
  }
  function getLastUsedCopilotId(chatId) {
    const pool = messagePoolByChatId\u03A3.getOrCreate(chatId).get();
    const latest = pool.sorted.findRight(
      (m) => m.role === "assistant" && !m.deletedAt
    );
    return latest?.copilotId;
  }
  return {
    // Readers
    getMessageById,
    getChatMessagesForBranch\u03A3,
    getLastUsedCopilotId,
    // Mutations
    createOptimistically,
    upsert,
    upsertMany,
    remove,
    removeByChatId,
    addDelta,
    failAllPending,
    markMine(messageId) {
      myMessages.add(messageId);
    },
    /**
     * Iterates over all my auto-executing messages.
     *
     * These are messages that match all these conditions:
     * - The message is an assistant message
     * - The message is owned by this client ("mine")
     * - The message is currently in "awaiting-tool" status
     * - The message has at least one tool invocation in "executing" stage
     * - The tool invocation has an execute() function defined
     */
    *getAutoExecutingMessageIds() {
      for (const messageId of myMessages) {
        const message = getMessageById(messageId);
        if (message?.role === "assistant" && message.status === "awaiting-tool") {
          const isAutoExecuting = message.contentSoFar.some((part) => {
            if (part.type === "tool-invocation" && part.stage === "executing") {
              const tool = toolsStore.getTool\u03A3(part.name, message.chatId).get();
              return typeof tool?.execute === "function";
            }
            return false;
          });
          if (isAutoExecuting) {
            yield message.id;
          }
        }
      }
    }
  };
}
function createStore_forUserAiChats() {
  const chatsDB = new AiChatDB();
  function upsertMany(chats) {
    batch(() => {
      for (const chat of chats) {
        chatsDB.upsert(chat);
      }
    });
  }
  function upsert(chat) {
    chatsDB.upsert(chat);
  }
  function markDeleted(chatId) {
    chatsDB.markDeleted(chatId);
  }
  function getChatById(chatId) {
    return chatsDB.getEvenIfDeleted(chatId);
  }
  function findMany(query) {
    return chatsDB.signal.get().findMany(query);
  }
  return {
    getChatById,
    findMany,
    // Mutations
    upsert,
    upsertMany,
    markDeleted
  };
}
function createAi(config) {
  const managedSocket = new ManagedSocket(
    config.delegates,
    config.enableDebugLogging,
    false
    // AI doesn't have actors (yet, but it will)
  );
  const chatsStore = createStore_forUserAiChats();
  const toolsStore = createStore_forTools();
  const messagesStore = createStore_forChatMessages(toolsStore, setToolResult);
  const context = {
    staticSessionInfoSig: new Signal(null),
    dynamicSessionInfoSig: new Signal(null),
    pendingCmds: /* @__PURE__ */ new Map(),
    chatsStore,
    messagesStore,
    toolsStore,
    knowledge: new KnowledgeStack()
  };
  const DELTA_THROTTLE = 25;
  let pendingDeltas = [];
  let deltaBatchTimer = null;
  function flushPendingDeltas() {
    const currentQueue = pendingDeltas;
    pendingDeltas = [];
    if (deltaBatchTimer !== null) {
      clearTimeout(deltaBatchTimer);
      deltaBatchTimer = null;
    }
    batch(() => {
      for (const { id, delta } of currentQueue) {
        context.messagesStore.addDelta(id, delta);
      }
    });
  }
  function enqueueDelta(id, delta) {
    pendingDeltas.push({ id, delta });
    if (deltaBatchTimer === null) {
      deltaBatchTimer = setTimeout(flushPendingDeltas, DELTA_THROTTLE);
    }
  }
  let lastTokenKey;
  function onStatusDidChange(_newStatus) {
    const authValue = managedSocket.authValue;
    if (authValue !== null) {
      const tokenKey = getBearerTokenFromAuthValue(authValue);
      if (tokenKey !== lastTokenKey) {
        lastTokenKey = tokenKey;
        if (authValue.type === "secret") {
          const token = authValue.token.parsed;
          context.staticSessionInfoSig.set({
            userId: token.k === "sec-legacy" /* SECRET_LEGACY */ ? token.id : token.uid,
            userInfo: token.k === "sec-legacy" /* SECRET_LEGACY */ ? token.info : token.ui
          });
        } else {
          context.staticSessionInfoSig.set({
            userId: void 0,
            userInfo: void 0
          });
        }
      }
    }
  }
  let _connectionLossTimerId;
  let _hasLostConnection = false;
  function handleConnectionLossEvent(newStatus) {
    if (newStatus === "reconnecting") {
      _connectionLossTimerId = setTimeout(() => {
        _hasLostConnection = true;
      }, config.lostConnectionTimeout);
    } else {
      clearTimeout(_connectionLossTimerId);
      if (_hasLostConnection) {
        _hasLostConnection = false;
      }
    }
  }
  function onDidConnect() {
  }
  function onDidDisconnect() {
    flushPendingDeltas();
  }
  function handleServerMessage(event) {
    if (typeof event.data !== "string")
      return;
    const msg = tryParseJson(event.data);
    if (!msg)
      return;
    const cmdId = "cmdId" in msg ? msg.cmdId : msg.event === "cmd-failed" ? msg.failedCmdId : void 0;
    const pendingCmd = context.pendingCmds.get(cmdId);
    if (cmdId && !pendingCmd) {
      warn("Ignoring unexpected command response. Already timed out, or not for us?", msg);
      return;
    }
    if ("event" in msg) {
      if (msg.event === "delta") {
        const { id, delta } = msg;
        enqueueDelta(id, delta);
      } else {
        batch(() => {
          flushPendingDeltas();
          switch (msg.event) {
            case "cmd-failed":
              pendingCmd?.reject(new Error(msg.error));
              break;
            case "settle": {
              context.messagesStore.upsert(msg.message);
              break;
            }
            case "warning":
              warn(msg.message);
              break;
            case "error":
              error2(msg.error);
              break;
            case "rebooted":
              context.messagesStore.failAllPending();
              break;
            case "sync":
              for (const m of msg["-messages"] ?? []) {
                context.messagesStore.remove(m.chatId, m.id);
              }
              for (const chatId of msg["-chats"] ?? []) {
                context.chatsStore.markDeleted(chatId);
                context.messagesStore.removeByChatId(chatId);
              }
              for (const chatId of msg.clear ?? []) {
                context.messagesStore.removeByChatId(chatId);
              }
              if (msg.chats) {
                context.chatsStore.upsertMany(msg.chats);
              }
              if (msg.messages) {
                context.messagesStore.upsertMany(msg.messages);
              }
              break;
            default:
              return assertNever(msg, "Unhandled case");
          }
        });
      }
    } else {
      switch (msg.cmd) {
        case "get-chats":
          context.chatsStore.upsertMany(msg.chats);
          break;
        case "get-or-create-chat":
          context.chatsStore.upsert(msg.chat);
          break;
        case "delete-chat":
          context.chatsStore.markDeleted(msg.chatId);
          context.messagesStore.removeByChatId(msg.chatId);
          break;
        case "get-message-tree":
          context.chatsStore.upsert(msg.chat);
          context.messagesStore.upsertMany(msg.messages);
          break;
        case "delete-message":
          context.messagesStore.remove(msg.chatId, msg.messageId);
          break;
        case "clear-chat":
          context.messagesStore.removeByChatId(msg.chatId);
          break;
        case "ask-in-chat":
          if (msg.sourceMessage) {
            context.messagesStore.upsert(msg.sourceMessage);
          }
          context.messagesStore.upsert(msg.targetMessage);
          break;
        case "abort-ai":
          break;
        case "set-tool-result":
          if (msg.ok) {
            context.messagesStore.upsert(msg.message);
          }
          break;
        default:
          return assertNever(msg, "Unhandled case");
      }
    }
    pendingCmd?.resolve(msg);
  }
  managedSocket.events.onMessage.subscribe(handleServerMessage);
  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);
  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);
  managedSocket.events.didConnect.subscribe(onDidConnect);
  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);
  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {
    if (process.env.NODE_ENV !== "production") {
      error2(
        `Connection to websocket server closed. Reason: ${message} (code: ${code}).`
      );
    }
  });
  function connectInitially() {
    if (managedSocket.getStatus() === "initial") {
      managedSocket.connect();
    }
  }
  async function sendClientMsgWithResponse(msg) {
    connectInitially();
    if (managedSocket.getStatus() !== "connected") {
      await managedSocket.events.didConnect.waitUntil();
    }
    const { promise, resolve, reject } = Promise_withResolvers();
    const abortSignal = AbortSignal.timeout(DEFAULT_REQUEST_TIMEOUT);
    abortSignal.addEventListener("abort", () => reject(abortSignal.reason), {
      once: true
    });
    const cmdId = nanoid(7);
    context.pendingCmds.set(cmdId, { resolve, reject });
    sendClientMsg({ ...msg, cmdId });
    return promise.finally(() => {
      context.pendingCmds.delete(cmdId);
    }).catch((err) => {
      error2(err.message);
      throw err;
    });
  }
  function sendClientMsg(msg) {
    managedSocket.send(
      JSON.stringify({
        ...msg
      })
    );
  }
  function getChats(options = {}) {
    return sendClientMsgWithResponse({
      cmd: "get-chats",
      cursor: options.cursor,
      query: options.query
    });
  }
  function getOrCreateChat(id, options) {
    return sendClientMsgWithResponse({
      cmd: "get-or-create-chat",
      id,
      options
    });
  }
  function getMessageTree(chatId) {
    return sendClientMsgWithResponse({
      cmd: "get-message-tree",
      chatId
    });
  }
  function registerKnowledgeLayer(uniqueLayerId) {
    return context.knowledge.registerLayer(uniqueLayerId);
  }
  function deregisterKnowledgeLayer(layerKey) {
    context.knowledge.deregisterLayer(layerKey);
  }
  function updateKnowledge(layerKey, data, key = nanoid()) {
    context.knowledge.updateKnowledge(layerKey, key, data);
  }
  async function setToolResult(chatId, messageId, invocationId, result, options) {
    const knowledge = context.knowledge.get();
    const tools = context.toolsStore.getToolDescriptions(chatId);
    const resp = await sendClientMsgWithResponse({
      cmd: "set-tool-result",
      chatId,
      messageId,
      invocationId,
      result,
      generationOptions: {
        copilotId: options?.copilotId,
        stream: options?.stream,
        timeout: options?.timeout,
        // Knowledge and tools aren't coming from the options, but retrieved
        // from the global context
        knowledge: knowledge.length > 0 ? knowledge : void 0,
        tools: tools.length > 0 ? tools : void 0
      }
    });
    if (resp.ok) {
      messagesStore.markMine(resp.message.id);
    }
  }
  function handleBeforeUnload() {
    for (const messageId of context.messagesStore.getAutoExecutingMessageIds()) {
      sendClientMsgWithResponse({ cmd: "abort-ai", messageId }).catch(() => {
      });
    }
  }
  const win = typeof window !== "undefined" ? window : void 0;
  win?.addEventListener("beforeunload", handleBeforeUnload, { once: true });
  return Object.defineProperty(
    {
      [kInternal]: {
        context
      },
      connectInitially,
      // reconnect: () => managedSocket.reconnect(),
      disconnect: () => managedSocket.disconnect(),
      getChats,
      getOrCreateChat,
      deleteChat: (chatId) => {
        return sendClientMsgWithResponse({ cmd: "delete-chat", chatId });
      },
      getMessageTree,
      deleteMessage: (chatId, messageId) => sendClientMsgWithResponse({ cmd: "delete-message", chatId, messageId }),
      clearChat: (chatId) => sendClientMsgWithResponse({ cmd: "clear-chat", chatId }),
      askUserMessageInChat: async (chatId, userMessage, targetMessageId, options) => {
        const globalKnowledge = context.knowledge.get();
        const requestKnowledge = options?.knowledge || [];
        const combinedKnowledge = [...globalKnowledge, ...requestKnowledge];
        const tools = context.toolsStore.getToolDescriptions(chatId);
        messagesStore.markMine(targetMessageId);
        const resp = await sendClientMsgWithResponse({
          cmd: "ask-in-chat",
          chatId,
          sourceMessage: userMessage,
          targetMessageId,
          generationOptions: {
            copilotId: options?.copilotId,
            stream: options?.stream,
            timeout: options?.timeout,
            // Combine global knowledge with request-specific knowledge
            knowledge: combinedKnowledge.length > 0 ? combinedKnowledge : void 0,
            tools: tools.length > 0 ? tools : void 0
          }
        });
        return resp;
      },
      abort: (messageId) => sendClientMsgWithResponse({ cmd: "abort-ai", messageId }),
      setToolResult,
      getStatus: () => managedSocket.getStatus(),
      signals: {
        getChatMessagesForBranch\u03A3: context.messagesStore.getChatMessagesForBranch\u03A3,
        getTool\u03A3: context.toolsStore.getTool\u03A3
      },
      getChatById: context.chatsStore.getChatById,
      queryChats: context.chatsStore.findMany,
      getLastUsedCopilotId: context.messagesStore.getLastUsedCopilotId,
      registerKnowledgeLayer,
      deregisterKnowledgeLayer,
      updateKnowledge,
      registerTool: context.toolsStore.registerTool
    },
    kInternal,
    { enumerable: false }
  );
}
function makeCreateSocketDelegateForAi(baseUrl, WebSocketPolyfill) {
  return (authValue) => {
    const ws = WebSocketPolyfill ?? (typeof WebSocket === "undefined" ? void 0 : WebSocket);
    if (ws === void 0) {
      throw new StopRetrying(
        "To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill."
      );
    }
    const url2 = new URL(baseUrl);
    url2.protocol = url2.protocol === "http:" ? "ws" : "wss";
    url2.pathname = "/ai/v6";
    if (authValue.type === "secret") {
      url2.searchParams.set("tok", authValue.token.raw);
    } else if (authValue.type === "public") {
      throw new Error("Public key not supported with AI Copilots");
    } else {
      return assertNever(authValue, "Unhandled case");
    }
    url2.searchParams.set("version", PKG_VERSION || "dev");
    return new ws(url2.toString());
  };
}

// src/auth-manager.ts
function createAuthManager(authOptions, onAuthenticate) {
  const authentication = prepareAuthentication(authOptions);
  const seenTokens = /* @__PURE__ */ new Set();
  const tokens = [];
  const expiryTimes = [];
  const requestPromises = /* @__PURE__ */ new Map();
  function reset() {
    seenTokens.clear();
    tokens.length = 0;
    expiryTimes.length = 0;
    requestPromises.clear();
  }
  function hasCorrespondingScopes(requestedScope, scopes) {
    if (requestedScope === "comments:read") {
      return scopes.includes("comments:read" /* CommentsRead */) || scopes.includes("comments:write" /* CommentsWrite */) || scopes.includes("room:read" /* Read */) || scopes.includes("room:write" /* Write */);
    } else if (requestedScope === "room:read") {
      return scopes.includes("room:read" /* Read */) || scopes.includes("room:write" /* Write */);
    }
    return false;
  }
  function getCachedToken(requestOptions) {
    const now2 = Math.ceil(Date.now() / 1e3);
    for (let i = tokens.length - 1; i >= 0; i--) {
      const token = tokens[i];
      const expiresAt = expiryTimes[i];
      if (expiresAt <= now2) {
        tokens.splice(i, 1);
        expiryTimes.splice(i, 1);
        continue;
      }
      if (token.parsed.k === "id" /* ID_TOKEN */) {
        return token;
      } else if (token.parsed.k === "acc" /* ACCESS_TOKEN */) {
        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {
          return token;
        }
        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {
          if (!requestOptions.roomId) {
            if (resource.includes("*") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {
              return token;
            }
          } else if (resource.includes("*") && requestOptions.roomId.startsWith(resource.replace("*", "")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {
            return token;
          }
        }
      }
    }
    return void 0;
  }
  async function makeAuthRequest(options) {
    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === "undefined" ? void 0 : window.fetch);
    if (authentication.type === "private") {
      if (fetcher === void 0) {
        throw new StopRetrying(
          "To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill."
        );
      }
      const response = await fetchAuthEndpoint(fetcher, authentication.url, {
        room: options.roomId
      });
      const parsed = parseAuthToken(response.token);
      if (seenTokens.has(parsed.raw)) {
        throw new StopRetrying(
          "The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported."
        );
      }
      onAuthenticate?.(parsed.parsed);
      return parsed;
    }
    if (authentication.type === "custom") {
      const response = await authentication.callback(options.roomId);
      if (response && typeof response === "object") {
        if (typeof response.token === "string") {
          const parsed = parseAuthToken(response.token);
          onAuthenticate?.(parsed.parsed);
          return parsed;
        } else if (typeof response.error === "string") {
          const reason = `Authentication failed: ${"reason" in response && typeof response.reason === "string" ? response.reason : "Forbidden"}`;
          if (response.error === "forbidden") {
            throw new StopRetrying(reason);
          } else {
            throw new Error(reason);
          }
        }
      }
      throw new Error(
        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: "..." }'
      );
    }
    throw new Error(
      "Unexpected authentication type. Must be private or custom."
    );
  }
  async function getAuthValue(requestOptions) {
    if (authentication.type === "public") {
      return { type: "public", publicApiKey: authentication.publicApiKey };
    }
    const cachedToken = getCachedToken(requestOptions);
    if (cachedToken !== void 0) {
      return { type: "secret", token: cachedToken };
    }
    let currentPromise;
    if (requestOptions.roomId) {
      currentPromise = requestPromises.get(requestOptions.roomId);
      if (currentPromise === void 0) {
        currentPromise = makeAuthRequest(requestOptions);
        requestPromises.set(requestOptions.roomId, currentPromise);
      }
    } else {
      currentPromise = requestPromises.get("liveblocks-user-token");
      if (currentPromise === void 0) {
        currentPromise = makeAuthRequest(requestOptions);
        requestPromises.set("liveblocks-user-token", currentPromise);
      }
    }
    try {
      const token = await currentPromise;
      const BUFFER = 30;
      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;
      seenTokens.add(token.raw);
      if (token.parsed.k !== "sec-legacy" /* SECRET_LEGACY */) {
        tokens.push(token);
        expiryTimes.push(expiresAt);
      }
      return { type: "secret", token };
    } finally {
      if (requestOptions.roomId) {
        requestPromises.delete(requestOptions.roomId);
      } else {
        requestPromises.delete("liveblocks-user-token");
      }
    }
  }
  return {
    reset,
    getAuthValue
  };
}
function prepareAuthentication(authOptions) {
  const { publicApiKey, authEndpoint } = authOptions;
  if (authEndpoint !== void 0 && publicApiKey !== void 0) {
    throw new Error(
      "You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  }
  if (typeof publicApiKey === "string") {
    if (publicApiKey.startsWith("sk_")) {
      throw new Error(
        "Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    } else if (!publicApiKey.startsWith("pk_")) {
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    }
    return {
      type: "public",
      publicApiKey
    };
  }
  if (typeof authEndpoint === "string") {
    return {
      type: "private",
      url: authEndpoint
    };
  } else if (typeof authEndpoint === "function") {
    return {
      type: "custom",
      callback: authEndpoint
    };
  } else if (authEndpoint !== void 0) {
    throw new Error(
      "The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
    );
  }
  throw new Error(
    "Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}
async function fetchAuthEndpoint(fetch, endpoint, body) {
  const res = await fetch(endpoint, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: stringifyOrLog(body)
  });
  if (!res.ok) {
    const reason = `${(await res.text()).trim() || "reason not provided in auth response"} (${res.status} returned by POST ${endpoint})`;
    if (res.status === 401 || res.status === 403) {
      throw new StopRetrying(`Unauthorized: ${reason}`);
    } else {
      throw new Error(`Failed to authenticate: ${reason}`);
    }
  }
  let data;
  try {
    data = await res.json();
  } catch (er) {
    throw new Error(
      `Expected a JSON response when doing a POST request on "${endpoint}". ${String(
        er
      )}`
    );
  }
  if (!isPlainObject(data) || typeof data.token !== "string") {
    throw new Error(
      `Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${endpoint}", but got ${stringifyOrLog(
        data
      )}`
    );
  }
  const { token } = data;
  return { token };
}

// src/constants.ts
var DEFAULT_BASE_URL = "https://api.liveblocks.io";
var MENTION_CHARACTER = "@";

// src/devtools/bridge.ts
var _bridgeActive = false;
function activateBridge(allowed) {
  _bridgeActive = allowed;
}
function sendToPanel(message, options) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  const fullMsg = {
    ...message,
    source: "liveblocks-devtools-client"
  };
  if (!(options?.force || _bridgeActive)) {
    return;
  }
  window.postMessage(fullMsg, "*");
}
var eventSource = makeEventSource();
if (process.env.NODE_ENV !== "production" && typeof window !== "undefined") {
  window.addEventListener("message", (event) => {
    if (event.source === window && event.data?.source === "liveblocks-devtools-panel") {
      eventSource.notify(event.data);
    } else {
    }
  });
}
var onMessageFromPanel = eventSource.observable;

// src/devtools/index.ts
var VERSION = PKG_VERSION || "dev";
var _devtoolsSetupHasRun = false;
function setupDevTools(getAllRooms) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  if (_devtoolsSetupHasRun) {
    return;
  }
  _devtoolsSetupHasRun = true;
  onMessageFromPanel.subscribe((msg) => {
    switch (msg.msg) {
      // When a devtool panel sends an explicit "connect" message back to this
      // live running client (in response to the "wake-up-devtools" message,
      // or when the devtool panel is opened for the first time), it means that it's okay to
      // start emitting messages.
      // Before this explicit acknowledgement, any call to sendToPanel() will
      // be a no-op.
      case "connect": {
        activateBridge(true);
        for (const roomId of getAllRooms()) {
          sendToPanel({
            msg: "room::available",
            roomId,
            clientVersion: VERSION
          });
        }
        break;
      }
    }
  });
  sendToPanel({ msg: "wake-up-devtools" }, { force: true });
}
var unsubsByRoomId = /* @__PURE__ */ new Map();
function stopSyncStream(roomId) {
  const unsubs = unsubsByRoomId.get(roomId) ?? [];
  unsubsByRoomId.delete(roomId);
  for (const unsub of unsubs) {
    unsub();
  }
}
function startSyncStream(room) {
  stopSyncStream(room.id);
  fullSync(room);
  unsubsByRoomId.set(room.id, [
    // When the connection status changes
    room.events.status.subscribe(() => partialSyncConnection(room)),
    // When storage initializes, send the update
    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),
    // Any time storage updates, send the new storage root
    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),
    // Any time "me" or "others" updates, send the new values accordingly
    room.events.self.subscribe(() => partialSyncMe(room)),
    room.events.others.subscribe(() => partialSyncOthers(room)),
    // Any time ydoc is updated, forward the update
    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),
    // Any time a custom room event is received, forward it
    room.events.customEvent.subscribe(
      (eventData) => forwardEvent(room, eventData)
    )
  ]);
}
function syncYdocUpdate(room, update) {
  sendToPanel({
    msg: "room::sync::ydoc",
    roomId: room.id,
    update
  });
}
var loadedAt = Date.now();
var eventCounter = 0;
function nextEventId() {
  return `event-${loadedAt}-${eventCounter++}`;
}
function forwardEvent(room, eventData) {
  sendToPanel({
    msg: "room::events::custom-event",
    roomId: room.id,
    event: {
      type: "CustomEvent",
      id: nextEventId(),
      key: "Event",
      connectionId: eventData.connectionId,
      payload: eventData.event
    }
  });
}
function partialSyncConnection(room) {
  sendToPanel({
    msg: "room::sync::partial",
    roomId: room.id,
    status: room.getStatus()
  });
}
function partialSyncStorage(room) {
  const root = room.getStorageSnapshot();
  if (root) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      storage: root.toTreeNode("root").payload
    });
  }
}
function partialSyncMe(room) {
  const me = room[kInternal].getSelf_forDevTools();
  if (me) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      me
    });
  }
}
function partialSyncOthers(room) {
  const others = room[kInternal].getOthers_forDevTools();
  if (others) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      others
    });
  }
}
function fullSync(room) {
  const root = room.getStorageSnapshot();
  const me = room[kInternal].getSelf_forDevTools();
  const others = room[kInternal].getOthers_forDevTools();
  room.fetchYDoc("");
  sendToPanel({
    msg: "room::sync::full",
    roomId: room.id,
    status: room.getStatus(),
    storage: root?.toTreeNode("root").payload ?? null,
    me,
    others
  });
}
var roomChannelListeners = /* @__PURE__ */ new Map();
function stopRoomChannelListener(roomId) {
  const listener = roomChannelListeners.get(roomId);
  roomChannelListeners.delete(roomId);
  if (listener) {
    listener();
  }
}
function linkDevTools(roomId, room) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  sendToPanel({ msg: "room::available", roomId, clientVersion: VERSION });
  stopRoomChannelListener(roomId);
  roomChannelListeners.set(
    roomId,
    // Returns the unsubscribe callback, that we store in the
    // roomChannelListeners registry
    onMessageFromPanel.subscribe((msg) => {
      switch (msg.msg) {
        // Sent by the devtool panel when it wants to receive the sync stream
        // for a room
        case "room::subscribe": {
          if (msg.roomId === roomId) {
            startSyncStream(room);
          }
          break;
        }
        case "room::unsubscribe": {
          if (msg.roomId === roomId) {
            stopSyncStream(roomId);
          }
          break;
        }
      }
    })
  );
}
function unlinkDevTools(roomId) {
  if (process.env.NODE_ENV === "production" || typeof window === "undefined") {
    return;
  }
  stopSyncStream(roomId);
  stopRoomChannelListener(roomId);
  sendToPanel({
    msg: "room::unavailable",
    roomId
  });
}

// src/lib/warnings.ts
var _emittedWarnings = /* @__PURE__ */ new Set();
function warnOnce(message, key = message) {
  if (process.env.NODE_ENV !== "production") {
    if (!_emittedWarnings.has(key)) {
      _emittedWarnings.add(key);
      warn(message);
    }
  }
}
function warnOnceIf(condition, message, key = message) {
  if (typeof condition === "function" ? condition() : condition) {
    warnOnce(message, key);
  }
}

// src/protocol/NotificationSettings.ts
var kPlain = Symbol("notification-settings-plain");
function createNotificationSettings(plain) {
  const channels = [
    "email",
    "slack",
    "teams",
    "webPush"
  ];
  const descriptors = {
    [kPlain]: {
      value: plain,
      enumerable: false
    }
  };
  for (const channel of channels) {
    descriptors[channel] = {
      enumerable: true,
      /**
       * In the TypeScript standard library definitions, the built-in interface for a property descriptor
       * does not include a specialized type for the this context in the getter or setter functions.
       * As a result, both the get and set methods implicitly have this: any.
       * The reason is that property descriptors in JavaScript are used across various objects with
       * no enforced shape for this. And so the standard library definitions have to remain as broad as possible
       * to support any valid JavaScript usage (e.g `Object.defineProperty`).
       *
       * So we can safely tells that this getter is typed as `this: NotificationSettings` because we're
       * creating a well known shaped object  `NotificationSettings`.
       */
      get() {
        const value = this[kPlain][channel];
        if (typeof value === "undefined") {
          error2(
            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`
          );
          return null;
        }
        return value;
      }
    };
  }
  return create(null, descriptors);
}
function patchNotificationSettings(existing, patch) {
  const outcoming = createNotificationSettings({
    ...existing[kPlain]
  });
  for (const channel of keys(patch)) {
    const updates = patch[channel];
    if (updates !== void 0) {
      const kindUpdates = Object.fromEntries(
        entries(updates).filter(([, value]) => value !== void 0)
      );
      outcoming[kPlain][channel] = {
        ...outcoming[kPlain][channel],
        ...kindUpdates
      };
    }
  }
  return outcoming;
}
function isNotificationChannelEnabled(settings) {
  return settings !== null ? values(settings).every((enabled) => enabled === true) : false;
}

// src/lib/position.ts
var MIN_CODE = 32;
var MAX_CODE = 126;
var NUM_DIGITS = MAX_CODE - MIN_CODE + 1;
var ZERO = nthDigit(0);
var ONE = nthDigit(1);
var ZERO_NINE = ZERO + nthDigit(-1);
function nthDigit(n) {
  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);
  if (code < MIN_CODE || code > MAX_CODE) {
    throw new Error(`Invalid n value: ${n}`);
  }
  return String.fromCharCode(code);
}
function makePosition(x, y) {
  if (x !== void 0 && y !== void 0) {
    return between(x, y);
  } else if (x !== void 0) {
    return after(x);
  } else if (y !== void 0) {
    return before(y);
  } else {
    return ONE;
  }
}
function before(pos) {
  const lastIndex = pos.length - 1;
  for (let i = 0; i <= lastIndex; i++) {
    const code = pos.charCodeAt(i);
    if (code <= MIN_CODE) {
      continue;
    }
    if (i === lastIndex) {
      if (code === MIN_CODE + 1) {
        return pos.substring(0, i) + ZERO_NINE;
      } else {
        return pos.substring(0, i) + String.fromCharCode(code - 1);
      }
    } else {
      return pos.substring(0, i + 1);
    }
  }
  return ONE;
}
function after(pos) {
  for (let i = 0; i <= pos.length - 1; i++) {
    const code = pos.charCodeAt(i);
    if (code >= MAX_CODE) {
      continue;
    }
    return pos.substring(0, i) + String.fromCharCode(code + 1);
  }
  return pos + ONE;
}
function between(lo, hi) {
  if (lo < hi) {
    return _between(lo, hi);
  } else if (lo > hi) {
    return _between(hi, lo);
  } else {
    throw new Error("Cannot compute value between two equal positions");
  }
}
function _between(lo, hi) {
  let index = 0;
  const loLen = lo.length;
  const hiLen = hi.length;
  while (true) {
    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;
    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;
    if (loCode === hiCode) {
      index++;
      continue;
    }
    if (hiCode - loCode === 1) {
      const size = index + 1;
      let prefix = lo.substring(0, size);
      if (prefix.length < size) {
        prefix += ZERO.repeat(size - prefix.length);
      }
      const suffix = lo.substring(size);
      const nines = "";
      return prefix + _between(suffix, nines);
    } else {
      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);
    }
  }
}
function takeN(pos, n) {
  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);
}
var MIN_NON_ZERO_CODE = MIN_CODE + 1;
function isPos(str) {
  if (str === "") {
    return false;
  }
  const lastIdx = str.length - 1;
  const last = str.charCodeAt(lastIdx);
  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {
    return false;
  }
  for (let i = 0; i < lastIdx; i++) {
    const code = str.charCodeAt(i);
    if (code < MIN_CODE || code > MAX_CODE) {
      return false;
    }
  }
  return true;
}
function convertToPos(str) {
  const codes = [];
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);
  }
  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {
    codes.length--;
  }
  return codes.length > 0 ? String.fromCharCode(...codes) : (
    // Edge case: the str was a 0-only string, which is invalid. Default back to .1
    ONE
  );
}
function asPos(str) {
  return isPos(str) ? str : convertToPos(str);
}

// src/protocol/Op.ts
var OpCode = /* @__PURE__ */ ((OpCode2) => {
  OpCode2[OpCode2["INIT"] = 0] = "INIT";
  OpCode2[OpCode2["SET_PARENT_KEY"] = 1] = "SET_PARENT_KEY";
  OpCode2[OpCode2["CREATE_LIST"] = 2] = "CREATE_LIST";
  OpCode2[OpCode2["UPDATE_OBJECT"] = 3] = "UPDATE_OBJECT";
  OpCode2[OpCode2["CREATE_OBJECT"] = 4] = "CREATE_OBJECT";
  OpCode2[OpCode2["DELETE_CRDT"] = 5] = "DELETE_CRDT";
  OpCode2[OpCode2["DELETE_OBJECT_KEY"] = 6] = "DELETE_OBJECT_KEY";
  OpCode2[OpCode2["CREATE_MAP"] = 7] = "CREATE_MAP";
  OpCode2[OpCode2["CREATE_REGISTER"] = 8] = "CREATE_REGISTER";
  return OpCode2;
})(OpCode || {});
function ackOp(opId) {
  return {
    type: 5 /* DELETE_CRDT */,
    id: "ACK",
    // (H)ACK
    opId
  };
}
function isAckOp(op) {
  return op.type === 5 /* DELETE_CRDT */ && op.id === "ACK";
}

// src/crdts/AbstractCrdt.ts
function createManagedPool(roomId, options) {
  const {
    getCurrentConnectionId,
    onDispatch,
    isStorageWritable = () => true
  } = options;
  let clock = 0;
  let opClock = 0;
  const nodes = /* @__PURE__ */ new Map();
  return {
    roomId,
    nodes,
    getNode: (id) => nodes.get(id),
    addNode: (id, node) => void nodes.set(id, node),
    deleteNode: (id) => void nodes.delete(id),
    generateId: () => `${getCurrentConnectionId()}:${clock++}`,
    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,
    dispatch(ops, reverse, storageUpdates) {
      onDispatch?.(ops, reverse, storageUpdates);
    },
    assertStorageIsWritable: () => {
      if (!isStorageWritable()) {
        throw new Error(
          "Cannot write to storage with a read only user, please ensure the user has write permissions"
        );
      }
    }
  };
}
function crdtAsLiveNode(value) {
  return value;
}
function HasParent(node, key, pos = asPos(key)) {
  return Object.freeze({ type: "HasParent", node, key, pos });
}
var NoParent = Object.freeze({ type: "NoParent" });
function Orphaned(oldKey, oldPos = asPos(oldKey)) {
  return Object.freeze({ type: "Orphaned", oldKey, oldPos });
}
var AbstractCrdt = class {
  //                  ^^^^^^^^^^^^ TODO: Make this an interface
  #pool;
  #id;
  #parent = NoParent;
  /** @internal */
  _getParentKeyOrThrow() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _parentPos() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.pos;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldPos;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _pool() {
    return this.#pool;
  }
  get roomId() {
    return this.#pool ? this.#pool.roomId : null;
  }
  /** @internal */
  get _id() {
    return this.#id;
  }
  /** @internal */
  get parent() {
    return this.#parent;
  }
  /** @internal */
  get _parentKey() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        return null;
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _apply(op, _isLocal) {
    switch (op.type) {
      case 5 /* DELETE_CRDT */: {
        if (this.parent.type === "HasParent") {
          return this.parent.node._detachChild(crdtAsLiveNode(this));
        }
        return { modified: false };
      }
    }
    return { modified: false };
  }
  /** @internal */
  _setParentLink(newParentNode, newParentKey) {
    switch (this.parent.type) {
      case "HasParent":
        if (this.parent.node !== newParentNode) {
          throw new Error("Cannot set parent: node already has a parent");
        } else {
          this.#parent = HasParent(newParentNode, newParentKey);
          return;
        }
      case "Orphaned":
      case "NoParent": {
        this.#parent = HasParent(newParentNode, newParentKey);
        return;
      }
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _attach(id, pool) {
    if (this.#id || this.#pool) {
      throw new Error("Cannot attach node: already attached");
    }
    pool.addNode(id, crdtAsLiveNode(this));
    this.#id = id;
    this.#pool = pool;
  }
  /** @internal */
  _detach() {
    if (this.#pool && this.#id) {
      this.#pool.deleteNode(this.#id);
    }
    switch (this.parent.type) {
      case "HasParent": {
        this.#parent = Orphaned(this.parent.key, this.parent.pos);
        break;
      }
      case "NoParent": {
        this.#parent = NoParent;
        break;
      }
      case "Orphaned": {
        break;
      }
      default:
        assertNever(this.parent, "Unknown state");
    }
    this.#pool = void 0;
  }
  /** This caches the result of the last .toImmutable() call for this Live node. */
  #cachedImmutable;
  #cachedTreeNodeKey;
  /** This caches the result of the last .toTreeNode() call for this Live node. */
  #cachedTreeNode;
  /**
   * @internal
   *
   * Clear the Immutable cache, so that the next call to `.toImmutable()` will
   * recompute the equivalent Immutable value again.  Call this after every
   * mutation to the Live node.
   */
  invalidate() {
    if (this.#cachedImmutable !== void 0 || this.#cachedTreeNode !== void 0) {
      this.#cachedImmutable = void 0;
      this.#cachedTreeNode = void 0;
      if (this.parent.type === "HasParent") {
        this.parent.node.invalidate();
      }
    }
  }
  /**
   * @internal
   *
   * Return an snapshot of this Live tree for use in DevTools.
   */
  toTreeNode(key) {
    if (this.#cachedTreeNode === void 0 || this.#cachedTreeNodeKey !== key) {
      this.#cachedTreeNodeKey = key;
      this.#cachedTreeNode = this._toTreeNode(key);
    }
    return this.#cachedTreeNode;
  }
  /**
   * Return an immutable snapshot of this Live node and its children.
   */
  toImmutable() {
    if (this.#cachedImmutable === void 0) {
      this.#cachedImmutable = this._toImmutable();
    }
    return this.#cachedImmutable;
  }
};

// src/protocol/SerializedCrdt.ts
var CrdtType = /* @__PURE__ */ ((CrdtType2) => {
  CrdtType2[CrdtType2["OBJECT"] = 0] = "OBJECT";
  CrdtType2[CrdtType2["LIST"] = 1] = "LIST";
  CrdtType2[CrdtType2["MAP"] = 2] = "MAP";
  CrdtType2[CrdtType2["REGISTER"] = 3] = "REGISTER";
  return CrdtType2;
})(CrdtType || {});
function isRootCrdt(crdt) {
  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);
}
function isChildCrdt(crdt) {
  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;
}

// src/crdts/LiveRegister.ts
var LiveRegister = class _LiveRegister extends AbstractCrdt {
  #data;
  constructor(data) {
    super();
    this.#data = data;
  }
  get data() {
    return this.#data;
  }
  /** @internal */
  static _deserialize([id, item], _parentToChildren, pool) {
    const register = new _LiveRegister(item.data);
    register._attach(id, pool);
    return register;
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error(
        "Cannot serialize register if parentId or parentKey is undefined"
      );
    }
    return [
      {
        type: 8 /* CREATE_REGISTER */,
        opId: pool?.generateOpId(),
        id: this._id,
        parentId,
        parentKey,
        data: this.data
      }
    ];
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveRegister if parent is missing");
    }
    return {
      type: 3 /* REGISTER */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
      data: this.data
    };
  }
  /** @internal */
  _attachChild(_op) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _detachChild(_crdt) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  /** @internal */
  _toTreeNode(key) {
    return {
      type: "Json",
      id: this._id ?? nanoid(),
      key,
      payload: this.#data
    };
  }
  /** @internal */
  _toImmutable() {
    return this.#data;
  }
  clone() {
    return deepClone(this.data);
  }
};

// src/crdts/LiveList.ts
function compareNodePosition(itemA, itemB) {
  const posA = itemA._parentPos;
  const posB = itemB._parentPos;
  return posA === posB ? 0 : posA < posB ? -1 : 1;
}
var LiveList = class _LiveList extends AbstractCrdt {
  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?
  #items;
  #implicitlyDeletedItems;
  #unacknowledgedSets;
  constructor(items) {
    super();
    this.#items = [];
    this.#implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();
    this.#unacknowledgedSets = /* @__PURE__ */ new Map();
    let position = void 0;
    for (const item of items) {
      const newPosition = makePosition(position);
      const node = lsonToLiveNode(item);
      node._setParentLink(this, newPosition);
      this.#items.push(node);
      position = newPosition;
    }
  }
  /** @internal */
  static _deserialize([id], parentToChildren, pool) {
    const list = new _LiveList([]);
    list._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return list;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(list, crdt.parentKey);
      list._insertAndSort(child);
    }
    return list;
  }
  /**
   * @internal
   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'
   * so we mutate _unacknowledgedSets to avoid potential flickering
   * https://github.com/liveblocks/liveblocks/pull/1177
   *
   * This is quite unintuitive and should disappear as soon as
   * we introduce an explicit LiveList.Set operation
   */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool?.generateOpId(),
      type: 2 /* CREATE_LIST */,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const item of this.#items) {
      const parentKey2 = item._getParentKeyOrThrow();
      const childOps = HACK_addIntentAndDeletedIdToOperation(
        item._toOps(this._id, parentKey2, pool),
        void 0
      );
      const childOpId = childOps[0].opId;
      if (childOpId !== void 0) {
        this.#unacknowledgedSets.set(parentKey2, childOpId);
      }
      ops.push(...childOps);
    }
    return ops;
  }
  /**
   * @internal
   *
   * Adds a new item into the sorted list, in the correct position.
   */
  _insertAndSort(item) {
    this.#items.push(item);
    this._sortItems();
  }
  /** @internal */
  _sortItems() {
    this.#items.sort(compareNodePosition);
    this.invalidate();
  }
  /** @internal */
  _indexOfPosition(position) {
    return this.#items.findIndex(
      (item) => item._getParentKeyOrThrow() === position
    );
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const item of this.#items) {
      item._attach(pool.generateId(), pool);
    }
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const item of this.#items) {
      item._detach();
    }
  }
  #applySetRemote(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    child._attach(id, this._pool);
    child._setParentLink(this, key);
    const deletedId = op.deletedId;
    const indexOfItemWithSamePosition = this._indexOfPosition(key);
    if (indexOfItemWithSamePosition !== -1) {
      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];
      if (itemWithSamePosition._id === deletedId) {
        itemWithSamePosition._detach();
        this.#items[indexOfItemWithSamePosition] = child;
        return {
          modified: makeUpdate(this, [
            setDelta(indexOfItemWithSamePosition, child)
          ]),
          reverse: []
        };
      } else {
        this.#implicitlyDeletedItems.add(itemWithSamePosition);
        this.#items[indexOfItemWithSamePosition] = child;
        const delta = [
          setDelta(indexOfItemWithSamePosition, child)
        ];
        const deleteDelta2 = this.#detachItemAssociatedToSetOperation(
          op.deletedId
        );
        if (deleteDelta2) {
          delta.push(deleteDelta2);
        }
        return {
          modified: makeUpdate(this, delta),
          reverse: []
        };
      }
    } else {
      const updates = [];
      const deleteDelta2 = this.#detachItemAssociatedToSetOperation(
        op.deletedId
      );
      if (deleteDelta2) {
        updates.push(deleteDelta2);
      }
      this._insertAndSort(child);
      updates.push(insertDelta(this._indexOfPosition(key), child));
      return {
        reverse: [],
        modified: makeUpdate(this, updates)
      };
    }
  }
  #applySetAck(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const delta = [];
    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);
    if (deletedDelta) {
      delta.push(deletedDelta);
    }
    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);
    if (unacknowledgedOpId !== void 0) {
      if (unacknowledgedOpId !== op.opId) {
        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };
      } else {
        this.#unacknowledgedSets.delete(op.parentKey);
      }
    }
    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);
    const existingItem = this.#items.find((item) => item._id === op.id);
    if (existingItem !== void 0) {
      if (existingItem._parentKey === op.parentKey) {
        return {
          modified: delta.length > 0 ? makeUpdate(this, delta) : false,
          reverse: []
        };
      }
      if (indexOfItemWithSamePosition !== -1) {
        this.#implicitlyDeletedItems.add(
          this.#items[indexOfItemWithSamePosition]
        );
        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);
        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));
      }
      const prevIndex = this.#items.indexOf(existingItem);
      existingItem._setParentLink(this, op.parentKey);
      this._sortItems();
      const newIndex = this.#items.indexOf(existingItem);
      if (newIndex !== prevIndex) {
        delta.push(moveDelta(prevIndex, newIndex, existingItem));
      }
      return {
        modified: delta.length > 0 ? makeUpdate(this, delta) : false,
        reverse: []
      };
    } else {
      const orphan = this._pool.getNode(op.id);
      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, op.parentKey);
        this.#implicitlyDeletedItems.delete(orphan);
        this._insertAndSort(orphan);
        const recreatedItemIndex = this.#items.indexOf(orphan);
        return {
          modified: makeUpdate(this, [
            // If there is an item at this position, update is a set, else it's an insert
            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),
            ...delta
          ]),
          reverse: []
        };
      } else {
        if (indexOfItemWithSamePosition !== -1) {
          this.#items.splice(indexOfItemWithSamePosition, 1);
        }
        const { newItem, newIndex } = this.#createAttachItemAndSort(
          op,
          op.parentKey
        );
        return {
          modified: makeUpdate(this, [
            // If there is an item at this position, update is a set, else it's an insert
            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),
            ...delta
          ]),
          reverse: []
        };
      }
    }
  }
  /**
   * Returns the update delta of the deletion or null
   */
  #detachItemAssociatedToSetOperation(deletedId) {
    if (deletedId === void 0 || this._pool === void 0) {
      return null;
    }
    const deletedItem = this._pool.getNode(deletedId);
    if (deletedItem === void 0) {
      return null;
    }
    const result = this._detachChild(deletedItem);
    if (result.modified === false) {
      return null;
    }
    return result.modified.updates[0];
  }
  #applyRemoteInsert(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const key = asPos(op.parentKey);
    const existingItemIndex = this._indexOfPosition(key);
    if (existingItemIndex !== -1) {
      this.#shiftItemPosition(existingItemIndex, key);
    }
    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
      reverse: []
    };
  }
  #applyInsertAck(op) {
    const existingItem = this.#items.find((item) => item._id === op.id);
    const key = asPos(op.parentKey);
    const itemIndexAtPosition = this._indexOfPosition(key);
    if (existingItem) {
      if (existingItem._parentKey === key) {
        return {
          modified: false
        };
      } else {
        const oldPositionIndex = this.#items.indexOf(existingItem);
        if (itemIndexAtPosition !== -1) {
          this.#shiftItemPosition(itemIndexAtPosition, key);
        }
        existingItem._setParentLink(this, key);
        this._sortItems();
        const newIndex = this._indexOfPosition(key);
        if (newIndex === oldPositionIndex) {
          return { modified: false };
        }
        return {
          modified: makeUpdate(this, [
            moveDelta(oldPositionIndex, newIndex, existingItem)
          ]),
          reverse: []
        };
      }
    } else {
      const orphan = nn(this._pool).getNode(op.id);
      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, key);
        this.#implicitlyDeletedItems.delete(orphan);
        this._insertAndSort(orphan);
        const newIndex = this._indexOfPosition(key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),
          reverse: []
        };
      } else {
        if (itemIndexAtPosition !== -1) {
          this.#shiftItemPosition(itemIndexAtPosition, key);
        }
        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
          reverse: []
        };
      }
    }
  }
  #applyInsertUndoRedo(op) {
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    if (this._pool?.getNode(id) !== void 0) {
      return { modified: false };
    }
    child._attach(id, nn(this._pool));
    child._setParentLink(this, key);
    const existingItemIndex = this._indexOfPosition(key);
    let newKey = key;
    if (existingItemIndex !== -1) {
      const before2 = this.#items[existingItemIndex]?._parentPos;
      const after2 = this.#items[existingItemIndex + 1]?._parentPos;
      newKey = makePosition(before2, after2);
      child._setParentLink(this, newKey);
    }
    this._insertAndSort(child);
    const newIndex = this._indexOfPosition(newKey);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, child)]),
      reverse: [{ type: 5 /* DELETE_CRDT */, id }]
    };
  }
  #applySetUndoRedo(op) {
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    if (this._pool?.getNode(id) !== void 0) {
      return { modified: false };
    }
    this.#unacknowledgedSets.set(key, nn(op.opId));
    const indexOfItemWithSameKey = this._indexOfPosition(key);
    child._attach(id, nn(this._pool));
    child._setParentLink(this, key);
    const newKey = key;
    if (indexOfItemWithSameKey !== -1) {
      const existingItem = this.#items[indexOfItemWithSameKey];
      existingItem._detach();
      this.#items[indexOfItemWithSameKey] = child;
      const reverse = HACK_addIntentAndDeletedIdToOperation(
        existingItem._toOps(nn(this._id), key, this._pool),
        op.id
      );
      const delta = [setDelta(indexOfItemWithSameKey, child)];
      const deletedDelta = this.#detachItemAssociatedToSetOperation(
        op.deletedId
      );
      if (deletedDelta) {
        delta.push(deletedDelta);
      }
      return {
        modified: makeUpdate(this, delta),
        reverse
      };
    } else {
      this._insertAndSort(child);
      this.#detachItemAssociatedToSetOperation(op.deletedId);
      const newIndex = this._indexOfPosition(newKey);
      return {
        reverse: [{ type: 5 /* DELETE_CRDT */, id }],
        modified: makeUpdate(this, [insertDelta(newIndex, child)])
      };
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    let result;
    if (op.intent === "set") {
      if (source === 1 /* REMOTE */) {
        result = this.#applySetRemote(op);
      } else if (source === 2 /* ACK */) {
        result = this.#applySetAck(op);
      } else {
        result = this.#applySetUndoRedo(op);
      }
    } else {
      if (source === 1 /* REMOTE */) {
        result = this.#applyRemoteInsert(op);
      } else if (source === 2 /* ACK */) {
        result = this.#applyInsertAck(op);
      } else {
        result = this.#applyInsertUndoRedo(op);
      }
    }
    if (result.modified !== false) {
      this.invalidate();
    }
    return result;
  }
  /** @internal */
  _detachChild(child) {
    if (child) {
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(nn(this._id), parentKey, this._pool);
      const indexToDelete = this.#items.indexOf(child);
      if (indexToDelete === -1) {
        return {
          modified: false
        };
      }
      const [previousNode] = this.#items.splice(indexToDelete, 1);
      this.invalidate();
      child._detach();
      return {
        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),
        reverse
      };
    }
    return { modified: false };
  }
  #applySetChildKeyRemote(newKey, child) {
    if (this.#implicitlyDeletedItems.has(child)) {
      this.#implicitlyDeletedItems.delete(child);
      child._setParentLink(this, newKey);
      this._insertAndSort(child);
      const newIndex = this.#items.indexOf(child);
      return {
        modified: makeUpdate(this, [insertDelta(newIndex, child)]),
        reverse: []
      };
    }
    const previousKey = child._parentKey;
    if (newKey === previousKey) {
      return {
        modified: false
      };
    }
    const existingItemIndex = this._indexOfPosition(newKey);
    if (existingItemIndex === -1) {
      const previousIndex = this.#items.indexOf(child);
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this.#items.indexOf(child);
      if (newIndex === previousIndex) {
        return {
          modified: false
        };
      }
      return {
        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
        reverse: []
      };
    } else {
      this.#items[existingItemIndex]._setParentLink(
        this,
        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)
      );
      const previousIndex = this.#items.indexOf(child);
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this.#items.indexOf(child);
      if (newIndex === previousIndex) {
        return {
          modified: false
        };
      }
      return {
        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
        reverse: []
      };
    }
  }
  #applySetChildKeyAck(newKey, child) {
    const previousKey = nn(child._parentKey);
    if (this.#implicitlyDeletedItems.has(child)) {
      const existingItemIndex = this._indexOfPosition(newKey);
      this.#implicitlyDeletedItems.delete(child);
      if (existingItemIndex !== -1) {
        this.#items[existingItemIndex]._setParentLink(
          this,
          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)
        );
      }
      child._setParentLink(this, newKey);
      this._insertAndSort(child);
      return {
        modified: false
      };
    } else {
      if (newKey === previousKey) {
        return {
          modified: false
        };
      }
      const previousIndex = this.#items.indexOf(child);
      const existingItemIndex = this._indexOfPosition(newKey);
      if (existingItemIndex !== -1) {
        this.#items[existingItemIndex]._setParentLink(
          this,
          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)
        );
      }
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this.#items.indexOf(child);
      if (previousIndex === newIndex) {
        return {
          modified: false
        };
      } else {
        return {
          modified: makeUpdate(this, [
            moveDelta(previousIndex, newIndex, child)
          ]),
          reverse: []
        };
      }
    }
  }
  #applySetChildKeyUndoRedo(newKey, child) {
    const previousKey = nn(child._parentKey);
    const previousIndex = this.#items.indexOf(child);
    const existingItemIndex = this._indexOfPosition(newKey);
    let actualNewKey = newKey;
    if (existingItemIndex !== -1) {
      actualNewKey = makePosition(
        newKey,
        this.#items[existingItemIndex + 1]?._parentPos
      );
    }
    child._setParentLink(this, actualNewKey);
    this._sortItems();
    const newIndex = this.#items.indexOf(child);
    if (previousIndex === newIndex) {
      return {
        modified: false
      };
    }
    return {
      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
      reverse: [
        {
          type: 1 /* SET_PARENT_KEY */,
          id: nn(child._id),
          parentKey: previousKey
        }
      ]
    };
  }
  /** @internal */
  _setChildKey(newKey, child, source) {
    if (source === 1 /* REMOTE */) {
      return this.#applySetChildKeyRemote(newKey, child);
    } else if (source === 2 /* ACK */) {
      return this.#applySetChildKeyAck(newKey, child);
    } else {
      return this.#applySetChildKeyUndoRedo(newKey, child);
    }
  }
  /** @internal */
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveList if parent is missing");
    }
    return {
      type: 1 /* LIST */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns the number of elements.
   */
  get length() {
    return this.#items.length;
  }
  /**
   * Adds one element to the end of the LiveList.
   * @param element The element to add to the end of the LiveList.
   */
  push(element) {
    this._pool?.assertStorageIsWritable();
    return this.insert(element, this.length);
  }
  /**
   * Inserts one element at a specified index.
   * @param element The element to insert.
   * @param index The index at which you want to insert the element.
   */
  insert(element, index) {
    this._pool?.assertStorageIsWritable();
    if (index < 0 || index > this.#items.length) {
      throw new Error(
        `Cannot insert list item at index "${index}". index should be between 0 and ${this.#items.length}`
      );
    }
    const before2 = this.#items[index - 1] ? this.#items[index - 1]._parentPos : void 0;
    const after2 = this.#items[index] ? this.#items[index]._parentPos : void 0;
    const position = makePosition(before2, after2);
    const value = lsonToLiveNode(element);
    value._setParentLink(this, position);
    this._insertAndSort(value);
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      this._pool.dispatch(
        value._toOps(this._id, position, this._pool),
        [{ type: 5 /* DELETE_CRDT */, id }],
        /* @__PURE__ */ new Map([
          [this._id, makeUpdate(this, [insertDelta(index, value)])]
        ])
      );
    }
  }
  /**
   * Move one element from one index to another.
   * @param index The index of the element to move
   * @param targetIndex The index where the element should be after moving.
   */
  move(index, targetIndex) {
    this._pool?.assertStorageIsWritable();
    if (targetIndex < 0) {
      throw new Error("targetIndex cannot be less than 0");
    }
    if (targetIndex >= this.#items.length) {
      throw new Error(
        "targetIndex cannot be greater or equal than the list length"
      );
    }
    if (index < 0) {
      throw new Error("index cannot be less than 0");
    }
    if (index >= this.#items.length) {
      throw new Error("index cannot be greater or equal than the list length");
    }
    let beforePosition = null;
    let afterPosition = null;
    if (index < targetIndex) {
      afterPosition = targetIndex === this.#items.length - 1 ? void 0 : this.#items[targetIndex + 1]._parentPos;
      beforePosition = this.#items[targetIndex]._parentPos;
    } else {
      afterPosition = this.#items[targetIndex]._parentPos;
      beforePosition = targetIndex === 0 ? void 0 : this.#items[targetIndex - 1]._parentPos;
    }
    const position = makePosition(beforePosition, afterPosition);
    const item = this.#items[index];
    const previousPosition = item._getParentKeyOrThrow();
    item._setParentLink(this, position);
    this._sortItems();
    if (this._pool && this._id) {
      const storageUpdates = /* @__PURE__ */ new Map([
        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]
      ]);
      this._pool.dispatch(
        [
          {
            type: 1 /* SET_PARENT_KEY */,
            id: nn(item._id),
            opId: this._pool.generateOpId(),
            parentKey: position
          }
        ],
        [
          {
            type: 1 /* SET_PARENT_KEY */,
            id: nn(item._id),
            parentKey: previousPosition
          }
        ],
        storageUpdates
      );
    }
  }
  /**
   * Deletes an element at the specified index
   * @param index The index of the element to delete
   */
  delete(index) {
    this._pool?.assertStorageIsWritable();
    if (index < 0 || index >= this.#items.length) {
      throw new Error(
        `Cannot delete list item at index "${index}". index should be between 0 and ${this.#items.length - 1}`
      );
    }
    const item = this.#items[index];
    item._detach();
    const [prev] = this.#items.splice(index, 1);
    this.invalidate();
    if (this._pool) {
      const childRecordId = item._id;
      if (childRecordId) {
        const storageUpdates = /* @__PURE__ */ new Map();
        storageUpdates.set(
          nn(this._id),
          makeUpdate(this, [deleteDelta(index, prev)])
        );
        this._pool.dispatch(
          [
            {
              id: childRecordId,
              opId: this._pool.generateOpId(),
              type: 5 /* DELETE_CRDT */
            }
          ],
          item._toOps(nn(this._id), item._getParentKeyOrThrow()),
          storageUpdates
        );
      }
    }
  }
  clear() {
    this._pool?.assertStorageIsWritable();
    if (this._pool) {
      const ops = [];
      const reverseOps = [];
      const updateDelta = [];
      for (const item of this.#items) {
        item._detach();
        const childId = item._id;
        if (childId) {
          ops.push({
            type: 5 /* DELETE_CRDT */,
            id: childId,
            opId: this._pool.generateOpId()
          });
          reverseOps.push(
            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())
          );
          updateDelta.push(deleteDelta(0, item));
        }
      }
      this.#items = [];
      this.invalidate();
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    } else {
      for (const item of this.#items) {
        item._detach();
      }
      this.#items = [];
      this.invalidate();
    }
  }
  set(index, item) {
    this._pool?.assertStorageIsWritable();
    if (index < 0 || index >= this.#items.length) {
      throw new Error(
        `Cannot set list item at index "${index}". index should be between 0 and ${this.#items.length - 1}`
      );
    }
    const existingItem = this.#items[index];
    const position = existingItem._getParentKeyOrThrow();
    const existingId = existingItem._id;
    existingItem._detach();
    const value = lsonToLiveNode(item);
    value._setParentLink(this, position);
    this.#items[index] = value;
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));
      const ops = HACK_addIntentAndDeletedIdToOperation(
        value._toOps(this._id, position, this._pool),
        existingId
      );
      this.#unacknowledgedSets.set(position, nn(ops[0].opId));
      const reverseOps = HACK_addIntentAndDeletedIdToOperation(
        existingItem._toOps(this._id, position, void 0),
        id
      );
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    }
  }
  /**
   * Returns an Array of all the elements in the LiveList.
   */
  toArray() {
    return this.#items.map(
      (entry) => liveNodeToLson(entry)
      //                               ^^^^^^^^
      //                               FIXME! This isn't safe.
    );
  }
  /**
   * Tests whether all elements pass the test implemented by the provided function.
   * @param predicate Function to test for each element, taking two arguments (the element and its index).
   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.
   */
  every(predicate) {
    return this.toArray().every(predicate);
  }
  /**
   * Creates an array with all elements that pass the test implemented by the provided function.
   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.
   * @returns An array with the elements that pass the test.
   */
  filter(predicate) {
    return this.toArray().filter(predicate);
  }
  /**
   * Returns the first element that satisfies the provided testing function.
   * @param predicate Function to execute on each value.
   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.
   */
  find(predicate) {
    return this.toArray().find(predicate);
  }
  /**
   * Returns the index of the first element in the LiveList that satisfies the provided testing function.
   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.
   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.
   */
  findIndex(predicate) {
    return this.toArray().findIndex(predicate);
  }
  /**
   * Executes a provided function once for each element.
   * @param callbackfn Function to execute on each element.
   */
  forEach(callbackfn) {
    return this.toArray().forEach(callbackfn);
  }
  /**
   * Get the element at the specified index.
   * @param index The index on the element to get.
   * @returns The element at the specified index or undefined.
   */
  get(index) {
    if (index < 0 || index >= this.#items.length) {
      return void 0;
    }
    return liveNodeToLson(this.#items[index]);
  }
  /**
   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.
   * @param searchElement Element to locate.
   * @param fromIndex The index to start the search at.
   * @returns The first index of the element in the LiveList; -1 if not found.
   */
  indexOf(searchElement, fromIndex) {
    return this.toArray().indexOf(searchElement, fromIndex);
  }
  /**
   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.
   * @param searchElement Element to locate.
   * @param fromIndex The index at which to start searching backwards.
   * @returns
   */
  lastIndexOf(searchElement, fromIndex) {
    return this.toArray().lastIndexOf(searchElement, fromIndex);
  }
  /**
   * Creates an array populated with the results of calling a provided function on every element.
   * @param callback Function that is called for every element.
   * @returns An array with each element being the result of the callback function.
   */
  map(callback) {
    return this.#items.map(
      (entry, i) => callback(
        liveNodeToLson(entry),
        //                    ^^^^^^^^
        //                    FIXME! This isn't safe.
        i
      )
    );
  }
  /**
   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.
   * @param predicate Function to test for each element.
   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.
   */
  some(predicate) {
    return this.toArray().some(predicate);
  }
  [Symbol.iterator]() {
    return new LiveListIterator(this.#items);
  }
  #createAttachItemAndSort(op, key) {
    const newItem = creationOpToLiveNode(op);
    newItem._attach(op.id, nn(this._pool));
    newItem._setParentLink(this, key);
    this._insertAndSort(newItem);
    const newIndex = this._indexOfPosition(key);
    return { newItem, newIndex };
  }
  #shiftItemPosition(index, key) {
    const shiftedPosition = makePosition(
      key,
      this.#items.length > index + 1 ? this.#items[index + 1]?._parentPos : void 0
    );
    this.#items[index]._setParentLink(this, shiftedPosition);
  }
  /** @internal */
  _toTreeNode(key) {
    return {
      type: "LiveList",
      id: this._id ?? nanoid(),
      key,
      payload: this.#items.map(
        (item, index) => item.toTreeNode(index.toString())
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const result = this.#items.map((node) => node.toImmutable());
    return process.env.NODE_ENV === "production" ? result : Object.freeze(result);
  }
  clone() {
    return new _LiveList(this.#items.map((item) => item.clone()));
  }
};
var LiveListIterator = class {
  #innerIterator;
  constructor(items) {
    this.#innerIterator = items[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const result = this.#innerIterator.next();
    if (result.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const value = liveNodeToLson(result.value);
    return { value };
  }
};
function makeUpdate(liveList, deltaUpdates) {
  return {
    node: liveList,
    type: "LiveList",
    updates: deltaUpdates
  };
}
function setDelta(index, item) {
  return {
    index,
    type: "set",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function deleteDelta(index, deletedNode) {
  return {
    type: "delete",
    index,
    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode
  };
}
function insertDelta(index, item) {
  return {
    index,
    type: "insert",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function moveDelta(previousIndex, index, item) {
  return {
    type: "move",
    index,
    item: item instanceof LiveRegister ? item.data : item,
    previousIndex
  };
}
function HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {
  return ops.map((op, index) => {
    if (index === 0) {
      const firstOp = op;
      return {
        ...firstOp,
        intent: "set",
        deletedId
      };
    } else {
      return op;
    }
  });
}

// src/crdts/LiveMap.ts
var LiveMap = class _LiveMap extends AbstractCrdt {
  #map;
  #unacknowledgedSet;
  constructor(entries2) {
    super();
    this.#unacknowledgedSet = /* @__PURE__ */ new Map();
    if (entries2) {
      const mappedEntries = [];
      for (const [key, value] of entries2) {
        const node = lsonToLiveNode(value);
        node._setParentLink(this, key);
        mappedEntries.push([key, node]);
      }
      this.#map = new Map(mappedEntries);
    } else {
      this.#map = /* @__PURE__ */ new Map();
    }
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool?.generateOpId(),
      type: 7 /* CREATE_MAP */,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const [key, value] of this.#map) {
      ops.push(...value._toOps(this._id, key, pool));
    }
    return ops;
  }
  /** @internal */
  static _deserialize([id, _item], parentToChildren, pool) {
    const map = new _LiveMap();
    map._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return map;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(map, crdt.parentKey);
      map.#map.set(crdt.parentKey, child);
      map.invalidate();
    }
    return map;
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of this.#map) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, parentKey, opId } = op;
    const key = parentKey;
    const child = creationOpToLiveNode(op);
    if (this._pool.getNode(id) !== void 0) {
      return { modified: false };
    }
    if (source === 2 /* ACK */) {
      const lastUpdateOpId = this.#unacknowledgedSet.get(key);
      if (lastUpdateOpId === opId) {
        this.#unacknowledgedSet.delete(key);
        return { modified: false };
      } else if (lastUpdateOpId !== void 0) {
        return { modified: false };
      }
    } else if (source === 1 /* REMOTE */) {
      this.#unacknowledgedSet.delete(key);
    }
    const previousValue = this.#map.get(key);
    let reverse;
    if (previousValue) {
      const thisId = nn(this._id);
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else {
      reverse = [{ type: 5 /* DELETE_CRDT */, id }];
    }
    child._setParentLink(this, key);
    child._attach(id, this._pool);
    this.#map.set(key, child);
    this.invalidate();
    return {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      },
      reverse
    };
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const item of this.#map.values()) {
      item._detach();
    }
  }
  /** @internal */
  _detachChild(child) {
    const id = nn(this._id);
    const parentKey = nn(child._parentKey);
    const reverse = child._toOps(id, parentKey, this._pool);
    for (const [key, value] of this.#map) {
      if (value === child) {
        this.#map.delete(key);
        this.invalidate();
      }
    }
    child._detach();
    const storageUpdate = {
      node: this,
      type: "LiveMap",
      updates: { [parentKey]: { type: "delete" } }
    };
    return { modified: storageUpdate, reverse };
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveMap if parent is missing");
    }
    return {
      type: 2 /* MAP */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns a specified element from the LiveMap.
   * @param key The key of the element to return.
   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.
   */
  get(key) {
    const value = this.#map.get(key);
    if (value === void 0) {
      return void 0;
    }
    return liveNodeToLson(value);
  }
  /**
   * Adds or updates an element with a specified key and a value.
   * @param key The key of the element to add. Should be a string.
   * @param value The value of the element to add. Should be serializable to JSON.
   */
  set(key, value) {
    this._pool?.assertStorageIsWritable();
    const oldValue = this.#map.get(key);
    if (oldValue) {
      oldValue._detach();
    }
    const item = lsonToLiveNode(value);
    item._setParentLink(this, key);
    this.#map.set(key, item);
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      item._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      });
      const ops = item._toOps(this._id, key, this._pool);
      this.#unacknowledgedSet.set(key, nn(ops[0].opId));
      this._pool.dispatch(
        item._toOps(this._id, key, this._pool),
        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],
        storageUpdates
      );
    }
  }
  /**
   * Returns the number of elements in the LiveMap.
   */
  get size() {
    return this.#map.size;
  }
  /**
   * Returns a boolean indicating whether an element with the specified key exists or not.
   * @param key The key of the element to test for presence.
   */
  has(key) {
    return this.#map.has(key);
  }
  /**
   * Removes the specified element by key.
   * @param key The key of the element to remove.
   * @returns true if an element existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    this._pool?.assertStorageIsWritable();
    const item = this.#map.get(key);
    if (item === void 0) {
      return false;
    }
    item._detach();
    this.#map.delete(key);
    this.invalidate();
    if (this._pool && item._id) {
      const thisId = nn(this._id);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(thisId, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "delete" } }
      });
      this._pool.dispatch(
        [
          {
            type: 5 /* DELETE_CRDT */,
            id: item._id,
            opId: this._pool.generateOpId()
          }
        ],
        item._toOps(thisId, key),
        storageUpdates
      );
    }
    return true;
  }
  /**
   * Returns a new Iterator object that contains the [key, value] pairs for each element.
   */
  entries() {
    const innerIterator = this.#map.entries();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const entry = iteratorValue.value;
        const key = entry[0];
        const value = liveNodeToLson(iteratorValue.value[1]);
        return {
          value: [key, value]
        };
      }
    };
  }
  /**
   * Same function object as the initial value of the entries method.
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Returns a new Iterator object that contains the keys for each element.
   */
  keys() {
    return this.#map.keys();
  }
  /**
   * Returns a new Iterator object that contains the values for each element.
   */
  values() {
    const innerIterator = this.#map.values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const value = liveNodeToLson(iteratorValue.value);
        return { value };
      }
    };
  }
  /**
   * Executes a provided function once per each key/value pair in the Map object, in insertion order.
   * @param callback Function to execute for each entry in the map.
   */
  forEach(callback) {
    for (const entry of this) {
      callback(entry[1], entry[0], this);
    }
  }
  /** @internal */
  _toTreeNode(key) {
    return {
      type: "LiveMap",
      id: this._id ?? nanoid(),
      key,
      payload: Array.from(this.#map.entries()).map(
        ([key2, val]) => val.toTreeNode(key2)
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of this.#map) {
      result.set(key, value.toImmutable());
    }
    return freeze(result);
  }
  clone() {
    return new _LiveMap(
      Array.from(this.#map).map(([key, node]) => [key, node.clone()])
    );
  }
};

// src/crdts/LiveObject.ts
var MAX_LIVE_OBJECT_SIZE = 128 * 1024;
var LiveObject = class _LiveObject extends AbstractCrdt {
  #map;
  #propToLastUpdate;
  /**
   * Enable or disable detection of too large LiveObjects.
   * When enabled, throws an error if LiveObject static data exceeds 128KB, which
   * is the maximum value the server will be able to accept.
   * By default, this behavior is disabled to avoid the runtime performance
   * overhead on every LiveObject.set() or LiveObject.update() call.
   *
   * @experimental
   */
  static detectLargeObjects = false;
  static #buildRootAndParentToChildren(items) {
    const parentToChildren = /* @__PURE__ */ new Map();
    let root = null;
    for (const [id, crdt] of items) {
      if (isRootCrdt(crdt)) {
        root = [id, crdt];
      } else {
        const tuple = [id, crdt];
        const children = parentToChildren.get(crdt.parentId);
        if (children !== void 0) {
          children.push(tuple);
        } else {
          parentToChildren.set(crdt.parentId, [tuple]);
        }
      }
    }
    if (root === null) {
      throw new Error("Root can't be null");
    }
    return [root, parentToChildren];
  }
  /** @private Do not use this API directly */
  static _fromItems(items, pool) {
    const [root, parentToChildren] = _LiveObject.#buildRootAndParentToChildren(items);
    return _LiveObject._deserialize(
      root,
      parentToChildren,
      pool
    );
  }
  constructor(obj = {}) {
    super();
    this.#propToLastUpdate = /* @__PURE__ */ new Map();
    const o = compactObject(obj);
    for (const key of Object.keys(o)) {
      const value = o[key];
      if (isLiveNode(value)) {
        value._setParentLink(this, key);
      }
    }
    this.#map = new Map(Object.entries(o));
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const opId = pool?.generateOpId();
    const ops = [];
    const op = {
      type: 4 /* CREATE_OBJECT */,
      id: this._id,
      opId,
      parentId,
      parentKey,
      data: {}
    };
    ops.push(op);
    for (const [key, value] of this.#map) {
      if (isLiveNode(value)) {
        ops.push(...value._toOps(this._id, key, pool));
      } else {
        op.data[key] = value;
      }
    }
    return ops;
  }
  /** @internal */
  static _deserialize([id, item], parentToChildren, pool) {
    const liveObj = new _LiveObject(item.data);
    liveObj._attach(id, pool);
    return this._deserializeChildren(liveObj, parentToChildren, pool);
  }
  /** @internal */
  static _deserializeChildren(liveObj, parentToChildren, pool) {
    const children = parentToChildren.get(nn(liveObj._id));
    if (children === void 0) {
      return liveObj;
    }
    for (const [id, crdt] of children) {
      const child = deserializeToLson([id, crdt], parentToChildren, pool);
      if (isLiveStructure(child)) {
        child._setParentLink(liveObj, crdt.parentKey);
      }
      liveObj.#map.set(crdt.parentKey, child);
      liveObj.invalidate();
    }
    return liveObj;
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of this.#map) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, opId, parentKey: key } = op;
    const child = creationOpToLson(op);
    if (this._pool.getNode(id) !== void 0) {
      if (this.#propToLastUpdate.get(key) === opId) {
        this.#propToLastUpdate.delete(key);
      }
      return { modified: false };
    }
    if (source === 0 /* UNDOREDO_RECONNECT */) {
      this.#propToLastUpdate.set(key, nn(opId));
    } else if (this.#propToLastUpdate.get(key) === void 0) {
    } else if (this.#propToLastUpdate.get(key) === opId) {
      this.#propToLastUpdate.delete(key);
      return { modified: false };
    } else {
      return { modified: false };
    }
    const thisId = nn(this._id);
    const previousValue = this.#map.get(key);
    let reverse;
    if (isLiveNode(previousValue)) {
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else if (previousValue === void 0) {
      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];
    } else {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          id: thisId,
          data: { [key]: previousValue }
        }
      ];
    }
    this.#map.set(key, child);
    this.invalidate();
    if (isLiveStructure(child)) {
      child._setParentLink(this, key);
      child._attach(id, this._pool);
    }
    return {
      reverse,
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [key]: { type: "update" } }
      }
    };
  }
  /** @internal */
  _detachChild(child) {
    if (child) {
      const id = nn(this._id);
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(id, parentKey, this._pool);
      for (const [key, value] of this.#map) {
        if (value === child) {
          this.#map.delete(key);
          this.invalidate();
        }
      }
      child._detach();
      const storageUpdate = {
        node: this,
        type: "LiveObject",
        updates: {
          [parentKey]: { type: "delete" }
        }
      };
      return { modified: storageUpdate, reverse };
    }
    return { modified: false };
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const value of this.#map.values()) {
      if (isLiveNode(value)) {
        value._detach();
      }
    }
  }
  /** @internal */
  _apply(op, isLocal) {
    if (op.type === 3 /* UPDATE_OBJECT */) {
      return this.#applyUpdate(op, isLocal);
    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {
      return this.#applyDeleteObjectKey(op, isLocal);
    }
    return super._apply(op, isLocal);
  }
  /** @internal */
  _serialize() {
    const data = {};
    for (const [key, value] of this.#map) {
      if (!isLiveNode(value)) {
        data[key] = value;
      }
    }
    if (this.parent.type === "HasParent" && this.parent.node._id) {
      return {
        type: 0 /* OBJECT */,
        parentId: this.parent.node._id,
        parentKey: this.parent.key,
        data
      };
    } else {
      return {
        type: 0 /* OBJECT */,
        data
      };
    }
  }
  #applyUpdate(op, isLocal) {
    let isModified = false;
    const id = nn(this._id);
    const reverse = [];
    const reverseUpdate = {
      type: 3 /* UPDATE_OBJECT */,
      id,
      data: {}
    };
    for (const key in op.data) {
      const oldValue = this.#map.get(key);
      if (isLiveNode(oldValue)) {
        reverse.push(...oldValue._toOps(id, key));
        oldValue._detach();
      } else if (oldValue !== void 0) {
        reverseUpdate.data[key] = oldValue;
      } else if (oldValue === void 0) {
        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });
      }
    }
    const updateDelta = {};
    for (const key in op.data) {
      const value = op.data[key];
      if (value === void 0) {
        continue;
      }
      if (isLocal) {
        this.#propToLastUpdate.set(key, nn(op.opId));
      } else if (this.#propToLastUpdate.get(key) === void 0) {
        isModified = true;
      } else if (this.#propToLastUpdate.get(key) === op.opId) {
        this.#propToLastUpdate.delete(key);
        continue;
      } else {
        continue;
      }
      const oldValue = this.#map.get(key);
      if (isLiveNode(oldValue)) {
        oldValue._detach();
      }
      isModified = true;
      updateDelta[key] = { type: "update" };
      this.#map.set(key, value);
      this.invalidate();
    }
    if (Object.keys(reverseUpdate.data).length !== 0) {
      reverse.unshift(reverseUpdate);
    }
    return isModified ? {
      modified: {
        node: this,
        type: "LiveObject",
        updates: updateDelta
      },
      reverse
    } : { modified: false };
  }
  #applyDeleteObjectKey(op, isLocal) {
    const key = op.key;
    if (this.#map.has(key) === false) {
      return { modified: false };
    }
    if (!isLocal && this.#propToLastUpdate.get(key) !== void 0) {
      return { modified: false };
    }
    const oldValue = this.#map.get(key);
    const id = nn(this._id);
    let reverse = [];
    if (isLiveNode(oldValue)) {
      reverse = oldValue._toOps(id, op.key);
      oldValue._detach();
    } else if (oldValue !== void 0) {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          id,
          data: { [key]: oldValue }
        }
      ];
    }
    this.#map.delete(key);
    this.invalidate();
    return {
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [op.key]: { type: "delete" } }
      },
      reverse
    };
  }
  /**
   * Transform the LiveObject into a javascript object
   */
  toObject() {
    return Object.fromEntries(this.#map);
  }
  /**
   * Adds or updates a property with a specified key and a value.
   * @param key The key of the property to add
   * @param value The value of the property to add
   */
  set(key, value) {
    this._pool?.assertStorageIsWritable();
    this.update({ [key]: value });
  }
  /**
   * Returns a specified property from the LiveObject.
   * @param key The key of the property to get
   */
  get(key) {
    return this.#map.get(key);
  }
  /**
   * Deletes a key from the LiveObject
   * @param key The key of the property to delete
   */
  delete(key) {
    this._pool?.assertStorageIsWritable();
    const keyAsString = key;
    const oldValue = this.#map.get(keyAsString);
    if (oldValue === void 0) {
      return;
    }
    if (this._pool === void 0 || this._id === void 0) {
      if (isLiveNode(oldValue)) {
        oldValue._detach();
      }
      this.#map.delete(keyAsString);
      this.invalidate();
      return;
    }
    let reverse;
    if (isLiveNode(oldValue)) {
      oldValue._detach();
      reverse = oldValue._toOps(this._id, keyAsString);
    } else {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          data: { [keyAsString]: oldValue },
          id: this._id
        }
      ];
    }
    this.#map.delete(keyAsString);
    this.invalidate();
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: { [key]: { type: "delete" } }
    });
    this._pool.dispatch(
      [
        {
          type: 6 /* DELETE_OBJECT_KEY */,
          key: keyAsString,
          id: this._id,
          opId: this._pool.generateOpId()
        }
      ],
      reverse,
      storageUpdates
    );
  }
  /**
   * Adds or updates multiple properties at once with an object.
   * @param patch The object used to overrides properties
   */
  update(patch) {
    this._pool?.assertStorageIsWritable();
    if (_LiveObject.detectLargeObjects) {
      const data = {};
      for (const [key, value] of this.#map) {
        if (!isLiveNode(value)) {
          data[key] = value;
        }
      }
      for (const key of Object.keys(patch)) {
        const value = patch[key];
        if (value === void 0) continue;
        if (!isLiveNode(value)) {
          data[key] = value;
        }
      }
      const jsonString = JSON.stringify(data);
      const upperBoundSize = jsonString.length * 4;
      if (upperBoundSize > MAX_LIVE_OBJECT_SIZE) {
        const preciseSize = new TextEncoder().encode(jsonString).length;
        if (preciseSize > MAX_LIVE_OBJECT_SIZE) {
          throw new Error(
            `LiveObject size exceeded limit: ${preciseSize} bytes > ${MAX_LIVE_OBJECT_SIZE} bytes. See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits`
          );
        }
      }
    }
    if (this._pool === void 0 || this._id === void 0) {
      for (const key in patch) {
        const newValue = patch[key];
        if (newValue === void 0) {
          continue;
        }
        const oldValue = this.#map.get(key);
        if (isLiveNode(oldValue)) {
          oldValue._detach();
        }
        if (isLiveNode(newValue)) {
          newValue._setParentLink(this, key);
        }
        this.#map.set(key, newValue);
        this.invalidate();
      }
      return;
    }
    const ops = [];
    const reverseOps = [];
    const opId = this._pool.generateOpId();
    const updatedProps = {};
    const reverseUpdateOp = {
      id: this._id,
      type: 3 /* UPDATE_OBJECT */,
      data: {}
    };
    const updateDelta = {};
    for (const key in patch) {
      const newValue = patch[key];
      if (newValue === void 0) {
        continue;
      }
      const oldValue = this.#map.get(key);
      if (isLiveNode(oldValue)) {
        reverseOps.push(...oldValue._toOps(this._id, key));
        oldValue._detach();
      } else if (oldValue === void 0) {
        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });
      } else {
        reverseUpdateOp.data[key] = oldValue;
      }
      if (isLiveNode(newValue)) {
        newValue._setParentLink(this, key);
        newValue._attach(this._pool.generateId(), this._pool);
        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);
        const createCrdtOp = newAttachChildOps.find(
          (op) => op.parentId === this._id
        );
        if (createCrdtOp) {
          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));
        }
        ops.push(...newAttachChildOps);
      } else {
        updatedProps[key] = newValue;
        this.#propToLastUpdate.set(key, opId);
      }
      this.#map.set(key, newValue);
      this.invalidate();
      updateDelta[key] = { type: "update" };
    }
    if (Object.keys(reverseUpdateOp.data).length !== 0) {
      reverseOps.unshift(reverseUpdateOp);
    }
    if (Object.keys(updatedProps).length !== 0) {
      ops.unshift({
        opId,
        id: this._id,
        type: 3 /* UPDATE_OBJECT */,
        data: updatedProps
      });
    }
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: updateDelta
    });
    this._pool.dispatch(ops, reverseOps, storageUpdates);
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  toTreeNode(key) {
    return super.toTreeNode(key);
  }
  /** @internal */
  _toTreeNode(key) {
    const nodeId = this._id ?? nanoid();
    return {
      type: "LiveObject",
      id: nodeId,
      key,
      payload: Array.from(this.#map.entries()).map(
        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: "Json", id: `${nodeId}:${key2}`, key: key2, payload: value }
      )
    };
  }
  /** @internal */
  _toImmutable() {
    const result = {};
    for (const [key, val] of this.#map) {
      result[key] = isLiveStructure(val) ? val.toImmutable() : val;
    }
    return process.env.NODE_ENV === "production" ? result : Object.freeze(result);
  }
  clone() {
    return new _LiveObject(
      Object.fromEntries(
        Array.from(this.#map).map(([key, value]) => [
          key,
          isLiveStructure(value) ? value.clone() : deepClone(value)
        ])
      )
    );
  }
};

// src/crdts/liveblocks-helpers.ts
function creationOpToLiveNode(op) {
  return lsonToLiveNode(creationOpToLson(op));
}
function creationOpToLson(op) {
  switch (op.type) {
    case 8 /* CREATE_REGISTER */:
      return op.data;
    case 4 /* CREATE_OBJECT */:
      return new LiveObject(op.data);
    case 7 /* CREATE_MAP */:
      return new LiveMap();
    case 2 /* CREATE_LIST */:
      return new LiveList([]);
    default:
      return assertNever(op, "Unknown creation Op");
  }
}
function isSameNodeOrChildOf(node, parent) {
  if (node === parent) {
    return true;
  }
  if (node.parent.type === "HasParent") {
    return isSameNodeOrChildOf(node.parent.node, parent);
  }
  return false;
}
function deserialize([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0 /* OBJECT */: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1 /* LIST */: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2 /* MAP */: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3 /* REGISTER */: {
      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function deserializeToLson([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0 /* OBJECT */: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1 /* LIST */: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2 /* MAP */: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3 /* REGISTER */: {
      return crdt.data;
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function isLiveStructure(value) {
  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);
}
function isLiveNode(value) {
  return isLiveStructure(value) || isLiveRegister(value);
}
function isLiveList(value) {
  return value instanceof LiveList;
}
function isLiveMap(value) {
  return value instanceof LiveMap;
}
function isLiveObject(value) {
  return value instanceof LiveObject;
}
function isLiveRegister(value) {
  return value instanceof LiveRegister;
}
function cloneLson(value) {
  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);
}
function liveNodeToLson(obj) {
  if (obj instanceof LiveRegister) {
    return obj.data;
  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {
    return obj;
  } else {
    return assertNever(obj, "Unknown AbstractCrdt");
  }
}
function lsonToLiveNode(value) {
  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {
    return value;
  } else {
    return new LiveRegister(value);
  }
}
function getTreesDiffOperations(currentItems, newItems) {
  const ops = [];
  currentItems.forEach((_, id) => {
    if (!newItems.get(id)) {
      ops.push({
        type: 5 /* DELETE_CRDT */,
        id
      });
    }
  });
  newItems.forEach((crdt, id) => {
    const currentCrdt = currentItems.get(id);
    if (currentCrdt) {
      if (crdt.type === 0 /* OBJECT */) {
        if (currentCrdt.type !== 0 /* OBJECT */ || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {
          ops.push({
            type: 3 /* UPDATE_OBJECT */,
            id,
            data: crdt.data
          });
        }
      }
      if (crdt.parentKey !== currentCrdt.parentKey) {
        ops.push({
          type: 1 /* SET_PARENT_KEY */,
          id,
          parentKey: nn(crdt.parentKey, "Parent key must not be missing")
        });
      }
    } else {
      switch (crdt.type) {
        case 3 /* REGISTER */:
          ops.push({
            type: 8 /* CREATE_REGISTER */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey,
            data: crdt.data
          });
          break;
        case 1 /* LIST */:
          ops.push({
            type: 2 /* CREATE_LIST */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
        case 0 /* OBJECT */:
          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {
            throw new Error(
              "Internal error. Cannot serialize storage root into an operation"
            );
          }
          ops.push({
            type: 4 /* CREATE_OBJECT */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey,
            data: crdt.data
          });
          break;
        case 2 /* MAP */:
          ops.push({
            type: 7 /* CREATE_MAP */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
      }
    }
  });
  return ops;
}
function mergeObjectStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return {
    ...second,
    updates
  };
}
function mergeMapStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return {
    ...second,
    updates
  };
}
function mergeListStorageUpdates(first, second) {
  const updates = first.updates;
  return {
    ...second,
    updates: updates.concat(second.updates)
  };
}
function mergeStorageUpdates(first, second) {
  if (first === void 0) {
    return second;
  }
  if (first.type === "LiveObject" && second.type === "LiveObject") {
    return mergeObjectStorageUpdates(first, second);
  } else if (first.type === "LiveMap" && second.type === "LiveMap") {
    return mergeMapStorageUpdates(first, second);
  } else if (first.type === "LiveList" && second.type === "LiveList") {
    return mergeListStorageUpdates(first, second);
  } else {
  }
  return second;
}
function isPlain(value) {
  const type = typeof value;
  return value === void 0 || value === null || type === "string" || type === "boolean" || type === "number" || Array.isArray(value) || isPlainObject(value);
}
function findNonSerializableValue(value, path = "") {
  if (!isPlain) {
    return {
      path: path || "root",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  for (const [key, nestedValue] of Object.entries(value)) {
    const nestedPath = path ? path + "." + key : key;
    if (!isPlain(nestedValue)) {
      return {
        path: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      const nonSerializableNestedValue = findNonSerializableValue(
        nestedValue,
        nestedPath
      );
      if (nonSerializableNestedValue) {
        return nonSerializableNestedValue;
      }
    }
  }
  return false;
}

// src/lib/debug.ts
function captureStackTrace(msg, traceRoot) {
  const errorLike = { name: msg };
  if (typeof Error.captureStackTrace !== "function") {
    return void 0;
  }
  Error.captureStackTrace(errorLike, traceRoot);
  return errorLike.stack;
}

// src/lib/Deque.ts
var Deque = class {
  #data;
  #front;
  #back;
  #size;
  constructor() {
    this.#data = {};
    this.#front = 0;
    this.#back = 1;
    this.#size = 0;
  }
  get length() {
    return this.#size;
  }
  *[Symbol.iterator]() {
    const size = this.#size;
    const front = this.#front;
    for (let i = 0; i < size; i++) {
      yield this.#data[front + i];
    }
  }
  push(value) {
    const values2 = Array.isArray(value) ? value : [value];
    if (this.#back > Number.MAX_SAFE_INTEGER - values2.length - 1)
      raise("Deque full");
    for (const value2 of values2) {
      this.#data[this.#back++ - 1] = value2;
    }
    this.#size += values2.length;
  }
  pop() {
    if (this.#size < 1) return void 0;
    this.#back--;
    const value = this.#data[this.#back - 1];
    delete this.#data[this.#back - 1];
    this.#size--;
    return value;
  }
  pushLeft(value) {
    const values2 = Array.isArray(value) ? value : [value];
    if (this.#front < Number.MIN_SAFE_INTEGER + values2.length)
      raise("Deque full");
    for (let i = values2.length - 1; i >= 0; i--) {
      this.#data[--this.#front] = values2[i];
    }
    this.#size += values2.length;
  }
  popLeft() {
    if (this.#size < 1) return void 0;
    const value = this.#data[this.#front];
    delete this.#data[this.#front];
    this.#front++;
    this.#size--;
    return value;
  }
};

// src/lib/Json.ts
function isJsonScalar(data) {
  return data === null || typeof data === "string" || typeof data === "number" || typeof data === "boolean";
}
function isJsonArray(data) {
  return Array.isArray(data);
}
function isJsonObject(data) {
  return !isJsonScalar(data) && !isJsonArray(data);
}

// src/protocol/ClientMsg.ts
var ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {
  ClientMsgCode2[ClientMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ClientMsgCode2[ClientMsgCode2["BROADCAST_EVENT"] = 103] = "BROADCAST_EVENT";
  ClientMsgCode2[ClientMsgCode2["FETCH_STORAGE"] = 200] = "FETCH_STORAGE";
  ClientMsgCode2[ClientMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  ClientMsgCode2[ClientMsgCode2["FETCH_YDOC"] = 300] = "FETCH_YDOC";
  ClientMsgCode2[ClientMsgCode2["UPDATE_YDOC"] = 301] = "UPDATE_YDOC";
  return ClientMsgCode2;
})(ClientMsgCode || {});

// src/refs/ManagedOthers.ts
function makeUser(conn, presence) {
  const { connectionId, id, info } = conn;
  const canWrite = canWriteStorage(conn.scopes);
  return freeze(
    compactObject({
      connectionId,
      id,
      info,
      canWrite,
      canComment: canComment(conn.scopes),
      isReadOnly: !canWrite,
      // Deprecated, kept for backward-compatibility
      presence
    })
  );
}
var ManagedOthers = class {
  // Track mutable state internally, but signal to the outside when the
  // observable derived state changes only
  #internal;
  #userCache;
  // The "clean" signal that is exposed to the outside world
  signal;
  constructor() {
    this.#internal = new MutableSignal({
      connections: /* @__PURE__ */ new Map(),
      presences: /* @__PURE__ */ new Map()
    });
    this.signal = DerivedSignal.from(
      this.#internal,
      (_ignore) => compact(
        Array.from(this.#internal.get().presences.keys()).map(
          (connectionId) => this.getUser(Number(connectionId))
        )
      )
    );
    this.#userCache = /* @__PURE__ */ new Map();
  }
  // Shorthand for .signal.get()
  get() {
    return this.signal.get();
  }
  connectionIds() {
    return this.#internal.get().connections.keys();
  }
  clearOthers() {
    this.#internal.mutate((state) => {
      state.connections.clear();
      state.presences.clear();
      this.#userCache.clear();
    });
  }
  #_getUser(connectionId) {
    const state = this.#internal.get();
    const conn = state.connections.get(connectionId);
    const presence = state.presences.get(connectionId);
    if (conn !== void 0 && presence !== void 0) {
      return makeUser(conn, presence);
    }
    return void 0;
  }
  getUser(connectionId) {
    const cachedUser = this.#userCache.get(connectionId);
    if (cachedUser) {
      return cachedUser;
    }
    const computedUser = this.#_getUser(connectionId);
    if (computedUser) {
      this.#userCache.set(connectionId, computedUser);
      return computedUser;
    }
    return void 0;
  }
  #invalidateUser(connectionId) {
    this.#userCache.delete(connectionId);
  }
  /**
   * Records a known connection. This records the connection ID and the
   * associated metadata.
   */
  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {
    this.#internal.mutate((state) => {
      state.connections.set(
        connectionId,
        freeze({
          connectionId,
          id: metaUserId,
          info: metaUserInfo,
          scopes
        })
      );
      if (!state.presences.has(connectionId)) {
        return false;
      }
      return this.#invalidateUser(connectionId);
    });
  }
  /**
   * Removes a known connectionId. Removes both the connection's metadata and
   * the presence information.
   */
  removeConnection(connectionId) {
    this.#internal.mutate((state) => {
      state.connections.delete(connectionId);
      state.presences.delete(connectionId);
      this.#invalidateUser(connectionId);
    });
  }
  /**
   * Stores a new user from a full presence update. If the user already exists,
   * its known presence data is overwritten.
   */
  setOther(connectionId, presence) {
    this.#internal.mutate((state) => {
      state.presences.set(connectionId, freeze(compactObject(presence)));
      if (!state.connections.has(connectionId)) {
        return false;
      }
      return this.#invalidateUser(connectionId);
    });
  }
  /**
   * Patches the presence data for an existing "other". If we don't know the
   * initial presence data for this user yet, discard this patch and await the
   * full .setOther() call first.
   */
  patchOther(connectionId, patch) {
    this.#internal.mutate((state) => {
      const oldPresence = state.presences.get(connectionId);
      if (oldPresence === void 0) {
        return false;
      }
      const newPresence = merge(oldPresence, patch);
      if (oldPresence === newPresence) {
        return false;
      }
      state.presences.set(connectionId, freeze(newPresence));
      return this.#invalidateUser(connectionId);
    });
  }
};

// src/types/LiveblocksError.ts
var LiveblocksError = class _LiveblocksError extends Error {
  context;
  constructor(message, context, cause) {
    super(message, { cause });
    this.context = context;
    this.name = "LiveblocksError";
  }
  /** Convenience accessor for error.context.roomId (if available) */
  get roomId() {
    return this.context.roomId;
  }
  /** @internal Use `context.code` instead, to enable type narrowing */
  get code() {
    return this.context.code;
  }
  /**
   * Creates a LiveblocksError from a generic error, by attaching Liveblocks
   * contextual information like room ID, thread ID, etc.
   */
  static from(context, cause) {
    return new _LiveblocksError(
      defaultMessageFromContext(context),
      context,
      cause
    );
  }
};
function defaultMessageFromContext(context) {
  switch (context.type) {
    case "ROOM_CONNECTION_ERROR": {
      switch (context.code) {
        case 4001:
          return "Not allowed to connect to the room";
        case 4005:
          return "Room is already full";
        case 4006:
          return "Kicked out of the room, because the room ID changed";
        default:
          return "Could not connect to the room";
      }
    }
    case "AI_CONNECTION_ERROR": {
      switch (context.code) {
        case 4001:
          return "Not allowed to connect to ai";
        default:
          return "Could not connect to the room";
      }
    }
    case "CREATE_THREAD_ERROR":
      return "Could not create new thread";
    case "DELETE_THREAD_ERROR":
      return "Could not delete thread";
    case "EDIT_THREAD_METADATA_ERROR":
      return "Could not edit thread metadata";
    case "MARK_THREAD_AS_RESOLVED_ERROR":
      return "Could not mark thread as resolved";
    case "MARK_THREAD_AS_UNRESOLVED_ERROR":
      return "Could not mark thread as unresolved";
    case "SUBSCRIBE_TO_THREAD_ERROR":
      return "Could not subscribe to thread";
    case "UNSUBSCRIBE_FROM_THREAD_ERROR":
      return "Could not unsubscribe from thread";
    case "CREATE_COMMENT_ERROR":
      return "Could not create new comment";
    case "EDIT_COMMENT_ERROR":
      return "Could not edit comment";
    case "DELETE_COMMENT_ERROR":
      return "Could not delete comment";
    case "ADD_REACTION_ERROR":
      return "Could not add reaction";
    case "REMOVE_REACTION_ERROR":
      return "Could not remove reaction";
    case "MARK_INBOX_NOTIFICATION_AS_READ_ERROR":
      return "Could not mark inbox notification as read";
    case "DELETE_INBOX_NOTIFICATION_ERROR":
      return "Could not delete inbox notification";
    case "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR":
      return "Could not mark all inbox notifications as read";
    case "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR":
      return "Could not delete all inbox notifications";
    case "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR":
      return "Could not update room subscription settings";
    case "UPDATE_NOTIFICATION_SETTINGS_ERROR":
      return "Could not update notification settings";
    case "LARGE_MESSAGE_ERROR":
      return "Could not send large message";
    default:
      return assertNever(context, "Unhandled case");
  }
}

// src/room.ts
var MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;
function makeIdFactory(connectionId) {
  let count = 0;
  return () => `${connectionId}:${count++}`;
}
function userToTreeNode(key, user) {
  return {
    type: "User",
    id: `${user.connectionId}`,
    key,
    payload: {
      connectionId: user.connectionId,
      id: user.id,
      info: user.info,
      presence: user.presence,
      isReadOnly: !user.canWrite
    }
  };
}
function installBackgroundTabSpy() {
  const doc = typeof document !== "undefined" ? document : void 0;
  const inBackgroundSince = { current: null };
  function onVisibilityChange() {
    if (doc?.visibilityState === "hidden") {
      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();
    } else {
      inBackgroundSince.current = null;
    }
  }
  doc?.addEventListener("visibilitychange", onVisibilityChange);
  const unsub = () => {
    doc?.removeEventListener("visibilitychange", onVisibilityChange);
  };
  return [inBackgroundSince, unsub];
}
function createRoom(options, config) {
  const roomId = config.roomId;
  const initialPresence = options.initialPresence;
  const initialStorage = options.initialStorage;
  const httpClient = config.roomHttpClient;
  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();
  const delegates = {
    ...config.delegates,
    // A connection is allowed to go into "zombie state" only if all of the
    // following conditions apply:
    //
    // - The `backgroundKeepAliveTimeout` client option is configured
    // - The browser window has been in the background for at least
    //   `backgroundKeepAliveTimeout` milliseconds
    // - There are no pending changes
    //
    canZombie() {
      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== "synchronizing";
    }
  };
  const managedSocket = new ManagedSocket(
    delegates,
    config.enableDebugLogging
  );
  const context = {
    buffer: {
      flushTimerID: void 0,
      lastFlushedAt: 0,
      presenceUpdates: (
        // Queue up the initial presence message as a Full Presence update
        {
          type: "full",
          data: initialPresence
        }
      ),
      messages: [],
      storageOperations: []
    },
    staticSessionInfoSig: new Signal(null),
    dynamicSessionInfoSig: new Signal(null),
    myPresence: new PatchableSignal(initialPresence),
    others: new ManagedOthers(),
    initialStorage,
    idFactory: null,
    // The Yjs provider associated to this room
    yjsProvider: void 0,
    yjsProviderDidChange: makeEventSource(),
    // Storage
    pool: createManagedPool(roomId, {
      getCurrentConnectionId,
      onDispatch,
      isStorageWritable
    }),
    root: void 0,
    undoStack: [],
    redoStack: [],
    pausedHistory: null,
    activeBatch: null,
    unacknowledgedOps: /* @__PURE__ */ new Map(),
    // Debug
    opStackTraces: process.env.NODE_ENV !== "production" ? /* @__PURE__ */ new Map() : void 0
  };
  let lastTokenKey;
  function onStatusDidChange(newStatus) {
    const authValue = managedSocket.authValue;
    if (authValue !== null) {
      const tokenKey = getBearerTokenFromAuthValue(authValue);
      if (tokenKey !== lastTokenKey) {
        lastTokenKey = tokenKey;
        if (authValue.type === "secret") {
          const token = authValue.token.parsed;
          context.staticSessionInfoSig.set({
            userId: token.k === "sec-legacy" /* SECRET_LEGACY */ ? token.id : token.uid,
            userInfo: token.k === "sec-legacy" /* SECRET_LEGACY */ ? token.info : token.ui
          });
        } else {
          context.staticSessionInfoSig.set({
            userId: void 0,
            userInfo: void 0
          });
        }
      }
    }
    eventHub.status.notify(newStatus);
    notifySelfChanged();
  }
  let _connectionLossTimerId;
  let _hasLostConnection = false;
  function handleConnectionLossEvent(newStatus) {
    if (newStatus === "reconnecting") {
      _connectionLossTimerId = setTimeout(() => {
        eventHub.lostConnection.notify("lost");
        _hasLostConnection = true;
        context.others.clearOthers();
        notify({ others: [{ type: "reset" }] });
      }, config.lostConnectionTimeout);
    } else {
      clearTimeout(_connectionLossTimerId);
      if (_hasLostConnection) {
        if (newStatus === "disconnected") {
          eventHub.lostConnection.notify("failed");
        } else {
          eventHub.lostConnection.notify("restored");
        }
        _hasLostConnection = false;
      }
    }
  }
  function onDidConnect() {
    context.buffer.presenceUpdates = {
      type: "full",
      data: (
        // Because context.me.current is a readonly object, we'll have to
        // make a copy here. Otherwise, type errors happen later when
        // "patching" my presence.
        { ...context.myPresence.get() }
      )
    };
    if (_getStorage$ !== null) {
      refreshStorage({ flush: false });
    }
    flushNowOrSoon();
  }
  function onDidDisconnect() {
    clearTimeout(context.buffer.flushTimerID);
  }
  managedSocket.events.onMessage.subscribe(handleServerMessage);
  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);
  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);
  managedSocket.events.didConnect.subscribe(onDidConnect);
  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);
  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {
    const type = "ROOM_CONNECTION_ERROR";
    const err = new LiveblocksError(message, { type, code, roomId });
    const didNotify = config.errorEventSource.notify(err);
    if (!didNotify) {
      if (process.env.NODE_ENV !== "production") {
        error2(
          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`
        );
      }
    }
  });
  function onDispatch(ops, reverse, storageUpdates) {
    if (process.env.NODE_ENV !== "production") {
      const stackTrace = captureStackTrace("Storage mutation", onDispatch);
      if (stackTrace) {
        for (const op of ops) {
          if (op.opId) {
            nn(context.opStackTraces).set(op.opId, stackTrace);
          }
        }
      }
    }
    if (context.activeBatch) {
      for (const op of ops) {
        context.activeBatch.ops.push(op);
      }
      for (const [key, value] of storageUpdates) {
        context.activeBatch.updates.storageUpdates.set(
          key,
          mergeStorageUpdates(
            context.activeBatch.updates.storageUpdates.get(key),
            value
          )
        );
      }
      context.activeBatch.reverseOps.pushLeft(reverse);
    } else {
      addToUndoStack(reverse);
      context.redoStack.length = 0;
      dispatchOps(ops);
      notify({ storageUpdates });
    }
  }
  function isStorageWritable() {
    const scopes = context.dynamicSessionInfoSig.get()?.scopes;
    return scopes !== void 0 ? canWriteStorage(scopes) : true;
  }
  const eventHub = {
    status: makeEventSource(),
    // New/recommended API
    lostConnection: makeEventSource(),
    customEvent: makeEventSource(),
    self: makeEventSource(),
    myPresence: makeEventSource(),
    others: makeEventSource(),
    storageBatch: makeEventSource(),
    history: makeEventSource(),
    storageDidLoad: makeEventSource(),
    storageStatus: makeEventSource(),
    ydoc: makeEventSource(),
    comments: makeEventSource(),
    roomWillDestroy: makeEventSource()
  };
  async function createTextMention(mentionId, mention) {
    return httpClient.createTextMention({ roomId, mentionId, mention });
  }
  async function deleteTextMention(mentionId) {
    return httpClient.deleteTextMention({ roomId, mentionId });
  }
  async function reportTextEditor(type, rootKey) {
    await httpClient.reportTextEditor({ roomId, type, rootKey });
  }
  async function listTextVersions() {
    return httpClient.listTextVersions({ roomId });
  }
  async function listTextVersionsSince(options2) {
    return httpClient.listTextVersionsSince({
      roomId,
      since: options2.since,
      signal: options2.signal
    });
  }
  async function getTextVersion(versionId) {
    return httpClient.getTextVersion({ roomId, versionId });
  }
  async function createTextVersion() {
    return httpClient.createTextVersion({ roomId });
  }
  async function executeContextualPrompt(options2) {
    return httpClient.executeContextualPrompt({
      roomId,
      ...options2
    });
  }
  function* chunkOps(msg) {
    const { ops, ...rest } = msg;
    if (ops.length < 2) {
      throw new Error("Cannot split ops into smaller chunks");
    }
    const mid = Math.floor(ops.length / 2);
    const firstHalf = ops.slice(0, mid);
    const secondHalf = ops.slice(mid);
    for (const halfOps of [firstHalf, secondHalf]) {
      const half = { ops: halfOps, ...rest };
      const text = stringifyOrLog([half]);
      if (!isTooBigForWebSocket(text)) {
        yield text;
      } else {
        yield* chunkOps(half);
      }
    }
  }
  function* chunkMessages(messages) {
    if (messages.length < 2) {
      if (messages[0].type === 201 /* UPDATE_STORAGE */) {
        yield* chunkOps(messages[0]);
        return;
      } else {
        throw new Error(
          "Cannot split into chunks smaller than the allowed message size"
        );
      }
    }
    const mid = Math.floor(messages.length / 2);
    const firstHalf = messages.slice(0, mid);
    const secondHalf = messages.slice(mid);
    for (const half of [firstHalf, secondHalf]) {
      const text = stringifyOrLog(half);
      if (!isTooBigForWebSocket(text)) {
        yield text;
      } else {
        yield* chunkMessages(half);
      }
    }
  }
  function isTooBigForWebSocket(text) {
    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {
      return false;
    }
    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;
  }
  function sendMessages(messages) {
    const strategy = config.largeMessageStrategy ?? "default";
    const text = stringifyOrLog(messages);
    if (!isTooBigForWebSocket(text)) {
      return managedSocket.send(text);
    }
    switch (strategy) {
      case "default": {
        const type = "LARGE_MESSAGE_ERROR";
        const err = new LiveblocksError("Message is too large for websockets", {
          type
        });
        const didNotify = config.errorEventSource.notify(err);
        if (!didNotify) {
          error2(
            "Message is too large for websockets.  Configure largeMessageStrategy option or useErrorListener to handle this."
          );
        }
        return;
      }
      case "split": {
        warn("Message is too large for websockets, splitting into smaller chunks");
        for (const chunk2 of chunkMessages(messages)) {
          managedSocket.send(chunk2);
        }
        return;
      }
      case "experimental-fallback-to-http": {
        warn("Message is too large for websockets, so sending over HTTP instead");
        const nonce = context.dynamicSessionInfoSig.get()?.nonce ?? raise("Session is not authorized to send message over HTTP");
        void httpClient.sendMessages({ roomId, nonce, messages }).then((resp) => {
          if (!resp.ok && resp.status === 403) {
            managedSocket.reconnect();
          }
        });
        return;
      }
    }
  }
  const self = DerivedSignal.from(
    context.staticSessionInfoSig,
    context.dynamicSessionInfoSig,
    context.myPresence,
    (staticSession, dynamicSession, myPresence) => {
      if (staticSession === null || dynamicSession === null) {
        return null;
      } else {
        const canWrite = canWriteStorage(dynamicSession.scopes);
        return {
          connectionId: dynamicSession.actor,
          id: staticSession.userId,
          info: staticSession.userInfo,
          presence: myPresence,
          canWrite,
          canComment: canComment(dynamicSession.scopes)
        };
      }
    }
  );
  let _lastSelf;
  function notifySelfChanged() {
    const currSelf = self.get();
    if (currSelf !== null && currSelf !== _lastSelf) {
      eventHub.self.notify(currSelf);
      _lastSelf = currSelf;
    }
  }
  const selfAsTreeNode = DerivedSignal.from(
    self,
    (me) => me !== null ? userToTreeNode("Me", me) : null
  );
  function createOrUpdateRootFromMessage(message) {
    if (message.items.length === 0) {
      throw new Error("Internal error: cannot load storage without items");
    }
    if (context.root !== void 0) {
      updateRoot(message.items);
    } else {
      context.root = LiveObject._fromItems(message.items, context.pool);
    }
    const canWrite = self.get()?.canWrite ?? true;
    const stackSizeBefore = context.undoStack.length;
    for (const key in context.initialStorage) {
      if (context.root.get(key) === void 0) {
        if (canWrite) {
          context.root.set(key, cloneLson(context.initialStorage[key]));
        } else {
          warn(
            `Attempted to populate missing storage key '${key}', but current user has no write access`
          );
        }
      }
    }
    context.undoStack.length = stackSizeBefore;
  }
  function updateRoot(items) {
    if (context.root === void 0) {
      return;
    }
    const currentItems = /* @__PURE__ */ new Map();
    for (const [id, node] of context.pool.nodes) {
      currentItems.set(id, node._serialize());
    }
    const ops = getTreesDiffOperations(currentItems, new Map(items));
    const result = applyOps(ops, false);
    notify(result.updates);
  }
  function _addToRealUndoStack(historyOps) {
    if (context.undoStack.length >= 50) {
      context.undoStack.shift();
    }
    context.undoStack.push(historyOps);
    onHistoryChange();
  }
  function addToUndoStack(historyOps) {
    if (context.pausedHistory !== null) {
      context.pausedHistory.pushLeft(historyOps);
    } else {
      _addToRealUndoStack(historyOps);
    }
  }
  function notify(updates) {
    const storageUpdates = updates.storageUpdates;
    const othersUpdates = updates.others;
    if (othersUpdates !== void 0 && othersUpdates.length > 0) {
      const others = context.others.get();
      for (const event of othersUpdates) {
        eventHub.others.notify({ ...event, others });
      }
    }
    if (updates.presence ?? false) {
      notifySelfChanged();
      eventHub.myPresence.notify(context.myPresence.get());
    }
    if (storageUpdates !== void 0 && storageUpdates.size > 0) {
      const updates2 = Array.from(storageUpdates.values());
      eventHub.storageBatch.notify(updates2);
    }
    notifyStorageStatus();
  }
  function getCurrentConnectionId() {
    const info = context.dynamicSessionInfoSig.get();
    if (info) {
      return info.actor;
    }
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function applyOps(rawOps, isLocal) {
    const output = {
      reverse: new Deque(),
      storageUpdates: /* @__PURE__ */ new Map(),
      presence: false
    };
    const createdNodeIds = /* @__PURE__ */ new Set();
    const ops = rawOps.map((op) => {
      if (op.type !== "presence" && !op.opId) {
        return { ...op, opId: context.pool.generateOpId() };
      } else {
        return op;
      }
    });
    for (const op of ops) {
      if (op.type === "presence") {
        const reverse = {
          type: "presence",
          data: {}
        };
        for (const key in op.data) {
          reverse.data[key] = context.myPresence.get()[key];
        }
        context.myPresence.patch(op.data);
        if (context.buffer.presenceUpdates === null) {
          context.buffer.presenceUpdates = { type: "partial", data: op.data };
        } else {
          for (const key in op.data) {
            context.buffer.presenceUpdates.data[key] = op.data[key];
          }
        }
        output.reverse.pushLeft(reverse);
        output.presence = true;
      } else {
        let source;
        if (isLocal) {
          source = 0 /* UNDOREDO_RECONNECT */;
        } else {
          const opId = nn(op.opId);
          if (process.env.NODE_ENV !== "production") {
            nn(context.opStackTraces).delete(opId);
          }
          const deleted = context.unacknowledgedOps.delete(opId);
          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;
        }
        const applyOpResult = applyOp(op, source);
        if (applyOpResult.modified) {
          const nodeId = applyOpResult.modified.node._id;
          if (!(nodeId && createdNodeIds.has(nodeId))) {
            output.storageUpdates.set(
              nn(applyOpResult.modified.node._id),
              mergeStorageUpdates(
                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),
                applyOpResult.modified
              )
            );
            output.reverse.pushLeft(applyOpResult.reverse);
          }
          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {
            createdNodeIds.add(nn(op.id));
          }
        }
      }
    }
    return {
      ops,
      reverse: Array.from(output.reverse),
      updates: {
        storageUpdates: output.storageUpdates,
        presence: output.presence
      }
    };
  }
  function applyOp(op, source) {
    if (isAckOp(op)) {
      return { modified: false };
    }
    switch (op.type) {
      case 6 /* DELETE_OBJECT_KEY */:
      case 3 /* UPDATE_OBJECT */:
      case 5 /* DELETE_CRDT */: {
        const node = context.pool.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);
      }
      case 1 /* SET_PARENT_KEY */: {
        const node = context.pool.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        if (node.parent.type === "HasParent" && isLiveList(node.parent.node)) {
          return node.parent.node._setChildKey(
            asPos(op.parentKey),
            node,
            source
          );
        }
        return { modified: false };
      }
      case 4 /* CREATE_OBJECT */:
      case 2 /* CREATE_LIST */:
      case 7 /* CREATE_MAP */:
      case 8 /* CREATE_REGISTER */: {
        if (op.parentId === void 0) {
          return { modified: false };
        }
        const parentNode = context.pool.nodes.get(op.parentId);
        if (parentNode === void 0) {
          return { modified: false };
        }
        return parentNode._attachChild(op, source);
      }
    }
  }
  function updatePresence(patch, options2) {
    const oldValues = {};
    if (context.buffer.presenceUpdates === null) {
      context.buffer.presenceUpdates = {
        type: "partial",
        data: {}
      };
    }
    for (const key in patch) {
      const overrideValue = patch[key];
      if (overrideValue === void 0) {
        continue;
      }
      context.buffer.presenceUpdates.data[key] = overrideValue;
      oldValues[key] = context.myPresence.get()[key];
    }
    context.myPresence.patch(patch);
    if (context.activeBatch) {
      if (options2?.addToHistory) {
        context.activeBatch.reverseOps.pushLeft({
          type: "presence",
          data: oldValues
        });
      }
      context.activeBatch.updates.presence = true;
    } else {
      flushNowOrSoon();
      if (options2?.addToHistory) {
        addToUndoStack([{ type: "presence", data: oldValues }]);
      }
      notify({ presence: true });
    }
  }
  function onUpdatePresenceMessage(message) {
    if (message.targetActor !== void 0) {
      const oldUser = context.others.getUser(message.actor);
      context.others.setOther(message.actor, message.data);
      const newUser = context.others.getUser(message.actor);
      if (oldUser === void 0 && newUser !== void 0) {
        return { type: "enter", user: newUser };
      }
    } else {
      context.others.patchOther(message.actor, message.data), message;
    }
    const user = context.others.getUser(message.actor);
    if (user) {
      return {
        type: "update",
        updates: message.data,
        user
      };
    } else {
      return void 0;
    }
  }
  function onUserLeftMessage(message) {
    const user = context.others.getUser(message.actor);
    if (user) {
      context.others.removeConnection(message.actor);
      return { type: "leave", user };
    }
    return null;
  }
  function onRoomStateMessage(message) {
    context.dynamicSessionInfoSig.set({
      actor: message.actor,
      nonce: message.nonce,
      scopes: message.scopes
    });
    context.idFactory = makeIdFactory(message.actor);
    notifySelfChanged();
    for (const connectionId of context.others.connectionIds()) {
      const user = message.users[connectionId];
      if (user === void 0) {
        context.others.removeConnection(connectionId);
      }
    }
    for (const key in message.users) {
      const user = message.users[key];
      const connectionId = Number(key);
      context.others.setConnection(
        connectionId,
        user.id,
        user.info,
        user.scopes
      );
    }
    return { type: "reset" };
  }
  function canUndo() {
    return context.undoStack.length > 0;
  }
  function canRedo() {
    return context.redoStack.length > 0;
  }
  function onHistoryChange() {
    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });
  }
  function onUserJoinedMessage(message) {
    context.others.setConnection(
      message.actor,
      message.id,
      message.info,
      message.scopes
    );
    context.buffer.messages.push({
      type: 100 /* UPDATE_PRESENCE */,
      data: context.myPresence.get(),
      targetActor: message.actor
    });
    flushNowOrSoon();
    const user = context.others.getUser(message.actor);
    return user ? { type: "enter", user } : void 0;
  }
  function parseServerMessage(data) {
    if (!isJsonObject(data)) {
      return null;
    }
    return data;
  }
  function parseServerMessages(text) {
    const data = tryParseJson(text);
    if (data === void 0) {
      return null;
    } else if (isJsonArray(data)) {
      return compact(data.map((item) => parseServerMessage(item)));
    } else {
      return compact([parseServerMessage(data)]);
    }
  }
  function applyAndSendOps(offlineOps) {
    if (offlineOps.size === 0) {
      return;
    }
    const messages = [];
    const inOps = Array.from(offlineOps.values());
    const result = applyOps(inOps, true);
    messages.push({
      type: 201 /* UPDATE_STORAGE */,
      ops: result.ops
    });
    notify(result.updates);
    sendMessages(messages);
  }
  function handleServerMessage(event) {
    if (typeof event.data !== "string") {
      return;
    }
    const messages = parseServerMessages(event.data);
    if (messages === null || messages.length === 0) {
      return;
    }
    const updates = {
      storageUpdates: /* @__PURE__ */ new Map(),
      others: []
    };
    for (const message of messages) {
      switch (message.type) {
        case 101 /* USER_JOINED */: {
          const userJoinedUpdate = onUserJoinedMessage(message);
          if (userJoinedUpdate) {
            updates.others.push(userJoinedUpdate);
          }
          break;
        }
        case 100 /* UPDATE_PRESENCE */: {
          const othersPresenceUpdate = onUpdatePresenceMessage(message);
          if (othersPresenceUpdate) {
            updates.others.push(othersPresenceUpdate);
          }
          break;
        }
        case 103 /* BROADCASTED_EVENT */: {
          const others = context.others.get();
          eventHub.customEvent.notify({
            connectionId: message.actor,
            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,
            event: message.event
          });
          break;
        }
        case 102 /* USER_LEFT */: {
          const event2 = onUserLeftMessage(message);
          if (event2) {
            updates.others.push(event2);
          }
          break;
        }
        case 300 /* UPDATE_YDOC */: {
          eventHub.ydoc.notify(message);
          break;
        }
        case 104 /* ROOM_STATE */: {
          updates.others.push(onRoomStateMessage(message));
          break;
        }
        case 200 /* INITIAL_STORAGE_STATE */: {
          processInitialStorage(message);
          break;
        }
        // Write event
        case 201 /* UPDATE_STORAGE */: {
          const applyResult = applyOps(message.ops, false);
          for (const [key, value] of applyResult.updates.storageUpdates) {
            updates.storageUpdates.set(
              key,
              mergeStorageUpdates(updates.storageUpdates.get(key), value)
            );
          }
          break;
        }
        // Receiving a RejectedOps message in the client means that the server is no
        // longer in sync with the client. Trying to synchronize the client again by
        // rolling back particular Ops may be hard/impossible. It's fine to not try and
        // accept the out-of-sync reality and throw an error. We look at this kind of bug
        // as a developer-owned bug. In production, these errors are not expected to happen.
        case 299 /* REJECT_STORAGE_OP */: {
          errorWithTitle(
            "Storage mutation rejection error",
            message.reason
          );
          if (process.env.NODE_ENV !== "production") {
            const traces = /* @__PURE__ */ new Set();
            for (const opId of message.opIds) {
              const trace = context.opStackTraces?.get(opId);
              if (trace) {
                traces.add(trace);
              }
            }
            if (traces.size > 0) {
              warnWithTitle(
                "The following function calls caused the rejected storage mutations:",
                `

${Array.from(traces).join("\n\n")}`
              );
            }
            throw new Error(
              `Storage mutations rejected by server: ${message.reason}`
            );
          }
          break;
        }
        case 400 /* THREAD_CREATED */:
        case 407 /* THREAD_DELETED */:
        case 401 /* THREAD_METADATA_UPDATED */:
        case 408 /* THREAD_UPDATED */:
        case 405 /* COMMENT_REACTION_ADDED */:
        case 406 /* COMMENT_REACTION_REMOVED */:
        case 402 /* COMMENT_CREATED */:
        case 403 /* COMMENT_EDITED */:
        case 404 /* COMMENT_DELETED */: {
          eventHub.comments.notify(message);
          break;
        }
      }
    }
    notify(updates);
  }
  function flushNowOrSoon() {
    const storageOps = context.buffer.storageOperations;
    if (storageOps.length > 0) {
      for (const op of storageOps) {
        context.unacknowledgedOps.set(nn(op.opId), op);
      }
      notifyStorageStatus();
    }
    if (managedSocket.getStatus() !== "connected") {
      context.buffer.storageOperations = [];
      return;
    }
    const now2 = Date.now();
    const elapsedMillis = now2 - context.buffer.lastFlushedAt;
    if (elapsedMillis >= config.throttleDelay) {
      const messagesToFlush = serializeBuffer();
      if (messagesToFlush.length === 0) {
        return;
      }
      sendMessages(messagesToFlush);
      context.buffer = {
        flushTimerID: void 0,
        lastFlushedAt: now2,
        messages: [],
        storageOperations: [],
        presenceUpdates: null
      };
    } else {
      clearTimeout(context.buffer.flushTimerID);
      context.buffer.flushTimerID = setTimeout(
        flushNowOrSoon,
        config.throttleDelay - elapsedMillis
      );
    }
  }
  function serializeBuffer() {
    const messages = [];
    if (context.buffer.presenceUpdates) {
      messages.push(
        context.buffer.presenceUpdates.type === "full" ? {
          type: 100 /* UPDATE_PRESENCE */,
          // Populating the `targetActor` field turns this message into
          // a Full Presence update message (not a patch), which will get
          // interpreted by other clients as such.
          targetActor: -1,
          data: context.buffer.presenceUpdates.data
        } : {
          type: 100 /* UPDATE_PRESENCE */,
          data: context.buffer.presenceUpdates.data
        }
      );
    }
    for (const event of context.buffer.messages) {
      messages.push(event);
    }
    if (context.buffer.storageOperations.length > 0) {
      messages.push({
        type: 201 /* UPDATE_STORAGE */,
        ops: context.buffer.storageOperations
      });
    }
    return messages;
  }
  function updateYDoc(update, guid, isV2) {
    const clientMsg = {
      type: 301 /* UPDATE_YDOC */,
      update,
      guid,
      v2: isV2
    };
    context.buffer.messages.push(clientMsg);
    eventHub.ydoc.notify(clientMsg);
    flushNowOrSoon();
  }
  function broadcastEvent(event, options2 = {
    shouldQueueEventIfNotReady: false
  }) {
    if (managedSocket.getStatus() !== "connected" && !options2.shouldQueueEventIfNotReady) {
      return;
    }
    context.buffer.messages.push({
      type: 103 /* BROADCAST_EVENT */,
      event
    });
    flushNowOrSoon();
  }
  function dispatchOps(ops) {
    const { storageOperations } = context.buffer;
    for (const op of ops) {
      storageOperations.push(op);
    }
    flushNowOrSoon();
  }
  let _getStorage$ = null;
  let _resolveStoragePromise = null;
  function processInitialStorage(message) {
    const unacknowledgedOps = new Map(context.unacknowledgedOps);
    createOrUpdateRootFromMessage(message);
    applyAndSendOps(unacknowledgedOps);
    _resolveStoragePromise?.();
    notifyStorageStatus();
    eventHub.storageDidLoad.notify();
  }
  async function streamStorage() {
    if (!managedSocket.authValue) return;
    const items = await httpClient.streamStorage({ roomId });
    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });
  }
  function refreshStorage(options2) {
    const messages = context.buffer.messages;
    if (config.unstable_streamData) {
      void streamStorage();
    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {
      messages.push({ type: 200 /* FETCH_STORAGE */ });
    }
    if (options2.flush) {
      flushNowOrSoon();
    }
  }
  function startLoadingStorage() {
    if (_getStorage$ === null) {
      refreshStorage({ flush: true });
      _getStorage$ = new Promise((resolve) => {
        _resolveStoragePromise = resolve;
      });
      notifyStorageStatus();
    }
    return _getStorage$;
  }
  function getStorageSnapshot() {
    const root = context.root;
    if (root !== void 0) {
      return root;
    } else {
      void startLoadingStorage();
      return null;
    }
  }
  async function getStorage() {
    if (context.root !== void 0) {
      return Promise.resolve({
        root: context.root
      });
    }
    await startLoadingStorage();
    return {
      root: nn(context.root)
    };
  }
  function fetchYDoc(vector, guid, isV2) {
    if (!context.buffer.messages.find((m) => {
      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid && m.v2 === isV2;
    })) {
      context.buffer.messages.push({
        type: 300 /* FETCH_YDOC */,
        vector,
        guid,
        v2: isV2
      });
    }
    flushNowOrSoon();
  }
  function undo() {
    if (context.activeBatch) {
      throw new Error("undo is not allowed during a batch");
    }
    const historyOps = context.undoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    context.pausedHistory = null;
    const result = applyOps(historyOps, true);
    notify(result.updates);
    context.redoStack.push(result.reverse);
    onHistoryChange();
    for (const op of result.ops) {
      if (op.type !== "presence") {
        context.buffer.storageOperations.push(op);
      }
    }
    flushNowOrSoon();
  }
  function redo() {
    if (context.activeBatch) {
      throw new Error("redo is not allowed during a batch");
    }
    const historyOps = context.redoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    context.pausedHistory = null;
    const result = applyOps(historyOps, true);
    notify(result.updates);
    context.undoStack.push(result.reverse);
    onHistoryChange();
    for (const op of result.ops) {
      if (op.type !== "presence") {
        context.buffer.storageOperations.push(op);
      }
    }
    flushNowOrSoon();
  }
  function clear() {
    context.undoStack.length = 0;
    context.redoStack.length = 0;
  }
  function batch2(callback) {
    if (context.activeBatch) {
      return callback();
    }
    let returnValue = void 0;
    context.activeBatch = {
      ops: [],
      updates: {
        storageUpdates: /* @__PURE__ */ new Map(),
        presence: false,
        others: []
      },
      reverseOps: new Deque()
    };
    try {
      returnValue = callback();
    } finally {
      const currentBatch = context.activeBatch;
      context.activeBatch = null;
      if (currentBatch.reverseOps.length > 0) {
        addToUndoStack(Array.from(currentBatch.reverseOps));
      }
      if (currentBatch.ops.length > 0) {
        context.redoStack.length = 0;
      }
      if (currentBatch.ops.length > 0) {
        dispatchOps(currentBatch.ops);
      }
      notify(currentBatch.updates);
      flushNowOrSoon();
    }
    return returnValue;
  }
  function pauseHistory() {
    if (context.pausedHistory === null) {
      context.pausedHistory = new Deque();
    }
  }
  function resumeHistory() {
    const historyOps = context.pausedHistory;
    context.pausedHistory = null;
    if (historyOps !== null && historyOps.length > 0) {
      _addToRealUndoStack(Array.from(historyOps));
    }
  }
  const syncSourceForStorage = config.createSyncSource();
  function getStorageStatus() {
    if (context.root === void 0) {
      return _getStorage$ === null ? "not-loaded" : "loading";
    } else {
      return context.unacknowledgedOps.size === 0 ? "synchronized" : "synchronizing";
    }
  }
  let _lastStorageStatus = getStorageStatus();
  function notifyStorageStatus() {
    const storageStatus = getStorageStatus();
    if (_lastStorageStatus !== storageStatus) {
      _lastStorageStatus = storageStatus;
      eventHub.storageStatus.notify(storageStatus);
    }
    syncSourceForStorage.setSyncStatus(
      storageStatus === "synchronizing" ? "synchronizing" : "synchronized"
    );
  }
  function isPresenceReady() {
    return self.get() !== null;
  }
  async function waitUntilPresenceReady() {
    while (!isPresenceReady()) {
      const { promise, resolve } = Promise_withResolvers();
      const unsub1 = events.self.subscribeOnce(resolve);
      const unsub2 = events.status.subscribeOnce(resolve);
      await promise;
      unsub1();
      unsub2();
    }
  }
  function isStorageReady() {
    return getStorageSnapshot() !== null;
  }
  async function waitUntilStorageReady() {
    while (!isStorageReady()) {
      await getStorage();
    }
  }
  const others_forDevTools = DerivedSignal.from(
    context.others.signal,
    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))
  );
  const events = {
    status: eventHub.status.observable,
    lostConnection: eventHub.lostConnection.observable,
    customEvent: eventHub.customEvent.observable,
    others: eventHub.others.observable,
    self: eventHub.self.observable,
    myPresence: eventHub.myPresence.observable,
    storageBatch: eventHub.storageBatch.observable,
    history: eventHub.history.observable,
    storageDidLoad: eventHub.storageDidLoad.observable,
    storageStatus: eventHub.storageStatus.observable,
    ydoc: eventHub.ydoc.observable,
    comments: eventHub.comments.observable,
    roomWillDestroy: eventHub.roomWillDestroy.observable
  };
  async function getThreadsSince(options2) {
    return httpClient.getThreadsSince({
      roomId,
      since: options2.since,
      signal: options2.signal
    });
  }
  async function getThreads(options2) {
    return httpClient.getThreads({
      roomId,
      query: options2?.query,
      cursor: options2?.cursor
    });
  }
  async function getThread(threadId) {
    return httpClient.getThread({ roomId, threadId });
  }
  async function createThread(options2) {
    return httpClient.createThread({
      roomId,
      threadId: options2.threadId,
      commentId: options2.commentId,
      metadata: options2.metadata,
      body: options2.body,
      attachmentIds: options2.attachmentIds
    });
  }
  async function deleteThread(threadId) {
    return httpClient.deleteThread({ roomId, threadId });
  }
  async function editThreadMetadata({
    metadata,
    threadId
  }) {
    return httpClient.editThreadMetadata({ roomId, threadId, metadata });
  }
  async function markThreadAsResolved(threadId) {
    return httpClient.markThreadAsResolved({ roomId, threadId });
  }
  async function markThreadAsUnresolved(threadId) {
    return httpClient.markThreadAsUnresolved({
      roomId,
      threadId
    });
  }
  async function subscribeToThread(threadId) {
    return httpClient.subscribeToThread({ roomId, threadId });
  }
  async function unsubscribeFromThread(threadId) {
    return httpClient.unsubscribeFromThread({ roomId, threadId });
  }
  async function createComment(options2) {
    return httpClient.createComment({
      roomId,
      threadId: options2.threadId,
      commentId: options2.commentId,
      body: options2.body,
      attachmentIds: options2.attachmentIds
    });
  }
  async function editComment(options2) {
    return httpClient.editComment({
      roomId,
      threadId: options2.threadId,
      commentId: options2.commentId,
      body: options2.body,
      attachmentIds: options2.attachmentIds
    });
  }
  async function deleteComment({
    threadId,
    commentId
  }) {
    return httpClient.deleteComment({ roomId, threadId, commentId });
  }
  async function addReaction({
    threadId,
    commentId,
    emoji
  }) {
    return httpClient.addReaction({ roomId, threadId, commentId, emoji });
  }
  async function removeReaction({
    threadId,
    commentId,
    emoji
  }) {
    return await httpClient.removeReaction({
      roomId,
      threadId,
      commentId,
      emoji
    });
  }
  function prepareAttachment(file) {
    return {
      type: "localAttachment",
      status: "idle",
      id: createCommentAttachmentId(),
      name: file.name,
      size: file.size,
      mimeType: file.type,
      file
    };
  }
  async function uploadAttachment(attachment, options2 = {}) {
    return httpClient.uploadAttachment({
      roomId,
      attachment,
      signal: options2.signal
    });
  }
  function getAttachmentUrl(attachmentId) {
    return httpClient.getAttachmentUrl({ roomId, attachmentId });
  }
  function getSubscriptionSettings(options2) {
    return httpClient.getSubscriptionSettings({
      roomId,
      signal: options2?.signal
    });
  }
  function updateSubscriptionSettings(settings) {
    return httpClient.updateSubscriptionSettings({ roomId, settings });
  }
  async function markInboxNotificationAsRead(inboxNotificationId) {
    await httpClient.markRoomInboxNotificationAsRead({
      roomId,
      inboxNotificationId
    });
  }
  const syncSourceForYjs = config.createSyncSource();
  function yjsStatusDidChange(status) {
    return syncSourceForYjs.setSyncStatus(
      status === "synchronizing" || status === "loading" ? "synchronizing" : "synchronized"
    );
  }
  return Object.defineProperty(
    {
      [kInternal]: {
        get presenceBuffer() {
          return deepClone(context.buffer.presenceUpdates?.data ?? null);
        },
        // prettier-ignore
        get undoStack() {
          return deepClone(context.undoStack);
        },
        // prettier-ignore
        get nodeCount() {
          return context.pool.nodes.size;
        },
        // prettier-ignore
        getYjsProvider() {
          return context.yjsProvider;
        },
        setYjsProvider(newProvider) {
          context.yjsProvider?.off("status", yjsStatusDidChange);
          context.yjsProvider = newProvider;
          newProvider?.on("status", yjsStatusDidChange);
          context.yjsProviderDidChange.notify();
        },
        yjsProviderDidChange: context.yjsProviderDidChange.observable,
        // send metadata when using a text editor
        reportTextEditor,
        // create a text mention when using a text editor
        createTextMention,
        // delete a text mention when using a text editor
        deleteTextMention,
        // list versions of the document
        listTextVersions,
        // List versions of the document since the specified date
        listTextVersionsSince,
        // get a specific version
        getTextVersion,
        // create a version
        createTextVersion,
        // execute a contextual prompt
        executeContextualPrompt,
        // Support for the Liveblocks browser extension
        getSelf_forDevTools: () => selfAsTreeNode.get(),
        getOthers_forDevTools: () => others_forDevTools.get(),
        // prettier-ignore
        simulate: {
          // These exist only for our E2E testing app
          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: "EXPLICIT_SOCKET_CLOSE", event }),
          rawSend: (data) => managedSocket.send(data)
        },
        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)
      },
      id: roomId,
      subscribe: makeClassicSubscribeFn(
        roomId,
        events,
        config.errorEventSource
      ),
      connect: () => managedSocket.connect(),
      reconnect: () => managedSocket.reconnect(),
      disconnect: () => managedSocket.disconnect(),
      destroy: () => {
        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;
        for (const source of Object.values(eventsExceptDestroy)) {
          source.dispose();
        }
        eventHub.roomWillDestroy.notify();
        context.yjsProvider?.off("status", yjsStatusDidChange);
        syncSourceForStorage.destroy();
        syncSourceForYjs.destroy();
        uninstallBgTabSpy();
        managedSocket.destroy();
        roomWillDestroy.dispose();
      },
      // Presence
      updatePresence,
      updateYDoc,
      broadcastEvent,
      // Storage
      batch: batch2,
      history: {
        undo,
        redo,
        canUndo,
        canRedo,
        clear,
        pause: pauseHistory,
        resume: resumeHistory
      },
      fetchYDoc,
      getStorage,
      getStorageSnapshot,
      getStorageStatus,
      isPresenceReady,
      isStorageReady,
      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),
      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),
      events,
      // Core
      getStatus: () => managedSocket.getStatus(),
      getSelf: () => self.get(),
      // Presence
      getPresence: () => context.myPresence.get(),
      getOthers: () => context.others.get(),
      // Comments
      getThreads,
      getThreadsSince,
      getThread,
      createThread,
      deleteThread,
      editThreadMetadata,
      markThreadAsResolved,
      markThreadAsUnresolved,
      subscribeToThread,
      unsubscribeFromThread,
      createComment,
      editComment,
      deleteComment,
      addReaction,
      removeReaction,
      prepareAttachment,
      uploadAttachment,
      getAttachmentUrl,
      // Notifications
      getNotificationSettings: getSubscriptionSettings,
      getSubscriptionSettings,
      updateNotificationSettings: updateSubscriptionSettings,
      updateSubscriptionSettings,
      markInboxNotificationAsRead
    },
    // Explictly make the internal field non-enumerable, to avoid aggressive
    // freezing when used with Immer
    kInternal,
    { enumerable: false }
  );
}
function makeClassicSubscribeFn(roomId, events, errorEvents) {
  function subscribeToLiveStructureDeeply(node, callback) {
    return events.storageBatch.subscribe((updates) => {
      const relatedUpdates = updates.filter(
        (update) => isSameNodeOrChildOf(update.node, node)
      );
      if (relatedUpdates.length > 0) {
        callback(relatedUpdates);
      }
    });
  }
  function subscribeToLiveStructureShallowly(node, callback) {
    return events.storageBatch.subscribe((updates) => {
      for (const update of updates) {
        if (update.node._id === node._id) {
          callback(update.node);
        }
      }
    });
  }
  function subscribe(first, second, options) {
    if (typeof first === "string" && isRoomEventName(first)) {
      if (typeof second !== "function") {
        throw new Error("Second argument must be a callback function");
      }
      const callback = second;
      switch (first) {
        case "event":
          return events.customEvent.subscribe(
            callback
          );
        case "my-presence":
          return events.myPresence.subscribe(callback);
        case "others": {
          const cb = callback;
          return events.others.subscribe((event) => {
            const { others, ...internalEvent } = event;
            return cb(others, internalEvent);
          });
        }
        case "error": {
          return errorEvents.subscribe((err) => {
            if (err.roomId === roomId) {
              return callback(err);
            }
          });
        }
        case "status":
          return events.status.subscribe(callback);
        case "lost-connection":
          return events.lostConnection.subscribe(
            callback
          );
        case "history":
          return events.history.subscribe(callback);
        case "storage-status":
          return events.storageStatus.subscribe(
            callback
          );
        case "comments":
          return events.comments.subscribe(
            callback
          );
        // istanbul ignore next
        default:
          return assertNever(
            first,
            `"${String(first)}" is not a valid event name`
          );
      }
    }
    if (second === void 0 || typeof first === "function") {
      if (typeof first === "function") {
        const storageCallback = first;
        return events.storageBatch.subscribe(storageCallback);
      } else {
        throw new Error("Please specify a listener callback");
      }
    }
    if (isLiveNode(first)) {
      const node = first;
      if (options?.isDeep) {
        const storageCallback = second;
        return subscribeToLiveStructureDeeply(node, storageCallback);
      } else {
        const nodeCallback = second;
        return subscribeToLiveStructureShallowly(node, nodeCallback);
      }
    }
    throw new Error(
      `${String(first)} is not a value that can be subscribed to.`
    );
  }
  return subscribe;
}
function isRoomEventName(value) {
  return value === "my-presence" || value === "others" || value === "event" || value === "error" || value === "history" || value === "status" || value === "storage-status" || value === "lost-connection" || value === "connection" || value === "comments";
}
function makeAuthDelegateForRoom(roomId, authManager) {
  return async () => {
    return authManager.getAuthValue({ requestedScope: "room:read", roomId });
  };
}
function makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {
  return (authValue) => {
    const ws = WebSocketPolyfill ?? (typeof WebSocket === "undefined" ? void 0 : WebSocket);
    if (ws === void 0) {
      throw new StopRetrying(
        "To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill."
      );
    }
    const url2 = new URL(baseUrl);
    url2.protocol = url2.protocol === "http:" ? "ws" : "wss";
    url2.pathname = "/v7";
    url2.searchParams.set("roomId", roomId);
    if (authValue.type === "secret") {
      url2.searchParams.set("tok", authValue.token.raw);
    } else if (authValue.type === "public") {
      url2.searchParams.set("pubkey", authValue.publicApiKey);
    } else {
      return assertNever(authValue, "Unhandled case");
    }
    url2.searchParams.set("version", PKG_VERSION || "dev");
    return new ws(url2.toString());
  };
}

// src/client.ts
var MIN_THROTTLE = 16;
var MAX_THROTTLE = 1e3;
var DEFAULT_THROTTLE = 100;
var MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;
var MIN_LOST_CONNECTION_TIMEOUT = 200;
var RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;
var MAX_LOST_CONNECTION_TIMEOUT = 3e4;
var DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;
var RESOLVE_USERS_BATCH_DELAY = 50;
var RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;
var RESOLVE_GROUPS_INFO_BATCH_DELAY = 50;
function getBaseUrl(baseUrl) {
  if (typeof baseUrl === "string" && baseUrl.startsWith("http")) {
    return baseUrl;
  } else {
    return DEFAULT_BASE_URL;
  }
}
function createClient(options) {
  const clientOptions = options;
  const throttleDelay = process.env.NODE_ENV !== "production" && clientOptions.__DANGEROUSLY_disableThrottling ? 0 : getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);
  const lostConnectionTimeout = getLostConnectionTimeout(
    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT
  );
  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(
    clientOptions.backgroundKeepAliveTimeout
  );
  const baseUrl = getBaseUrl(clientOptions.baseUrl);
  const currentUserId = new Signal(void 0);
  const authManager = createAuthManager(options, (token) => {
    const userId = token.k === "sec-legacy" /* SECRET_LEGACY */ ? token.id : token.uid;
    currentUserId.set(() => userId);
  });
  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */
  globalThis.fetch?.bind(globalThis);
  const httpClient = createApiClient({
    baseUrl,
    fetchPolyfill,
    currentUserId,
    authManager
  });
  const roomsById = /* @__PURE__ */ new Map();
  const ai = createAi({
    userId: currentUserId.get(),
    lostConnectionTimeout,
    backgroundKeepAliveTimeout: getBackgroundKeepAliveTimeout(
      clientOptions.backgroundKeepAliveTimeout
    ),
    polyfills: clientOptions.polyfills,
    delegates: {
      createSocket: makeCreateSocketDelegateForAi(
        baseUrl,
        clientOptions.polyfills?.WebSocket
      ),
      authenticate: async () => {
        const resp = await authManager.getAuthValue({
          requestedScope: "room:read"
        });
        if (resp.type === "public") {
          throw new StopRetrying(
            "Cannot use AI Copilots with a public API key"
          );
        } else if (resp.token.parsed.k === "sec-legacy" /* SECRET_LEGACY */) {
          throw new StopRetrying("AI Copilots requires an ID or Access token");
        } else {
          if (!resp.token.parsed.ai) {
            throw new StopRetrying(
              "AI Copilots is not yet enabled for this account. To get started, see https://liveblocks.io/docs/get-started/ai-copilots#Quickstart"
            );
          }
        }
        return resp;
      },
      canZombie: () => false
    }
  });
  function teardownRoom(room) {
    unlinkDevTools(room.id);
    roomsById.delete(room.id);
    room.destroy();
  }
  function leaseRoom(details) {
    const leave = () => {
      const self = leave;
      if (!details.unsubs.delete(self)) {
        warn(
          "This leave function was already called. Calling it more than once has no effect."
        );
      } else {
        if (details.unsubs.size === 0) {
          teardownRoom(details.room);
        }
      }
    };
    details.unsubs.add(leave);
    return {
      room: details.room,
      leave
    };
  }
  function enterRoom(roomId, ...args) {
    const existing = roomsById.get(roomId);
    if (existing !== void 0) {
      return leaseRoom(existing);
    }
    const options2 = args[0] ?? {};
    const initialPresence = (typeof options2.initialPresence === "function" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};
    const initialStorage = (typeof options2.initialStorage === "function" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};
    const newRoom = createRoom(
      { initialPresence, initialStorage },
      {
        roomId,
        throttleDelay,
        lostConnectionTimeout,
        backgroundKeepAliveTimeout,
        polyfills: clientOptions.polyfills,
        delegates: clientOptions.mockedDelegates ?? {
          createSocket: makeCreateSocketDelegateForRoom(
            roomId,
            baseUrl,
            clientOptions.polyfills?.WebSocket
          ),
          authenticate: makeAuthDelegateForRoom(roomId, authManager)
        },
        enableDebugLogging: clientOptions.enableDebugLogging,
        baseUrl,
        errorEventSource: liveblocksErrorSource,
        largeMessageStrategy: clientOptions.largeMessageStrategy,
        unstable_streamData: !!clientOptions.unstable_streamData,
        roomHttpClient: httpClient,
        createSyncSource
      }
    );
    const newRoomDetails = {
      room: newRoom,
      unsubs: /* @__PURE__ */ new Set()
    };
    roomsById.set(roomId, newRoomDetails);
    setupDevTools(() => Array.from(roomsById.keys()));
    linkDevTools(roomId, newRoom);
    const shouldConnect = options2.autoConnect ?? true;
    if (shouldConnect) {
      if (typeof atob === "undefined") {
        if (clientOptions.polyfills?.atob === void 0) {
          throw new Error(
            "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
          );
        }
        global.atob = clientOptions.polyfills.atob;
      }
      newRoom.connect();
    }
    return leaseRoom(newRoomDetails);
  }
  function getRoom(roomId) {
    const room = roomsById.get(roomId)?.room;
    return room ? room : null;
  }
  function logout() {
    authManager.reset();
    currentUserId.set(() => void 0);
    for (const { room } of roomsById.values()) {
      if (!isIdle(room.getStatus())) {
        room.reconnect();
      }
    }
  }
  const resolveUsers = clientOptions.resolveUsers;
  const batchedResolveUsers = new Batch(
    async (batchedUserIds) => {
      const userIds = batchedUserIds.flat();
      const users = await resolveUsers?.({ userIds });
      warnOnceIf(
        !resolveUsers,
        "Set the resolveUsers option in createClient to specify user info."
      );
      return users ?? userIds.map(() => void 0);
    },
    { delay: RESOLVE_USERS_BATCH_DELAY }
  );
  const usersStore = createBatchStore(batchedResolveUsers);
  function invalidateResolvedUsers(userIds) {
    usersStore.invalidate(userIds);
  }
  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;
  const batchedResolveRoomsInfo = new Batch(
    async (batchedRoomIds) => {
      const roomIds = batchedRoomIds.flat();
      const roomsInfo = await resolveRoomsInfo?.({ roomIds });
      warnOnceIf(
        !resolveRoomsInfo,
        "Set the resolveRoomsInfo option in createClient to specify room info."
      );
      return roomsInfo ?? roomIds.map(() => void 0);
    },
    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }
  );
  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);
  function invalidateResolvedRoomsInfo(roomIds) {
    roomsInfoStore.invalidate(roomIds);
  }
  const resolveGroupsInfo = clientOptions.resolveGroupsInfo;
  const batchedResolveGroupsInfo = new Batch(
    async (batchedGroupIds) => {
      const groupIds = batchedGroupIds.flat();
      const groupsInfo = await resolveGroupsInfo?.({ groupIds });
      warnOnceIf(
        !resolveGroupsInfo,
        "Set the resolveGroupsInfo option in createClient to specify group info."
      );
      return groupsInfo ?? groupIds.map(() => void 0);
    },
    { delay: RESOLVE_GROUPS_INFO_BATCH_DELAY }
  );
  const groupsInfoStore = createBatchStore(batchedResolveGroupsInfo);
  function invalidateResolvedGroupsInfo(groupIds) {
    groupsInfoStore.invalidate(groupIds);
  }
  const mentionSuggestionsCache = /* @__PURE__ */ new Map();
  function invalidateResolvedMentionSuggestions() {
    mentionSuggestionsCache.clear();
  }
  const syncStatusSources = [];
  const syncStatusSignal = new Signal("synchronized");
  const liveblocksErrorSource = makeEventSource();
  function getSyncStatus() {
    const status = syncStatusSignal.get();
    return status === "synchronizing" ? status : "synchronized";
  }
  function recompute() {
    syncStatusSignal.set(
      syncStatusSources.some((src) => src.get() === "synchronizing") ? "synchronizing" : syncStatusSources.some((src) => src.get() === "has-local-changes") ? "has-local-changes" : "synchronized"
    );
  }
  function createSyncSource() {
    const source = new Signal("synchronized");
    syncStatusSources.push(source);
    const unsub = source.subscribe(() => recompute());
    function setSyncStatus(status) {
      source.set(status);
    }
    function destroy() {
      unsub();
      const index = syncStatusSources.findIndex((item) => item === source);
      if (index > -1) {
        const [ref] = syncStatusSources.splice(index, 1);
        const wasStillPending = ref.get() !== "synchronized";
        if (wasStillPending) {
          recompute();
        }
      }
    }
    return { setSyncStatus, destroy };
  }
  {
    const maybePreventClose = (e) => {
      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== "synchronized") {
        e.preventDefault();
      }
    };
    const win = typeof window !== "undefined" ? window : void 0;
    win?.addEventListener("beforeunload", maybePreventClose);
  }
  async function getNotificationSettings(options2) {
    const plainSettings = await httpClient.getNotificationSettings(options2);
    const settings = createNotificationSettings(plainSettings);
    return settings;
  }
  async function updateNotificationSettings(settings) {
    const plainSettings = await httpClient.updateNotificationSettings(settings);
    const settingsObject = createNotificationSettings(plainSettings);
    return settingsObject;
  }
  const client = Object.defineProperty(
    {
      enterRoom,
      getRoom,
      logout,
      // Public inbox notifications API
      getInboxNotifications: httpClient.getInboxNotifications,
      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,
      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,
      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,
      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,
      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,
      deleteInboxNotification: httpClient.deleteInboxNotification,
      // Public notification settings API
      getNotificationSettings,
      updateNotificationSettings,
      // Advanced resolvers APIs
      resolvers: {
        invalidateUsers: invalidateResolvedUsers,
        invalidateRoomsInfo: invalidateResolvedRoomsInfo,
        invalidateGroupsInfo: invalidateResolvedGroupsInfo,
        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions
      },
      getSyncStatus,
      events: {
        error: liveblocksErrorSource,
        syncStatus: syncStatusSignal
      },
      // Internal
      [kInternal]: {
        currentUserId,
        mentionSuggestionsCache,
        ai,
        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,
        usersStore,
        roomsInfoStore,
        groupsInfoStore,
        getRoomIds() {
          return Array.from(roomsById.keys());
        },
        httpClient,
        // Type-level helper only, it's effectively only an identity-function at runtime
        as: () => client,
        createSyncSource,
        emitError: (context, cause) => {
          const error3 = LiveblocksError.from(context, cause);
          const didNotify = liveblocksErrorSource.notify(error3);
          if (!didNotify) {
            error2(error3.message);
          }
        }
      }
    },
    kInternal,
    {
      enumerable: false
    }
  );
  return client;
}
function checkBounds(option, value, min, max, recommendedMin) {
  if (typeof value !== "number" || value < min || max !== void 0 && value > max) {
    throw new Error(
      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`
    );
  }
  return value;
}
function getBackgroundKeepAliveTimeout(value) {
  if (value === void 0) return void 0;
  return checkBounds(
    "backgroundKeepAliveTimeout",
    value,
    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT
  );
}
function getThrottle(value) {
  return checkBounds("throttle", value, MIN_THROTTLE, MAX_THROTTLE);
}
function getLostConnectionTimeout(value) {
  return checkBounds(
    "lostConnectionTimeout",
    value,
    MIN_LOST_CONNECTION_TIMEOUT,
    MAX_LOST_CONNECTION_TIMEOUT,
    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT
  );
}

// src/comments/comment-body.ts
function isCommentBodyParagraph(element) {
  return "type" in element && element.type === "paragraph";
}
function isCommentBodyText(element) {
  return !("type" in element) && "text" in element && typeof element.text === "string";
}
function isCommentBodyMention(element) {
  return "type" in element && element.type === "mention";
}
function isCommentBodyLink(element) {
  return "type" in element && element.type === "link";
}
var commentBodyElementsGuards = {
  paragraph: isCommentBodyParagraph,
  text: isCommentBodyText,
  link: isCommentBodyLink,
  mention: isCommentBodyMention
};
var commentBodyElementsTypes = {
  paragraph: "block",
  text: "inline",
  link: "inline",
  mention: "inline"
};
function traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {
  if (!body || !body?.content) {
    return;
  }
  const element = typeof elementOrVisitor === "string" ? elementOrVisitor : void 0;
  const type = element ? commentBodyElementsTypes[element] : "all";
  const guard = element ? commentBodyElementsGuards[element] : () => true;
  const visitor = typeof elementOrVisitor === "function" ? elementOrVisitor : possiblyVisitor;
  for (const block of body.content) {
    if (type === "all" || type === "block") {
      if (guard(block)) {
        visitor?.(block);
      }
    }
    if (type === "all" || type === "inline") {
      for (const inline of block.children) {
        if (guard(inline)) {
          visitor?.(inline);
        }
      }
    }
  }
}
function getMentionsFromCommentBody(body, predicate) {
  const mentionIds = /* @__PURE__ */ new Set();
  const mentions = [];
  traverseCommentBody(body, "mention", (mention) => {
    if (
      // If this mention isn't already in the list
      !mentionIds.has(mention.id) && // And the provided predicate is true
      (predicate ? predicate(mention) : true)
    ) {
      mentionIds.add(mention.id);
      mentions.push(mention);
    }
  });
  return mentions;
}
async function resolveMentionsInCommentBody(body, resolveUsers, resolveGroupsInfo) {
  const resolvedUsers = /* @__PURE__ */ new Map();
  const resolvedGroupsInfo = /* @__PURE__ */ new Map();
  if (!resolveUsers && !resolveGroupsInfo) {
    return {
      users: resolvedUsers,
      groups: resolvedGroupsInfo
    };
  }
  const mentions = getMentionsFromCommentBody(body);
  const userIds = mentions.filter((mention) => mention.kind === "user").map((mention) => mention.id);
  const groupIds = mentions.filter((mention) => mention.kind === "group").map((mention) => mention.id);
  const [users, groups] = await Promise.all([
    resolveUsers && userIds.length > 0 ? resolveUsers({ userIds }) : void 0,
    resolveGroupsInfo && groupIds.length > 0 ? resolveGroupsInfo({ groupIds }) : void 0
  ]);
  if (users) {
    for (const [index, userId] of userIds.entries()) {
      const user = users[index];
      if (user) {
        resolvedUsers.set(userId, user);
      }
    }
  }
  if (groups) {
    for (const [index, groupId] of groupIds.entries()) {
      const group = groups[index];
      if (group) {
        resolvedGroupsInfo.set(groupId, group);
      }
    }
  }
  return {
    users: resolvedUsers,
    groups: resolvedGroupsInfo
  };
}
var htmlEscapables = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var htmlEscapablesRegex = new RegExp(
  Object.keys(htmlEscapables).map((entity) => `\\${entity}`).join("|"),
  "g"
);
function htmlSafe(value) {
  return new HtmlSafeString([String(value)], []);
}
function joinHtml(strings) {
  if (strings.length <= 0) {
    return new HtmlSafeString([""], []);
  }
  return new HtmlSafeString(
    ["", ...Array(strings.length - 1).fill(""), ""],
    strings
  );
}
function escapeHtml(value) {
  if (value instanceof HtmlSafeString) {
    return value.toString();
  }
  if (Array.isArray(value)) {
    return joinHtml(value).toString();
  }
  return String(value).replace(
    htmlEscapablesRegex,
    (character) => htmlEscapables[character]
  );
}
var HtmlSafeString = class {
  #strings;
  #values;
  constructor(strings, values2) {
    this.#strings = strings;
    this.#values = values2;
  }
  toString() {
    return this.#strings.reduce((result, str, i) => {
      return result + escapeHtml(nn(this.#values[i - 1])) + str;
    });
  }
};
function html(strings, ...values2) {
  return new HtmlSafeString(strings, values2);
}
var markdownEscapables = {
  _: "\\_",
  "*": "\\*",
  "#": "\\#",
  "`": "\\`",
  "~": "\\~",
  "!": "\\!",
  "|": "\\|",
  "(": "\\(",
  ")": "\\)",
  "{": "\\{",
  "}": "\\}",
  "[": "\\[",
  "]": "\\]"
};
var markdownEscapablesRegex = new RegExp(
  Object.keys(markdownEscapables).map((entity) => `\\${entity}`).join("|"),
  "g"
);
function joinMarkdown(strings) {
  if (strings.length <= 0) {
    return new MarkdownSafeString([""], []);
  }
  return new MarkdownSafeString(
    ["", ...Array(strings.length - 1).fill(""), ""],
    strings
  );
}
function escapeMarkdown(value) {
  if (value instanceof MarkdownSafeString) {
    return value.toString();
  }
  if (Array.isArray(value)) {
    return joinMarkdown(value).toString();
  }
  return String(value).replace(
    markdownEscapablesRegex,
    (character) => markdownEscapables[character]
  );
}
var MarkdownSafeString = class {
  #strings;
  #values;
  constructor(strings, values2) {
    this.#strings = strings;
    this.#values = values2;
  }
  toString() {
    return this.#strings.reduce((result, str, i) => {
      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;
    });
  }
};
function markdown(strings, ...values2) {
  return new MarkdownSafeString(strings, values2);
}
var stringifyCommentBodyPlainElements = {
  paragraph: ({ children }) => children,
  text: ({ element }) => element.text,
  link: ({ element }) => element.text ?? element.url,
  mention: ({ element, user, group }) => {
    return `@${user?.name ?? group?.name ?? element.id}`;
  }
};
var stringifyCommentBodyHtmlElements = {
  paragraph: ({ children }) => {
    return children ? html`<p>${htmlSafe(children)}</p>` : children;
  },
  text: ({ element }) => {
    let children = element.text;
    if (!children) {
      return html`${children}`;
    }
    if (element.bold) {
      children = html`<strong>${children}</strong>`;
    }
    if (element.italic) {
      children = html`<em>${children}</em>`;
    }
    if (element.strikethrough) {
      children = html`<s>${children}</s>`;
    }
    if (element.code) {
      children = html`<code>${children}</code>`;
    }
    return html`${children}`;
  },
  link: ({ element, href }) => {
    return html`<a href="${href}" target="_blank" rel="noopener noreferrer">${element.text ? html`${element.text}` : element.url}</a>`;
  },
  mention: ({ element, user, group }) => {
    return html`<span data-mention>@${user?.name ? html`${user?.name}` : group?.name ? html`${group?.name}` : element.id}</span>`;
  }
};
var stringifyCommentBodyMarkdownElements = {
  paragraph: ({ children }) => {
    return children;
  },
  text: ({ element }) => {
    let children = element.text;
    if (!children) {
      return children;
    }
    if (element.bold) {
      children = markdown`**${children}**`;
    }
    if (element.italic) {
      children = markdown`_${children}_`;
    }
    if (element.strikethrough) {
      children = markdown`~~${children}~~`;
    }
    if (element.code) {
      children = markdown`\`${children}\``;
    }
    return children;
  },
  link: ({ element, href }) => {
    return markdown`[${element.text ?? element.url}](${href})`;
  },
  mention: ({ element, user, group }) => {
    return markdown`@${user?.name ?? group?.name ?? element.id}`;
  }
};
async function stringifyCommentBody(body, options) {
  const format = options?.format ?? "plain";
  const separator = options?.separator ?? (format === "markdown" ? "\n\n" : "\n");
  const elements = {
    ...format === "html" ? stringifyCommentBodyHtmlElements : format === "markdown" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,
    ...options?.elements
  };
  const { users: resolvedUsers, groups: resolvedGroupsInfo } = await resolveMentionsInCommentBody(
    body,
    options?.resolveUsers,
    options?.resolveGroupsInfo
  );
  const blocks = body.content.flatMap((block, blockIndex) => {
    switch (block.type) {
      case "paragraph": {
        const inlines = block.children.flatMap((inline, inlineIndex) => {
          if (isCommentBodyMention(inline)) {
            return inline.id ? [
              elements.mention(
                {
                  element: inline,
                  user: inline.kind === "user" ? resolvedUsers.get(inline.id) : void 0,
                  group: inline.kind === "group" ? resolvedGroupsInfo.get(inline.id) : void 0
                },
                inlineIndex
              )
            ] : [];
          }
          if (isCommentBodyLink(inline)) {
            const href = sanitizeUrl(inline.url);
            if (href === null) {
              return [
                elements.text(
                  {
                    element: { text: inline.text ?? inline.url }
                  },
                  inlineIndex
                )
              ];
            }
            return [
              elements.link(
                {
                  element: inline,
                  href
                },
                inlineIndex
              )
            ];
          }
          if (isCommentBodyText(inline)) {
            return [elements.text({ element: inline }, inlineIndex)];
          }
          return [];
        });
        return [
          elements.paragraph(
            { element: block, children: inlines.join("") },
            blockIndex
          )
        ];
      }
      default:
        return [];
    }
  });
  return blocks.join(separator);
}

// src/crdts/utils.ts
function toPlainLson(lson) {
  if (lson instanceof LiveObject) {
    return {
      liveblocksType: "LiveObject",
      data: Object.fromEntries(
        Object.entries(lson.toObject()).flatMap(
          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []
        )
      )
    };
  } else if (lson instanceof LiveMap) {
    return {
      liveblocksType: "LiveMap",
      data: Object.fromEntries(
        [...lson].map(([key, value]) => [key, toPlainLson(value)])
      )
    };
  } else if (lson instanceof LiveList) {
    return {
      liveblocksType: "LiveList",
      data: [...lson].map((item) => toPlainLson(item))
    };
  } else {
    return lson;
  }
}

// src/immutable.ts
function lsonObjectToJson(obj) {
  const result = {};
  for (const key in obj) {
    const val = obj[key];
    if (val !== void 0) {
      result[key] = lsonToJson(val);
    }
  }
  return result;
}
function liveObjectToJson(liveObject) {
  return lsonObjectToJson(liveObject.toObject());
}
function liveMapToJson(map) {
  const result = {};
  for (const [key, value] of map.entries()) {
    result[key] = lsonToJson(value);
  }
  return result;
}
function lsonListToJson(value) {
  return value.map(lsonToJson);
}
function liveListToJson(value) {
  return lsonListToJson(value.toArray());
}
function lsonToJson(value) {
  if (value instanceof LiveObject) {
    return liveObjectToJson(value);
  } else if (value instanceof LiveList) {
    return liveListToJson(value);
  } else if (value instanceof LiveMap) {
    return liveMapToJson(value);
  } else if (value instanceof LiveRegister) {
    return value.data;
  }
  if (Array.isArray(value)) {
    return lsonListToJson(value);
  } else if (isPlainObject(value)) {
    return lsonObjectToJson(value);
  }
  return value;
}
function deepLiveify(value) {
  if (Array.isArray(value)) {
    return new LiveList(value.map(deepLiveify));
  } else if (isPlainObject(value)) {
    const init = {};
    for (const key in value) {
      const val = value[key];
      if (val === void 0) {
        continue;
      }
      init[key] = deepLiveify(val);
    }
    return new LiveObject(init);
  } else {
    return value;
  }
}
function patchLiveList(liveList, prev, next) {
  let i = 0;
  let prevEnd = prev.length - 1;
  let nextEnd = next.length - 1;
  let prevNode = prev[0];
  let nextNode = next[0];
  outer: {
    while (prevNode === nextNode) {
      ++i;
      if (i > prevEnd || i > nextEnd) {
        break outer;
      }
      prevNode = prev[i];
      nextNode = next[i];
    }
    prevNode = prev[prevEnd];
    nextNode = next[nextEnd];
    while (prevNode === nextNode) {
      prevEnd--;
      nextEnd--;
      if (i > prevEnd || i > nextEnd) {
        break outer;
      }
      prevNode = prev[prevEnd];
      nextNode = next[nextEnd];
    }
  }
  if (i > prevEnd) {
    if (i <= nextEnd) {
      while (i <= nextEnd) {
        liveList.insert(deepLiveify(next[i]), i);
        i++;
      }
    }
  } else if (i > nextEnd) {
    let localI = i;
    while (localI <= prevEnd) {
      liveList.delete(i);
      localI++;
    }
  } else {
    while (i <= prevEnd && i <= nextEnd) {
      prevNode = prev[i];
      nextNode = next[i];
      const liveListNode = liveList.get(i);
      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {
        patchLiveObject(liveListNode, prevNode, nextNode);
      } else {
        liveList.set(i, deepLiveify(nextNode));
      }
      i++;
    }
    while (i <= nextEnd) {
      liveList.insert(deepLiveify(next[i]), i);
      i++;
    }
    let localI = i;
    while (localI <= prevEnd) {
      liveList.delete(i);
      localI++;
    }
  }
}
function patchLiveObjectKey(liveObject, key, prev, next) {
  if (process.env.NODE_ENV !== "production") {
    const nonSerializableValue = findNonSerializableValue(next);
    if (nonSerializableValue) {
      error2(
        `New state path: '${nonSerializableValue.path}' value: '${String(
          nonSerializableValue.value
        )}' is not serializable.
Only serializable value can be synced with Liveblocks.`
      );
      return;
    }
  }
  const value = liveObject.get(key);
  if (next === void 0) {
    liveObject.delete(key);
  } else if (value === void 0) {
    liveObject.set(key, deepLiveify(next));
  } else if (prev === next) {
    return;
  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {
    patchLiveList(value, prev, next);
  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {
    patchLiveObject(value, prev, next);
  } else {
    liveObject.set(key, deepLiveify(next));
  }
}
function patchLiveObject(root, prev, next) {
  const updates = {};
  for (const key in next) {
    patchLiveObjectKey(root, key, prev[key], next[key]);
  }
  for (const key in prev) {
    if (next[key] === void 0) {
      root.delete(key);
    }
  }
  if (Object.keys(updates).length > 0) {
    root.update(updates);
  }
}
function getParentsPath(node) {
  const path = [];
  while (node.parent.type === "HasParent") {
    if (isLiveList(node.parent.node)) {
      path.push(node.parent.node._indexOfPosition(node.parent.key));
    } else {
      path.push(node.parent.key);
    }
    node = node.parent.node;
  }
  return path;
}
function legacy_patchImmutableObject(state, updates) {
  return updates.reduce(
    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),
    state
  );
}
function legacy_patchImmutableObjectWithUpdate(state, update) {
  const path = getParentsPath(update.node);
  return legacy_patchImmutableNode(state, path, update);
}
function legacy_patchImmutableNode(state, path, update) {
  const pathItem = path.pop();
  if (pathItem === void 0) {
    switch (update.type) {
      case "LiveObject": {
        if (!isJsonObject(state)) {
          throw new Error(
            "Internal: received update on LiveObject but state was not an object"
          );
        }
        const newState = Object.assign({}, state);
        for (const key in update.updates) {
          if (update.updates[key]?.type === "update") {
            const val = update.node.get(key);
            if (val !== void 0) {
              newState[key] = lsonToJson(val);
            }
          } else if (update.updates[key]?.type === "delete") {
            delete newState[key];
          }
        }
        return newState;
      }
      case "LiveList": {
        if (!Array.isArray(state)) {
          throw new Error(
            "Internal: received update on LiveList but state was not an array"
          );
        }
        let newState = state.map((x) => x);
        for (const listUpdate of update.updates) {
          if (listUpdate.type === "set") {
            newState = newState.map(
              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item
            );
          } else if (listUpdate.type === "insert") {
            if (listUpdate.index === newState.length) {
              newState.push(lsonToJson(listUpdate.item));
            } else {
              newState = [
                ...newState.slice(0, listUpdate.index),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index)
              ];
            }
          } else if (listUpdate.type === "delete") {
            newState.splice(listUpdate.index, 1);
          } else if (listUpdate.type === "move") {
            if (listUpdate.previousIndex > listUpdate.index) {
              newState = [
                ...newState.slice(0, listUpdate.index),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index, listUpdate.previousIndex),
                ...newState.slice(listUpdate.previousIndex + 1)
              ];
            } else {
              newState = [
                ...newState.slice(0, listUpdate.previousIndex),
                ...newState.slice(
                  listUpdate.previousIndex + 1,
                  listUpdate.index + 1
                ),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index + 1)
              ];
            }
          }
        }
        return newState;
      }
      case "LiveMap": {
        if (!isJsonObject(state)) {
          throw new Error(
            "Internal: received update on LiveMap but state was not an object"
          );
        }
        const newState = Object.assign({}, state);
        for (const key in update.updates) {
          if (update.updates[key]?.type === "update") {
            const value = update.node.get(key);
            if (value !== void 0) {
              newState[key] = lsonToJson(value);
            }
          } else if (update.updates[key]?.type === "delete") {
            delete newState[key];
          }
        }
        return newState;
      }
    }
  }
  if (Array.isArray(state)) {
    const newArray = [...state];
    newArray[pathItem] = legacy_patchImmutableNode(
      state[pathItem],
      path,
      update
    );
    return newArray;
  } else if (isJsonObject(state)) {
    const node = state[pathItem];
    if (node === void 0) {
      return state;
    } else {
      const stateAsObj = state;
      return {
        ...stateAsObj,
        [pathItem]: legacy_patchImmutableNode(node, path, update)
      };
    }
  } else {
    return state;
  }
}

// src/lib/abortController.ts
function makeAbortController(externalSignal) {
  const ctl = new AbortController();
  return {
    signal: externalSignal ? AbortSignal.any([ctl.signal, externalSignal]) : ctl.signal,
    abort: ctl.abort.bind(ctl)
  };
}

// src/lib/deprecation.ts
var _emittedDeprecationWarnings = /* @__PURE__ */ new Set();
function deprecate(message, key = message) {
  if (process.env.NODE_ENV !== "production") {
    if (!_emittedDeprecationWarnings.has(key)) {
      _emittedDeprecationWarnings.add(key);
      errorWithTitle("Deprecation warning", message);
    }
  }
}
function deprecateIf(condition, message, key = message) {
  if (process.env.NODE_ENV !== "production") {
    if (condition) {
      deprecate(message, key);
    }
  }
}
function throwUsageError(message) {
  if (process.env.NODE_ENV !== "production") {
    const usageError = new Error(message);
    usageError.name = "Usage error";
    errorWithTitle("Usage error", message);
    throw usageError;
  }
}
function errorIf(condition, message) {
  if (process.env.NODE_ENV !== "production") {
    if (condition) {
      throwUsageError(message);
    }
  }
}

// src/lib/Poller.ts
var BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];
function makePoller(callback, intervalMs, options) {
  const startTime = performance.now();
  const doc = typeof document !== "undefined" ? document : void 0;
  const win = typeof window !== "undefined" ? window : void 0;
  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;
  const context = {
    inForeground: doc?.visibilityState !== "hidden",
    lastSuccessfulPollAt: startTime,
    count: 0,
    backoff: 0
  };
  function mayPoll() {
    return context.count > 0 && context.inForeground;
  }
  const fsm = new FSM({}).addState("@idle").addState("@enabled").addState("@polling");
  fsm.addTransitions("@idle", { START: "@enabled" });
  fsm.addTransitions("@enabled", { STOP: "@idle", POLL: "@polling" });
  fsm.addTimedTransition(
    "@enabled",
    () => {
      const lastPoll = context.lastSuccessfulPollAt;
      const nextPoll = lastPoll + intervalMs;
      return Math.max(0, nextPoll - performance.now()) + context.backoff;
    },
    "@polling"
  );
  fsm.onEnterAsync(
    "@polling",
    async (_ctx, signal) => {
      await callback(signal);
      if (!signal.aborted) {
        context.lastSuccessfulPollAt = performance.now();
      }
    },
    // When OK
    () => {
      return {
        target: mayPoll() ? "@enabled" : "@idle",
        effect: () => {
          context.backoff = 0;
        }
      };
    },
    // When error
    () => {
      return {
        target: mayPoll() ? "@enabled" : "@idle",
        effect: () => {
          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];
        }
      };
    },
    3e4
    // Abort the poll if the callback takes more than 30 seconds to complete
  );
  function startOrStop() {
    if (mayPoll()) {
      fsm.send({ type: "START" });
    } else {
      fsm.send({ type: "STOP" });
    }
  }
  function inc() {
    context.count++;
    startOrStop();
  }
  function dec() {
    context.count--;
    if (context.count < 0) {
      context.count = 0;
    }
    startOrStop();
  }
  function pollNowIfStale() {
    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {
      fsm.send({ type: "POLL" });
    }
  }
  function markAsStale() {
    context.lastSuccessfulPollAt = performance.now() - maxStaleTimeMs - 1;
  }
  function setInForeground(inForeground) {
    context.inForeground = inForeground;
    startOrStop();
    pollNowIfStale();
  }
  function onVisibilityChange() {
    setInForeground(doc?.visibilityState !== "hidden");
  }
  doc?.addEventListener("visibilitychange", onVisibilityChange);
  win?.addEventListener("online", onVisibilityChange);
  win?.addEventListener("focus", pollNowIfStale);
  fsm.start();
  return {
    inc,
    dec,
    pollNowIfStale,
    markAsStale,
    // Internal API, used by unit tests only to simulate visibility events
    setInForeground
  };
}

// src/protocol/Subscriptions.ts
function getSubscriptionKey(subscription, subjectId) {
  if (typeof subscription === "string") {
    return `${subscription}:${subjectId}`;
  }
  return `${subscription.kind}:${subscription.subjectId}`;
}

// src/types/Others.ts
var TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {
  TextEditorType2["Lexical"] = "lexical";
  TextEditorType2["TipTap"] = "tiptap";
  TextEditorType2["BlockNote"] = "blocknote";
  return TextEditorType2;
})(TextEditorType || {});

// src/index.ts
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);
export {
  ClientMsgCode,
  CrdtType,
  DefaultMap,
  Deque,
  DerivedSignal,
  HttpError,
  LiveList,
  LiveMap,
  LiveObject,
  LiveblocksError,
  MENTION_CHARACTER,
  MutableSignal,
  OpCode,
  Permission,
  Promise_withResolvers,
  ServerMsgCode,
  Signal,
  SortedList,
  TextEditorType,
  WebsocketCloseCodes,
  ackOp,
  asPos,
  assert,
  assertNever,
  autoRetry,
  b64decode,
  batch,
  checkBounds,
  chunk,
  cloneLson,
  compactObject,
  fancy_console_exports as console,
  convertToCommentData,
  convertToCommentUserReaction,
  convertToGroupData,
  convertToInboxNotificationData,
  convertToSubscriptionData,
  convertToThreadData,
  convertToUserSubscriptionData,
  createClient,
  createCommentAttachmentId,
  createCommentId,
  createInboxNotificationId,
  createManagedPool,
  createNotificationSettings,
  createThreadId,
  defineAiTool,
  deprecate,
  deprecateIf,
  detectDupes,
  entries,
  errorIf,
  findLastIndex,
  freeze,
  generateUrl,
  getMentionsFromCommentBody,
  getSubscriptionKey,
  html,
  htmlSafe,
  isChildCrdt,
  isCommentBodyLink,
  isCommentBodyMention,
  isCommentBodyText,
  isJsonArray,
  isJsonObject,
  isJsonScalar,
  isLiveNode,
  isNotificationChannelEnabled,
  isPlainObject,
  isRootCrdt,
  isStartsWithOperator,
  isUrl,
  kInternal,
  keys,
  legacy_patchImmutableObject,
  lsonToJson,
  makeAbortController,
  makeEventSource,
  makePoller,
  makePosition,
  mapValues,
  memoizeOnSuccess,
  nanoid,
  nn,
  objectToQuery,
  patchLiveObjectKey,
  patchNotificationSettings,
  raise,
  resolveMentionsInCommentBody,
  sanitizeUrl,
  shallow,
  shallow2,
  stableStringify,
  stringifyCommentBody,
  throwUsageError,
  toPlainLson,
  tryParseJson,
  url,
  urljoin,
  wait,
  warnOnce,
  warnOnceIf,
  withTimeout
};
//# sourceMappingURL=index.js.map