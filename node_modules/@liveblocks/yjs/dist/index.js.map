{"version":3,"sources":["../src/index.ts","../src/version.ts","../src/provider.ts","../../../node_modules/lib0/map.js","../../../node_modules/lib0/set.js","../../../node_modules/lib0/array.js","../../../node_modules/lib0/observable.js","../src/awareness.ts","../src/doc.ts","../src/providerContext.ts"],"sourcesContent":["import { detectDupes } from \"@liveblocks/core\";\n\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\nexport type { ProviderOptions } from \"./provider\";\nexport { LiveblocksYjsProvider } from \"./provider\";\nexport { getYjsProviderForRoom } from \"./providerContext\";\n","declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/yjs\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import {\n  DerivedSignal,\n  type IYjsProvider,\n  type OpaqueRoom,\n  type YjsSyncStatus,\n} from \"@liveblocks/core\";\nimport { ClientMsgCode, kInternal, MutableSignal } from \"@liveblocks/core\";\nimport { Base64 } from \"js-base64\";\nimport { Observable } from \"lib0/observable\";\nimport { IndexeddbPersistence } from \"y-indexeddb\";\nimport type { Doc } from \"yjs\";\nimport { PermanentUserData } from \"yjs\";\n\nimport { Awareness } from \"./awareness\";\nimport yDocHandler from \"./doc\";\n\nexport type ProviderOptions = {\n  enablePermanentUserData?: boolean;\n  autoloadSubdocs?: boolean;\n  offlineSupport_experimental?: boolean;\n  useV2Encoding_experimental?: boolean;\n};\n\nexport class LiveblocksYjsProvider\n  extends Observable<unknown>\n  implements IYjsProvider\n{\n  private readonly room: OpaqueRoom;\n  private readonly rootDoc: Doc;\n  private readonly options: ProviderOptions;\n  private indexeddbProvider: IndexeddbPersistence | null = null;\n  private isPaused = false;\n\n  private readonly unsubscribers: Array<() => void> = [];\n\n  public readonly awareness: Awareness;\n\n  public readonly rootDocHandler: yDocHandler;\n  private readonly subdocHandlersΣ = new MutableSignal<\n    Map<string, yDocHandler>\n  >(new Map());\n  private readonly syncStatusΣ: DerivedSignal<YjsSyncStatus>;\n\n  public readonly permanentUserData?: PermanentUserData;\n\n  constructor(room: OpaqueRoom, doc: Doc, options: ProviderOptions = {}) {\n    super();\n    this.rootDoc = doc;\n    this.room = room;\n    this.options = options;\n    this.rootDocHandler = new yDocHandler({\n      doc,\n      isRoot: true,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false,\n    });\n\n    if (this.options.enablePermanentUserData) {\n      this.permanentUserData = new PermanentUserData(doc);\n    }\n\n    // TODO: Display a warning if a YjsProvider is already attached to the room\n    room[kInternal].setYjsProvider(this);\n\n    // if we have a connectionId already during construction, use that\n    this.awareness = new Awareness(this.rootDoc, this.room);\n\n    this.unsubscribers.push(\n      this.room.events.status.subscribe((status) => {\n        if (status === \"connected\") {\n          this.rootDocHandler.syncDoc();\n        } else {\n          this.rootDocHandler.synced = false;\n        }\n      })\n    );\n\n    this.unsubscribers.push(\n      this.room.events.ydoc.subscribe((message) => {\n        const { type } = message;\n        if (type === ClientMsgCode.UPDATE_YDOC) {\n          // don't apply updates that came from the client\n          return;\n        }\n        const {\n          stateVector,\n          update: updateStr,\n          guid,\n          v2,\n          remoteSnapshotHash,\n        } = message;\n        const canWrite = this.room.getSelf()?.canWrite ?? true;\n        const update = Base64.toUint8Array(updateStr);\n\n        // find the right doc and update\n        if (guid !== undefined) {\n          this.subdocHandlersΣ.get().get(guid)?.handleServerUpdate({\n            update,\n            stateVector,\n            readOnly: !canWrite,\n            v2,\n            remoteSnapshotHash,\n          });\n        } else {\n          this.rootDocHandler.handleServerUpdate({\n            update,\n            stateVector,\n            readOnly: !canWrite,\n            v2,\n            remoteSnapshotHash,\n          });\n        }\n      })\n    );\n\n    if (options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n\n    // different consumers listen to sync and synced\n    this.rootDocHandler.on(\"synced\", () => {\n      const state = this.rootDocHandler.synced;\n      for (const [_, handler] of this.subdocHandlersΣ.get()) {\n        handler.syncDoc();\n      }\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    });\n    this.rootDoc.on(\"subdocs\", this.handleSubdocs);\n    this.syncDoc();\n\n    this.syncStatusΣ = DerivedSignal.from(() => {\n      // If the root document is loading or synchronizing, we infer that the overall status is also loading or synchronizing.\n      const rootDocumentStatus =\n        this.rootDocHandler.experimental_getSyncStatus();\n      if (\n        rootDocumentStatus === \"loading\" ||\n        rootDocumentStatus === \"synchronizing\"\n      ) {\n        return rootDocumentStatus;\n      }\n\n      // If the root document is synchronized, we check if all subdocs are synchronized. If at least one subdoc is not synchronized, we are still synchronizing.\n      const subdocumentStatuses = Array.from(\n        this.subdocHandlersΣ.get().values()\n      ).map((handler) => handler.experimental_getSyncStatus());\n      if (subdocumentStatuses.some((state) => state !== \"synchronized\")) {\n        return \"synchronizing\";\n      }\n      return \"synchronized\";\n    });\n\n    this.emit(\"status\", [this.getStatus()]);\n\n    this.unsubscribers.push(\n      this.syncStatusΣ.subscribe(() => {\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n  }\n\n  private setupOfflineSupport = () => {\n    this.indexeddbProvider = new IndexeddbPersistence(\n      this.room.id,\n      this.rootDoc\n    );\n    const onIndexedDbSync = () => {\n      this.rootDocHandler.synced = true;\n    };\n    this.indexeddbProvider.on(\"synced\", onIndexedDbSync);\n\n    this.unsubscribers.push(() => {\n      this.indexeddbProvider?.off(\"synced\", onIndexedDbSync);\n    });\n  };\n\n  private handleSubdocs = ({\n    loaded,\n    removed,\n    added,\n  }: {\n    loaded: Set<Doc>;\n    removed: Set<Doc>;\n    added: Set<Doc>;\n  }) => {\n    loaded.forEach(this.createSubdocHandler);\n    const subdocHandlers = this.subdocHandlersΣ.get();\n    if (this.options.autoloadSubdocs) {\n      for (const subdoc of added) {\n        if (!subdocHandlers.has(subdoc.guid)) {\n          subdoc.load();\n        }\n      }\n    }\n    for (const subdoc of removed) {\n      if (subdocHandlers.has(subdoc.guid)) {\n        subdocHandlers.get(subdoc.guid)?.destroy();\n        subdocHandlers.delete(subdoc.guid);\n      }\n    }\n  };\n\n  private updateDoc = (update: Uint8Array, guid?: string) => {\n    const canWrite = this.room.getSelf()?.canWrite ?? true;\n    if (canWrite && !this.isPaused) {\n      this.room.updateYDoc(\n        Base64.fromUint8Array(update),\n        guid,\n        this.useV2Encoding\n      );\n    }\n  };\n\n  private fetchDoc = (vector: string, guid?: string) => {\n    this.room.fetchYDoc(vector, guid, this.useV2Encoding);\n  };\n\n  private createSubdocHandler = (subdoc: Doc): void => {\n    const subdocHandlers = this.subdocHandlersΣ.get();\n    if (subdocHandlers.has(subdoc.guid)) {\n      // if we already handle this subdoc, just fetch it again\n      subdocHandlers.get(subdoc.guid)?.syncDoc();\n      return;\n    }\n    const handler = new yDocHandler({\n      doc: subdoc,\n      isRoot: false,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false,\n    });\n    subdocHandlers.set(subdoc.guid, handler);\n  };\n\n  // attempt to load a subdoc of a given guid\n  public loadSubdoc = (guid: string): boolean => {\n    for (const subdoc of this.rootDoc.subdocs) {\n      if (subdoc.guid === guid) {\n        subdoc.load();\n        return true;\n      }\n    }\n    // should we throw instead?\n    return false;\n  };\n\n  private syncDoc = () => {\n    this.rootDocHandler.syncDoc();\n    for (const [_, handler] of this.subdocHandlersΣ.get()) {\n      handler.syncDoc();\n    }\n  };\n\n  get useV2Encoding(): boolean {\n    return this.options.useV2Encoding_experimental ?? false;\n  }\n\n  // The sync'd property is required by some provider implementations\n  get synced(): boolean {\n    return this.rootDocHandler.synced;\n  }\n\n  async pause(): Promise<void> {\n    await this.indexeddbProvider?.destroy();\n    this.indexeddbProvider = null;\n    this.isPaused = true;\n  }\n\n  unpause(): void {\n    this.isPaused = false;\n    if (this.options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n    this.rootDocHandler.syncDoc();\n  }\n\n  public getStatus(): YjsSyncStatus {\n    return this.syncStatusΣ.get();\n  }\n\n  destroy(): void {\n    this.unsubscribers.forEach((unsub) => unsub());\n    this.awareness.destroy();\n    this.rootDocHandler.destroy();\n    this._observers = new Map();\n    for (const [_, handler] of this.subdocHandlersΣ.get()) {\n      handler.destroy();\n    }\n    this.subdocHandlersΣ.get().clear();\n    super.destroy();\n  }\n\n  async clearOfflineData(): Promise<void> {\n    if (!this.indexeddbProvider) return;\n    return this.indexeddbProvider.clearData();\n  }\n\n  getYDoc(): Doc {\n    return this.rootDoc;\n  }\n\n  // Some provider implementations expect to be able to call connect/disconnect, implement as noop\n  disconnect(): void {\n    // This is a noop for liveblocks as connections are managed by the room\n  }\n\n  connect(): void {\n    // This is a noop for liveblocks as connections are managed by the room\n  }\n\n  get subdocHandlers(): Map<string, yDocHandler> {\n    return this.subdocHandlersΣ.get();\n  }\n\n  set subdocHandlers(value: Map<string, yDocHandler>) {\n    this.subdocHandlersΣ.mutate((map) => {\n      map.clear();\n      for (const [key, handler] of value) {\n        map.set(key, handler);\n      }\n    });\n  }\n}\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set =>\n  set.values().next().value ?? undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n","// TODO: apparently Yjs is full of anys or something, see if we can fix this\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport type { BaseUserMeta, JsonObject, User } from \"@liveblocks/client\";\nimport type { OpaqueRoom } from \"@liveblocks/core\";\nimport { Observable } from \"lib0/observable\";\nimport type * as Y from \"yjs\";\n\nconst Y_PRESENCE_KEY = \"__yjs\";\nconst Y_PRESENCE_ID_KEY = \"__yjs_clientid\";\n\ntype MetaClientState = {\n  clock: number;\n  lastUpdated: number;\n};\n\n/**\n * This class will store Yjs awareness in Liveblock's presence under the __yjs key\n * IMPORTANT: The Yjs awareness protocol uses ydoc.clientId to reference users\n * to their respective documents. To avoid mapping Yjs clientIds to liveblock's connectionId,\n * we simply set the clientId of the doc to the connectionId. Then no further mapping is required\n */\nexport class Awareness extends Observable<unknown> {\n  private room: OpaqueRoom;\n  public doc: Y.Doc;\n  public states: Map<number, unknown> = new Map();\n  // used to map liveblock's ActorId to Yjs ClientID, both unique numbers representing a client\n  public actorToClientMap: Map<number, number> = new Map();\n  // Meta is used to keep track and timeout users who disconnect. Liveblocks provides this for us, so we don't need to\n  // manage it here. Unfortunately, it's expected to exist by various integrations, so it's an empty map.\n  public meta: Map<number, MetaClientState> = new Map();\n  // _checkInterval this would hold a timer to remove users, but Liveblock's presence already handles this\n  // unfortunately it's typed by various integrations\n  public _checkInterval: number = 0;\n\n  private othersUnsub: () => void;\n  constructor(doc: Y.Doc, room: OpaqueRoom) {\n    super();\n    this.doc = doc;\n    this.room = room;\n    // Add the clientId to presence so we can map it to connectionId later\n    this.room.updatePresence({\n      [Y_PRESENCE_ID_KEY]: this.doc.clientID,\n    });\n    this.othersUnsub = this.room.events.others.subscribe((event) => {\n      let updates:\n        | { added: number[]; updated: number[]; removed: number[] }\n        | undefined;\n\n      // When others are changed, we emit an event that contains arrays added/updated/removed.\n      if (event.type === \"leave\") {\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== undefined) {\n          updates = { added: [], updated: [], removed: [targetClientId] };\n        }\n        // rebuild after the user leaves so we can get the ID of the user who left\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (event.type === \"enter\" || event.type === \"update\") {\n        this.rebuildActorToClientMap(event.others);\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== undefined) {\n          updates = {\n            added: event.type === \"enter\" ? [targetClientId] : [],\n            updated: event.type === \"update\" ? [targetClientId] : [],\n            removed: [],\n          };\n        }\n      }\n      if (event.type === \"reset\") {\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (updates !== undefined) {\n        this.emit(\"change\", [updates, \"presence\"]);\n        this.emit(\"update\", [updates, \"presence\"]);\n      }\n    });\n  }\n\n  rebuildActorToClientMap(\n    others: readonly User<JsonObject, BaseUserMeta>[]\n  ): void {\n    this.actorToClientMap.clear();\n    others.forEach((user) => {\n      if (user.presence[Y_PRESENCE_ID_KEY] !== undefined) {\n        this.actorToClientMap.set(\n          user.connectionId,\n          user.presence[Y_PRESENCE_ID_KEY] as number\n        );\n      }\n    });\n  }\n\n  destroy(): void {\n    this.emit(\"destroy\", [this]);\n    this.othersUnsub();\n    this.setLocalState(null);\n    super.destroy();\n  }\n\n  getLocalState(): JsonObject | null {\n    const presence = this.room.getPresence();\n    if (\n      Object.keys(presence).length === 0 ||\n      typeof presence[Y_PRESENCE_KEY] === \"undefined\"\n    ) {\n      return null;\n    }\n    return presence[Y_PRESENCE_KEY] as JsonObject | null;\n  }\n\n  setLocalState(state: Partial<JsonObject> | null): void {\n    const presence = this.room.getSelf()?.presence;\n    if (state === null) {\n      if (presence === undefined) {\n        // if presence is already undefined, we don't need to change anything here\n        return;\n      }\n      this.room.updatePresence({ ...presence, [Y_PRESENCE_KEY]: null });\n      this.emit(\"update\", [\n        { added: [], updated: [], removed: [this.doc.clientID] },\n        \"local\",\n      ]);\n      return;\n    }\n    // if presence was undefined, it's added, if not, it's updated\n    const yPresence = presence?.[Y_PRESENCE_KEY];\n    const added = yPresence === undefined ? [this.doc.clientID] : [];\n    const updated = yPresence === undefined ? [] : [this.doc.clientID];\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: {\n        ...((yPresence as JsonObject) || {}),\n        ...(state || {}),\n      },\n    });\n    this.emit(\"update\", [{ added, updated, removed: [] }, \"local\"]);\n  }\n\n  setLocalStateField(field: string, value: JsonObject | null): void {\n    const presence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    const update = { [field]: value } as Partial<JsonObject>;\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: { ...((presence as JsonObject) || {}), ...update },\n    });\n  }\n\n  // Translate liveblocks presence to yjs awareness\n  getStates(): Map<number, unknown> {\n    const others = this.room.getOthers();\n    const states = others.reduce((acc: Map<number, unknown>, otherUser) => {\n      const otherPresence = otherUser.presence[Y_PRESENCE_KEY];\n      const otherClientId = otherUser.presence[Y_PRESENCE_ID_KEY] as\n        | number\n        | undefined;\n      if (otherPresence !== undefined && otherClientId !== undefined) {\n        // set states of map clientId to yjs presence\n        acc.set(otherClientId, otherPresence || {});\n      }\n      return acc;\n    }, new Map<number, unknown>());\n\n    // add this client's yjs presence to states (local client not represented in others)\n    const localPresence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    if (localPresence !== undefined) {\n      states.set(this.doc.clientID, localPresence);\n    }\n    return states;\n  }\n}\n","import {\n  DerivedSignal,\n  Signal as Signal,\n  type YjsSyncStatus,\n} from \"@liveblocks/core\";\nimport { sha256 } from \"@noble/hashes/sha2\";\nimport { Base64 } from \"js-base64\";\nimport { Observable } from \"lib0/observable\";\nimport { IndexeddbPersistence } from \"y-indexeddb\";\nimport * as Y from \"yjs\";\n\nexport default class yDocHandler extends Observable<unknown> {\n  private unsubscribers: Array<() => void> = [];\n\n  private _synced = false;\n  private doc: Y.Doc;\n  private updateRoomDoc: (update: Uint8Array) => void;\n  private fetchRoomDoc: (vector: string) => void;\n  private useV2Encoding: boolean;\n  private localSnapshotHashΣ: Signal<string>;\n  private remoteSnapshotHashΣ: Signal<string | null>;\n\n  private debounceTimer: ReturnType<typeof setTimeout> | null = null;\n  private static readonly DEBOUNCE_INTERVAL_MS = 200;\n\n  private isLocalAndRemoteSnapshotEqualΣ: DerivedSignal<boolean>;\n\n  constructor({\n    doc,\n    isRoot,\n    updateDoc,\n    fetchDoc,\n    useV2Encoding,\n  }: {\n    doc: Y.Doc;\n    isRoot: boolean;\n    updateDoc: (update: Uint8Array, guid?: string) => void;\n    fetchDoc: (vector: string, guid?: string) => void;\n    useV2Encoding: boolean;\n  }) {\n    super();\n    this.doc = doc;\n    this.useV2Encoding = useV2Encoding;\n    // this.doc.load(); // this just emits a load event, it doesn't actually load anything\n    this.doc.on(useV2Encoding ? \"updateV2\" : \"update\", this.updateHandler);\n    this.updateRoomDoc = (update: Uint8Array) => {\n      updateDoc(update, isRoot ? undefined : this.doc.guid);\n    };\n    this.fetchRoomDoc = (vector: string) => {\n      fetchDoc(vector, isRoot ? undefined : this.doc.guid);\n    };\n\n    this.syncDoc();\n\n    const encodedSnapshot = this.useV2Encoding\n      ? Y.encodeSnapshotV2(Y.snapshot(this.doc))\n      : Y.encodeSnapshot(Y.snapshot(this.doc));\n\n    this.localSnapshotHashΣ = new Signal(\n      Base64.fromUint8Array(sha256(encodedSnapshot))\n    );\n    this.remoteSnapshotHashΣ = new Signal<string | null>(null);\n\n    this.isLocalAndRemoteSnapshotEqualΣ = DerivedSignal.from(() => {\n      const remoteSnapshotHash = this.remoteSnapshotHashΣ.get();\n      if (remoteSnapshotHash === null) return false;\n\n      const localSnapshotHash = this.localSnapshotHashΣ.get();\n      if (localSnapshotHash !== remoteSnapshotHash) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  public handleServerUpdate = ({\n    update,\n    stateVector,\n    readOnly,\n    v2,\n    remoteSnapshotHash,\n  }: {\n    update: Uint8Array;\n    stateVector: string | null;\n    readOnly: boolean;\n    v2?: boolean;\n    remoteSnapshotHash: string;\n  }): void => {\n    // apply update from the server, updates from the server can be v1 or v2\n    const applyUpdate = v2 ? Y.applyUpdateV2 : Y.applyUpdate;\n    applyUpdate(this.doc, update, \"backend\");\n    // if this update is the result of a fetch, the state vector is included\n    if (stateVector) {\n      if (!readOnly) {\n        // Use server state to calculate a diff and send it\n        try {\n          // send v1 or v2update according to client option\n          const encodeUpdate = this.useV2Encoding\n            ? Y.encodeStateAsUpdateV2\n            : Y.encodeStateAsUpdate;\n          const localUpdate = encodeUpdate(\n            this.doc,\n            Base64.toUint8Array(stateVector)\n          );\n          this.updateRoomDoc(localUpdate);\n        } catch (e) {\n          // something went wrong encoding local state to send to the server\n          console.warn(e);\n        }\n      }\n      // now that we've sent our local and received from server, we're in sync\n      // calling `syncDoc` again will sync up the documents\n      this.synced = true;\n    }\n\n    this.remoteSnapshotHashΣ.set(remoteSnapshotHash);\n  };\n\n  public syncDoc = (): void => {\n    this.synced = false;\n\n    // The state vector is sent to the server so it knows what to send back\n    // if you don't send it, it returns everything\n    const encodedVector = Base64.fromUint8Array(Y.encodeStateVector(this.doc));\n    this.fetchRoomDoc(encodedVector);\n  };\n\n  // The sync'd property is required by some provider implementations\n  get synced(): boolean {\n    return this._synced;\n  }\n\n  set synced(state: boolean) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    }\n  }\n\n  private debounced_updateLocalSnapshot() {\n    if (this.debounceTimer) clearTimeout(this.debounceTimer);\n    this.debounceTimer = setTimeout(() => {\n      // Compute local snapshot and update the local snapshot state\n      const encodedSnapshot = this.useV2Encoding\n        ? Y.encodeSnapshotV2(Y.snapshot(this.doc))\n        : Y.encodeSnapshot(Y.snapshot(this.doc));\n      this.localSnapshotHashΣ.set(\n        Base64.fromUint8Array(sha256(encodedSnapshot))\n      );\n      this.debounceTimer = null;\n    }, yDocHandler.DEBOUNCE_INTERVAL_MS);\n  }\n\n  private updateHandler = (\n    update: Uint8Array,\n    origin: string | IndexeddbPersistence\n  ) => {\n    this.debounced_updateLocalSnapshot();\n\n    // don't send updates from indexedb, those will get handled by sync\n    const isFromLocal = origin instanceof IndexeddbPersistence;\n    if (origin !== \"backend\" && !isFromLocal) {\n      this.updateRoomDoc(update);\n    }\n  };\n\n  experimental_getSyncStatus(): YjsSyncStatus {\n    const remoteSnapshotHash = this.remoteSnapshotHashΣ.get();\n    if (remoteSnapshotHash === null) {\n      return \"loading\";\n    }\n    if (!this.isLocalAndRemoteSnapshotEqualΣ.get()) {\n      return \"synchronizing\";\n    }\n    return \"synchronized\";\n  }\n\n  destroy(): void {\n    if (this.debounceTimer) clearTimeout(this.debounceTimer);\n    this.doc.off(\"update\", this.updateHandler);\n    this.unsubscribers.forEach((unsub) => unsub());\n    this._observers = new Map();\n    this.doc.destroy();\n  }\n}\n","import type { OpaqueRoom } from \"@liveblocks/core\";\nimport { Doc } from \"yjs\";\n\nimport { LiveblocksYjsProvider, type ProviderOptions } from \"./provider\";\n\n/* NOTE:\n      the purpose of the providersMap is to keep the same provider alive across renders\n      re-instantiating the provider when the room hasn't changed can cause the yjs doc state to be out of sync\n      with liveblocks yjs state. In this instance, we can just check if the room has changed, because the instance\n      from useRoom will be referentially equal to the previous instance.\n*/\nconst providersMap = new WeakMap<OpaqueRoom, LiveblocksYjsProvider>();\n\n/**\n * Get a LiveblocksYjsProvider for a room.\n * @param room - The room to get the provider for.\n * @param options - The options for the provider.\n * @returns A LiveblocksYjsProvider for the room.\n */\nconst getYjsProviderForRoom = (\n  room: OpaqueRoom,\n  options: ProviderOptions = {}\n): LiveblocksYjsProvider => {\n  const provider = providersMap.get(room);\n  if (provider !== undefined) {\n    return provider;\n  }\n  const doc = new Doc();\n  const newProvider = new LiveblocksYjsProvider(room, doc, options);\n\n  room.events.roomWillDestroy.subscribeOnce(() => {\n    newProvider.destroy();\n  });\n  providersMap.set(room, newProvider);\n  return newProvider;\n};\n\nexport { getYjsProviderForRoom };\n"],"mappings":"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","names":["DerivedSignal","Base64","create","create","IndexeddbPersistence","applyUpdate","Base64","DerivedSignal","IndexeddbPersistence"]}