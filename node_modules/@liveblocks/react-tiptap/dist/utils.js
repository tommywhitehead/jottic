import { assertNever } from '@liveblocks/core';
import { Fragment } from '@tiptap/pm/model';
import { TextSelection } from '@tiptap/pm/state';
import { ySyncPluginKey, getRelativeSelection, relativePositionToAbsolutePosition } from 'y-prosemirror';
import { LIVEBLOCKS_MENTION_TYPE, LIVEBLOCKS_GROUP_MENTION_TYPE } from './types.js';

const CONTEXT_TRUNCATION = "[\u2026]";
const CONTEXT_BLOCK_SEPARATOR = "\n";
const getRelativeSelectionFromState = (state) => {
  const pluginState = ySyncPluginKey.getState(state);
  if (!pluginState)
    return null;
  return getRelativeSelection(pluginState.binding, state);
};
const getRangeFromRelativeSelections = (pos, state) => {
  const pluginState = ySyncPluginKey.getState(state);
  if (!pluginState || !pluginState.binding)
    return { from: 0, to: 0 };
  const { doc, type, mapping } = pluginState.binding;
  const anchor = relativePositionToAbsolutePosition(doc, type, pos.anchor, mapping) ?? 0;
  const head = relativePositionToAbsolutePosition(doc, type, pos.head, mapping) ?? 0;
  const from = anchor > head ? head : anchor;
  const to = anchor > head ? anchor : head;
  return { from, to };
};
const getRectFromCoords = (coords) => {
  return {
    ...coords,
    x: coords.left,
    y: coords.top,
    width: coords.right - coords.left,
    height: coords.bottom - coords.top
  };
};
const getMentionsFromNode = (node, range) => {
  const mentions = /* @__PURE__ */ new Map();
  node.nodesBetween(range.from, range.to, (child) => {
    if (child.type.name === LIVEBLOCKS_MENTION_TYPE || child.type.name === LIVEBLOCKS_GROUP_MENTION_TYPE) {
      const mention = child.attrs;
      if (mention.id && mention.notificationId) {
        if (child.type.name === LIVEBLOCKS_MENTION_TYPE) {
          mentions.set(mention.notificationId, {
            kind: "user",
            id: mention.id,
            notificationId: mention.notificationId
          });
        } else if (child.type.name === LIVEBLOCKS_GROUP_MENTION_TYPE) {
          let userIds;
          if (mention.userIds) {
            try {
              const parsedUserIds = JSON.parse(mention.userIds);
              if (Array.isArray(parsedUserIds)) {
                userIds = parsedUserIds;
              }
            } catch {
              userIds = void 0;
            }
          }
          mentions.set(mention.notificationId, {
            kind: "group",
            id: mention.id,
            userIds,
            notificationId: mention.notificationId
          });
        } else {
          assertNever(child.type.name, "Unexpected mention kind");
        }
      }
    }
  });
  return mentions;
};
const mapFragment = (fragment, callback) => {
  const content = [];
  fragment.forEach((node) => {
    if (node.content.childCount > 0) {
      content.push(
        node.type.create(node.attrs, mapFragment(node.content, callback))
      );
      return;
    }
    content.push(callback(node));
  });
  return Fragment.from(content);
};
function getDomRangeFromSelection(editor, selection) {
  if (selection.from === selection.to) {
    const { parent, parentOffset } = selection.$from;
    if (parent.isBlock && parent.content.size === 0 || parent.isTextblock && parentOffset === parent.content.size) {
      selection = TextSelection.create(
        editor.state.doc,
        selection.$from.before(),
        selection.$from.after()
      );
    }
  }
  const from = editor.view.domAtPos(selection.from);
  const to = editor.view.domAtPos(selection.to);
  const domRange = document.createRange();
  domRange.setStart(from.node, from.offset);
  domRange.setEnd(to.node, to.offset);
  return domRange;
}
function compareSelections(a, b) {
  if (!a || !b) {
    return false;
  }
  return a.eq(b);
}
function getContextualPromptContext(editor, maxLength = 1e4) {
  const { selection, doc } = editor.state;
  const selectionLength = selection.to - selection.from;
  if (maxLength >= doc.content.size) {
    return {
      beforeSelection: doc.textBetween(
        0,
        selection.from,
        CONTEXT_BLOCK_SEPARATOR
      ),
      selection: doc.textBetween(
        selection.from,
        selection.to,
        CONTEXT_BLOCK_SEPARATOR
      ),
      afterSelection: doc.textBetween(
        selection.to,
        doc.content.size,
        CONTEXT_BLOCK_SEPARATOR
      )
    };
  } else if (selectionLength > maxLength) {
    const selectionStart = doc.textBetween(
      selection.from,
      selection.from + Math.floor(maxLength / 2) - CONTEXT_TRUNCATION.length,
      CONTEXT_BLOCK_SEPARATOR
    );
    const selectionEnd = doc.textBetween(
      selection.to - Math.floor(maxLength / 2) + CONTEXT_TRUNCATION.length,
      selection.to,
      CONTEXT_BLOCK_SEPARATOR
    );
    return {
      beforeSelection: "",
      selection: `${selectionStart}${CONTEXT_TRUNCATION}${selectionEnd}`,
      afterSelection: ""
    };
  } else {
    let beforeLength = Math.min(
      selection.from,
      Math.floor((maxLength - selectionLength) / 2)
    );
    const afterLength = Math.min(
      doc.content.size - selection.to,
      maxLength - selectionLength - beforeLength
    );
    if (beforeLength + afterLength + selectionLength < maxLength) {
      beforeLength = Math.min(
        selection.from,
        maxLength - selectionLength - afterLength
      );
    }
    let beforeSelection = doc.textBetween(
      Math.max(0, selection.from - beforeLength),
      selection.from,
      CONTEXT_BLOCK_SEPARATOR
    );
    let afterSelection = doc.textBetween(
      selection.to,
      Math.min(doc.content.size, selection.to + afterLength),
      CONTEXT_BLOCK_SEPARATOR
    );
    if (selection.from - beforeLength > 0) {
      beforeSelection = `${CONTEXT_TRUNCATION}${beforeSelection}`;
    }
    if (selection.to + afterLength < doc.content.size) {
      afterSelection = `${afterSelection}${CONTEXT_TRUNCATION}`;
    }
    return {
      beforeSelection,
      selection: doc.textBetween(
        selection.from,
        selection.to,
        CONTEXT_BLOCK_SEPARATOR
      ),
      afterSelection
    };
  }
}

export { compareSelections, getContextualPromptContext, getDomRangeFromSelection, getMentionsFromNode, getRangeFromRelativeSelections, getRectFromCoords, getRelativeSelectionFromState, mapFragment };
//# sourceMappingURL=utils.js.map
