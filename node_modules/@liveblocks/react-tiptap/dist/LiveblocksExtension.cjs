'use strict';

var core$1 = require('@liveblocks/core');
var react$1 = require('@liveblocks/react');
var _private = require('@liveblocks/react/_private');
var _private$1 = require('@liveblocks/react-ui/_private');
var yjs = require('@liveblocks/yjs');
var core = require('@tiptap/core');
var Collaboration = require('@tiptap/extension-collaboration');
var CollaborationCursor = require('@tiptap/extension-collaboration-cursor');
var react = require('react');
var AiExtension = require('./ai/AiExtension.cjs');
var CommentsExtension = require('./comments/CommentsExtension.cjs');
var MentionExtension = require('./mentions/MentionExtension.cjs');
var types = require('./types.cjs');

const DEFAULT_OPTIONS = {
  field: "default",
  comments: true,
  mentions: true,
  offlineSupport_experimental: false,
  enablePermanentUserData: false
};
const LiveblocksCollab = Collaboration.extend({
  onCreate() {
    if (!this.editor.extensionManager.extensions.find((e) => e.name === "doc")) {
      console.warn(
        "[Liveblocks] The tiptap document extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension."
      );
    }
    if (!this.editor.extensionManager.extensions.find(
      (e) => e.name === "paragraph"
    )) {
      console.warn(
        "[Liveblocks] The tiptap paragraph extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension."
      );
    }
    if (!this.editor.extensionManager.extensions.find((e) => e.name === "text")) {
      console.warn(
        "[Liveblocks] The tiptap text extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension."
      );
    }
    if (this.editor.extensionManager.extensions.find((e) => e.name === "history")) {
      console.warn(
        "[Liveblocks] The history extension is enabled, Liveblocks extension provides its own. Please remove or disable the History plugin to prevent unwanted conflicts."
      );
    }
  }
});
function useIsEditorReady() {
  const yjsProvider = _private.useYjsProvider();
  const getSnapshot = react.useCallback(() => {
    const status = yjsProvider?.getStatus();
    return status === "synchronizing" || status === "synchronized";
  }, [yjsProvider]);
  const subscribe = react.useCallback(
    (callback) => {
      if (yjsProvider === void 0)
        return () => {
        };
      yjsProvider.on("status", callback);
      return () => {
        yjsProvider.off("status", callback);
      };
    },
    [yjsProvider]
  );
  return react.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
const YChangeMark = core.Mark.create({
  name: "ychange",
  inclusive: false,
  parseHTML() {
    return [{ tag: "ychange" }];
  },
  addAttributes() {
    return {
      user: {
        default: null,
        parseHTML: (element) => element.getAttribute("ychange_user") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.user) {
            return {};
          }
          return { "data-ychange-user": attributes.user };
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("ychange_type") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.type) {
            return {};
          }
          return {
            "data-ychange-type": attributes.type,
            "data-liveblocks": "",
            class: `lb-root lb-tiptap-change lb-tiptap-change-${attributes.type}`
          };
        }
      },
      color: {
        default: null,
        parseHTML: (element) => {
          return element.getAttribute("ychange_color") ?? null;
        },
        renderHTML: () => {
          return {};
        }
      }
    };
  },
  renderHTML({ HTMLAttributes }) {
    return ["ychange", HTMLAttributes, 0];
  }
});
const useLiveblocksExtension = (opts) => {
  const options = {
    ...DEFAULT_OPTIONS,
    ...opts
  };
  const textEditorType = _private$1.useInitial(
    options.textEditorType ?? core$1.TextEditorType.TipTap
  );
  const editor = react.useRef(null);
  const room = react$1.useRoom();
  const isEditorReady = useIsEditorReady();
  const client = react$1.useClient();
  const store = _private.getUmbrellaStoreForClient(client);
  const roomId = room.id;
  const yjsProvider = _private.useYjsProvider();
  react.useEffect(() => {
    if (!isEditorReady || !yjsProvider || !options.initialContent || !editor.current)
      return;
    const ydoc = yjsProvider.getYDoc();
    const hasContentSet = ydoc.getMap("liveblocks_config").get("hasContentSet");
    if (!hasContentSet) {
      ydoc.getMap("liveblocks_config").set("hasContentSet", true);
      editor.current.commands.setContent(options.initialContent);
    }
  }, [isEditorReady, yjsProvider, options.initialContent]);
  _private.useReportTextEditor(textEditorType, options.field ?? DEFAULT_OPTIONS.field);
  const prevThreadsRef = react.useRef(void 0);
  react.useEffect(() => {
    if (!isEditorReady)
      return;
    if (!editor.current)
      return;
    const newThreads = options.threads_experimental ? new Set(options.threads_experimental.map((t) => t.id)) : void 0;
    const hasFilteredThreadsChanged = !CommentsExtension.areSetsEqual(
      prevThreadsRef.current,
      newThreads
    );
    if (hasFilteredThreadsChanged) {
      prevThreadsRef.current = newThreads;
    }
    if (hasFilteredThreadsChanged) {
      editor.current.view.dispatch(
        editor.current.state.tr.setMeta(CommentsExtension.FILTERED_THREADS_PLUGIN_KEY, {
          filteredThreads: options.threads_experimental ? new Set(options.threads_experimental.map((t) => t.id)) : void 0
        })
      );
    }
  }, [isEditorReady, options.threads_experimental]);
  const createTextMention = _private.useCreateTextMention();
  const deleteTextMention = _private.useDeleteTextMention();
  return core.Extension.create({
    name: "liveblocksExtension",
    onCreate() {
      editor.current = this.editor;
      if (this.editor.options.content) {
        console.warn(
          "[Liveblocks] Initial content must be set in the useLiveblocksExtension hook option. Remove content from your editor options."
        );
      }
      if (options.mentions && this.editor.extensionManager.extensions.find(
        (e) => e.name.toLowerCase() === "mention"
      )) {
        console.warn(
          "[Liveblocks] Liveblocks own mention plugin is enabled, using another mention plugin may cause a conflict."
        );
      }
      const self = room.getSelf();
      const updateUser = ({
        info,
        id: userId
      }) => {
        if (!info) {
          return;
        }
        const { user: storedUser } = this.storage.provider.awareness.getLocalState();
        if (this.storage.permanentUserData) {
          const pud = this.storage.permanentUserData.clients.get(
            this.storage.doc.clientID
          );
          if (!pud || pud !== userId) {
            this.storage.permanentUserData.setUserMapping(
              this.storage.doc,
              this.storage.doc.clientID,
              userId ?? "Unknown"
            );
          }
        }
        if (info.name !== storedUser?.name || info.color !== storedUser?.color) {
          this.editor.commands.updateUser({
            name: info.name,
            color: info.color
          });
        }
      };
      if (self?.info) {
        updateUser(self);
      }
      this.storage.unsubs.push(room.events.self.subscribe(updateUser));
      if (options.comments) {
        const commentMarkType = core.getMarkType(
          types.LIVEBLOCKS_COMMENT_MARK_TYPE,
          this.editor.schema
        );
        this.storage.unsubs.push(
          store.outputs.threads.subscribe(() => {
            const threadMap = new Map(
              store.outputs.threads.get().findMany(roomId, { resolved: false }, "asc").map((thread) => [thread.id, true])
            );
            function isComment(mark) {
              return mark.type.name === types.LIVEBLOCKS_COMMENT_MARK_TYPE;
            }
            this.editor.state.doc.descendants((node, pos) => {
              node.marks.forEach((mark) => {
                if (isComment(mark)) {
                  const markThreadId = mark.attrs.threadId;
                  const isOrphan = !threadMap.has(markThreadId);
                  if (isOrphan !== mark.attrs.orphan) {
                    const { tr } = this.editor.state;
                    const trimmedFrom = Math.max(pos, 0);
                    const trimmedTo = Math.min(
                      pos + node.nodeSize,
                      this.editor.state.doc.content.size - 1
                    );
                    tr.removeMark(trimmedFrom, trimmedTo, mark);
                    tr.addMark(
                      trimmedFrom,
                      trimmedTo,
                      commentMarkType.create({
                        ...mark.attrs,
                        orphan: isOrphan
                      })
                    );
                    this.editor.view.dispatch(tr);
                  }
                }
              });
            });
          })
        );
      }
    },
    onDestroy() {
      this.storage.unsubs.forEach((unsub) => unsub());
    },
    addGlobalAttributes() {
      return [
        {
          types: ["paragraph", "heading"],
          attributes: {
            ychange: { default: null }
          }
        }
      ];
    },
    addStorage() {
      const provider = yjs.getYjsProviderForRoom(room, {
        enablePermanentUserData: !!options.ai || options.enablePermanentUserData,
        offlineSupport_experimental: options.offlineSupport_experimental
      });
      return {
        doc: provider.getYDoc(),
        provider,
        permanentUserData: provider.permanentUserData,
        unsubs: []
      };
    },
    addExtensions() {
      const extensions = [
        YChangeMark,
        LiveblocksCollab.configure({
          ySyncOptions: {
            permanentUserData: this.storage.permanentUserData
          },
          document: this.storage.doc,
          field: options.field
        }),
        CollaborationCursor.configure({
          provider: this.storage.provider
        })
      ];
      if (options.comments) {
        extensions.push(CommentsExtension.CommentsExtension);
      }
      if (options.mentions) {
        extensions.push(
          MentionExtension.MentionExtension.configure({
            onCreateMention: (mention) => {
              createTextMention(mention.notificationId, mention);
            },
            onDeleteMention: deleteTextMention
          })
        );
      }
      if (options.ai) {
        const resolveContextualPrompt = async ({
          prompt,
          context,
          previous,
          signal
        }) => {
          const result = await room[core$1.kInternal].executeContextualPrompt({
            prompt,
            context,
            previous,
            signal
          });
          return JSON.parse(result);
        };
        extensions.push(
          AiExtension.AiExtension.configure({
            resolveContextualPrompt,
            ...typeof options.ai === "boolean" ? {} : options.ai,
            doc: this.storage.doc,
            pud: this.storage.permanentUserData
          })
        );
      }
      return extensions;
    }
  });
};

exports.useIsEditorReady = useIsEditorReady;
exports.useLiveblocksExtension = useLiveblocksExtension;
//# sourceMappingURL=LiveblocksExtension.cjs.map
