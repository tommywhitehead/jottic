import { autoRetry, HttpError } from '@liveblocks/core';
import { Extension } from '@tiptap/core';
import { Slice, Fragment } from '@tiptap/pm/model';
import { Plugin } from '@tiptap/pm/state';
import { DecorationSet, Decoration } from '@tiptap/pm/view';
import { ySyncPluginKey, yXmlFragmentToProseMirrorFragment } from 'y-prosemirror';
import { createDocFromSnapshot, emptySnapshot, snapshot, equalSnapshots } from 'yjs';
import { AI_TOOLBAR_SELECTION_PLUGIN } from '../types.js';
import { getContextualPromptContext } from '../utils.js';

const DEFAULT_AI_NAME = "AI";
const DEFAULT_STATE = { phase: "closed" };
const RESOLVE_AI_PROMPT_RETRY_ATTEMPTS = 3;
const RESOLVE_AI_PROMPT_RETRY_DELAYS = [1e3, 2e3, 4e3];
function getYjsBinding(editor) {
  return ySyncPluginKey.getState(editor.view.state).binding;
}
function getLiveblocksYjsProvider(editor) {
  return editor.extensionStorage.liveblocksExtension?.provider;
}
function isContextualPromptDiffResponse(response) {
  return response.type === "replace" || response.type === "insert";
}
function isResolveContextualPromptResponse(response) {
  return typeof response === "object" && response !== null && typeof response.text === "string" && typeof response.type === "string" && ["insert", "replace", "other"].includes(response.type);
}
function createParagraph(editor, text) {
  const paragraph = editor.schema.nodes.paragraph ?? Object.values(editor.schema.nodes).find((node) => node.isBlock);
  if (!paragraph) {
    throw new Error("Could not create a paragraph.");
  }
  return paragraph.create(null, text ? editor.schema.text(text) : void 0);
}
function getRevertTransaction(tr, editor, storage, doc) {
  if (storage.snapshot) {
    const binding = getYjsBinding(editor);
    if (binding) {
      binding.mapping.clear();
      const docFromSnapshot = createDocFromSnapshot(
        binding.doc,
        storage.snapshot
      );
      const type = docFromSnapshot.getXmlFragment("default");
      const fragmentContent = yXmlFragmentToProseMirrorFragment(
        type,
        editor.state.schema
      );
      tr.setMeta("addToHistory", false);
      tr.replace(
        0,
        editor.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      tr.setMeta(ySyncPluginKey, {
        snapshot: null,
        prevSnapshot: null
      });
      if (doc) {
        doc.gc = true;
      }
      storage.snapshot = void 0;
      return tr;
    }
  }
  return null;
}
const AiExtension = Extension.create({
  name: "liveblocksAi",
  addOptions() {
    return {
      doc: void 0,
      pud: void 0,
      resolveContextualPrompt: () => Promise.reject(),
      name: DEFAULT_AI_NAME
    };
  },
  addStorage() {
    return {
      state: DEFAULT_STATE,
      name: this.options.name
    };
  },
  addCommands() {
    return {
      askAi: (prompt) => () => {
        if (typeof prompt === "string") {
          this.editor.commands.$startAiToolbarThinking(prompt);
        } else {
          this.editor.commands.$openAiToolbarAsking();
        }
        return true;
      },
      closeAi: () => () => {
        this.editor.commands.$closeAiToolbar();
        return true;
      },
      $acceptAiToolbarResponse: () => ({ tr, view }) => {
        const currentState = this.storage.state;
        if (currentState.phase !== "reviewing") {
          return false;
        }
        if (isContextualPromptDiffResponse(currentState.response)) {
          const binding = getYjsBinding(this.editor);
          if (!binding) {
            return false;
          }
          const fragmentContent = yXmlFragmentToProseMirrorFragment(
            binding.type,
            this.editor.state.schema
          );
          tr.setMeta("addToHistory", false);
          tr.replace(
            0,
            this.editor.state.doc.content.size,
            new Slice(Fragment.from(fragmentContent), 0, 0)
          );
          tr.setMeta(ySyncPluginKey, {
            snapshot: null,
            prevSnapshot: null
          });
          this.storage.snapshot = void 0;
        } else {
          const paragraphs = currentState.response.text.split("\n").map((paragraph) => createParagraph(this.editor, paragraph));
          tr.insert(this.editor.state.selection.$to.end(), paragraphs);
          tr.setMeta("addToHistory", true);
          view.dispatch(tr);
          tr.setMeta("preventDispatch", true);
        }
        getLiveblocksYjsProvider(this.editor)?.unpause();
        this.editor.setEditable(true);
        this.storage.state = { phase: "closed" };
        return true;
      },
      $closeAiToolbar: () => ({ tr, view }) => {
        const currentState = this.storage.state;
        if (currentState.phase === "closed") {
          return false;
        }
        if (currentState.phase === "thinking") {
          currentState.abortController.abort();
        }
        if (currentState.phase === "thinking" || currentState.phase === "reviewing") {
          const revertTr = getRevertTransaction(
            tr,
            this.editor,
            this.storage,
            this.options.doc
          );
          if (revertTr) {
            view.dispatch(revertTr);
            tr.setMeta("preventDispatch", true);
          }
        }
        this.editor.commands.setTextSelection(currentState.initialSelection);
        getLiveblocksYjsProvider(this.editor)?.unpause();
        this.editor.setEditable(true);
        this.storage.state = { phase: "closed" };
        return true;
      },
      $openAiToolbarAsking: () => () => {
        const currentState = this.storage.state;
        if (currentState.phase !== "closed") {
          return false;
        }
        if (this.editor.isFocused) {
          this.editor.commands.blur();
        }
        this.storage.state = {
          phase: "asking",
          initialSelection: {
            from: this.editor.state.selection.from,
            to: this.editor.state.selection.to
          },
          customPrompt: ""
        };
        return true;
      },
      $startAiToolbarThinking: (prompt, withPreviousResponse) => ({ tr, view }) => {
        const currentState = this.storage.state;
        if (currentState.phase === "thinking") {
          return false;
        }
        if (this.editor.isFocused) {
          this.editor.commands.blur();
        }
        const abortController = new AbortController();
        const provider = getLiveblocksYjsProvider(this.editor);
        if (currentState.phase === "reviewing") {
          const revertTr = getRevertTransaction(
            tr,
            this.editor,
            this.storage,
            this.options.doc
          );
          if (revertTr) {
            view.dispatch(revertTr);
            tr.setMeta("preventDispatch", true);
          }
          this.editor.commands.setTextSelection(
            currentState.initialSelection
          );
        }
        this.storage.state = {
          phase: "thinking",
          initialSelection: currentState.initialSelection ?? {
            from: this.editor.state.selection.from,
            to: this.editor.state.selection.to
          },
          customPrompt: currentState.customPrompt ?? "",
          prompt,
          abortController,
          previousResponse: currentState.response
        };
        this.editor.setEditable(false);
        autoRetry(
          async () => {
            await provider?.pause();
            const response = await this.options.resolveContextualPrompt({
              prompt,
              context: getContextualPromptContext(this.editor, 3e3),
              signal: abortController.signal,
              previous: withPreviousResponse && currentState.phase === "reviewing" ? {
                prompt: currentState.prompt,
                response: {
                  type: currentState.response?.type,
                  text: currentState.response?.text
                }
              } : void 0
            });
            if (isResolveContextualPromptResponse(response)) {
              return response;
            } else {
              throw new Error("Failed to resolve AI prompt.");
            }
          },
          RESOLVE_AI_PROMPT_RETRY_ATTEMPTS,
          RESOLVE_AI_PROMPT_RETRY_DELAYS,
          (error) => {
            return abortController.signal.aborted || error instanceof HttpError && error.status >= 400 && error.status < 500;
          }
        ).then((response) => {
          if (abortController.signal.aborted) {
            return;
          }
          this.editor.commands._handleAiToolbarThinkingSuccess({
            type: response.type,
            text: response.text
          });
        }).catch((error) => {
          if (abortController.signal.aborted) {
            return;
          }
          this.editor.commands._handleAiToolbarThinkingError(error);
        });
        return true;
      },
      $cancelAiToolbarThinking: () => () => {
        const currentState = this.storage.state;
        if (currentState.phase !== "thinking") {
          return false;
        }
        currentState.abortController.abort();
        this.editor.setEditable(true);
        this.storage.state = {
          phase: "asking",
          initialSelection: currentState.initialSelection,
          customPrompt: currentState.prompt === currentState.customPrompt ? currentState.customPrompt : ""
        };
        return true;
      },
      _showAiToolbarReviewingDiff: () => () => {
        if (this.storage.state.phase !== "reviewing") {
          return false;
        }
        if (!this.options.doc || !this.storage.snapshot) {
          return false;
        }
        const previousSnapshot = this.storage.snapshot ?? emptySnapshot;
        const currentSnapshot = snapshot(this.options.doc);
        if (equalSnapshots(previousSnapshot, currentSnapshot)) {
          return true;
        }
        getYjsBinding(this.editor)?.renderSnapshot(
          currentSnapshot,
          previousSnapshot
        );
        return true;
      },
      _handleAiToolbarThinkingSuccess: (response) => ({ view, tr }) => {
        const currentState = this.storage.state;
        if (currentState.phase !== "thinking") {
          return false;
        }
        if (!isContextualPromptDiffResponse(response)) {
          this.storage.state = {
            phase: "reviewing",
            initialSelection: currentState.initialSelection,
            customPrompt: "",
            prompt: currentState.prompt,
            response
          };
          return true;
        }
        if (!this.options.doc) {
          return false;
        }
        this.options.doc.gc = false;
        this.storage.snapshot = snapshot(this.options.doc);
        this.storage.state = {
          phase: "reviewing",
          initialSelection: currentState.initialSelection,
          customPrompt: "",
          prompt: currentState.prompt,
          response
        };
        const [firstParagraph, ...otherParagraphs] = response.text.split("\n");
        tr.insertText(
          firstParagraph,
          response.type === "insert" ? this.editor.state.selection.to : this.editor.state.selection.from,
          this.editor.state.selection.to
        );
        if (otherParagraphs.length > 0) {
          const paragraphs = otherParagraphs.map(
            (paragraph) => createParagraph(this.editor, paragraph)
          );
          tr.insert(tr.selection.$to.pos, paragraphs);
        }
        view.dispatch(tr);
        tr.setMeta("preventDispatch", true);
        this.editor.commands._showAiToolbarReviewingDiff();
        return true;
      },
      _handleAiToolbarThinkingError: (error) => () => {
        const currentState = this.storage.state;
        if (currentState.phase !== "thinking") {
          return false;
        }
        this.editor.setEditable(true);
        console.error(error);
        this.storage.state = {
          phase: "asking",
          initialSelection: currentState.initialSelection,
          customPrompt: currentState.prompt === currentState.customPrompt ? currentState.customPrompt : "",
          error: error instanceof Error ? error : new Error(String(error), { cause: error })
        };
        return true;
      },
      _updateAiToolbarCustomPrompt: (customPrompt) => () => {
        const currentState = this.storage.state;
        if (typeof currentState.customPrompt !== "string") {
          return false;
        }
        this.storage.state.customPrompt = typeof customPrompt === "function" ? customPrompt(currentState.customPrompt) : customPrompt;
        return true;
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: AI_TOOLBAR_SELECTION_PLUGIN,
        props: {
          decorations: ({ doc, selection }) => {
            if (this.storage.state.phase === "closed" || this.storage.state.phase === "reviewing" && isContextualPromptDiffResponse(this.storage.state.response)) {
              return DecorationSet.create(doc, []);
            }
            const { from, to } = selection;
            const decorations = [
              Decoration.inline(from, to, {
                class: "lb-root lb-selection lb-tiptap-active-selection"
              })
            ];
            return DecorationSet.create(doc, decorations);
          }
        }
      })
    ];
  }
});

export { AiExtension, DEFAULT_STATE, isContextualPromptDiffResponse };
//# sourceMappingURL=AiExtension.js.map
