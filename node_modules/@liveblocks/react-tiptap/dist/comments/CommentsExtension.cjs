'use strict';

var core = require('@tiptap/core');
var state = require('@tiptap/pm/state');
var view = require('@tiptap/pm/view');
var yProsemirror = require('y-prosemirror');
var types = require('../types.cjs');

const FILTERED_THREADS_PLUGIN_KEY = new state.PluginKey();
const Comment = core.Mark.create({
  name: types.LIVEBLOCKS_COMMENT_MARK_TYPE,
  excludes: "",
  inclusive: false,
  keepOnSplit: true,
  parseHTML: () => {
    return [
      {
        tag: "span",
        getAttrs: (node) => node.getAttribute("data-lb-thread-id") !== null && null
      }
    ];
  },
  addAttributes() {
    return {
      orphan: {
        parseHTML: (element) => !!element.getAttribute("data-orphan"),
        renderHTML: (attributes) => {
          return attributes.orphan ? {
            "data-orphan": "true"
          } : {};
        },
        default: false
      },
      threadId: {
        parseHTML: (element) => element.getAttribute("data-lb-thread-id"),
        renderHTML: (attributes) => {
          return {
            "data-lb-thread-id": attributes.threadId
          };
        },
        default: ""
      }
    };
  },
  renderHTML({ HTMLAttributes }) {
    const filteredThreads = this.editor ? FILTERED_THREADS_PLUGIN_KEY.getState(this.editor.state)?.filteredThreads : void 0;
    const threadId = HTMLAttributes["data-lb-thread-id"];
    if (filteredThreads && !filteredThreads.has(threadId)) {
      return [
        "span",
        core.mergeAttributes(HTMLAttributes, {
          class: "lb-root lb-tiptap-thread-mark",
          "data-hidden": ""
        })
      ];
    }
    return [
      "span",
      core.mergeAttributes(HTMLAttributes, {
        class: "lb-root lb-tiptap-thread-mark"
      })
    ];
  },
  addProseMirrorPlugins() {
    const updateState = (doc, selectedThreadId) => {
      const threadPositions = /* @__PURE__ */ new Map();
      const decorations = [];
      doc.descendants((node, pos) => {
        node.marks.forEach((mark) => {
          if (mark.type === this.type) {
            const thisThreadId = mark.attrs.threadId;
            if (!thisThreadId) {
              return;
            }
            const from = pos;
            const to = from + node.nodeSize;
            const currentPosition = threadPositions.get(thisThreadId) ?? {
              from: Infinity,
              to: 0
            };
            threadPositions.set(thisThreadId, {
              from: Math.min(from, currentPosition.from),
              to: Math.max(to, currentPosition.to)
            });
            if (selectedThreadId === thisThreadId) {
              decorations.push(
                view.Decoration.inline(from, to, {
                  class: "lb-root lb-tiptap-thread-mark-selected"
                })
              );
              const decoration = this.editor.view.dom.querySelector(
                `.lb-tiptap-thread-mark[data-lb-thread-id="${thisThreadId}"]`
              );
              if (decoration) {
                decoration.scrollIntoView({
                  behavior: "smooth",
                  block: "nearest"
                });
              }
            }
          }
        });
      });
      return {
        decorations: view.DecorationSet.create(doc, decorations),
        selectedThreadId,
        threadPositions,
        selectedThreadPos: selectedThreadId !== null ? threadPositions.get(selectedThreadId)?.to ?? null : null
      };
    };
    return [
      new state.Plugin({
        key: types.THREADS_PLUGIN_KEY,
        state: {
          init() {
            return {
              threadPositions: /* @__PURE__ */ new Map(),
              selectedThreadId: null,
              selectedThreadPos: null,
              decorations: view.DecorationSet.empty
            };
          },
          apply(tr, state) {
            const action = tr.getMeta(types.THREADS_PLUGIN_KEY);
            if (!tr.docChanged && !action) {
              return state;
            }
            if (!action) {
              return updateState(tr.doc, state.selectedThreadId);
            }
            if (action.name === types.ThreadPluginActions.SET_SELECTED_THREAD_ID && state.selectedThreadId !== action.data) {
              return updateState(tr.doc, action.data);
            }
            return state;
          }
        },
        props: {
          decorations: (state) => {
            return types.THREADS_PLUGIN_KEY.getState(state)?.decorations ?? view.DecorationSet.empty;
          },
          handleClick: (view, pos, event) => {
            if (event.button !== 0) {
              return;
            }
            const selectThread = (threadId2) => {
              view.dispatch(
                view.state.tr.setMeta(types.THREADS_PLUGIN_KEY, {
                  name: types.ThreadPluginActions.SET_SELECTED_THREAD_ID,
                  data: threadId2
                })
              );
            };
            const node = view.state.doc.nodeAt(pos);
            if (!node) {
              selectThread(null);
              return;
            }
            const commentMark = node.marks.find(
              (mark) => mark.type === this.type && !mark.attrs.orphan
            );
            if (!commentMark) {
              selectThread(null);
              return;
            }
            const threadId = commentMark?.attrs.threadId;
            const filtered = FILTERED_THREADS_PLUGIN_KEY.getState(
              view.state
            )?.filteredThreads;
            if (threadId && filtered && !filtered.has(threadId)) {
              selectThread(null);
              return;
            }
            selectThread(threadId ?? null);
          }
        }
      })
    ];
  }
});
const CommentsExtension = core.Extension.create({
  name: "liveblocksComments",
  priority: 95,
  addExtensions() {
    return [Comment];
  },
  addStorage() {
    return {
      pendingComment: false
    };
  },
  addCommands() {
    return {
      addPendingComment: () => () => {
        if (this.editor.state.selection.empty) {
          return false;
        }
        this.editor.view.dispatch(
          this.editor.state.tr.setMeta(types.THREADS_PLUGIN_KEY, {
            name: types.ThreadPluginActions.SET_SELECTED_THREAD_ID,
            data: null
          })
        );
        this.storage.pendingComment = true;
        return true;
      },
      closePendingComment: () => () => {
        this.storage.pendingComment = false;
        return true;
      },
      selectThread: (id) => () => {
        const filtered = FILTERED_THREADS_PLUGIN_KEY.getState(
          this.editor.state
        )?.filteredThreads;
        if (id && filtered && !filtered.has(id)) {
          this.editor.view.dispatch(
            this.editor.state.tr.setMeta(types.THREADS_PLUGIN_KEY, {
              name: types.ThreadPluginActions.SET_SELECTED_THREAD_ID,
              data: null
            })
          );
          return true;
        }
        this.editor.view.dispatch(
          this.editor.state.tr.setMeta(types.THREADS_PLUGIN_KEY, {
            name: types.ThreadPluginActions.SET_SELECTED_THREAD_ID,
            data: id
          })
        );
        return true;
      },
      addComment: (id) => ({ commands }) => {
        if (!this.storage.pendingComment || this.editor.state.selection.empty) {
          return false;
        }
        commands.setMark(types.LIVEBLOCKS_COMMENT_MARK_TYPE, { threadId: id });
        this.storage.pendingComment = false;
        return true;
      }
    };
  },
  onSelectionUpdate({ transaction }) {
    if (!this.storage.pendingComment || transaction.getMeta(yProsemirror.ySyncPluginKey)) {
      return;
    }
    this.storage.pendingComment = false;
  },
  addProseMirrorPlugins() {
    return [
      new state.Plugin({
        key: types.THREADS_ACTIVE_SELECTION_PLUGIN,
        props: {
          decorations: ({ doc, selection }) => {
            if (!this.storage.pendingComment) {
              return view.DecorationSet.create(doc, []);
            }
            const { from, to } = selection;
            const decorations = [
              view.Decoration.inline(from, to, {
                class: "lb-root lb-selection lb-tiptap-active-selection"
              })
            ];
            return view.DecorationSet.create(doc, decorations);
          }
        }
      }),
      new state.Plugin({
        key: FILTERED_THREADS_PLUGIN_KEY,
        state: {
          init: () => ({
            filteredThreads: this.options.filteredThreads
          }),
          apply(tr, value) {
            const meta = tr.getMeta(FILTERED_THREADS_PLUGIN_KEY);
            if (meta?.filteredThreads) {
              return { filteredThreads: meta.filteredThreads };
            }
            return value;
          }
        },
        view: (view) => {
          const syncDom = () => {
            const filteredThreads = FILTERED_THREADS_PLUGIN_KEY.getState(
              view.state
            )?.filteredThreads;
            const els = view.dom.querySelectorAll(
              "span.lb-tiptap-thread-mark[data-lb-thread-id]"
            );
            els.forEach((el) => {
              const id = el.getAttribute("data-lb-thread-id");
              if (!id)
                return;
              if (!filteredThreads || filteredThreads.has(id)) {
                el.removeAttribute("data-hidden");
              } else {
                el.setAttribute("data-hidden", "");
              }
            });
          };
          queueMicrotask(syncDom);
          return {
            update: (view2, prevState) => {
              const curr = FILTERED_THREADS_PLUGIN_KEY.getState(
                view2.state
              )?.filteredThreads;
              const prev = FILTERED_THREADS_PLUGIN_KEY.getState(
                prevState
              )?.filteredThreads;
              if (!areSetsEqual(prev, curr) || view2.state.doc !== prevState.doc) {
                syncDom();
                const selected = types.THREADS_PLUGIN_KEY.getState(
                  view2.state
                )?.selectedThreadId;
                if (selected && curr && !curr.has(selected)) {
                  view2.dispatch(
                    view2.state.tr.setMeta(types.THREADS_PLUGIN_KEY, {
                      name: types.ThreadPluginActions.SET_SELECTED_THREAD_ID,
                      data: null
                    })
                  );
                }
              }
            }
          };
        }
      })
    ];
  }
});
function areSetsEqual(a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  if (a.size !== b.size)
    return false;
  for (const v of a)
    if (!b.has(v))
      return false;
  return true;
}

exports.CommentsExtension = CommentsExtension;
exports.FILTERED_THREADS_PLUGIN_KEY = FILTERED_THREADS_PLUGIN_KEY;
exports.areSetsEqual = areSetsEqual;
//# sourceMappingURL=CommentsExtension.cjs.map
