'use strict';

var jsxRuntime = require('react/jsx-runtime');
var reactDom = require('@floating-ui/react-dom');
var react$1 = require('@liveblocks/react');
var _private = require('@liveblocks/react/_private');
var reactUi = require('@liveblocks/react-ui');
var react$2 = require('@tiptap/react');
var react = require('react');
var reactDom$1 = require('react-dom');
var utils = require('../utils.cjs');

const FLOATING_COMPOSER_COLLISION_PADDING = 10;
const FloatingComposer = react.forwardRef(function FloatingComposer2({ editor, onComposerSubmit, onKeyDown, onClick, components, ...props }, forwardedRef) {
  const Composer = components?.Composer ?? reactUi.Composer;
  const createThread = react$1.useCreateThread();
  const pendingCommentSelection = react$2.useEditorState({
    editor,
    selector: (ctx) => {
      if (!ctx.editor)
        return;
      return ctx.editor.storage.liveblocksComments?.pendingComment && !ctx.editor.state.selection.empty ? ctx.editor.state.selection : void 0;
    },
    equalityFn: utils.compareSelections
  }) ?? void 0;
  const isOpen = pendingCommentSelection !== void 0;
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [
      reactDom.inline({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      reactDom.flip({ padding: FLOATING_COMPOSER_COLLISION_PADDING, crossAxis: false }),
      reactDom.offset(10),
      reactDom.hide({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      reactDom.shift({
        padding: FLOATING_COMPOSER_COLLISION_PADDING,
        limiter: reactDom.limitShift()
      }),
      reactDom.size({ padding: FLOATING_COMPOSER_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  _private.useLayoutEffect(() => {
    if (!editor || !isOpen) {
      return;
    }
    if (!pendingCommentSelection) {
      setReference(null);
    } else {
      const domRange = utils.getDomRangeFromSelection(
        editor,
        pendingCommentSelection
      );
      setReference(domRange);
    }
  }, [pendingCommentSelection, editor, isOpen, setReference]);
  const handleComposerSubmit = react.useCallback(
    (comment, event) => {
      onComposerSubmit?.(comment, event);
      if (event.defaultPrevented)
        return;
      if (!editor) {
        return;
      }
      event.preventDefault();
      const thread = createThread({
        body: comment.body,
        attachments: comment.attachments,
        metadata: props.metadata ?? {}
      });
      editor.commands.addComment(thread.id);
    },
    [onComposerSubmit, editor, createThread, props.metadata]
  );
  const handleKeyDown = react.useCallback(
    (event) => {
      onKeyDown?.(event);
      if (event.isDefaultPrevented() || !editor) {
        return;
      }
      if (event.key === "Escape") {
        editor.chain().closePendingComment().run();
      }
    },
    [editor, onKeyDown]
  );
  const handleClick = react.useCallback(
    (event) => {
      onClick?.(event);
      if (event.defaultPrevented) {
        return;
      }
      event.stopPropagation();
    },
    [onClick]
  );
  if (!isOpen || !editor) {
    return null;
  }
  return reactDom$1.createPortal(
    /* @__PURE__ */ jsxRuntime.jsx("div", {
      className: "lb-root lb-portal lb-elevation lb-tiptap-floating lb-tiptap-floating-composer",
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      children: /* @__PURE__ */ jsxRuntime.jsx(Composer, {
        ref: forwardedRef,
        autoFocus: true,
        ...props,
        onKeyDown: handleKeyDown,
        onComposerSubmit: handleComposerSubmit,
        onClick: handleClick
      })
    }),
    document.body
  );
});

exports.FLOATING_COMPOSER_COLLISION_PADDING = FLOATING_COMPOSER_COLLISION_PADDING;
exports.FloatingComposer = FloatingComposer;
//# sourceMappingURL=FloatingComposer.cjs.map
