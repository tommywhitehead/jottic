import { jsx } from 'react/jsx-runtime';
import { useFloating, flip, offset, hide, shift, limitShift, size, autoUpdate } from '@floating-ui/react-dom';
import { useLayoutEffect } from '@liveblocks/react/_private';
import { Thread } from '@liveblocks/react-ui';
import { cn } from '@liveblocks/react-ui/_private';
import { useEditorState } from '@tiptap/react';
import { useState, useEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { THREADS_PLUGIN_KEY } from '../types.js';

function FloatingThreads({
  threads,
  components,
  editor,
  ...props
}) {
  const Thread$1 = components?.Thread ?? Thread;
  const { pluginState } = useEditorState({
    editor,
    selector: (ctx) => {
      if (!ctx?.editor?.state)
        return { pluginState: void 0 };
      const state = THREADS_PLUGIN_KEY.getState(ctx.editor.state);
      return {
        pluginState: state
      };
    },
    equalityFn: (prev, next) => {
      if (!prev || !next)
        return false;
      return prev.pluginState?.selectedThreadPos === next.pluginState?.selectedThreadPos && prev.pluginState?.selectedThreadId === next.pluginState?.selectedThreadId;
    }
  }) ?? { pluginState: void 0 };
  const [activeThread, setActiveThread] = useState(null);
  useEffect(() => {
    if (!editor || !pluginState) {
      setActiveThread(null);
      return;
    }
    const { selectedThreadId, selectedThreadPos } = pluginState;
    if (selectedThreadId === null || selectedThreadPos === null) {
      setActiveThread(null);
      return;
    }
    const active = (threads ?? []).find(
      (thread) => selectedThreadId === thread.id
    );
    setActiveThread(active ?? null);
  }, [editor, pluginState, threads]);
  const handleEscapeKeydown = useCallback(() => {
    if (!editor || activeThread === null)
      return false;
    editor.commands.selectThread(null);
    return true;
  }, [activeThread, editor]);
  if (!activeThread || !editor || activeThread.resolved)
    return null;
  return /* @__PURE__ */ jsx(FloatingThreadPortal, {
    thread: activeThread,
    editor,
    container: document.body,
    ...props,
    children: activeThread && /* @__PURE__ */ jsx(ThreadWrapper, {
      thread: activeThread,
      Thread: Thread$1,
      onEscapeKeydown: handleEscapeKeydown,
      className: "lb-tiptap-floating-threads-thread"
    }, activeThread.id)
  });
}
const FLOATING_THREAD_COLLISION_PADDING = 10;
function FloatingThreadPortal({
  container,
  editor,
  thread,
  children,
  className,
  style,
  ...props
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "absolute",
    placement: "bottom",
    middleware: [
      flip({ padding: FLOATING_THREAD_COLLISION_PADDING, crossAxis: false }),
      offset(10),
      hide({ padding: FLOATING_THREAD_COLLISION_PADDING }),
      shift({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        limiter: limitShift()
      }),
      size({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        apply({ availableWidth, availableHeight, elements }) {
          elements.floating.style.setProperty(
            "--lb-tiptap-floating-threads-available-width",
            `${availableWidth}px`
          );
          elements.floating.style.setProperty(
            "--lb-tiptap-floating-threads-available-height",
            `${availableHeight}px`
          );
        }
      })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  const updateRef = useCallback(() => {
    const el = editor.view.dom.querySelector(
      `[data-lb-thread-id="${thread.id}"]`
    );
    if (el) {
      setReference(el);
    }
  }, [setReference, editor, thread.id]);
  useEffect(() => {
    editor.on("transaction", updateRef);
    return () => {
      editor.off("transaction", updateRef);
    };
  }, [editor, updateRef]);
  useLayoutEffect(updateRef, [updateRef]);
  return createPortal(
    /* @__PURE__ */ jsx("div", {
      ref: setFloating,
      ...props,
      style: {
        ...style,
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: cn(
        "lb-root lb-portal lb-elevation lb-tiptap-floating lb-tiptap-floating-threads",
        className
      ),
      children
    }),
    container
  );
}
function ThreadWrapper({
  thread,
  Thread,
  onEscapeKeydown,
  onKeyDown,
  ...threadProps
}) {
  const handleKeyDown = useCallback(
    (event) => {
      onKeyDown?.(event);
      if (event.key === "Escape") {
        onEscapeKeydown();
      }
    },
    [onEscapeKeydown, onKeyDown]
  );
  return /* @__PURE__ */ jsx(Thread, {
    thread,
    onKeyDown: handleKeyDown,
    ...threadProps
  });
}

export { FLOATING_THREAD_COLLISION_PADDING, FloatingThreads };
//# sourceMappingURL=FloatingThreads.js.map
