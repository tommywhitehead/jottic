import { jsx } from 'react/jsx-runtime';
import { useFloating, inline, flip, offset, hide, shift, limitShift, size, autoUpdate } from '@floating-ui/react-dom';
import { useCreateThread } from '@liveblocks/react';
import { useLayoutEffect } from '@liveblocks/react/_private';
import { Composer } from '@liveblocks/react-ui';
import { useEditorState } from '@tiptap/react';
import { forwardRef, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { compareSelections, getDomRangeFromSelection } from '../utils.js';

const FLOATING_COMPOSER_COLLISION_PADDING = 10;
const FloatingComposer = forwardRef(function FloatingComposer2({ editor, onComposerSubmit, onKeyDown, onClick, components, ...props }, forwardedRef) {
  const Composer$1 = components?.Composer ?? Composer;
  const createThread = useCreateThread();
  const pendingCommentSelection = useEditorState({
    editor,
    selector: (ctx) => {
      if (!ctx.editor)
        return;
      return ctx.editor.storage.liveblocksComments?.pendingComment && !ctx.editor.state.selection.empty ? ctx.editor.state.selection : void 0;
    },
    equalityFn: compareSelections
  }) ?? void 0;
  const isOpen = pendingCommentSelection !== void 0;
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [
      inline({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      flip({ padding: FLOATING_COMPOSER_COLLISION_PADDING, crossAxis: false }),
      offset(10),
      hide({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      shift({
        padding: FLOATING_COMPOSER_COLLISION_PADDING,
        limiter: limitShift()
      }),
      size({ padding: FLOATING_COMPOSER_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect(() => {
    if (!editor || !isOpen) {
      return;
    }
    if (!pendingCommentSelection) {
      setReference(null);
    } else {
      const domRange = getDomRangeFromSelection(
        editor,
        pendingCommentSelection
      );
      setReference(domRange);
    }
  }, [pendingCommentSelection, editor, isOpen, setReference]);
  const handleComposerSubmit = useCallback(
    (comment, event) => {
      onComposerSubmit?.(comment, event);
      if (event.defaultPrevented)
        return;
      if (!editor) {
        return;
      }
      event.preventDefault();
      const thread = createThread({
        body: comment.body,
        attachments: comment.attachments,
        metadata: props.metadata ?? {}
      });
      editor.commands.addComment(thread.id);
    },
    [onComposerSubmit, editor, createThread, props.metadata]
  );
  const handleKeyDown = useCallback(
    (event) => {
      onKeyDown?.(event);
      if (event.isDefaultPrevented() || !editor) {
        return;
      }
      if (event.key === "Escape") {
        editor.chain().closePendingComment().run();
      }
    },
    [editor, onKeyDown]
  );
  const handleClick = useCallback(
    (event) => {
      onClick?.(event);
      if (event.defaultPrevented) {
        return;
      }
      event.stopPropagation();
    },
    [onClick]
  );
  if (!isOpen || !editor) {
    return null;
  }
  return createPortal(
    /* @__PURE__ */ jsx("div", {
      className: "lb-root lb-portal lb-elevation lb-tiptap-floating lb-tiptap-floating-composer",
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      children: /* @__PURE__ */ jsx(Composer$1, {
        ref: forwardedRef,
        autoFocus: true,
        ...props,
        onKeyDown: handleKeyDown,
        onComposerSubmit: handleComposerSubmit,
        onClick: handleClick
      })
    }),
    document.body
  );
});

export { FLOATING_COMPOSER_COLLISION_PADDING, FloatingComposer };
//# sourceMappingURL=FloatingComposer.js.map
