'use strict';

var jsxRuntime = require('react/jsx-runtime');
var reactDom = require('@floating-ui/react-dom');
var _private = require('@liveblocks/react/_private');
var reactUi = require('@liveblocks/react-ui');
var _private$1 = require('@liveblocks/react-ui/_private');
var react = require('@tiptap/react');
var react$1 = require('react');
var reactDom$1 = require('react-dom');
var types = require('../types.cjs');

function FloatingThreads({
  threads,
  components,
  editor,
  ...props
}) {
  const Thread = components?.Thread ?? reactUi.Thread;
  const { pluginState } = react.useEditorState({
    editor,
    selector: (ctx) => {
      if (!ctx?.editor?.state)
        return { pluginState: void 0 };
      const state = types.THREADS_PLUGIN_KEY.getState(ctx.editor.state);
      return {
        pluginState: state
      };
    },
    equalityFn: (prev, next) => {
      if (!prev || !next)
        return false;
      return prev.pluginState?.selectedThreadPos === next.pluginState?.selectedThreadPos && prev.pluginState?.selectedThreadId === next.pluginState?.selectedThreadId;
    }
  }) ?? { pluginState: void 0 };
  const [activeThread, setActiveThread] = react$1.useState(null);
  react$1.useEffect(() => {
    if (!editor || !pluginState) {
      setActiveThread(null);
      return;
    }
    const { selectedThreadId, selectedThreadPos } = pluginState;
    if (selectedThreadId === null || selectedThreadPos === null) {
      setActiveThread(null);
      return;
    }
    const active = (threads ?? []).find(
      (thread) => selectedThreadId === thread.id
    );
    setActiveThread(active ?? null);
  }, [editor, pluginState, threads]);
  const handleEscapeKeydown = react$1.useCallback(() => {
    if (!editor || activeThread === null)
      return false;
    editor.commands.selectThread(null);
    return true;
  }, [activeThread, editor]);
  if (!activeThread || !editor || activeThread.resolved)
    return null;
  return /* @__PURE__ */ jsxRuntime.jsx(FloatingThreadPortal, {
    thread: activeThread,
    editor,
    container: document.body,
    ...props,
    children: activeThread && /* @__PURE__ */ jsxRuntime.jsx(ThreadWrapper, {
      thread: activeThread,
      Thread,
      onEscapeKeydown: handleEscapeKeydown,
      className: "lb-tiptap-floating-threads-thread"
    }, activeThread.id)
  });
}
const FLOATING_THREAD_COLLISION_PADDING = 10;
function FloatingThreadPortal({
  container,
  editor,
  thread,
  children,
  className,
  style,
  ...props
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "absolute",
    placement: "bottom",
    middleware: [
      reactDom.flip({ padding: FLOATING_THREAD_COLLISION_PADDING, crossAxis: false }),
      reactDom.offset(10),
      reactDom.hide({ padding: FLOATING_THREAD_COLLISION_PADDING }),
      reactDom.shift({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        limiter: reactDom.limitShift()
      }),
      reactDom.size({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        apply({ availableWidth, availableHeight, elements }) {
          elements.floating.style.setProperty(
            "--lb-tiptap-floating-threads-available-width",
            `${availableWidth}px`
          );
          elements.floating.style.setProperty(
            "--lb-tiptap-floating-threads-available-height",
            `${availableHeight}px`
          );
        }
      })
    ],
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  const updateRef = react$1.useCallback(() => {
    const el = editor.view.dom.querySelector(
      `[data-lb-thread-id="${thread.id}"]`
    );
    if (el) {
      setReference(el);
    }
  }, [setReference, editor, thread.id]);
  react$1.useEffect(() => {
    editor.on("transaction", updateRef);
    return () => {
      editor.off("transaction", updateRef);
    };
  }, [editor, updateRef]);
  _private.useLayoutEffect(updateRef, [updateRef]);
  return reactDom$1.createPortal(
    /* @__PURE__ */ jsxRuntime.jsx("div", {
      ref: setFloating,
      ...props,
      style: {
        ...style,
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: _private$1.cn(
        "lb-root lb-portal lb-elevation lb-tiptap-floating lb-tiptap-floating-threads",
        className
      ),
      children
    }),
    container
  );
}
function ThreadWrapper({
  thread,
  Thread,
  onEscapeKeydown,
  onKeyDown,
  ...threadProps
}) {
  const handleKeyDown = react$1.useCallback(
    (event) => {
      onKeyDown?.(event);
      if (event.key === "Escape") {
        onEscapeKeydown();
      }
    },
    [onEscapeKeydown, onKeyDown]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Thread, {
    thread,
    onKeyDown: handleKeyDown,
    ...threadProps
  });
}

exports.FLOATING_THREAD_COLLISION_PADDING = FLOATING_THREAD_COLLISION_PADDING;
exports.FloatingThreads = FloatingThreads;
//# sourceMappingURL=FloatingThreads.cjs.map
