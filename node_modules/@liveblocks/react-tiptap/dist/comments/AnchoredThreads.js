import { jsx } from 'react/jsx-runtime';
import { useLayoutEffect } from '@liveblocks/react/_private';
import { Thread } from '@liveblocks/react-ui';
import { cn } from '@liveblocks/react-ui/_private';
import { useEditorState } from '@tiptap/react';
import { useRef, useState, useCallback, useEffect } from 'react';
import { THREADS_PLUGIN_KEY } from '../types.js';
import { getRectFromCoords } from '../utils.js';

const DEFAULT_GAP = 20;
const DEFAULT_ACTIVE_THREAD_OFFSET = -12;
const GAP = `var(--lb-tiptap-anchored-threads-gap, ${DEFAULT_GAP}px)`;
const ACTIVE_THREAD_OFFSET = `var(--lb-tiptap-anchored-threads-active-thread-offset, ${DEFAULT_ACTIVE_THREAD_OFFSET}px)`;
function AnchoredThreads({
  threads,
  components,
  className,
  style,
  editor,
  ...props
}) {
  const Thread$1 = components?.Thread ?? Thread;
  const containerRef = useRef(null);
  const [orderedThreads, setOrderedThreads] = useState([]);
  const [elements, setElements] = useState(/* @__PURE__ */ new Map());
  const [positions, setPositions] = useState(/* @__PURE__ */ new Map());
  const { pluginState } = useEditorState({
    editor,
    selector: (ctx) => {
      if (!ctx?.editor?.state)
        return { pluginState: void 0 };
      const state = THREADS_PLUGIN_KEY.getState(ctx.editor.state);
      return {
        pluginState: state
      };
    },
    equalityFn: (prev, next) => {
      if (!prev || !next)
        return false;
      return prev.pluginState?.selectedThreadId === next.pluginState?.selectedThreadId && prev.pluginState?.threadPositions === next.pluginState?.threadPositions;
    }
  }) ?? { pluginState: void 0 };
  const handlePositionThreads = useCallback(() => {
    const container = containerRef.current;
    if (container === null || !editor || !editor.view)
      return;
    const activeIndex = orderedThreads.findIndex(
      ({ thread }) => thread.id === pluginState?.selectedThreadId
    );
    const ascending = activeIndex !== -1 ? orderedThreads.slice(activeIndex) : orderedThreads;
    const descending = activeIndex !== -1 ? orderedThreads.slice(0, activeIndex) : [];
    const newPositions = /* @__PURE__ */ new Map();
    for (const { thread, position } of ascending) {
      const coords = editor.view.coordsAtPos(
        Math.min(position.from, editor.view.state.doc.content.size - 1)
      );
      const rect = getRectFromCoords(coords);
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [id, position2] of newPositions) {
        const el = elements.get(id);
        if (el === void 0)
          continue;
        if (top >= position2 && top <= position2 + el.getBoundingClientRect().height) {
          top = position2 + el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    for (const { thread, position } of descending.reverse()) {
      const coords = editor.view.coordsAtPos(position.from);
      const rect = getRectFromCoords(coords);
      const el = elements.get(thread.id);
      if (el === void 0)
        continue;
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [, position2] of newPositions) {
        if (top >= position2 - el.getBoundingClientRect().height) {
          top = position2 - el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    setPositions(newPositions);
  }, [editor, orderedThreads, pluginState?.selectedThreadId, elements]);
  useEffect(() => {
    if (!pluginState)
      return;
    setOrderedThreads(
      Array.from(pluginState.threadPositions, ([threadId, position]) => ({
        threadId,
        position
      })).reduce(
        (acc, { threadId, position }) => {
          const thread = threads.find(
            (thread2) => thread2.id === threadId && !thread2.resolved
          );
          if (!thread)
            return acc;
          acc.push({ thread, position });
          return acc;
        },
        []
      )
    );
    handlePositionThreads();
  }, [pluginState, threads]);
  useLayoutEffect(handlePositionThreads, [handlePositionThreads]);
  useEffect(() => {
    const observer = new ResizeObserver(handlePositionThreads);
    const container = editor?.view?.dom;
    if (container) {
      observer.observe(container);
    }
    for (const element of elements.values()) {
      observer.observe(element);
    }
    return () => observer.disconnect();
  }, [elements, editor, handlePositionThreads]);
  const onItemAdd = useCallback((id, el) => {
    setElements((prev) => new Map(prev).set(id, el));
  }, []);
  const onItemRemove = useCallback((id) => {
    setElements((prev) => {
      const items = new Map(prev);
      items.delete(id);
      return items;
    });
  }, []);
  const onThreadSelect = useCallback(
    (id) => {
      if (!editor)
        return;
      editor.commands.selectThread(id);
    },
    [editor]
  );
  if (!editor)
    return null;
  return /* @__PURE__ */ jsx("div", {
    ...props,
    className: cn(className, "lb-root lb-tiptap-anchored-threads"),
    ref: containerRef,
    style: {
      position: "relative",
      ...style
    },
    children: orderedThreads.map(({ thread, position }) => {
      if (!editor.view) {
        return null;
      }
      const coords = editor.view.coordsAtPos(
        Math.min(position.from, editor.state.doc.content.size - 1)
      );
      const rect = getRectFromCoords(coords);
      const offset = editor.options.element.getBoundingClientRect().top;
      let top = rect.top - offset;
      if (positions.has(thread.id)) {
        top = positions.get(thread.id);
      }
      const isActive = thread.id === pluginState?.selectedThreadId;
      return /* @__PURE__ */ jsx(ThreadWrapper, {
        onThreadClick: onThreadSelect,
        onItemAdd,
        onItemRemove,
        Thread: Thread$1,
        thread,
        isActive,
        style: {
          position: "absolute",
          transform: `translate3d(${isActive ? ACTIVE_THREAD_OFFSET : 0}, ${top}px, 0)`,
          insetInlineStart: 0,
          inlineSize: "100%",
          paddingBlockEnd: GAP
        }
      }, thread.id);
    })
  });
}
function ThreadWrapper({
  onThreadClick,
  onItemAdd,
  onItemRemove,
  thread,
  Thread,
  className,
  isActive,
  ...props
}) {
  const divRef = useRef(null);
  useLayoutEffect(() => {
    const el = divRef.current;
    if (el === null)
      return;
    onItemAdd(thread.id, el);
    return () => {
      onItemRemove(thread.id);
    };
  }, [onItemAdd, onItemRemove, thread.id]);
  function handleThreadClick() {
    onThreadClick(thread.id);
  }
  return /* @__PURE__ */ jsx("div", {
    ref: divRef,
    className: cn("lb-tiptap-anchored-threads-thread-container", className),
    ...props,
    children: /* @__PURE__ */ jsx(Thread, {
      thread,
      "data-state": isActive ? "active" : "inactive",
      onClick: handleThreadClick,
      className: "lb-tiptap-anchored-threads-thread",
      showComposer: isActive ? true : false
    })
  });
}

export { AnchoredThreads };
//# sourceMappingURL=AnchoredThreads.js.map
