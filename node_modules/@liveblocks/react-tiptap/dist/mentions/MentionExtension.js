import { createInboxNotificationId, MENTION_CHARACTER, assertNever } from '@liveblocks/core';
import { combineTransactionSteps, getChangedRanges, Extension } from '@tiptap/core';
import { Slice } from '@tiptap/pm/model';
import { Plugin } from '@tiptap/pm/state';
import { ReactRenderer } from '@tiptap/react';
import Suggestion from '@tiptap/suggestion';
import { ySyncPluginKey } from 'y-prosemirror';
import { LIVEBLOCKS_MENTION_PASTE_KEY, LIVEBLOCKS_MENTION_TYPE, LIVEBLOCKS_GROUP_MENTION_TYPE, LIVEBLOCKS_MENTION_NOTIFIER_KEY, LIVEBLOCKS_MENTION_EXTENSION, LIVEBLOCKS_MENTION_KEY } from '../types.js';
import { mapFragment, getMentionsFromNode } from '../utils.js';
import { GroupMentionNode } from './GroupMentionNode.js';
import { MentionNode } from './MentionNode.js';
import { MentionsList } from './MentionsList.js';

const mentionPasteHandler = () => {
  return new Plugin({
    key: LIVEBLOCKS_MENTION_PASTE_KEY,
    props: {
      transformPasted: (slice) => {
        const getNewNotificationIds = (node) => {
          if (node.type.name === LIVEBLOCKS_MENTION_TYPE || node.type.name === LIVEBLOCKS_GROUP_MENTION_TYPE) {
            return node.type.create(
              { ...node.attrs, notificationId: createInboxNotificationId() },
              node.content
            );
          }
          return node.copy(node.content);
        };
        const fragment = mapFragment(slice.content, getNewNotificationIds);
        return new Slice(fragment, slice.openStart, slice.openEnd);
      }
    }
  });
};
const notifier = ({
  onCreateMention,
  onDeleteMention
}) => {
  return new Plugin({
    key: LIVEBLOCKS_MENTION_NOTIFIER_KEY,
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      if (transactions.some((transaction) => transaction.getMeta(ySyncPluginKey))) {
        return;
      }
      const transform = combineTransactionSteps(oldState.doc, [
        ...transactions
      ]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange, oldRange }) => {
        const newMentions = getMentionsFromNode(newState.doc, newRange);
        const oldMentions = getMentionsFromNode(oldState.doc, oldRange);
        if (oldMentions.size || newMentions.size) {
          newMentions.forEach((mention) => {
            if (!oldMentions.has(mention.notificationId)) {
              onCreateMention(mention);
            }
          });
          oldMentions.forEach((mention) => {
            if (!newMentions.has(mention.notificationId)) {
              onDeleteMention(mention.notificationId);
            }
          });
        }
      });
      return void 0;
    }
  });
};
const MentionExtension = Extension.create({
  name: LIVEBLOCKS_MENTION_EXTENSION,
  priority: 101,
  addOptions() {
    return {
      onCreateMention: () => {
      },
      onDeleteMention: () => {
      }
    };
  },
  addExtensions() {
    return [MentionNode, GroupMentionNode];
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: MENTION_CHARACTER,
        pluginKey: LIVEBLOCKS_MENTION_KEY,
        command: ({ editor, range, props }) => {
          const nodeAfter = editor.view.state.selection.$to.nodeAfter;
          const overrideSpace = nodeAfter?.text?.startsWith(" ");
          if (overrideSpace) {
            range.to += 1;
          }
          const mention = props;
          let mentionNode;
          if (mention.kind === "user") {
            mentionNode = {
              type: LIVEBLOCKS_MENTION_TYPE,
              attrs: {
                id: mention.id,
                notificationId: mention.notificationId
              }
            };
          } else if (mention.kind === "group") {
            mentionNode = {
              type: LIVEBLOCKS_GROUP_MENTION_TYPE,
              attrs: {
                id: mention.id,
                userIds: mention.userIds ? JSON.stringify(mention.userIds) : void 0,
                notificationId: mention.notificationId
              }
            };
          } else {
            assertNever(mention, "Unhandled mention kind");
          }
          editor.chain().focus().insertContentAt(range, [
            mentionNode,
            {
              type: "text",
              text: " "
            }
          ]).run();
          editor.view.dom.ownerDocument.defaultView?.getSelection()?.collapseToEnd();
        },
        allow: ({ state, range }) => {
          const $fromParentType = state.doc.resolve(range.from).parent.type;
          return Boolean(
            $fromParentType.contentMatch.matchType(
              state.schema.nodes[LIVEBLOCKS_MENTION_TYPE]
            ) || $fromParentType.contentMatch.matchType(
              state.schema.nodes[LIVEBLOCKS_GROUP_MENTION_TYPE]
            )
          );
        },
        allowSpaces: true,
        items: () => [],
        render: () => {
          let component;
          return {
            onStart: (props) => {
              component = new ReactRenderer(MentionsList, {
                props,
                editor: props.editor
              });
              if (!props.clientRect) {
                return;
              }
              document.body.appendChild(component.element);
            },
            onUpdate(props) {
              component.updateProps(props);
            },
            onKeyDown(props) {
              if (props.event.key === "Escape") {
                component.updateProps({
                  ...props,
                  hide: true
                });
                return true;
              }
              return component.ref?.onKeyDown(props) ?? false;
            },
            onExit() {
              if (document.body.contains(component.element)) {
                document.body.removeChild(component.element);
              }
              component.destroy();
            }
          };
        }
      }),
      notifier(this.options),
      mentionPasteHandler()
    ];
  }
});

export { MentionExtension };
//# sourceMappingURL=MentionExtension.js.map
