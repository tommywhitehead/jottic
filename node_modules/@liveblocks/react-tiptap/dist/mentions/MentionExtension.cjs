'use strict';

var core = require('@liveblocks/core');
var core$1 = require('@tiptap/core');
var model = require('@tiptap/pm/model');
var state = require('@tiptap/pm/state');
var react = require('@tiptap/react');
var Suggestion = require('@tiptap/suggestion');
var yProsemirror = require('y-prosemirror');
var types = require('../types.cjs');
var utils = require('../utils.cjs');
var GroupMentionNode = require('./GroupMentionNode.cjs');
var MentionNode = require('./MentionNode.cjs');
var MentionsList = require('./MentionsList.cjs');

const mentionPasteHandler = () => {
  return new state.Plugin({
    key: types.LIVEBLOCKS_MENTION_PASTE_KEY,
    props: {
      transformPasted: (slice) => {
        const getNewNotificationIds = (node) => {
          if (node.type.name === types.LIVEBLOCKS_MENTION_TYPE || node.type.name === types.LIVEBLOCKS_GROUP_MENTION_TYPE) {
            return node.type.create(
              { ...node.attrs, notificationId: core.createInboxNotificationId() },
              node.content
            );
          }
          return node.copy(node.content);
        };
        const fragment = utils.mapFragment(slice.content, getNewNotificationIds);
        return new model.Slice(fragment, slice.openStart, slice.openEnd);
      }
    }
  });
};
const notifier = ({
  onCreateMention,
  onDeleteMention
}) => {
  return new state.Plugin({
    key: types.LIVEBLOCKS_MENTION_NOTIFIER_KEY,
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      if (transactions.some((transaction) => transaction.getMeta(yProsemirror.ySyncPluginKey))) {
        return;
      }
      const transform = core$1.combineTransactionSteps(oldState.doc, [
        ...transactions
      ]);
      const changes = core$1.getChangedRanges(transform);
      changes.forEach(({ newRange, oldRange }) => {
        const newMentions = utils.getMentionsFromNode(newState.doc, newRange);
        const oldMentions = utils.getMentionsFromNode(oldState.doc, oldRange);
        if (oldMentions.size || newMentions.size) {
          newMentions.forEach((mention) => {
            if (!oldMentions.has(mention.notificationId)) {
              onCreateMention(mention);
            }
          });
          oldMentions.forEach((mention) => {
            if (!newMentions.has(mention.notificationId)) {
              onDeleteMention(mention.notificationId);
            }
          });
        }
      });
      return void 0;
    }
  });
};
const MentionExtension = core$1.Extension.create({
  name: types.LIVEBLOCKS_MENTION_EXTENSION,
  priority: 101,
  addOptions() {
    return {
      onCreateMention: () => {
      },
      onDeleteMention: () => {
      }
    };
  },
  addExtensions() {
    return [MentionNode.MentionNode, GroupMentionNode.GroupMentionNode];
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: core.MENTION_CHARACTER,
        pluginKey: types.LIVEBLOCKS_MENTION_KEY,
        command: ({ editor, range, props }) => {
          const nodeAfter = editor.view.state.selection.$to.nodeAfter;
          const overrideSpace = nodeAfter?.text?.startsWith(" ");
          if (overrideSpace) {
            range.to += 1;
          }
          const mention = props;
          let mentionNode;
          if (mention.kind === "user") {
            mentionNode = {
              type: types.LIVEBLOCKS_MENTION_TYPE,
              attrs: {
                id: mention.id,
                notificationId: mention.notificationId
              }
            };
          } else if (mention.kind === "group") {
            mentionNode = {
              type: types.LIVEBLOCKS_GROUP_MENTION_TYPE,
              attrs: {
                id: mention.id,
                userIds: mention.userIds ? JSON.stringify(mention.userIds) : void 0,
                notificationId: mention.notificationId
              }
            };
          } else {
            core.assertNever(mention, "Unhandled mention kind");
          }
          editor.chain().focus().insertContentAt(range, [
            mentionNode,
            {
              type: "text",
              text: " "
            }
          ]).run();
          editor.view.dom.ownerDocument.defaultView?.getSelection()?.collapseToEnd();
        },
        allow: ({ state, range }) => {
          const $fromParentType = state.doc.resolve(range.from).parent.type;
          return Boolean(
            $fromParentType.contentMatch.matchType(
              state.schema.nodes[types.LIVEBLOCKS_MENTION_TYPE]
            ) || $fromParentType.contentMatch.matchType(
              state.schema.nodes[types.LIVEBLOCKS_GROUP_MENTION_TYPE]
            )
          );
        },
        allowSpaces: true,
        items: () => [],
        render: () => {
          let component;
          return {
            onStart: (props) => {
              component = new react.ReactRenderer(MentionsList.MentionsList, {
                props,
                editor: props.editor
              });
              if (!props.clientRect) {
                return;
              }
              document.body.appendChild(component.element);
            },
            onUpdate(props) {
              component.updateProps(props);
            },
            onKeyDown(props) {
              if (props.event.key === "Escape") {
                component.updateProps({
                  ...props,
                  hide: true
                });
                return true;
              }
              return component.ref?.onKeyDown(props) ?? false;
            },
            onExit() {
              if (document.body.contains(component.element)) {
                document.body.removeChild(component.element);
              }
              component.destroy();
            }
          };
        }
      }),
      notifier(this.options),
      mentionPasteHandler()
    ];
  }
});

exports.MentionExtension = MentionExtension;
//# sourceMappingURL=MentionExtension.cjs.map
