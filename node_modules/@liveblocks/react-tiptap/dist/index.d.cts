import { ContextualPromptContext, ContextualPromptResponse, ThreadData, MentionData, BaseMetadata, DM, HistoryVersion } from '@liveblocks/core';
import { Content, Extension, Node } from '@tiptap/core';
import * as react from 'react';
import { ComponentProps, ReactNode, ComponentType, PropsWithChildren, ComponentPropsWithoutRef, HTMLAttributes } from 'react';
import { Editor } from '@tiptap/react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { ThreadProps, ComposerProps } from '@liveblocks/react-ui';
import { BaseMetadata as BaseMetadata$1 } from '@liveblocks/client';

/**
 * @beta
 */
type ResolveContextualPromptArgs = {
    /**
     * The prompt being requested by the user.
     */
    prompt: string;
    /**
     * The context of the document and its current selection.
     */
    context: ContextualPromptContext;
    /**
     * The previous request and its response, if this is a follow-up request.
     */
    previous?: {
        prompt: string;
        response: ContextualPromptResponse;
    };
    /**
     * An abort signal that can be used to cancel requests.
     */
    signal: AbortSignal;
};
/**
 * @beta
 */
type ResolveContextualPromptResponse = ContextualPromptResponse;
interface AiConfiguration {
    /**
     * The AI's name. ("Ask {name} anything…", "{name} is thinking…", etc)
     */
    name?: string;
    /**
     * A function that returns an a response to a contextual prompt.
     */
    resolveContextualPrompt?: (args: ResolveContextualPromptArgs) => Promise<ContextualPromptResponse>;
}
type LiveblocksExtensionOptions = {
    field?: string;
    comments?: boolean;
    mentions?: boolean;
    ai?: boolean | AiConfiguration;
    offlineSupport_experimental?: boolean;
    threads_experimental?: ThreadData[];
    initialContent?: Content;
    enablePermanentUserData?: boolean;
};
type FloatingPosition = "top" | "bottom";
type CommentsCommands<ReturnType = boolean> = {
    /**
     * Add a comment
     */
    addComment: (id: string) => ReturnType;
    selectThread: (id: string | null) => ReturnType;
    addPendingComment: () => ReturnType;
};
type AiCommands<ReturnType = boolean> = {
    /**
     * Open the AI toolbar, with an optional prompt.
     */
    askAi: (prompt?: string) => ReturnType;
    /**
     * Close the AI toolbar.
     */
    closeAi: () => ReturnType;
};
type TiptapMentionData = MentionData & {
    notificationId: string;
};

interface AiToolbarProps extends Omit<ComponentProps<"div">, "value" | "defaultValue" | "children"> {
    /**
     * The Tiptap editor.
     */
    editor: Editor | null;
    /**
     * The vertical offset of the AI toolbar from the selection.
     */
    offset?: number;
    /**
     * The prompt suggestions to display below the AI toolbar.
     */
    suggestions?: ReactNode | ComponentType<PropsWithChildren>;
}
interface AiToolbarSuggestionProps extends ComponentProps<"div"> {
    prompt?: string;
    icon?: ReactNode;
}
/**
 * @beta
 *
 * A floating AI toolbar attached to the editor.
 */
declare const AiToolbar: react.ForwardRefExoticComponent<Omit<AiToolbarProps, "ref"> & react.RefAttributes<HTMLDivElement>> & {
    /**
     * @beta
     *
     * A prompt suggestion displayed in the AI toolbar.
     */
    Suggestion: react.ForwardRefExoticComponent<Omit<AiToolbarSuggestionProps, "ref"> & react.RefAttributes<HTMLDivElement>>;
    /**
     * @beta
     *
     * A label to describe a group of prompt suggestions displayed in the AI toolbar.
     */
    SuggestionsLabel: react.ForwardRefExoticComponent<Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>, "ref"> & react.RefAttributes<HTMLDivElement>>;
    /**
     * @beta
     *
     * A separator between groups of prompt suggestions displayed in the AI toolbar.
     */
    SuggestionsSeparator: react.ForwardRefExoticComponent<Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & react.RefAttributes<HTMLDivElement>>;
};

type AnchoredThreadsComponents = {
    Thread: ComponentType<ThreadProps>;
};
interface AnchoredThreadsProps<M extends BaseMetadata = DM> extends Omit<ComponentPropsWithoutRef<"div">, "children"> {
    /**
     * The threads to display.
     */
    threads: ThreadData<M>[];
    /**
     * Override the component's components.
     */
    components?: Partial<AnchoredThreadsComponents>;
    /**
     * The Tiptap editor.
     */
    editor: Editor | null;
}
declare function AnchoredThreads({ threads, components, className, style, editor, ...props }: AnchoredThreadsProps): react_jsx_runtime.JSX.Element | null;

type FloatingComposerComponents = {
    Composer: ComponentType<Omit<ComposerProps, "threadId" | "commentId">>;
};
type FloatingComposerProps<M extends BaseMetadata$1 = DM> = Omit<ComposerProps<M>, "threadId" | "commentId"> & {
    /**
     * Override the component's components.
     */
    components?: Partial<FloatingComposerComponents>;
    /**
     * The Tiptap editor.
     */
    editor: Editor | null;
};
declare const FloatingComposer: react.ForwardRefExoticComponent<Omit<ComposerProps<BaseMetadata$1>, "threadId" | "commentId"> & {
    /**
     * Override the component's components.
     */
    components?: Partial<FloatingComposerComponents>;
    /**
     * The Tiptap editor.
     */
    editor: Editor | null;
} & react.RefAttributes<HTMLFormElement>>;

type FloatingThreadsComponents = {
    Thread: ComponentType<ThreadProps>;
};
interface FloatingThreadsProps<M extends BaseMetadata = DM> extends Omit<HTMLAttributes<HTMLDivElement>, "children"> {
    /**
     * The threads to display.
     */
    threads: ThreadData<M>[];
    /**
     * Override the component's components.
     */
    components?: Partial<FloatingThreadsComponents>;
    /**
     * The Tiptap editor.
     */
    editor: Editor | null;
}
declare function FloatingThreads({ threads, components, editor, ...props }: FloatingThreadsProps): react_jsx_runtime.JSX.Element | null;

/**
 * Returns whether the editor has loaded the initial text contents from the
 * server and is ready to be used.
 *
 */
declare function useIsEditorReady(): boolean;
declare const useLiveblocksExtension: (opts?: LiveblocksExtensionOptions) => Extension;

declare const GroupMentionNode: Node<never, never>;

type MentionExtensionOptions = {
    onCreateMention: (mention: TiptapMentionData) => void;
    onDeleteMention: (notificationId: string) => void;
};
declare const MentionExtension: Extension<MentionExtensionOptions, any>;

declare const MentionNode: Node<never, never>;

interface ToolbarSlotProps {
    editor: Editor;
}
type ToolbarSlot = ReactNode | ComponentType<ToolbarSlotProps>;
interface ToolbarProps extends Omit<ComponentProps<"div">, "children"> {
    /**
     * The Tiptap editor.
     */
    editor: Editor | null;
    /**
     * The content of the toolbar, overriding the default content.
     * Use the `before` and `after` props if you want to keep and extend the default content.
     */
    children?: ToolbarSlot;
    /**
     * The content to display at the start of the toolbar.
     */
    before?: ToolbarSlot;
    /**
     * The content to display at the end of the toolbar.
     */
    after?: ToolbarSlot;
}
interface ToolbarButtonProps extends ComponentProps<"button"> {
    /**
     * The name of this button displayed in its tooltip.
     */
    name: string;
    /**
     * An optional icon displayed in this button.
     */
    icon?: ReactNode;
    /**
     * An optional keyboard shortcut displayed in this button's tooltip.
     *
     * @example
     * "Mod-Alt-B" → "⌘⌥B" in Apple environments, "⌃⌥B" otherwise
     * "Ctrl-Shift-Escape" → "⌃⇧⎋"
     * "Space" → "␣"
     */
    shortcut?: string;
}
interface ToolbarToggleProps extends ToolbarButtonProps {
    /**
     * Whether the button is toggled.
     */
    active: boolean;
}
interface ToolbarBlockSelectorItem {
    /**
     * The name of this block element, displayed as the label of this item.
     */
    name: string;
    /**
     * Optionally replace the name used as the label of this item by any content.
     */
    label?: ReactNode;
    /**
     * An optional icon displayed in this item.
     */
    icon?: ReactNode;
    /**
     * Whether this block element is currently active.
     * Set to `"default"` to display this item when no other item is active.
     */
    isActive: ((editor: Editor) => boolean) | "default";
    /**
     * A callback invoked when this item is selected.
     */
    setActive: (editor: Editor) => void;
}
interface ToolbarBlockSelectorProps extends ComponentProps<"button"> {
    /**
     * The items displayed in this block selector.
     * When provided as an array, the default items are overridden. To avoid this,
     * a function can be provided instead and it will receive the default items.
     *
     * @example
     * <Toolbar.BlockSelector
     *   items={[
     *     {
     *       name: "Text",
     *       isActive: "default",
     *       setActive: () => { ... },
     *     },
     *     {
     *       name: "Heading 1",
     *       isActive: () => { ... },
     *       setActive: () => { ... },
     *     },
     *   ]}
     * />
     *
     * @example
     * <Toolbar.BlockSelector
     *   items={(defaultItems) => [
     *     ...defaultItems,
     *     {
     *       name: "Custom block",
     *       isActive: () => { ... },
     *       setActive: () => { ... },
     *     },
     *   ]}
     * />
     */
    items?: ToolbarBlockSelectorItem[] | ((defaultItems: ToolbarBlockSelectorItem[]) => ToolbarBlockSelectorItem[]);
}
type ToolbarSeparatorProps = ComponentProps<"div">;
declare function ToolbarSectionHistory(): react_jsx_runtime.JSX.Element;
declare function ToolbarSectionInline(): react_jsx_runtime.JSX.Element;
declare function ToolbarSectionCollaboration(): react_jsx_runtime.JSX.Element;
declare function ToolbarSectionAi(): react_jsx_runtime.JSX.Element;
/**
 * A static toolbar containing actions and values related to the editor.
 *
 * @example
 * <Toolbar editor={editor} />
 *
 * @example
 * <Toolbar editor={editor}>
 *   <Toolbar.BlockSelector />
 *   <Toolbar.Separator />
 *   <Toolbar.SectionInline />
 *   <Toolbar.Separator />
 *   <Toolbar.Button name="Custom action" onClick={() => { ... }} icon={<Icon.QuestionMark />} />
 * </Toolbar>
 */
declare const Toolbar: react.ForwardRefExoticComponent<Omit<ToolbarProps, "ref"> & react.RefAttributes<HTMLDivElement>> & {
    /**
     * A button for triggering actions.
     *
     * @example
     * <Toolbar.Button name="Comment" shortcut="Mod-Shift-E" onClick={() => { ... }} />
     *
     * @example
     * <Toolbar.Button name="Mention someone" icon={<Icon.Mention />} onClick={() => { ... }} />
     */
    Button: react.ForwardRefExoticComponent<Omit<ToolbarButtonProps, "ref"> & react.RefAttributes<HTMLButtonElement>>;
    /**
     * A toggle button for values that can be active or inactive.
     *
     * @example
     * <Toolbar.Toggle name="Bold" active={isBold} />
     *
     * @example
     * <Toolbar.Toggle name="Italic" icon={<Icon.Italic />} shortcut="Mod-I" active={isItalic} onClick={() => { ... }} />
     */
    Toggle: react.ForwardRefExoticComponent<Omit<ToolbarToggleProps, "ref"> & react.RefAttributes<HTMLButtonElement>>;
    /**
     * A dropdown selector to switch between different block types.
     *
     * @example
     * <Toolbar.BlockSelector />
     */
    BlockSelector: react.ForwardRefExoticComponent<Omit<ToolbarBlockSelectorProps, "ref"> & react.RefAttributes<HTMLButtonElement>>;
    /**
     * A visual (and accessible) separator to separate sections in a toolbar.
     */
    Separator: react.ForwardRefExoticComponent<Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & react.RefAttributes<HTMLDivElement>>;
    /**
     * A section containing history actions. (e.g. undo, redo)
     */
    SectionHistory: typeof ToolbarSectionHistory;
    /**
     * A section containing inline formatting actions. (e.g. bold, italic, underline, ...)
     */
    SectionInline: typeof ToolbarSectionInline;
    /**
     * A section containing collaborative actions. (e.g. adding a comment)
     */
    SectionCollaboration: typeof ToolbarSectionCollaboration;
    /**
     * A section containing AI actions. (e.g. opening the AI toolbar)
     */
    SectionAi: typeof ToolbarSectionAi;
};

interface FloatingToolbarProps extends Omit<ComponentProps<"div">, "children"> {
    /**
     * The Tiptap editor.
     */
    editor: Editor | null;
    /**
     * The vertical position of the floating toolbar.
     */
    position?: FloatingPosition;
    /**
     * The vertical offset of the floating toolbar from the selection.
     */
    offset?: number;
    /**
     * The content of the floating toolbar, overriding the default content.
     * Use the `before` and `after` props if you want to keep and extend the default content.
     */
    children?: ToolbarSlot;
    /**
     * The content to display at the start of the floating toolbar.
     */
    before?: ToolbarSlot;
    /**
     * The content to display at the end of the floating toolbar.
     */
    after?: ToolbarSlot;
}
/**
 * A floating toolbar attached to the selection and containing actions and values related to the editor.
 *
 * @example
 * <FloatingToolbar editor={editor} />
 *
 * @example
 * <FloatingToolbar editor={editor}>
 *   <Toolbar.BlockSelector />
 *   <Toolbar.Separator />
 *   <Toolbar.SectionInline />
 *   <Toolbar.Separator />
 *   <Toolbar.Button name="Custom action" onClick={() => { ... }} icon={<Icon.QuestionMark />} />
 * </FloatingToolbar>
 */
declare const FloatingToolbar: react.ForwardRefExoticComponent<Omit<FloatingToolbarProps, "ref"> & react.RefAttributes<HTMLDivElement>> & {
    /**
     * A component that can be wrapped around elements which are rendered outside of the floating
     * toolbar (e.g. portals) to prevent the toolbar from closing when clicking/focusing within them.
     *
     * @example
     * <FloatingToolbar editor={editor}>
     *   <Popover.Root>
     *     <Popover.Trigger asChild>
     *       <Toolbar.Button>Open popover</Toolbar.Button>
     *     </Popover.Trigger>
     *     <Popover.Portal>
     *       <FloatingToolbar.External>
     *         <Popover.Content>
     *           This popover is rendered outside of the floating toolbar, but the toolbar will not close when clicking/focusing within it.
     *         </Popover.Content>
     *       </FloatingToolbar.External>
     *     </Popover.Portal>
     *   </Popover.Root>
     * </FloatingToolbar>
     */
    External: react.ForwardRefExoticComponent<Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & react.RefAttributes<HTMLDivElement>>;
};

interface HistoryVersionPreviewProps extends ComponentPropsWithoutRef<"div"> {
    version: HistoryVersion;
    editor: Editor;
    onVersionRestore?: (version: HistoryVersion) => void;
}
/**
 * Displays a specific version of the current TipTap document.
 *
 * @example
 * <HistoryVersionPreview version={version} />
 */
declare const HistoryVersionPreview: react.ForwardRefExoticComponent<HistoryVersionPreviewProps & react.RefAttributes<HTMLDivElement>>;

declare module "@tiptap/core" {
    interface Commands<ReturnType> {
        liveblocksComments: CommentsCommands<ReturnType>;
        liveblocksAi: AiCommands<ReturnType>;
    }
}

export { AiConfiguration, AiToolbar, AiToolbarProps, AnchoredThreads, AnchoredThreadsProps, FloatingComposer, FloatingComposerProps, FloatingThreads, FloatingThreadsProps, FloatingToolbar, FloatingToolbarProps, GroupMentionNode, HistoryVersionPreview, HistoryVersionPreviewProps, MentionExtension, MentionNode, ResolveContextualPromptArgs, ResolveContextualPromptResponse, Toolbar, ToolbarBlockSelectorItem, ToolbarBlockSelectorProps, ToolbarButtonProps, ToolbarProps, ToolbarSeparatorProps, ToolbarToggleProps, useIsEditorReady, useLiveblocksExtension };
