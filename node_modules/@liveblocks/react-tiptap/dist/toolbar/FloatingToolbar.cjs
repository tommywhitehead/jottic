'use strict';

var jsxRuntime = require('react/jsx-runtime');
var reactDom = require('@floating-ui/react-dom');
var _private$1 = require('@liveblocks/react/_private');
var _private = require('@liveblocks/react-ui/_private');
var react$1 = require('@tiptap/react');
var react = require('react');
var reactDom$1 = require('react-dom');
var context = require('../context.cjs');
var shared = require('./shared.cjs');
var Toolbar = require('./Toolbar.cjs');

const FLOATING_TOOLBAR_COLLISION_PADDING = 10;
const FLOATING_TOOLBAR_OPEN_DELAY = 50;
function DefaultFloatingToolbarContent({ editor }) {
  const supportsThread = "addPendingComment" in editor.commands;
  const supportsAi = "askAi" in editor.commands;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      supportsAi ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(Toolbar.Toolbar.SectionAi, {}),
          /* @__PURE__ */ jsxRuntime.jsx(Toolbar.Toolbar.Separator, {})
        ]
      }) : null,
      /* @__PURE__ */ jsxRuntime.jsx(Toolbar.Toolbar.BlockSelector, {}),
      /* @__PURE__ */ jsxRuntime.jsx(Toolbar.Toolbar.SectionInline, {}),
      supportsThread ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(Toolbar.Toolbar.Separator, {}),
          /* @__PURE__ */ jsxRuntime.jsx(Toolbar.Toolbar.SectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
const FloatingToolbar = Object.assign(
  react.forwardRef(
    ({
      children = DefaultFloatingToolbarContent,
      before,
      after,
      position = "top",
      offset: sideOffset = 6,
      editor,
      onPointerDown,
      onFocus,
      onBlur,
      className,
      ...props
    }, forwardedRef) => {
      const toolbarRef = react.useRef(null);
      const externalIds = _private.useInitial(() => /* @__PURE__ */ new Set());
      const [isPointerDown, setPointerDown] = react.useState(false);
      const [isFocused, setFocused] = react.useState(false);
      const [isManuallyClosed, setManuallyClosed] = react.useState(false);
      const hasSelectionRange = react$1.useEditorState({
        editor,
        equalityFn: Object.is,
        selector: (ctx) => {
          const editor2 = ctx.editor;
          if (!editor2) {
            return false;
          }
          const { doc, selection } = editor2.state;
          const { empty, ranges } = selection;
          const from = Math.min(...ranges.map((range) => range.$from.pos));
          const to = Math.max(...ranges.map((range) => range.$to.pos));
          if (empty) {
            return false;
          }
          return react$1.isTextSelection(selection) && doc.textBetween(from, to).length > 0;
        }
      }) ?? false;
      const isOpen = isFocused && !isPointerDown && hasSelectionRange && !isManuallyClosed;
      const [delayedIsOpen, setDelayedIsOpen] = react.useState(isOpen);
      const delayedIsOpenTimeoutRef = react.useRef();
      react.useEffect(() => {
        if (!editor) {
          return;
        }
        setManuallyClosed(false);
        const handleSelectionChange = () => {
          setManuallyClosed(false);
        };
        editor.on("selectionUpdate", handleSelectionChange);
        return () => {
          editor.off("selectionUpdate", handleSelectionChange);
        };
      }, [isFocused, hasSelectionRange, editor]);
      react.useEffect(() => {
        if (!editor) {
          return;
        }
        const handleFocus2 = () => {
          setFocused(true);
        };
        const handleBlur2 = (event) => {
          if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {
            return;
          }
          if (event.relatedTarget === editor.view.dom) {
            return;
          }
          for (const externalId of externalIds) {
            if (document.getElementById(externalId)?.contains(event.relatedTarget)) {
              return;
            }
          }
          setFocused(false);
        };
        editor.view.dom.addEventListener("focus", handleFocus2);
        editor.view.dom.addEventListener("blur", handleBlur2);
        return () => {
          editor.view.dom.removeEventListener("focus", handleFocus2);
          editor.view.dom.removeEventListener("blur", handleBlur2);
        };
      }, [editor, externalIds]);
      const handleFocus = react.useCallback(
        (event) => {
          onFocus?.(event);
          if (!event.isDefaultPrevented()) {
            setFocused(true);
          }
        },
        [onFocus]
      );
      const handleBlur = react.useCallback(
        (event) => {
          onBlur?.(event);
          if (!event.isDefaultPrevented()) {
            if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {
              return;
            }
            if (event.relatedTarget === editor?.view.dom) {
              return;
            }
            for (const externalId of externalIds) {
              if (document.getElementById(externalId)?.contains(event.relatedTarget)) {
                return;
              }
            }
            setFocused(false);
          }
        },
        [onBlur, editor, externalIds]
      );
      react.useEffect(() => {
        if (isOpen) {
          delayedIsOpenTimeoutRef.current = window.setTimeout(() => {
            setDelayedIsOpen(true);
          }, FLOATING_TOOLBAR_OPEN_DELAY);
        } else {
          setDelayedIsOpen(false);
        }
        return () => {
          window.clearTimeout(delayedIsOpenTimeoutRef.current);
        };
      }, [isOpen]);
      const floatingOptions = react.useMemo(() => {
        const detectOverflowOptions = {
          padding: FLOATING_TOOLBAR_COLLISION_PADDING
        };
        return {
          strategy: "fixed",
          placement: position,
          middleware: [
            reactDom.inline(detectOverflowOptions),
            reactDom.flip({ ...detectOverflowOptions, crossAxis: false }),
            reactDom.hide(detectOverflowOptions),
            reactDom.shift({
              ...detectOverflowOptions,
              limiter: reactDom.limitShift()
            }),
            reactDom.offset(sideOffset),
            reactDom.size(detectOverflowOptions)
          ],
          whileElementsMounted: (...args) => {
            return reactDom.autoUpdate(...args, {
              animationFrame: true
            });
          }
        };
      }, [position, sideOffset]);
      const {
        refs: { setReference, setFloating },
        strategy,
        x,
        y,
        isPositioned
      } = reactDom.useFloating({
        ...floatingOptions,
        open: delayedIsOpen
      });
      const mergedRefs = _private.useRefs(forwardedRef, toolbarRef, setFloating);
      const handlePointerDown = react.useCallback(
        (event) => {
          onPointerDown?.(event);
          event.stopPropagation();
          if (event.target === toolbarRef.current) {
            event.preventDefault();
          }
        },
        [onPointerDown]
      );
      react.useEffect(() => {
        if (!editor) {
          return;
        }
        const handlePointerDown2 = () => {
          setPointerDown(true);
        };
        const handlePointerUp = () => {
          setPointerDown(false);
        };
        editor.view.dom.addEventListener("pointerdown", handlePointerDown2);
        document.addEventListener("pointercancel", handlePointerUp);
        document.addEventListener("pointerup", handlePointerUp);
        return () => {
          editor.view.dom.removeEventListener("pointerdown", handlePointerDown2);
          document.removeEventListener("pointercancel", handlePointerUp);
          document.removeEventListener("pointerup", handlePointerUp);
        };
      }, [editor]);
      _private$1.useLayoutEffect(() => {
        if (!editor || !delayedIsOpen) {
          return;
        }
        const updateSelectionReference = () => {
          const domSelection = window.getSelection();
          if (editor.state.selection.empty || !domSelection || !domSelection.rangeCount) {
            setReference(null);
          } else {
            const domRange = domSelection.getRangeAt(0);
            setReference(domRange);
          }
        };
        editor.on("transaction", updateSelectionReference);
        updateSelectionReference();
        return () => {
          editor.off("transaction", updateSelectionReference);
        };
      }, [editor, delayedIsOpen, setReference]);
      react.useEffect(() => {
        if (!editor || !delayedIsOpen) {
          return;
        }
        const handleKeyDown = (event) => {
          if (event.target !== editor.view.dom && event.defaultPrevented) {
            return;
          }
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            editor.commands.focus();
            setManuallyClosed(true);
          }
        };
        editor.view.dom.addEventListener("keydown", handleKeyDown);
        return () => {
          editor.view.dom.removeEventListener("keydown", handleKeyDown);
        };
      }, [editor, delayedIsOpen]);
      const close = react.useCallback(() => {
        setManuallyClosed(true);
      }, [setManuallyClosed]);
      const registerExternal = react.useCallback(
        (id) => {
          externalIds.add(id);
          return () => {
            externalIds.delete(id);
          };
        },
        [externalIds]
      );
      if (!editor || !delayedIsOpen) {
        return null;
      }
      const slotProps = { editor };
      return reactDom$1.createPortal(
        /* @__PURE__ */ jsxRuntime.jsx(_private.TooltipProvider, {
          children: /* @__PURE__ */ jsxRuntime.jsx(context.EditorProvider, {
            editor,
            children: /* @__PURE__ */ jsxRuntime.jsx(shared.FloatingToolbarContext.Provider, {
              value: { close, registerExternal },
              children: /* @__PURE__ */ jsxRuntime.jsxs("div", {
                role: "toolbar",
                "aria-label": "Floating toolbar",
                "aria-orientation": "horizontal",
                className: _private.cn(
                  "lb-root lb-portal lb-elevation lb-tiptap-floating-toolbar lb-tiptap-toolbar",
                  className
                ),
                ref: mergedRefs,
                style: {
                  position: strategy,
                  top: 0,
                  left: 0,
                  transform: isPositioned ? `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)` : "translate3d(0, -200%, 0)",
                  minWidth: "max-content"
                },
                onPointerDown: handlePointerDown,
                onFocus: handleFocus,
                onBlur: handleBlur,
                ...props,
                children: [
                  Toolbar.applyToolbarSlot(before, slotProps),
                  Toolbar.applyToolbarSlot(children, slotProps),
                  Toolbar.applyToolbarSlot(after, slotProps)
                ]
              })
            })
          })
        }),
        document.body
      );
    }
  ),
  {
    External: shared.FloatingToolbarExternal
  }
);

exports.FLOATING_TOOLBAR_COLLISION_PADDING = FLOATING_TOOLBAR_COLLISION_PADDING;
exports.FloatingToolbar = FloatingToolbar;
//# sourceMappingURL=FloatingToolbar.cjs.map
