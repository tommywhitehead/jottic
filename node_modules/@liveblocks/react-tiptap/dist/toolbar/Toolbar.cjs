'use strict';

var jsxRuntime = require('react/jsx-runtime');
var _private = require('@liveblocks/react-ui/_private');
var SelectPrimitive = require('@radix-ui/react-select');
var TogglePrimitive = require('@radix-ui/react-toggle');
var react = require('react');
var context = require('../context.cjs');
var shared = require('./shared.cjs');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var SelectPrimitive__namespace = /*#__PURE__*/_interopNamespaceDefault(SelectPrimitive);
var TogglePrimitive__namespace = /*#__PURE__*/_interopNamespaceDefault(TogglePrimitive);

const BLOCK_SELECT_SIDE_OFFSET = 10;
const FLOATING_ELEMENT_COLLISION_PADDING = 10;
function applyToolbarSlot(slot, props) {
  if (typeof slot === "function") {
    const Component = slot;
    return /* @__PURE__ */ jsxRuntime.jsx(Component, {
      ...props
    });
  }
  return slot;
}
const ToolbarButton = react.forwardRef(
  ({ icon, children, name, shortcut, onKeyDown, ...props }, forwardedRef) => {
    const floatingToolbarContext = react.useContext(shared.FloatingToolbarContext);
    const closeFloatingToolbar = floatingToolbarContext?.close;
    const handleKeyDown = react.useCallback(
      (event) => {
        onKeyDown?.(event);
        if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
          closeFloatingToolbar();
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [onKeyDown, closeFloatingToolbar]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(_private.ShortcutTooltip, {
      content: name,
      shortcut,
      children: /* @__PURE__ */ jsxRuntime.jsx(_private.Button, {
        type: "button",
        variant: "toolbar",
        ref: forwardedRef,
        icon,
        "aria-label": !children ? name : void 0,
        tabIndex: 0,
        ...props,
        onKeyDown: handleKeyDown,
        children: !children && !icon ? name : children
      })
    });
  }
);
const ToolbarToggle = react.forwardRef(
  ({ active, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntime.jsx(TogglePrimitive__namespace.Root, {
      asChild: true,
      pressed: active,
      children: /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
        ref: forwardedRef,
        ...props
      })
    });
  }
);
function createDefaultBlockSelectorItems(editor) {
  const items = [
    {
      name: "Text",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.TextIcon, {}),
      isActive: "default",
      setActive: (editor2) => editor2.chain().focus().clearNodes().run()
    },
    "toggleHeading" in editor.commands ? {
      name: "Heading 1",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.H1Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 1 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 1 }).run()
    } : null,
    "toggleHeading" in editor.commands ? {
      name: "Heading 2",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.H2Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 2 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 2 }).run()
    } : null,
    "toggleHeading" in editor.commands ? {
      name: "Heading 3",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.H3Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 3 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 3 }).run()
    } : null,
    "toggleBulletList" in editor.commands ? {
      name: "Bullet list",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.ListUnorderedIcon, {}),
      isActive: (editor2) => editor2.isActive("bulletList"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBulletList().run()
    } : null,
    "toggleOrderedList" in editor.commands ? {
      name: "Numbered list",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.ListOrderedIcon, {}),
      isActive: (editor2) => editor2.isActive("orderedList"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleOrderedList().run()
    } : null,
    "toggleBlockquote" in editor.commands ? {
      name: "Blockquote",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.BlockquoteIcon, {}),
      isActive: (editor2) => editor2.isActive("blockquote"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBlockquote().run()
    } : null
  ];
  return items.filter(Boolean);
}
const ToolbarBlockSelector = react.forwardRef(({ items, onKeyDown, ...props }, forwardedRef) => {
  const floatingToolbarContext = react.useContext(shared.FloatingToolbarContext);
  const closeFloatingToolbar = floatingToolbarContext?.close;
  const editor = context.useCurrentEditor(
    "BlockSelector",
    "Toolbar or FloatingToolbar"
  );
  const resolvedItems = react.useMemo(() => {
    if (Array.isArray(items)) {
      return items;
    }
    const defaultItems = createDefaultBlockSelectorItems(editor);
    return items ? items(defaultItems) : defaultItems;
  }, [editor, items]);
  let defaultItem;
  let activeItem = editor.isInitialized ? resolvedItems.find((item) => {
    if (item.isActive === "default") {
      defaultItem = item;
      return false;
    }
    return item.isActive(editor);
  }) : void 0;
  if (!activeItem) {
    activeItem = defaultItem;
  }
  const handleItemChange = (name) => {
    const item = resolvedItems.find((item2) => item2.name === name);
    if (item) {
      item.setActive(editor);
      floatingToolbarContext?.close();
    }
  };
  const handleKeyDown = react.useCallback(
    (event) => {
      onKeyDown?.(event);
      if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
        closeFloatingToolbar();
        event.preventDefault();
        event.stopPropagation();
      }
    },
    [onKeyDown, closeFloatingToolbar]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(SelectPrimitive__namespace.Root, {
    value: activeItem?.name,
    onValueChange: handleItemChange,
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(_private.ShortcutTooltip, {
        content: "Turn into\u2026",
        children: /* @__PURE__ */ jsxRuntime.jsx(SelectPrimitive__namespace.Trigger, {
          asChild: true,
          ...props,
          ref: forwardedRef,
          onKeyDown: handleKeyDown,
          disabled: resolvedItems.length === 0,
          children: /* @__PURE__ */ jsxRuntime.jsx(_private.SelectButton, {
            variant: "toolbar",
            children: activeItem?.name ?? "Turn into\u2026"
          })
        })
      }),
      /* @__PURE__ */ jsxRuntime.jsx(SelectPrimitive__namespace.Portal, {
        children: /* @__PURE__ */ jsxRuntime.jsx(shared.FloatingToolbarExternal, {
          children: /* @__PURE__ */ jsxRuntime.jsx(SelectPrimitive__namespace.Content, {
            position: "popper",
            sideOffset: BLOCK_SELECT_SIDE_OFFSET,
            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,
            className: "lb-root lb-portal lb-elevation lb-dropdown lb-select-dropdown lb-tiptap-block-selector-dropdown",
            children: resolvedItems.map((item) => /* @__PURE__ */ jsxRuntime.jsxs(SelectPrimitive__namespace.Item, {
              value: item.name,
              className: "lb-dropdown-item",
              "data-name": item.name,
              children: [
                item.icon ? /* @__PURE__ */ jsxRuntime.jsx("span", {
                  className: "lb-dropdown-item-icon lb-icon-container",
                  children: item.icon
                }) : null,
                /* @__PURE__ */ jsxRuntime.jsx("span", {
                  className: "lb-dropdown-item-label",
                  children: item.label ?? item.name
                }),
                item.name === activeItem?.name ? /* @__PURE__ */ jsxRuntime.jsx("span", {
                  className: "lb-dropdown-item-accessory lb-icon-container",
                  children: /* @__PURE__ */ jsxRuntime.jsx(_private.CheckIcon, {})
                }) : null
              ]
            }, item.name))
          })
        })
      })
    ]
  });
});
const ToolbarSeparator = react.forwardRef(
  ({ className, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntime.jsx("div", {
      ref: forwardedRef,
      role: "separator",
      "aria-orientation": "vertical",
      className: _private.cn("lb-tiptap-toolbar-separator", className),
      ...props
    });
  }
);
function ToolbarSectionHistory() {
  const editor = context.useCurrentEditor(
    "SectionHistory",
    "Toolbar or FloatingToolbar"
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
        name: "Undo",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.UndoIcon, {}),
        shortcut: "Mod-Z",
        onClick: () => editor.chain().focus().undo().run(),
        disabled: !editor.can().chain().focus().undo().run()
      }),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
        name: "Redo",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.RedoIcon, {}),
        shortcut: "Mod-Shift-Z",
        onClick: () => editor.chain().focus().redo().run(),
        disabled: !editor.can().chain().focus().redo().run()
      })
    ]
  });
}
function ToolbarSectionInline() {
  const editor = context.useCurrentEditor(
    "SectionInline",
    "Toolbar or FloatingToolbar"
  );
  const supportsBold = "toggleBold" in editor.commands;
  const supportsItalic = "toggleItalic" in editor.commands;
  const supportsUnderline = "toggleUnderline" in editor.commands;
  const supportsStrike = "toggleStrike" in editor.commands;
  const supportsCode = "toggleCode" in editor.commands;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      supportsBold && /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Bold",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.BoldIcon, {}),
        shortcut: "Mod-B",
        onClick: () => editor.chain().focus().toggleBold().run(),
        disabled: !editor.can().chain().focus().toggleBold().run(),
        active: editor.isActive("bold")
      }),
      supportsItalic && /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Italic",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.ItalicIcon, {}),
        shortcut: "Mod-I",
        onClick: () => editor.chain().focus().toggleItalic().run(),
        disabled: !editor.can().chain().focus().toggleItalic().run(),
        active: editor.isActive("italic")
      }),
      supportsUnderline && /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Underline",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.UnderlineIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.chain().focus().toggleUnderline().run(),
        disabled: !editor.can().chain().focus().toggleUnderline().run(),
        active: editor.isActive("underline")
      }),
      supportsStrike && /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Strikethrough",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.StrikethroughIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.chain().focus().toggleStrike().run(),
        disabled: !editor.can().chain().focus().toggleStrike().run(),
        active: editor.isActive("strike")
      }),
      supportsCode && /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Inline code",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.CodeIcon, {}),
        shortcut: "Mod-E",
        onClick: () => editor.chain().focus().toggleCode().run(),
        disabled: !editor.can().chain().focus().toggleCode().run(),
        active: editor.isActive("code")
      })
    ]
  });
}
function ToolbarSectionCollaboration() {
  const editor = context.useCurrentEditor(
    "SectionCollaboration",
    "Toolbar or FloatingToolbar"
  );
  const supportsThread = "addPendingComment" in editor.commands;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: supportsThread && /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
      name: "Add a comment",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.CommentIcon, {}),
      onClick: () => editor.chain().focus().addPendingComment().run(),
      children: "Comment"
    })
  });
}
function ToolbarSectionAi() {
  const editor = context.useCurrentEditor("SectionAi", "Toolbar or FloatingToolbar");
  const supportsAi = "askAi" in editor.commands;
  const aiName = editor.storage.liveblocksAi?.name;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: supportsAi && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ToolbarButton, {
          name: `Ask ${aiName} anything\u2026`,
          icon: /* @__PURE__ */ jsxRuntime.jsx(_private.SparklesIcon, {}),
          onClick: () => editor.chain().focus().askAi(),
          children: [
            "Ask ",
            aiName
          ]
        }),
        /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
          name: "Explain",
          icon: /* @__PURE__ */ jsxRuntime.jsx(_private.QuestionMarkIcon, {}),
          onClick: () => editor.chain().focus().askAi("Explain what the text is about"),
          children: "Explain"
        })
      ]
    })
  });
}
function DefaultToolbarContent({ editor }) {
  const supportsThread = "addPendingComment" in editor.commands;
  const supportsAi = "askAi" in editor.commands;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarSectionHistory, {}),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarSeparator, {}),
      supportsAi ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSectionAi, {}),
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSeparator, {})
        ]
      }) : null,
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarBlockSelector, {}),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarSectionInline, {}),
      supportsThread ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSeparator, {}),
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
const Toolbar = Object.assign(
  react.forwardRef(
    ({
      before,
      after,
      children = DefaultToolbarContent,
      editor,
      className,
      ...props
    }, forwardedRef) => {
      if (!editor) {
        return null;
      }
      const slotProps = { editor };
      return /* @__PURE__ */ jsxRuntime.jsx(_private.TooltipProvider, {
        children: /* @__PURE__ */ jsxRuntime.jsx(context.EditorProvider, {
          editor,
          children: /* @__PURE__ */ jsxRuntime.jsxs("div", {
            ref: forwardedRef,
            role: "toolbar",
            "aria-label": "Toolbar",
            "aria-orientation": "horizontal",
            className: _private.cn("lb-root lb-tiptap-toolbar", className),
            ...props,
            children: [
              applyToolbarSlot(before, slotProps),
              applyToolbarSlot(children, slotProps),
              applyToolbarSlot(after, slotProps)
            ]
          })
        })
      });
    }
  ),
  {
    Button: ToolbarButton,
    Toggle: ToolbarToggle,
    BlockSelector: ToolbarBlockSelector,
    Separator: ToolbarSeparator,
    SectionHistory: ToolbarSectionHistory,
    SectionInline: ToolbarSectionInline,
    SectionCollaboration: ToolbarSectionCollaboration,
    SectionAi: ToolbarSectionAi
  }
);

exports.BLOCK_SELECT_SIDE_OFFSET = BLOCK_SELECT_SIDE_OFFSET;
exports.FLOATING_ELEMENT_COLLISION_PADDING = FLOATING_ELEMENT_COLLISION_PADDING;
exports.Toolbar = Toolbar;
exports.applyToolbarSlot = applyToolbarSlot;
//# sourceMappingURL=Toolbar.cjs.map
