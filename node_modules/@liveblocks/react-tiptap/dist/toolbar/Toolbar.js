import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { ShortcutTooltip, Button, TextIcon, H1Icon, H2Icon, H3Icon, ListUnorderedIcon, ListOrderedIcon, BlockquoteIcon, SelectButton, CheckIcon, cn, UndoIcon, RedoIcon, BoldIcon, ItalicIcon, UnderlineIcon, StrikethroughIcon, CodeIcon, CommentIcon, SparklesIcon, QuestionMarkIcon, TooltipProvider } from '@liveblocks/react-ui/_private';
import * as SelectPrimitive from '@radix-ui/react-select';
import * as TogglePrimitive from '@radix-ui/react-toggle';
import { forwardRef, useContext, useCallback, useMemo } from 'react';
import { useCurrentEditor, EditorProvider } from '../context.js';
import { FloatingToolbarContext, FloatingToolbarExternal } from './shared.js';

const BLOCK_SELECT_SIDE_OFFSET = 10;
const FLOATING_ELEMENT_COLLISION_PADDING = 10;
function applyToolbarSlot(slot, props) {
  if (typeof slot === "function") {
    const Component = slot;
    return /* @__PURE__ */ jsx(Component, {
      ...props
    });
  }
  return slot;
}
const ToolbarButton = forwardRef(
  ({ icon, children, name, shortcut, onKeyDown, ...props }, forwardedRef) => {
    const floatingToolbarContext = useContext(FloatingToolbarContext);
    const closeFloatingToolbar = floatingToolbarContext?.close;
    const handleKeyDown = useCallback(
      (event) => {
        onKeyDown?.(event);
        if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
          closeFloatingToolbar();
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [onKeyDown, closeFloatingToolbar]
    );
    return /* @__PURE__ */ jsx(ShortcutTooltip, {
      content: name,
      shortcut,
      children: /* @__PURE__ */ jsx(Button, {
        type: "button",
        variant: "toolbar",
        ref: forwardedRef,
        icon,
        "aria-label": !children ? name : void 0,
        tabIndex: 0,
        ...props,
        onKeyDown: handleKeyDown,
        children: !children && !icon ? name : children
      })
    });
  }
);
const ToolbarToggle = forwardRef(
  ({ active, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsx(TogglePrimitive.Root, {
      asChild: true,
      pressed: active,
      children: /* @__PURE__ */ jsx(ToolbarButton, {
        ref: forwardedRef,
        ...props
      })
    });
  }
);
function createDefaultBlockSelectorItems(editor) {
  const items = [
    {
      name: "Text",
      icon: /* @__PURE__ */ jsx(TextIcon, {}),
      isActive: "default",
      setActive: (editor2) => editor2.chain().focus().clearNodes().run()
    },
    "toggleHeading" in editor.commands ? {
      name: "Heading 1",
      icon: /* @__PURE__ */ jsx(H1Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 1 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 1 }).run()
    } : null,
    "toggleHeading" in editor.commands ? {
      name: "Heading 2",
      icon: /* @__PURE__ */ jsx(H2Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 2 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 2 }).run()
    } : null,
    "toggleHeading" in editor.commands ? {
      name: "Heading 3",
      icon: /* @__PURE__ */ jsx(H3Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 3 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 3 }).run()
    } : null,
    "toggleBulletList" in editor.commands ? {
      name: "Bullet list",
      icon: /* @__PURE__ */ jsx(ListUnorderedIcon, {}),
      isActive: (editor2) => editor2.isActive("bulletList"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBulletList().run()
    } : null,
    "toggleOrderedList" in editor.commands ? {
      name: "Numbered list",
      icon: /* @__PURE__ */ jsx(ListOrderedIcon, {}),
      isActive: (editor2) => editor2.isActive("orderedList"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleOrderedList().run()
    } : null,
    "toggleBlockquote" in editor.commands ? {
      name: "Blockquote",
      icon: /* @__PURE__ */ jsx(BlockquoteIcon, {}),
      isActive: (editor2) => editor2.isActive("blockquote"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBlockquote().run()
    } : null
  ];
  return items.filter(Boolean);
}
const ToolbarBlockSelector = forwardRef(({ items, onKeyDown, ...props }, forwardedRef) => {
  const floatingToolbarContext = useContext(FloatingToolbarContext);
  const closeFloatingToolbar = floatingToolbarContext?.close;
  const editor = useCurrentEditor(
    "BlockSelector",
    "Toolbar or FloatingToolbar"
  );
  const resolvedItems = useMemo(() => {
    if (Array.isArray(items)) {
      return items;
    }
    const defaultItems = createDefaultBlockSelectorItems(editor);
    return items ? items(defaultItems) : defaultItems;
  }, [editor, items]);
  let defaultItem;
  let activeItem = editor.isInitialized ? resolvedItems.find((item) => {
    if (item.isActive === "default") {
      defaultItem = item;
      return false;
    }
    return item.isActive(editor);
  }) : void 0;
  if (!activeItem) {
    activeItem = defaultItem;
  }
  const handleItemChange = (name) => {
    const item = resolvedItems.find((item2) => item2.name === name);
    if (item) {
      item.setActive(editor);
      floatingToolbarContext?.close();
    }
  };
  const handleKeyDown = useCallback(
    (event) => {
      onKeyDown?.(event);
      if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
        closeFloatingToolbar();
        event.preventDefault();
        event.stopPropagation();
      }
    },
    [onKeyDown, closeFloatingToolbar]
  );
  return /* @__PURE__ */ jsxs(SelectPrimitive.Root, {
    value: activeItem?.name,
    onValueChange: handleItemChange,
    children: [
      /* @__PURE__ */ jsx(ShortcutTooltip, {
        content: "Turn into\u2026",
        children: /* @__PURE__ */ jsx(SelectPrimitive.Trigger, {
          asChild: true,
          ...props,
          ref: forwardedRef,
          onKeyDown: handleKeyDown,
          disabled: resolvedItems.length === 0,
          children: /* @__PURE__ */ jsx(SelectButton, {
            variant: "toolbar",
            children: activeItem?.name ?? "Turn into\u2026"
          })
        })
      }),
      /* @__PURE__ */ jsx(SelectPrimitive.Portal, {
        children: /* @__PURE__ */ jsx(FloatingToolbarExternal, {
          children: /* @__PURE__ */ jsx(SelectPrimitive.Content, {
            position: "popper",
            sideOffset: BLOCK_SELECT_SIDE_OFFSET,
            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,
            className: "lb-root lb-portal lb-elevation lb-dropdown lb-select-dropdown lb-tiptap-block-selector-dropdown",
            children: resolvedItems.map((item) => /* @__PURE__ */ jsxs(SelectPrimitive.Item, {
              value: item.name,
              className: "lb-dropdown-item",
              "data-name": item.name,
              children: [
                item.icon ? /* @__PURE__ */ jsx("span", {
                  className: "lb-dropdown-item-icon lb-icon-container",
                  children: item.icon
                }) : null,
                /* @__PURE__ */ jsx("span", {
                  className: "lb-dropdown-item-label",
                  children: item.label ?? item.name
                }),
                item.name === activeItem?.name ? /* @__PURE__ */ jsx("span", {
                  className: "lb-dropdown-item-accessory lb-icon-container",
                  children: /* @__PURE__ */ jsx(CheckIcon, {})
                }) : null
              ]
            }, item.name))
          })
        })
      })
    ]
  });
});
const ToolbarSeparator = forwardRef(
  ({ className, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsx("div", {
      ref: forwardedRef,
      role: "separator",
      "aria-orientation": "vertical",
      className: cn("lb-tiptap-toolbar-separator", className),
      ...props
    });
  }
);
function ToolbarSectionHistory() {
  const editor = useCurrentEditor(
    "SectionHistory",
    "Toolbar or FloatingToolbar"
  );
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx(ToolbarButton, {
        name: "Undo",
        icon: /* @__PURE__ */ jsx(UndoIcon, {}),
        shortcut: "Mod-Z",
        onClick: () => editor.chain().focus().undo().run(),
        disabled: !editor.can().chain().focus().undo().run()
      }),
      /* @__PURE__ */ jsx(ToolbarButton, {
        name: "Redo",
        icon: /* @__PURE__ */ jsx(RedoIcon, {}),
        shortcut: "Mod-Shift-Z",
        onClick: () => editor.chain().focus().redo().run(),
        disabled: !editor.can().chain().focus().redo().run()
      })
    ]
  });
}
function ToolbarSectionInline() {
  const editor = useCurrentEditor(
    "SectionInline",
    "Toolbar or FloatingToolbar"
  );
  const supportsBold = "toggleBold" in editor.commands;
  const supportsItalic = "toggleItalic" in editor.commands;
  const supportsUnderline = "toggleUnderline" in editor.commands;
  const supportsStrike = "toggleStrike" in editor.commands;
  const supportsCode = "toggleCode" in editor.commands;
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      supportsBold && /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Bold",
        icon: /* @__PURE__ */ jsx(BoldIcon, {}),
        shortcut: "Mod-B",
        onClick: () => editor.chain().focus().toggleBold().run(),
        disabled: !editor.can().chain().focus().toggleBold().run(),
        active: editor.isActive("bold")
      }),
      supportsItalic && /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Italic",
        icon: /* @__PURE__ */ jsx(ItalicIcon, {}),
        shortcut: "Mod-I",
        onClick: () => editor.chain().focus().toggleItalic().run(),
        disabled: !editor.can().chain().focus().toggleItalic().run(),
        active: editor.isActive("italic")
      }),
      supportsUnderline && /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Underline",
        icon: /* @__PURE__ */ jsx(UnderlineIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.chain().focus().toggleUnderline().run(),
        disabled: !editor.can().chain().focus().toggleUnderline().run(),
        active: editor.isActive("underline")
      }),
      supportsStrike && /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Strikethrough",
        icon: /* @__PURE__ */ jsx(StrikethroughIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.chain().focus().toggleStrike().run(),
        disabled: !editor.can().chain().focus().toggleStrike().run(),
        active: editor.isActive("strike")
      }),
      supportsCode && /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Inline code",
        icon: /* @__PURE__ */ jsx(CodeIcon, {}),
        shortcut: "Mod-E",
        onClick: () => editor.chain().focus().toggleCode().run(),
        disabled: !editor.can().chain().focus().toggleCode().run(),
        active: editor.isActive("code")
      })
    ]
  });
}
function ToolbarSectionCollaboration() {
  const editor = useCurrentEditor(
    "SectionCollaboration",
    "Toolbar or FloatingToolbar"
  );
  const supportsThread = "addPendingComment" in editor.commands;
  return /* @__PURE__ */ jsx(Fragment, {
    children: supportsThread && /* @__PURE__ */ jsx(ToolbarButton, {
      name: "Add a comment",
      icon: /* @__PURE__ */ jsx(CommentIcon, {}),
      onClick: () => editor.chain().focus().addPendingComment().run(),
      children: "Comment"
    })
  });
}
function ToolbarSectionAi() {
  const editor = useCurrentEditor("SectionAi", "Toolbar or FloatingToolbar");
  const supportsAi = "askAi" in editor.commands;
  const aiName = editor.storage.liveblocksAi?.name;
  return /* @__PURE__ */ jsx(Fragment, {
    children: supportsAi && /* @__PURE__ */ jsxs(Fragment, {
      children: [
        /* @__PURE__ */ jsxs(ToolbarButton, {
          name: `Ask ${aiName} anything\u2026`,
          icon: /* @__PURE__ */ jsx(SparklesIcon, {}),
          onClick: () => editor.chain().focus().askAi(),
          children: [
            "Ask ",
            aiName
          ]
        }),
        /* @__PURE__ */ jsx(ToolbarButton, {
          name: "Explain",
          icon: /* @__PURE__ */ jsx(QuestionMarkIcon, {}),
          onClick: () => editor.chain().focus().askAi("Explain what the text is about"),
          children: "Explain"
        })
      ]
    })
  });
}
function DefaultToolbarContent({ editor }) {
  const supportsThread = "addPendingComment" in editor.commands;
  const supportsAi = "askAi" in editor.commands;
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx(ToolbarSectionHistory, {}),
      /* @__PURE__ */ jsx(ToolbarSeparator, {}),
      supportsAi ? /* @__PURE__ */ jsxs(Fragment, {
        children: [
          /* @__PURE__ */ jsx(ToolbarSectionAi, {}),
          /* @__PURE__ */ jsx(ToolbarSeparator, {})
        ]
      }) : null,
      /* @__PURE__ */ jsx(ToolbarBlockSelector, {}),
      /* @__PURE__ */ jsx(ToolbarSectionInline, {}),
      supportsThread ? /* @__PURE__ */ jsxs(Fragment, {
        children: [
          /* @__PURE__ */ jsx(ToolbarSeparator, {}),
          /* @__PURE__ */ jsx(ToolbarSectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
const Toolbar = Object.assign(
  forwardRef(
    ({
      before,
      after,
      children = DefaultToolbarContent,
      editor,
      className,
      ...props
    }, forwardedRef) => {
      if (!editor) {
        return null;
      }
      const slotProps = { editor };
      return /* @__PURE__ */ jsx(TooltipProvider, {
        children: /* @__PURE__ */ jsx(EditorProvider, {
          editor,
          children: /* @__PURE__ */ jsxs("div", {
            ref: forwardedRef,
            role: "toolbar",
            "aria-label": "Toolbar",
            "aria-orientation": "horizontal",
            className: cn("lb-root lb-tiptap-toolbar", className),
            ...props,
            children: [
              applyToolbarSlot(before, slotProps),
              applyToolbarSlot(children, slotProps),
              applyToolbarSlot(after, slotProps)
            ]
          })
        })
      });
    }
  ),
  {
    Button: ToolbarButton,
    Toggle: ToolbarToggle,
    BlockSelector: ToolbarBlockSelector,
    Separator: ToolbarSeparator,
    SectionHistory: ToolbarSectionHistory,
    SectionInline: ToolbarSectionInline,
    SectionCollaboration: ToolbarSectionCollaboration,
    SectionAi: ToolbarSectionAi
  }
);

export { BLOCK_SELECT_SIDE_OFFSET, FLOATING_ELEMENT_COLLISION_PADDING, Toolbar, applyToolbarSlot };
//# sourceMappingURL=Toolbar.js.map
