import {
  DefaultMap,
  DerivedSignal,
  HttpError,
  MutableSignal,
  ServerMsgCode,
  Signal,
  SortedList,
  assert,
  assertNever,
  autoRetry,
  batch,
  compactObject,
  createClient,
  createCommentId,
  createNotificationSettings,
  createThreadId,
  detectDupes,
  errorIf,
  fancy_console_exports,
  getSubscriptionKey,
  isStartsWithOperator,
  kInternal,
  makePoller,
  nanoid,
  nn,
  patchNotificationSettings,
  raise,
  shallow,
  shallow2,
  stableStringify
} from "./chunk-NT76HTXR.js";
import {
  require_jsx_runtime
} from "./chunk-CRNJR6QK.js";
import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/@liveblocks/react/dist/chunk-W466HEJW.js
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "3.7.1";
var PKG_FORMAT = "esm";
function ClientSideSuspense(props) {
  const [mounted, setMounted] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    setMounted(true);
  }, []);
  return (0, import_jsx_runtime.jsx)(import_react.Suspense, { fallback: props.fallback, children: mounted ? typeof props.children === "function" ? props.children() : props.children : props.fallback });
}

// node_modules/@liveblocks/react/dist/chunk-OKYUUXNY.js
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var React = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var ClientContext = (0, import_react2.createContext)(null);
function useClientOrNull() {
  return (0, import_react2.useContext)(ClientContext);
}
function useClient() {
  return useClientOrNull() ?? raise("LiveblocksProvider is missing from the React tree.");
}
var RoomContext = (0, import_react2.createContext)(null);
function useRoomOrNull() {
  return (0, import_react2.useContext)(RoomContext);
}
function useIsInsideRoom() {
  const room = useRoomOrNull();
  return room !== null;
}
function useLatest(value) {
  const ref = (0, import_react3.useRef)(value);
  (0, import_react3.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref;
}
function useAi() {
  return useClient()[kInternal].ai;
}
function useRandom() {
  return (0, import_react4.useState)(nanoid)[0];
}
var RegisterAiKnowledge = (0, import_react4.memo)(function RegisterAiKnowledge2(props) {
  const layerId = (0, import_react4.useId)();
  const ai = useAi();
  const { description, value } = props;
  const [layerKey, setLayerKey] = (0, import_react4.useState)();
  (0, import_react4.useEffect)(() => {
    const layerKey2 = ai.registerKnowledgeLayer(layerId);
    setLayerKey(layerKey2);
    return () => {
      ai.deregisterKnowledgeLayer(layerKey2);
      setLayerKey(void 0);
    };
  }, [ai, layerId]);
  const randomKey = useRandom();
  const knowledgeKey = props.id ?? randomKey;
  (0, import_react4.useEffect)(() => {
    if (layerKey !== void 0) {
      ai.updateKnowledge(layerKey, { description, value }, knowledgeKey);
    }
  }, [ai, layerKey, knowledgeKey, description, value]);
  return null;
});
var RegisterAiTool = (0, import_react4.memo)(function RegisterAiTool2({
  chatId,
  name,
  tool,
  enabled
}) {
  const client = useClient();
  const ai = client[kInternal].ai;
  (0, import_react4.useEffect)(() => {
    const toolWithEnabled = enabled !== void 0 ? { ...tool, enabled } : tool;
    return ai.registerTool(name, toolWithEnabled, chatId);
  }, [ai, chatId, name, tool, enabled]);
  return null;
});
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
  const instRef = (0, import_react5.useRef)(null);
  let inst;
  if (instRef.current === null) {
    inst = {
      hasValue: false,
      value: null
    };
    instRef.current = inst;
  } else {
    inst = instRef.current;
  }
  const [getSelection, getServerSelection] = (0, import_react5.useMemo)(() => {
    let hasMemo = false;
    let memoizedSnapshot;
    let memoizedSelection;
    const memoizedSelector = (nextSnapshot) => {
      if (!hasMemo) {
        hasMemo = true;
        memoizedSnapshot = nextSnapshot;
        const nextSelection2 = selector(nextSnapshot);
        if (isEqual !== void 0) {
          if (inst.hasValue) {
            const currentSelection = inst.value;
            if (isEqual(currentSelection, nextSelection2)) {
              memoizedSelection = currentSelection;
              return currentSelection;
            }
          }
        }
        memoizedSelection = nextSelection2;
        return nextSelection2;
      }
      const prevSnapshot = memoizedSnapshot;
      const prevSelection = memoizedSelection;
      if (is(prevSnapshot, nextSnapshot)) {
        return prevSelection;
      }
      const nextSelection = selector(nextSnapshot);
      if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
        memoizedSnapshot = nextSnapshot;
        return prevSelection;
      }
      memoizedSnapshot = nextSnapshot;
      memoizedSelection = nextSelection;
      return nextSelection;
    };
    const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());
    const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : () => memoizedSelector(maybeGetServerSnapshot());
    return [getSnapshotWithSelector, getServerSnapshotWithSelector];
  }, [getSnapshot, getServerSnapshot, selector, isEqual]);
  const value = (0, import_react5.useSyncExternalStore)(
    subscribe,
    getSelection,
    getServerSelection
  );
  (0, import_react5.useEffect)(() => {
    inst.hasValue = true;
    inst.value = value;
  }, [value]);
  (0, import_react5.useDebugValue)(value);
  return value;
}
var identity = (value) => value;
function useSignal(signal, selector, isEqual) {
  if (signal instanceof MutableSignal) {
    throw new Error(
      "Using a mutable Signal with useSignal will likely not work as expected."
    );
  }
  return useSyncExternalStoreWithSelector(
    signal.subscribe,
    signal.get,
    signal.get,
    selector ?? identity,
    isEqual
  );
}
var SECONDS = 1e3;
var MINUTES = 60 * SECONDS;
var config = {
  SMOOTH_DELAY: 1 * SECONDS,
  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,
  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,
  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,
  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,
  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,
  USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,
  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,
  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,
  ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,
  ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,
  USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,
  USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES
};
var ASYNC_LOADING = Object.freeze({ isLoading: true });
var ASYNC_ERR = (error) => Object.freeze({ isLoading: false, error });
function ASYNC_OK(fieldOrData, data) {
  if (arguments.length === 1) {
    return Object.freeze({ isLoading: false, data: fieldOrData });
  } else {
    return Object.freeze({ isLoading: false, [fieldOrData]: data });
  }
}
function find(it, predicate) {
  for (const item of it) {
    if (predicate(item)) return item;
  }
  return void 0;
}
function count(it, predicate) {
  let total = 0;
  for (const item of it) {
    if (predicate(item)) total++;
  }
  return total;
}
function ensureNotServerSide() {
  if (typeof window === "undefined") {
    throw new Error(
      "You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense"
    );
  }
}
function useInitial(value, roomId) {
  return (0, import_react7.useMemo)(() => value, [roomId]);
}
function useInitialUnlessFunction(latestValue, roomId) {
  const frozenValue = useInitial(latestValue, roomId);
  const ref = useLatest(latestValue);
  const wrapper = (0, import_react7.useCallback)(
    (...args) => ref.current(...args),
    [ref]
  );
  if (typeof frozenValue === "function") {
    return wrapper;
  } else {
    return frozenValue;
  }
}
var reactUse = React[" use ".trim().toString()];
var use = reactUse ?? ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    promise.status = "pending";
    promise.then(
      (v) => {
        promise.status = "fulfilled";
        promise.value = v;
      },
      (e) => {
        promise.status = "rejected";
        promise.reason = e;
      }
    );
    throw promise;
  }
});
function autobind(self) {
  const seen = /* @__PURE__ */ new Set();
  seen.add("constructor");
  let obj = self.constructor.prototype;
  do {
    for (const key of Reflect.ownKeys(obj)) {
      if (seen.has(key)) continue;
      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
      if (typeof (descriptor == null ? void 0 : descriptor.value) === "function") {
        seen.add(key);
        self[key] = self[key].bind(self);
      }
    }
  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);
}
function makeThreadsFilter(query) {
  return (thread) => matchesThreadsQuery(thread, query) && matchesMetadata(thread, query);
}
function matchesThreadsQuery(thread, q) {
  return q.resolved === void 0 || thread.resolved === q.resolved;
}
function matchesMetadata(thread, q) {
  const metadata = thread.metadata;
  return q.metadata === void 0 || Object.entries(q.metadata).every(
    ([key, op]) => (
      // Ignore explicit-undefined filters
      // Boolean logic: op? => value matches the operator
      op === void 0 || matchesOperator(metadata[key], op)
    )
  );
}
function matchesOperator(value, op) {
  if (op === null) {
    return value === void 0;
  } else if (isStartsWithOperator(op)) {
    return typeof value === "string" && value.startsWith(op.startsWith);
  } else {
    return value === op;
  }
}
function makeInboxNotificationsFilter(query) {
  return (inboxNotification) => matchesInboxNotificationsQuery(inboxNotification, query);
}
function matchesInboxNotificationsQuery(inboxNotification, q) {
  return (q.roomId === void 0 || q.roomId === inboxNotification.roomId) && (q.kind === void 0 || q.kind === inboxNotification.kind);
}
function sanitizeThread(thread) {
  if (thread.deletedAt) {
    if (thread.comments.length > 0) {
      return { ...thread, comments: [] };
    }
  }
  const hasComment = thread.comments.some((c) => !c.deletedAt);
  if (!hasComment) {
    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };
  }
  return thread;
}
var _byId, _asc, _desc, _a;
var ThreadDB = (_a = class {
  constructor() {
    __privateAdd(this, _byId);
    __privateAdd(this, _asc);
    __privateAdd(this, _desc);
    // This signal will be notified on every mutation
    __publicField(this, "signal");
    __privateSet(this, _asc, SortedList.from([], (t1, t2) => {
      const d1 = t1.createdAt;
      const d2 = t2.createdAt;
      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;
    }));
    __privateSet(this, _desc, SortedList.from([], (t1, t2) => {
      const d2 = t2.updatedAt;
      const d1 = t1.updatedAt;
      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;
    }));
    __privateSet(this, _byId, /* @__PURE__ */ new Map());
    this.signal = new MutableSignal(this);
  }
  //
  // Public APIs
  //
  clone() {
    const newPool = new _a();
    __privateSet(newPool, _byId, new Map(__privateGet(this, _byId)));
    __privateSet(newPool, _asc, __privateGet(this, _asc).clone());
    __privateSet(newPool, _desc, __privateGet(this, _desc).clone());
    return newPool;
  }
  /** Returns an existing thread by ID. Will never return a deleted thread. */
  get(threadId) {
    const thread = this.getEvenIfDeleted(threadId);
    return (thread == null ? void 0 : thread.deletedAt) ? void 0 : thread;
  }
  /** Returns the (possibly deleted) thread by ID. */
  getEvenIfDeleted(threadId) {
    return __privateGet(this, _byId).get(threadId);
  }
  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */
  upsert(thread) {
    this.signal.mutate(() => {
      thread = sanitizeThread(thread);
      const id = thread.id;
      const toRemove = __privateGet(this, _byId).get(id);
      if (toRemove) {
        if (toRemove.deletedAt) return false;
        __privateGet(this, _asc).remove(toRemove);
        __privateGet(this, _desc).remove(toRemove);
      }
      if (!thread.deletedAt) {
        __privateGet(this, _asc).add(thread);
        __privateGet(this, _desc).add(thread);
      }
      __privateGet(this, _byId).set(id, thread);
      return true;
    });
  }
  /** Like .upsert(), except it won't update if a thread by this ID already exists. */
  // TODO Consider renaming this to just .upsert(). I'm not sure if we really
  // TODO need the raw .upsert(). Would be nice if this behavior was the default.
  upsertIfNewer(thread) {
    const existing = this.get(thread.id);
    if (!existing || thread.updatedAt >= existing.updatedAt) {
      this.upsert(thread);
    }
  }
  applyDelta(newThreads, deletedThreads) {
    batch(() => {
      for (const thread of newThreads) {
        this.upsertIfNewer(thread);
      }
      for (const { id, deletedAt } of deletedThreads) {
        const existing = this.getEvenIfDeleted(id);
        if (!existing) continue;
        this.delete(id, deletedAt);
      }
    });
  }
  /**
   * Marks a thread as deleted. It will no longer pop up in .findMany()
   * queries, but it can still be accessed via `.getEvenIfDeleted()`.
   */
  delete(threadId, deletedAt) {
    const existing = __privateGet(this, _byId).get(threadId);
    if (existing && !existing.deletedAt) {
      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });
    }
  }
  /**
   * Returns all threads matching a given roomId and query. If roomId is not
   * specified, it will return all threads matching the query, across all
   * rooms.
   *
   * Returns the results in the requested order. Please note:
   *   'asc'  means by createdAt ASC
   *   'desc' means by updatedAt DESC
   *
   * Will never return deleted threads in the result.
   */
  findMany(roomId, query, direction) {
    const index = direction === "desc" ? __privateGet(this, _desc) : __privateGet(this, _asc);
    const crit = [];
    if (roomId !== void 0) {
      crit.push((t) => t.roomId === roomId);
    }
    if (query !== void 0) {
      crit.push(makeThreadsFilter(query));
    }
    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));
  }
}, _byId = new WeakMap(), _asc = new WeakMap(), _desc = new WeakMap(), _a);
function makeRoomThreadsQueryKey(roomId, query) {
  return stableStringify([roomId, query ?? {}]);
}
function makeUserThreadsQueryKey(query) {
  return stableStringify(query ?? {});
}
function makeAiChatsQueryKey(query) {
  return stableStringify(query ?? {});
}
function makeInboxNotificationsQueryKey(query) {
  return stableStringify(query ?? {});
}
function usify(promise) {
  if ("status" in promise) {
    return promise;
  }
  const usable = promise;
  usable.status = "pending";
  usable.then(
    (value) => {
      usable.status = "fulfilled";
      usable.value = value;
    },
    (err) => {
      usable.status = "rejected";
      usable.reason = err;
    }
  );
  return usable;
}
var noop = Promise.resolve();
var _signal, _fetchPage, _pendingFetchMore, _PaginatedResource_instances, patch_fn, fetchMore_fn, _cachedPromise, _a2;
var PaginatedResource = (_a2 = class {
  constructor(fetchPage) {
    __privateAdd(this, _PaginatedResource_instances);
    __privateAdd(this, _signal);
    __publicField(this, "signal");
    __privateAdd(this, _fetchPage);
    __privateAdd(this, _pendingFetchMore);
    __privateAdd(this, _cachedPromise, null);
    __privateSet(this, _signal, new Signal(ASYNC_LOADING));
    __privateSet(this, _fetchPage, fetchPage);
    __privateSet(this, _pendingFetchMore, null);
    this.signal = __privateGet(this, _signal).asReadonly();
    autobind(this);
  }
  get() {
    return __privateGet(this, _signal).get();
  }
  fetchMore() {
    var _a5;
    const state = __privateGet(this, _signal).get();
    if (!((_a5 = state.data) == null ? void 0 : _a5.cursor)) return noop;
    if (!__privateGet(this, _pendingFetchMore)) {
      __privateSet(this, _pendingFetchMore, __privateMethod(this, _PaginatedResource_instances, fetchMore_fn).call(this).finally(() => {
        __privateSet(this, _pendingFetchMore, null);
      }));
    }
    return __privateGet(this, _pendingFetchMore);
  }
  waitUntilLoaded() {
    if (__privateGet(this, _cachedPromise)) {
      return __privateGet(this, _cachedPromise);
    }
    const initialPageFetch$ = autoRetry(
      () => __privateGet(this, _fetchPage).call(
        this,
        /* cursor */
        void 0
      ),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(initialPageFetch$);
    promise.then(
      (cursor) => {
        __privateGet(this, _signal).set(
          ASYNC_OK({
            cursor,
            hasFetchedAll: cursor === null,
            isFetchingMore: false,
            fetchMoreError: void 0,
            fetchMore: this.fetchMore
          })
        );
      },
      (err) => {
        __privateGet(this, _signal).set(ASYNC_ERR(err));
        setTimeout(() => {
          __privateSet(this, _cachedPromise, null);
          __privateGet(this, _signal).set(ASYNC_LOADING);
        }, 5e3);
      }
    );
    __privateSet(this, _cachedPromise, promise);
    return __privateGet(this, _cachedPromise);
  }
}, _signal = new WeakMap(), _fetchPage = new WeakMap(), _pendingFetchMore = new WeakMap(), _PaginatedResource_instances = new WeakSet(), patch_fn = function(patch) {
  const state = __privateGet(this, _signal).get();
  if (state.data === void 0) return;
  __privateGet(this, _signal).set(ASYNC_OK({ ...state.data, ...patch }));
}, fetchMore_fn = async function() {
  var _a5;
  const state = __privateGet(this, _signal).get();
  if (!((_a5 = state.data) == null ? void 0 : _a5.cursor) || state.data.isFetchingMore) {
    return;
  }
  __privateMethod(this, _PaginatedResource_instances, patch_fn).call(this, { isFetchingMore: true });
  try {
    const nextCursor = await __privateGet(this, _fetchPage).call(this, state.data.cursor);
    __privateMethod(this, _PaginatedResource_instances, patch_fn).call(this, {
      cursor: nextCursor,
      hasFetchedAll: nextCursor === null,
      fetchMoreError: void 0,
      isFetchingMore: false
    });
  } catch (err) {
    __privateMethod(this, _PaginatedResource_instances, patch_fn).call(this, {
      isFetchingMore: false,
      fetchMoreError: err
    });
  }
}, _cachedPromise = new WeakMap(), _a2);
var _signal2, _fetchPage2, _cachedPromise2, _a3;
var SinglePageResource = (_a3 = class {
  constructor(fetchPage) {
    __privateAdd(this, _signal2);
    __publicField(this, "signal");
    __privateAdd(this, _fetchPage2);
    __privateAdd(this, _cachedPromise2, null);
    __privateSet(this, _signal2, new Signal(ASYNC_LOADING));
    this.signal = __privateGet(this, _signal2).asReadonly();
    __privateSet(this, _fetchPage2, fetchPage);
    autobind(this);
  }
  get() {
    return __privateGet(this, _signal2).get();
  }
  waitUntilLoaded() {
    if (__privateGet(this, _cachedPromise2)) {
      return __privateGet(this, _cachedPromise2);
    }
    const initialFetcher$ = autoRetry(
      () => __privateGet(this, _fetchPage2).call(this),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(initialFetcher$);
    promise.then(
      () => {
        __privateGet(this, _signal2).set(ASYNC_OK(void 0));
      },
      (err) => {
        __privateGet(this, _signal2).set(ASYNC_ERR(err));
        setTimeout(() => {
          __privateSet(this, _cachedPromise2, null);
          __privateGet(this, _signal2).set(ASYNC_LOADING);
        }, 5e3);
      }
    );
    __privateSet(this, _cachedPromise2, promise);
    return promise;
  }
}, _signal2 = new WeakMap(), _fetchPage2 = new WeakMap(), _cachedPromise2 = new WeakMap(), _a3);
function createStore_forNotifications() {
  const signal = new MutableSignal(/* @__PURE__ */ new Map());
  function markRead(notificationId, readAt) {
    signal.mutate((lut) => {
      const existing = lut.get(notificationId);
      if (!existing) {
        return false;
      }
      lut.set(notificationId, { ...existing, readAt });
      return true;
    });
  }
  function markAllRead(readAt) {
    signal.mutate((lut) => {
      for (const n of lut.values()) {
        n.readAt = readAt;
      }
    });
  }
  function deleteOne(inboxNotificationId) {
    signal.mutate((lut) => lut.delete(inboxNotificationId));
  }
  function clear() {
    signal.mutate((lut) => lut.clear());
  }
  function applyDelta(newNotifications, deletedNotifications) {
    signal.mutate((lut) => {
      let mutated = false;
      for (const n of newNotifications) {
        const existing = lut.get(n.id);
        if (existing) {
          const result = compareInboxNotifications(existing, n);
          if (result === 1) continue;
        }
        lut.set(n.id, n);
        mutated = true;
      }
      for (const n of deletedNotifications) {
        lut.delete(n.id);
        mutated = true;
      }
      return mutated;
    });
  }
  function updateAssociatedNotification(newComment) {
    signal.mutate((lut) => {
      const existing = find(
        lut.values(),
        (notification) => notification.kind === "thread" && notification.threadId === newComment.threadId
      );
      if (!existing) return false;
      lut.set(existing.id, {
        ...existing,
        notifiedAt: newComment.createdAt,
        readAt: newComment.createdAt
      });
      return true;
    });
  }
  function upsert(notification) {
    signal.mutate((lut) => {
      lut.set(notification.id, notification);
    });
  }
  return {
    signal: signal.asReadonly(),
    // Mutations
    markAllRead,
    markRead,
    delete: deleteOne,
    applyDelta,
    clear,
    updateAssociatedNotification,
    upsert
  };
}
function createStore_forSubscriptions(updates, threads) {
  const baseSignal = new MutableSignal(/* @__PURE__ */ new Map());
  function applyDelta(newSubscriptions, deletedSubscriptions) {
    baseSignal.mutate((lut) => {
      let mutated = false;
      for (const s of newSubscriptions) {
        lut.set(getSubscriptionKey(s), s);
        mutated = true;
      }
      for (const s of deletedSubscriptions) {
        lut.delete(getSubscriptionKey(s));
        mutated = true;
      }
      return mutated;
    });
  }
  function create(subscription) {
    baseSignal.mutate((lut) => {
      lut.set(getSubscriptionKey(subscription), subscription);
    });
  }
  function deleteOne(subscriptionKey) {
    baseSignal.mutate((lut) => {
      lut.delete(subscriptionKey);
    });
  }
  return {
    signal: DerivedSignal.from(
      baseSignal,
      updates,
      (base, updates2) => applyOptimisticUpdates_forSubscriptions(base, threads, updates2)
    ),
    // Mutations
    applyDelta,
    create,
    delete: deleteOne
  };
}
function createStore_forRoomSubscriptionSettings(updates) {
  const baseSignal = new MutableSignal(/* @__PURE__ */ new Map());
  function update(roomId, settings) {
    baseSignal.mutate((lut) => {
      lut.set(roomId, settings);
    });
  }
  return {
    signal: DerivedSignal.from(
      baseSignal,
      updates,
      (base, updates2) => applyOptimisticUpdates_forRoomSubscriptionSettings(base, updates2)
    ),
    // Mutations
    update
  };
}
function createStore_forHistoryVersions() {
  const baseSignal = new MutableSignal(
    new DefaultMap(() => /* @__PURE__ */ new Map())
  );
  function update(roomId, versions) {
    baseSignal.mutate((lut) => {
      const versionsById = lut.getOrCreate(roomId);
      for (const version of versions) {
        versionsById.set(version.id, version);
      }
    });
  }
  return {
    signal: DerivedSignal.from(
      baseSignal,
      (hv) => Object.fromEntries(
        [...hv].map(([roomId, versions]) => [
          roomId,
          Object.fromEntries(versions)
        ])
      )
    ),
    // Mutations
    update
  };
}
function createStore_forPermissionHints() {
  const permissionsByRoomId = new DefaultMap(
    () => new Signal(/* @__PURE__ */ new Set())
  );
  function update(newHints) {
    batch(() => {
      for (const [roomId, permissions] of Object.entries(newHints)) {
        const signal = permissionsByRoomId.getOrCreate(roomId);
        const existingPermissions = new Set(signal.get());
        for (const permission of permissions) {
          existingPermissions.add(permission);
        }
        signal.set(existingPermissions);
      }
    });
  }
  function getPermissionForRoomΣ(roomId) {
    return permissionsByRoomId.getOrCreate(roomId);
  }
  return {
    getPermissionForRoomΣ,
    // Mutations
    update
  };
}
function createStore_forNotificationSettings(updates) {
  const signal = new Signal(
    createNotificationSettings({})
  );
  function update(settings) {
    signal.set(settings);
  }
  return {
    signal: DerivedSignal.from(
      signal,
      updates,
      (base, updates2) => applyOptimisticUpdates_forNotificationSettings(base, updates2)
    ),
    // Mutations
    update
  };
}
function createStore_forOptimistic(client) {
  const signal = new Signal([]);
  const syncSource = client[kInternal].createSyncSource();
  signal.subscribe(
    () => syncSource.setSyncStatus(
      signal.get().length > 0 ? "synchronizing" : "synchronized"
    )
  );
  function add(optimisticUpdate) {
    const id = nanoid();
    const newUpdate = { ...optimisticUpdate, id };
    signal.set((state) => [...state, newUpdate]);
    return id;
  }
  function remove(optimisticId) {
    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));
  }
  return {
    signal: signal.asReadonly(),
    // Mutations
    add,
    remove
  };
}
var _client, _notificationsLastRequestedAt, _roomThreadsLastRequestedAtByRoom, _userThreadsLastRequestedAt, _roomVersionsLastRequestedAtByRoom, _notificationSettings, _UmbrellaStore_instances, updateThread_fn, _a4;
var UmbrellaStore = (_a4 = class {
  constructor(client) {
    __privateAdd(this, _UmbrellaStore_instances);
    __privateAdd(this, _client);
    //
    // Internally, the UmbrellaStore keeps track of a few source signals that can
    // be set and mutated individually. When any of those are mutated then the
    // clean "external state" is recomputed.
    //
    //   Mutate inputs...                                             ...observe clean/consistent output!
    //
    //            .-> Base ThreadDB ---------+                 +-------> Clean threads by ID         (Part 1)
    //           /                           |                 |
    //   mutate ----> Base Notifications --+ |                 | +-----> Clean notifications         (Part 1)
    //          \                          | |                 | |       & notifications by ID
    //         | \                         | |      Apply      | |
    //         |   `-> OptimisticUpdates --+--+--> Optimistic -+-+-+-+-> Subscriptions               (Part 2)
    //          \                          |        Updates    |   | |
    //           `------- etc etc ---------+                   |   | +-> History Versions            (Part 3)
    //                       ^                                 |   |
    //                       |                                 |   +---> Room Subscription Settings  (Part 4)
    //                       |                                 |
    //                       |                                 +-------> Notification Settings       (Part 5)
    //                       |
    //                       |
    //                       |                        ^                  ^
    //                    Signal                      |                  |
    //                      or                   DerivedSignal      DerivedSignals
    //                  MutableSignal
    //
    //
    // Input signals.
    // (Can be mutated directly.)
    //
    // XXX_vincent Now that we have createStore_forX, we should probably also change
    // `threads` to this pattern, ie create a createStore_forThreads helper as
    // well. It almost works like that already anyway!
    __publicField(this, "threads");
    // Exposes its signal under `.signal` prop
    __publicField(this, "notifications");
    __publicField(this, "subscriptions");
    __publicField(this, "roomSubscriptionSettings");
    // prettier-ignore
    __publicField(this, "historyVersions");
    __publicField(this, "permissionHints");
    __publicField(this, "notificationSettings");
    __publicField(this, "optimisticUpdates");
    //
    // Output signals.
    // (Readonly, clean, consistent. With optimistic updates applied.)
    //
    // Note that the output of threadifications signal is the same as the ones for
    // threads and notifications separately, but the threadifications signal will
    // be updated whenever either of them change.
    //
    __publicField(this, "outputs");
    // Notifications
    __privateAdd(this, _notificationsLastRequestedAt, null);
    // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.
    // Room Threads
    __privateAdd(this, _roomThreadsLastRequestedAtByRoom, /* @__PURE__ */ new Map());
    // User Threads
    __privateAdd(this, _userThreadsLastRequestedAt, null);
    // Room versions
    __privateAdd(this, _roomVersionsLastRequestedAtByRoom, /* @__PURE__ */ new Map());
    // Notification Settings
    __privateAdd(this, _notificationSettings);
    __privateSet(this, _client, client[kInternal].as());
    this.optimisticUpdates = createStore_forOptimistic(__privateGet(this, _client));
    this.permissionHints = createStore_forPermissionHints();
    const notificationSettingsFetcher = async () => {
      const result = await __privateGet(this, _client).getNotificationSettings();
      this.notificationSettings.update(result);
    };
    this.notificationSettings = createStore_forNotificationSettings(
      this.optimisticUpdates.signal
    );
    __privateSet(this, _notificationSettings, new SinglePageResource(
      notificationSettingsFetcher
    ));
    this.threads = new ThreadDB();
    this.subscriptions = createStore_forSubscriptions(
      this.optimisticUpdates.signal,
      this.threads
    );
    this.notifications = createStore_forNotifications();
    this.roomSubscriptionSettings = createStore_forRoomSubscriptionSettings(
      this.optimisticUpdates.signal
    );
    this.historyVersions = createStore_forHistoryVersions();
    const threadifications = DerivedSignal.from(
      this.threads.signal,
      this.notifications.signal,
      this.optimisticUpdates.signal,
      (ts, ns, updates) => applyOptimisticUpdates_forThreadifications(ts, ns, updates)
    );
    const threads = DerivedSignal.from(threadifications, (s) => s.threadsDB);
    const notifications = DerivedSignal.from(
      threadifications,
      (s) => ({
        sortedNotifications: s.sortedNotifications,
        notificationsById: s.notificationsById
      }),
      shallow
    );
    const threadSubscriptions = DerivedSignal.from(
      notifications,
      this.subscriptions.signal,
      (n, s) => ({
        subscriptions: s,
        notifications: n.sortedNotifications
      })
    );
    const loadingUserThreads = new DefaultMap(
      (queryKey) => {
        const query = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await __privateGet(this, _client)[kInternal].httpClient.getUserThreads_experimental({
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications,
            result.subscriptions
          );
          this.permissionHints.update(result.permissionHints);
          if (__privateGet(this, _userThreadsLastRequestedAt) === null) {
            __privateSet(this, _userThreadsLastRequestedAt, result.requestedAt);
          }
          return result.nextCursor;
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const threads2 = this.outputs.threads.get().findMany(
            void 0,
            // Do _not_ filter by roomId
            query ?? {},
            "desc"
          );
          const page = result.data;
          return {
            isLoading: false,
            threads: threads2,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, shallow2);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const loadingRoomThreads = new DefaultMap(
      (queryKey) => {
        const [roomId, query] = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await __privateGet(this, _client)[kInternal].httpClient.getThreads({
            roomId,
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications,
            result.subscriptions
          );
          this.permissionHints.update(result.permissionHints);
          const lastRequestedAt = __privateGet(this, _roomThreadsLastRequestedAtByRoom).get(roomId);
          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
            __privateGet(this, _roomThreadsLastRequestedAtByRoom).set(
              roomId,
              result.requestedAt
            );
          }
          return result.nextCursor;
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const threads2 = this.outputs.threads.get().findMany(roomId, query ?? {}, "asc");
          const page = result.data;
          return {
            isLoading: false,
            threads: threads2,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, shallow2);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const loadingNotifications = new DefaultMap(
      (queryKey) => {
        const query = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await __privateGet(this, _client).getInboxNotifications({
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications,
            result.subscriptions
          );
          if (__privateGet(this, _notificationsLastRequestedAt) === null) {
            __privateSet(this, _notificationsLastRequestedAt, result.requestedAt);
          }
          const nextCursor = result.nextCursor;
          return nextCursor;
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const crit = [];
          if (query !== void 0) {
            crit.push(makeInboxNotificationsFilter(query));
          }
          const inboxNotifications = this.outputs.notifications.get().sortedNotifications.filter(
            (inboxNotification) => crit.every((pred) => pred(inboxNotification))
          );
          const page = result.data;
          return {
            isLoading: false,
            inboxNotifications,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, shallow2);
        return {
          signal,
          waitUntilLoaded: resource.waitUntilLoaded
        };
      }
    );
    const roomSubscriptionSettingsByRoomId = new DefaultMap(
      (roomId) => {
        const resource = new SinglePageResource(async () => {
          const room = __privateGet(this, _client).getRoom(roomId);
          if (room === null) {
            throw new Error(`Room '${roomId}' is not available on client`);
          }
          const result = await room.getSubscriptionSettings();
          this.roomSubscriptionSettings.update(roomId, result);
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          } else {
            return ASYNC_OK(
              "settings",
              nn(this.roomSubscriptionSettings.signal.get()[roomId])
            );
          }
        }, shallow);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const versionsByRoomId = new DefaultMap(
      (roomId) => {
        const resource = new SinglePageResource(async () => {
          const room = __privateGet(this, _client).getRoom(roomId);
          if (room === null) {
            throw new Error(`Room '${roomId}' is not available on client`);
          }
          const result = await room[kInternal].listTextVersions();
          this.historyVersions.update(roomId, result.versions);
          const lastRequestedAt = __privateGet(this, _roomVersionsLastRequestedAtByRoom).get(roomId);
          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
            __privateGet(this, _roomVersionsLastRequestedAtByRoom).set(
              roomId,
              result.requestedAt
            );
          }
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          } else {
            return ASYNC_OK(
              "versions",
              Object.values(this.historyVersions.signal.get()[roomId] ?? {})
            );
          }
        }, shallow);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const notificationSettings = {
      signal: DerivedSignal.from(() => {
        const result = __privateGet(this, _notificationSettings).get();
        if (result.isLoading || result.error) {
          return result;
        }
        return ASYNC_OK(
          "settings",
          nn(this.notificationSettings.signal.get())
        );
      }, shallow),
      waitUntilLoaded: __privateGet(this, _notificationSettings).waitUntilLoaded
    };
    const aiChats = new DefaultMap(
      (queryKey) => {
        const query = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await __privateGet(this, _client)[kInternal].ai.getChats({
            cursor,
            query
          });
          return result.nextCursor;
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const chats = __privateGet(this, _client)[kInternal].ai.queryChats(query);
          return {
            isLoading: false,
            chats,
            hasFetchedAll: result.data.hasFetchedAll,
            isFetchingMore: result.data.isFetchingMore,
            fetchMore: result.data.fetchMore,
            fetchMoreError: result.data.fetchMoreError
          };
        }, shallow);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const messagesByChatId = new DefaultMap((chatId) => {
      const resourceΣ = new SinglePageResource(async () => {
        await __privateGet(this, _client)[kInternal].ai.getMessageTree(chatId);
      });
      return new DefaultMap(
        (branch) => {
          const signal = DerivedSignal.from(() => {
            const result = resourceΣ.get();
            if (result.isLoading || result.error) {
              return result;
            }
            return ASYNC_OK(
              "messages",
              __privateGet(this, _client)[kInternal].ai.signals.getChatMessagesForBranchΣ(chatId, branch ?? void 0).get()
            );
          });
          return { signal, waitUntilLoaded: resourceΣ.waitUntilLoaded };
        }
      );
    });
    const aiChatById = new DefaultMap((chatId) => {
      const resource = new SinglePageResource(async () => {
        await __privateGet(this, _client)[kInternal].ai.getOrCreateChat(chatId);
      });
      const signal = DerivedSignal.from(() => {
        const chat = __privateGet(this, _client)[kInternal].ai.getChatById(chatId);
        if (chat === void 0) {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          } else {
            return ASYNC_OK(
              "chat",
              nn(__privateGet(this, _client)[kInternal].ai.getChatById(chatId))
            );
          }
        } else {
          return ASYNC_OK(
            "chat",
            nn(__privateGet(this, _client)[kInternal].ai.getChatById(chatId))
          );
        }
      }, shallow);
      return { signal, waitUntilLoaded: resource.waitUntilLoaded };
    });
    this.outputs = {
      threadifications,
      threads,
      loadingRoomThreads,
      loadingUserThreads,
      notifications,
      loadingNotifications,
      roomSubscriptionSettingsByRoomId,
      versionsByRoomId,
      notificationSettings,
      threadSubscriptions,
      aiChats,
      messagesByChatId,
      aiChatById
    };
    autobind(this);
  }
  /**
   * Updates an existing inbox notification with a new value, replacing the
   * corresponding optimistic update.
   *
   * This will not update anything if the inbox notification ID isn't found.
   */
  markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.markRead(inboxNotificationId, readAt);
    });
  }
  markAllInboxNotificationsRead(optimisticId, readAt) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.markAllRead(readAt);
    });
  }
  /**
   * Deletes an existing inbox notification, replacing the corresponding
   * optimistic update.
   */
  deleteInboxNotification(inboxNotificationId, optimisticId) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.delete(inboxNotificationId);
    });
  }
  /**
   * Deletes *all* inbox notifications, replacing the corresponding optimistic
   * update.
   */
  deleteAllInboxNotifications(optimisticId) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.clear();
    });
  }
  /**
   * Creates an existing subscription, replacing the corresponding
   * optimistic update.
   */
  createSubscription(subscription, optimisticId) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.subscriptions.create(subscription);
    });
  }
  /**
   * Deletes an existing subscription, replacing the corresponding
   * optimistic update.
   */
  deleteSubscription(subscriptionKey, optimisticId) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.subscriptions.delete(subscriptionKey);
    });
  }
  /**
   * Creates an new thread, replacing the corresponding optimistic update.
   */
  createThread(optimisticId, thread) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.threads.upsert(thread);
    });
  }
  patchThread(threadId, optimisticId, patch, updatedAt) {
    return __privateMethod(this, _UmbrellaStore_instances, updateThread_fn).call(this, threadId, optimisticId, (thread) => ({ ...thread, ...compactObject(patch) }), updatedAt);
  }
  addReaction(threadId, optimisticId, commentId, reaction, createdAt) {
    __privateMethod(this, _UmbrellaStore_instances, updateThread_fn).call(this, threadId, optimisticId, (thread) => applyAddReaction(thread, commentId, reaction), createdAt);
  }
  removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {
    __privateMethod(this, _UmbrellaStore_instances, updateThread_fn).call(this, threadId, optimisticId, (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt), removedAt);
  }
  /**
   * Soft-deletes an existing thread by setting its `deletedAt` value,
   * replacing the corresponding optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted
   */
  deleteThread(threadId, optimisticId) {
    return __privateMethod(this, _UmbrellaStore_instances, updateThread_fn).call(
      this,
      threadId,
      optimisticId,
      // A deletion is actually an update of the deletedAt property internally
      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })
    );
  }
  /**
   * Creates an existing comment and ensures the associated notification is
   * updated correctly, replacing the corresponding optimistic update.
   */
  createComment(newComment, optimisticId) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      const existingThread = this.threads.get(newComment.threadId);
      if (!existingThread) {
        return;
      }
      this.threads.upsert(applyUpsertComment(existingThread, newComment));
      this.notifications.updateAssociatedNotification(newComment);
    });
  }
  editComment(threadId, optimisticId, editedComment) {
    return __privateMethod(this, _UmbrellaStore_instances, updateThread_fn).call(this, threadId, optimisticId, (thread) => applyUpsertComment(thread, editedComment));
  }
  deleteComment(threadId, optimisticId, commentId, deletedAt) {
    return __privateMethod(this, _UmbrellaStore_instances, updateThread_fn).call(this, threadId, optimisticId, (thread) => applyDeleteComment(thread, commentId, deletedAt), deletedAt);
  }
  updateThreadifications(threads, notifications, subscriptions, deletedThreads = [], deletedNotifications = [], deletedSubscriptions = []) {
    batch(() => {
      this.threads.applyDelta(threads, deletedThreads);
      this.notifications.applyDelta(notifications, deletedNotifications);
      this.subscriptions.applyDelta(subscriptions, deletedSubscriptions);
    });
  }
  /**
   * Updates existing subscription settings for a room with a new value,
   * replacing the corresponding optimistic update.
   */
  updateRoomSubscriptionSettings(roomId, optimisticId, settings) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.roomSubscriptionSettings.update(roomId, settings);
    });
  }
  async fetchNotificationsDeltaUpdate(signal) {
    const lastRequestedAt = __privateGet(this, _notificationsLastRequestedAt);
    if (lastRequestedAt === null) {
      return;
    }
    const result = await __privateGet(this, _client).getInboxNotificationsSince({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      __privateSet(this, _notificationsLastRequestedAt, result.requestedAt);
    }
    this.updateThreadifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.subscriptions.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted,
      result.subscriptions.deleted
    );
  }
  async fetchRoomThreadsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = __privateGet(this, _roomThreadsLastRequestedAtByRoom).get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const updates = await __privateGet(this, _client)[kInternal].httpClient.getThreadsSince({
      roomId,
      since: lastRequestedAt,
      signal
    });
    this.updateThreadifications(
      updates.threads.updated,
      updates.inboxNotifications.updated,
      updates.subscriptions.updated,
      updates.threads.deleted,
      updates.inboxNotifications.deleted,
      updates.subscriptions.deleted
    );
    this.permissionHints.update(updates.permissionHints);
    if (lastRequestedAt < updates.requestedAt) {
      __privateGet(this, _roomThreadsLastRequestedAtByRoom).set(roomId, updates.requestedAt);
    }
  }
  async fetchUserThreadsDeltaUpdate(signal) {
    const lastRequestedAt = __privateGet(this, _userThreadsLastRequestedAt);
    if (lastRequestedAt === null) {
      return;
    }
    const result = await __privateGet(this, _client)[kInternal].httpClient.getUserThreadsSince_experimental({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      __privateSet(this, _notificationsLastRequestedAt, result.requestedAt);
    }
    this.updateThreadifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.subscriptions.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted,
      result.subscriptions.deleted
    );
    this.permissionHints.update(result.permissionHints);
  }
  async fetchRoomVersionsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = __privateGet(this, _roomVersionsLastRequestedAtByRoom).get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const room = nn(
      __privateGet(this, _client).getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const updates = await room[kInternal].listTextVersionsSince({
      since: lastRequestedAt,
      signal
    });
    this.historyVersions.update(roomId, updates.versions);
    if (lastRequestedAt < updates.requestedAt) {
      __privateGet(this, _roomVersionsLastRequestedAtByRoom).set(roomId, updates.requestedAt);
    }
  }
  async refreshRoomSubscriptionSettings(roomId, signal) {
    const room = nn(
      __privateGet(this, _client).getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const result = await room.getSubscriptionSettings({ signal });
    this.roomSubscriptionSettings.update(roomId, result);
  }
  /**
   * Refresh notification settings from poller
   */
  async refreshNotificationSettings(signal) {
    const result = await __privateGet(this, _client).getNotificationSettings({
      signal
    });
    this.notificationSettings.update(result);
  }
  /**
   * Updates notification settings with a new value, replacing the
   * corresponding optimistic update.
   */
  updateNotificationSettings_confirmOptimisticUpdate(settings, optimisticUpdateId) {
    batch(() => {
      this.optimisticUpdates.remove(optimisticUpdateId);
      this.notificationSettings.update(settings);
    });
  }
}, _client = new WeakMap(), _notificationsLastRequestedAt = new WeakMap(), _roomThreadsLastRequestedAtByRoom = new WeakMap(), _userThreadsLastRequestedAt = new WeakMap(), _roomVersionsLastRequestedAtByRoom = new WeakMap(), _notificationSettings = new WeakMap(), _UmbrellaStore_instances = new WeakSet(), /**
 * Updates an existing thread with a new value, replacing the corresponding
 * optimistic update.
 *
 * This will not update anything if:
 * - The thread ID isn't found; or
 * - The thread ID was already deleted; or
 * - The thread ID was updated more recently than the optimistic update's
 *   timestamp (if given)
 */
updateThread_fn = function(threadId, optimisticId, callback, updatedAt) {
  batch(() => {
    if (optimisticId !== null) {
      this.optimisticUpdates.remove(optimisticId);
    }
    const db = this.threads;
    const existing = db.get(threadId);
    if (!existing) return;
    if (!!updatedAt && existing.updatedAt > updatedAt) return;
    db.upsert(callback(existing));
  });
}, _a4);
function applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {
  const threadsDB = baseThreadsDB.clone();
  let notificationsById = Object.fromEntries(notificationsLUT);
  for (const optimisticUpdate of optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "create-thread": {
        threadsDB.upsert(optimisticUpdate.thread);
        break;
      }
      case "edit-thread-metadata": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        if (thread.updatedAt > optimisticUpdate.updatedAt) {
          break;
        }
        threadsDB.upsert({
          ...thread,
          updatedAt: optimisticUpdate.updatedAt,
          metadata: {
            ...thread.metadata,
            ...optimisticUpdate.metadata
          }
        });
        break;
      }
      case "mark-thread-as-resolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: true });
        break;
      }
      case "mark-thread-as-unresolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: false });
        break;
      }
      case "create-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        const inboxNotification = Object.values(notificationsById).find(
          (notification) => notification.kind === "thread" && notification.threadId === thread.id
        );
        if (inboxNotification === void 0) {
          break;
        }
        notificationsById[inboxNotification.id] = {
          ...inboxNotification,
          notifiedAt: optimisticUpdate.comment.createdAt,
          readAt: optimisticUpdate.comment.createdAt
        };
        break;
      }
      case "edit-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        break;
      }
      case "delete-comment": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyDeleteComment(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.deletedAt
          )
        );
        break;
      }
      case "delete-thread": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({
          ...thread,
          deletedAt: optimisticUpdate.deletedAt,
          updatedAt: optimisticUpdate.deletedAt,
          comments: []
        });
        break;
      }
      case "add-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyAddReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.reaction
          )
        );
        break;
      }
      case "remove-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyRemoveReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.emoji,
            optimisticUpdate.userId,
            optimisticUpdate.removedAt
          )
        );
        break;
      }
      case "mark-inbox-notification-as-read": {
        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];
        if (ibn === void 0) {
          break;
        }
        notificationsById[optimisticUpdate.inboxNotificationId] = {
          ...ibn,
          readAt: optimisticUpdate.readAt
        };
        break;
      }
      case "mark-all-inbox-notifications-as-read": {
        for (const id in notificationsById) {
          const ibn = notificationsById[id];
          if (ibn === void 0) {
            break;
          }
          notificationsById[id] = {
            ...ibn,
            readAt: optimisticUpdate.readAt
          };
        }
        break;
      }
      case "delete-inbox-notification": {
        delete notificationsById[optimisticUpdate.inboxNotificationId];
        break;
      }
      case "delete-all-inbox-notifications": {
        notificationsById = {};
        break;
      }
    }
  }
  const sortedNotifications = (
    // Sort so that the most recent notifications are first
    Object.values(notificationsById).filter(
      (ibn) => ibn.kind === "thread" ? threadsDB.get(ibn.threadId) !== void 0 : true
    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())
  );
  return {
    sortedNotifications,
    notificationsById,
    threadsDB
  };
}
function applyOptimisticUpdates_forRoomSubscriptionSettings(settingsLUT, optimisticUpdates) {
  const roomSubscriptionSettingsByRoomId = Object.fromEntries(settingsLUT);
  for (const optimisticUpdate of optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "update-room-subscription-settings": {
        const settings = roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId];
        if (settings === void 0) {
          break;
        }
        roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId] = {
          ...settings,
          ...optimisticUpdate.settings
        };
      }
    }
  }
  return roomSubscriptionSettingsByRoomId;
}
function applyOptimisticUpdates_forSubscriptions(subscriptionsLUT, threads, optimisticUpdates) {
  const subscriptions = Object.fromEntries(subscriptionsLUT);
  for (const update of optimisticUpdates) {
    switch (update.type) {
      case "update-room-subscription-settings": {
        if (!update.settings.threads) {
          continue;
        }
        const roomThreads = threads.findMany(update.roomId, void 0, "desc");
        for (const thread of roomThreads) {
          const subscriptionKey = getSubscriptionKey("thread", thread.id);
          switch (update.settings.threads) {
            // Create subscriptions for all existing threads in the room
            case "all": {
              subscriptions[subscriptionKey] = {
                kind: "thread",
                subjectId: thread.id,
                createdAt: /* @__PURE__ */ new Date()
              };
              break;
            }
            // Delete subscriptions for all existing threads in the room
            case "none": {
              delete subscriptions[subscriptionKey];
              break;
            }
            case "replies_and_mentions": {
              break;
            }
            default:
              assertNever(
                update.settings.threads,
                "Unexpected thread subscription settings."
              );
          }
        }
      }
    }
  }
  return subscriptions;
}
function applyOptimisticUpdates_forNotificationSettings(settings, optimisticUpdates) {
  let outcoming = settings;
  for (const update of optimisticUpdates) {
    if (update.type === "update-notification-settings") {
      outcoming = patchNotificationSettings(outcoming, update.settings);
    }
  }
  return outcoming;
}
function compareInboxNotifications(inboxNotificationA, inboxNotificationB) {
  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {
    return 1;
  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {
    return -1;
  }
  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {
    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;
  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {
    return inboxNotificationA.readAt ? 1 : -1;
  }
  return 0;
}
function applyUpsertComment(thread, comment) {
  var _a5;
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  if (comment.threadId !== thread.id) {
    fancy_console_exports.warn(
      `Comment ${comment.id} does not belong to thread ${thread.id}`
    );
    return thread;
  }
  const existingComment = thread.comments.find(
    (existingComment2) => existingComment2.id === comment.id
  );
  if (existingComment === void 0) {
    const updatedAt = new Date(
      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())
    );
    const updatedThread = {
      ...thread,
      updatedAt,
      comments: [...thread.comments, comment]
    };
    return updatedThread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {
    const updatedComments = thread.comments.map(
      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2
    );
    const updatedThread = {
      ...thread,
      updatedAt: new Date(
        Math.max(
          thread.updatedAt.getTime(),
          ((_a5 = comment.editedAt) == null ? void 0 : _a5.getTime()) || comment.createdAt.getTime()
        )
      ),
      comments: updatedComments
    };
    return updatedThread;
  }
  return thread;
}
function applyDeleteComment(thread, commentId, deletedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      deletedAt,
      // We optimistically remove the comment body and attachments when marking it as deleted
      body: void 0,
      attachments: []
    } : comment
  );
  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {
    return {
      ...thread,
      deletedAt,
      updatedAt: deletedAt
    };
  }
  return {
    ...thread,
    updatedAt: deletedAt,
    comments: updatedComments
  };
}
function applyAddReaction(thread, commentId, reaction) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: upsertReaction(comment.reactions, reaction)
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: comment.reactions.map(
        (reaction) => reaction.emoji === emoji ? {
          ...reaction,
          users: reaction.users.filter((user) => user.id !== userId)
        } : reaction
      ).filter((reaction) => reaction.users.length > 0)
      // Remove reactions with no users left
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(removedAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function upsertReaction(reactions, reaction) {
  const existingReaction = reactions.find(
    (existingReaction2) => existingReaction2.emoji === reaction.emoji
  );
  if (existingReaction === void 0) {
    return [
      ...reactions,
      {
        emoji: reaction.emoji,
        createdAt: reaction.createdAt,
        users: [{ id: reaction.userId }]
      }
    ];
  }
  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {
    return reactions.map(
      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {
        ...existingReaction2,
        users: [...existingReaction2.users, { id: reaction.userId }]
      } : existingReaction2
    );
  }
  return reactions;
}
function missingUserError(userId) {
  return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
  return new Error(
    `resolveRoomsInfo didn't return anything for room '${roomId}'`
  );
}
function missingGroupInfoError(groupId) {
  return new Error(
    `resolveGroupsInfo didn't return anything for group '${groupId}'`
  );
}
function identity2(x) {
  return x;
}
var _umbrellaStores = /* @__PURE__ */ new WeakMap();
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
function selectorFor_useUnreadInboxNotificationsCount(result) {
  if (!result.inboxNotifications) {
    return result;
  }
  return ASYNC_OK(
    "count",
    count(
      result.inboxNotifications,
      (n) => n.readAt === null || n.readAt < n.notifiedAt
    )
  );
}
function selectorFor_useUser(state, userId) {
  if (state === void 0 || (state == null ? void 0 : state.isLoading)) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingUserError(userId)
    };
  }
  return {
    isLoading: false,
    user: state.data
  };
}
function selectorFor_useRoomInfo(state, roomId) {
  if (state === void 0 || (state == null ? void 0 : state.isLoading)) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingRoomInfoError(roomId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function selectorFor_useGroupInfo(state, groupId) {
  if (state === void 0 || (state == null ? void 0 : state.isLoading)) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingGroupInfoError(groupId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function getOrCreateContextBundle(client) {
  let bundle = _bundles.get(client);
  if (!bundle) {
    bundle = makeLiveblocksContextBundle(client);
    _bundles.set(client, bundle);
  }
  return bundle;
}
function getUmbrellaStoreForClient(client) {
  let store = _umbrellaStores.get(client);
  if (!store) {
    store = new UmbrellaStore(client);
    _umbrellaStores.set(client, store);
  }
  return store;
}
function getLiveblocksExtrasForClient(client) {
  let extras = _extras.get(client);
  if (!extras) {
    extras = makeLiveblocksExtrasForClient(client);
    _extras.set(client, extras);
  }
  return extras;
}
function useEnsureAiConnection(client) {
  (0, import_react6.useEffect)(() => {
    client[kInternal].ai.connectInitially();
  }, [client]);
}
function makeLiveblocksExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  const notificationsPoller = makePoller(
    async (signal) => {
      try {
        return await store.fetchNotificationsDeltaUpdate(signal);
      } catch (err) {
        fancy_console_exports.warn(`Polling new inbox notifications failed: ${String(err)}`);
        throw err;
      }
    },
    config.NOTIFICATIONS_POLL_INTERVAL,
    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }
  );
  const userThreadsPoller = makePoller(
    async (signal) => {
      try {
        return await store.fetchUserThreadsDeltaUpdate(signal);
      } catch (err) {
        fancy_console_exports.warn(`Polling new user threads failed: ${String(err)}`);
        throw err;
      }
    },
    config.USER_THREADS_POLL_INTERVAL,
    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }
  );
  const notificationSettingsPoller = makePoller(
    async (signal) => {
      try {
        return await store.refreshNotificationSettings(signal);
      } catch (err) {
        fancy_console_exports.warn(
          `Polling new notification settings failed: ${String(err)}`
        );
        throw err;
      }
    },
    config.USER_NOTIFICATION_SETTINGS_INTERVAL,
    { maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME }
  );
  return {
    store,
    notificationsPoller,
    userThreadsPoller,
    notificationSettingsPoller
  };
}
function makeLiveblocksContextBundle(client) {
  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);
  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);
  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);
  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);
  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);
  const useUpdateNotificationSettings2 = () => useUpdateNotificationSettings_withClient(client);
  function LiveblocksProvider2(props) {
    useEnsureNoLiveblocksProvider();
    return (0, import_jsx_runtime2.jsx)(ClientContext.Provider, { value: client, children: props.children });
  }
  const shared = createSharedContext(client);
  const bundle = {
    LiveblocksProvider: LiveblocksProvider2,
    useInboxNotifications: (options) => useInboxNotifications_withClient(client, identity2, shallow, options),
    useUnreadInboxNotificationsCount: (options) => useUnreadInboxNotificationsCount_withClient(client, options),
    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
    useDeleteInboxNotification: useDeleteInboxNotification2,
    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
    useNotificationSettings: () => useNotificationSettings_withClient(client),
    useUpdateNotificationSettings: useUpdateNotificationSettings2,
    useInboxNotificationThread: useInboxNotificationThread2,
    useUserThreads_experimental,
    useAiChats,
    useAiChat,
    useAiChatMessages,
    useCreateAiChat,
    useDeleteAiChat,
    useSendAiMessage,
    ...shared.classic,
    suspense: {
      LiveblocksProvider: LiveblocksProvider2,
      useInboxNotifications: (options) => useInboxNotificationsSuspense_withClient(client, options),
      useUnreadInboxNotificationsCount: (options) => useUnreadInboxNotificationsCountSuspense_withClient(client, options),
      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
      useDeleteInboxNotification: useDeleteInboxNotification2,
      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
      useInboxNotificationThread: useInboxNotificationThread2,
      useNotificationSettings: () => useNotificationSettingsSuspense_withClient(client),
      useUpdateNotificationSettings: useUpdateNotificationSettings2,
      useUserThreads_experimental: useUserThreadsSuspense_experimental,
      useAiChats: useAiChatsSuspense,
      useAiChat: useAiChatSuspense,
      useAiChatMessages: useAiChatMessagesSuspense,
      useCreateAiChat,
      useDeleteAiChat,
      useSendAiMessage,
      ...shared.suspense
    }
  };
  return bundle;
}
function useInboxNotifications_withClient(client, selector, isEqual, options) {
  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);
  const queryKey = makeInboxNotificationsQueryKey(options == null ? void 0 : options.query);
  (0, import_react6.useEffect)(
    () => void store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  (0, import_react6.useEffect)(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  return useSignal(
    store.outputs.loadingNotifications.getOrCreate(queryKey).signal,
    selector,
    isEqual
  );
}
function useInboxNotificationsSuspense_withClient(client, options) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  const queryKey = makeInboxNotificationsQueryKey(options == null ? void 0 : options.query);
  use(
    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()
  );
  const result = useInboxNotifications_withClient(
    client,
    identity2,
    shallow,
    options
  );
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useUnreadInboxNotificationsCount_withClient(client, options) {
  return useInboxNotifications_withClient(
    client,
    selectorFor_useUnreadInboxNotificationsCount,
    shallow,
    options
  );
}
function useUnreadInboxNotificationsCountSuspense_withClient(client, options) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  const queryKey = makeInboxNotificationsQueryKey(options == null ? void 0 : options.query);
  use(
    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()
  );
  const result = useUnreadInboxNotificationsCount_withClient(client, options);
  assert(!result.isLoading, "Did not expect loading");
  assert(!result.error, "Did not expect error");
  return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
  return (0, import_react6.useCallback)(
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const readAt = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId,
        readAt
      });
      client.markInboxNotificationAsRead(inboxNotificationId).then(
        () => {
          store.markInboxNotificationRead(
            inboxNotificationId,
            readAt,
            optimisticId
          );
        },
        (err) => {
          store.optimisticUpdates.remove(optimisticId);
          client[kInternal].emitError(
            {
              type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
              inboxNotificationId
            },
            err
          );
        }
      );
    },
    [client]
  );
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
  return (0, import_react6.useCallback)(() => {
    const { store } = getLiveblocksExtrasForClient(client);
    const readAt = /* @__PURE__ */ new Date();
    const optimisticId = store.optimisticUpdates.add({
      type: "mark-all-inbox-notifications-as-read",
      readAt
    });
    client.markAllInboxNotificationsAsRead().then(
      () => {
        store.markAllInboxNotificationsRead(optimisticId, readAt);
      },
      (err) => {
        store.optimisticUpdates.remove(optimisticId);
        client[kInternal].emitError(
          // No roomId, threadId, commentId to include for this error
          { type: "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR" },
          err
        );
      }
    );
  }, [client]);
}
function useDeleteInboxNotification_withClient(client) {
  return (0, import_react6.useCallback)(
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const deletedAt = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-inbox-notification",
        inboxNotificationId,
        deletedAt
      });
      client.deleteInboxNotification(inboxNotificationId).then(
        () => {
          store.deleteInboxNotification(inboxNotificationId, optimisticId);
        },
        (err) => {
          store.optimisticUpdates.remove(optimisticId);
          client[kInternal].emitError(
            { type: "DELETE_INBOX_NOTIFICATION_ERROR", inboxNotificationId },
            err
          );
        }
      );
    },
    [client]
  );
}
function useDeleteAllInboxNotifications_withClient(client) {
  return (0, import_react6.useCallback)(() => {
    const { store } = getLiveblocksExtrasForClient(client);
    const deletedAt = /* @__PURE__ */ new Date();
    const optimisticId = store.optimisticUpdates.add({
      type: "delete-all-inbox-notifications",
      deletedAt
    });
    client.deleteAllInboxNotifications().then(
      () => {
        store.deleteAllInboxNotifications(optimisticId);
      },
      (err) => {
        store.optimisticUpdates.remove(optimisticId);
        client[kInternal].emitError(
          { type: "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR" },
          err
        );
      }
    );
  }, [client]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
  const { store } = getLiveblocksExtrasForClient(client);
  return useSignal(
    store.outputs.threadifications,
    (0, import_react6.useCallback)(
      (state) => {
        const inboxNotification = state.notificationsById[inboxNotificationId] ?? raise(
          `Inbox notification with ID "${inboxNotificationId}" not found`
        );
        if (inboxNotification.kind !== "thread") {
          raise(
            `Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`
          );
        }
        const thread = state.threadsDB.get(inboxNotification.threadId) ?? raise(
          `Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`
        );
        return thread;
      },
      [inboxNotificationId]
    )
  );
}
function useUpdateNotificationSettings_withClient(client) {
  return (0, import_react6.useCallback)(
    (settings) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const optimisticUpdateId = store.optimisticUpdates.add({
        type: "update-notification-settings",
        settings
      });
      client.updateNotificationSettings(settings).then(
        (settings2) => {
          store.updateNotificationSettings_confirmOptimisticUpdate(
            settings2,
            optimisticUpdateId
          );
        },
        (err) => {
          var _a5, _b;
          store.optimisticUpdates.remove(optimisticUpdateId);
          if (err instanceof HttpError) {
            if (err.status === 422) {
              const msg = [(_a5 = err.details) == null ? void 0 : _a5.error, (_b = err.details) == null ? void 0 : _b.reason].filter(Boolean).join("\n");
              fancy_console_exports.error(msg);
            }
            client[kInternal].emitError(
              {
                type: "UPDATE_NOTIFICATION_SETTINGS_ERROR"
              },
              err
            );
          } else {
            throw err;
          }
        }
      );
    },
    [client]
  );
}
function useNotificationSettings_withClient(client) {
  const updateNotificationSettings = useUpdateNotificationSettings_withClient(client);
  const { store, notificationSettingsPoller: poller } = getLiveblocksExtrasForClient(client);
  (0, import_react6.useEffect)(() => {
    void store.outputs.notificationSettings.waitUntilLoaded();
  });
  (0, import_react6.useEffect)(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  const result = useSignal(store.outputs.notificationSettings.signal);
  return (0, import_react6.useMemo)(() => {
    return [result, updateNotificationSettings];
  }, [result, updateNotificationSettings]);
}
function useNotificationSettingsSuspense_withClient(client) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  use(store.outputs.notificationSettings.waitUntilLoaded());
  const [result, updateNotificationSettings] = useNotificationSettings_withClient(client);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return (0, import_react6.useMemo)(() => {
    return [result, updateNotificationSettings];
  }, [result, updateNotificationSettings]);
}
function useUser_withClient(client, userId) {
  const usersStore = client[kInternal].usersStore;
  const getUserState = (0, import_react6.useCallback)(
    () => usersStore.getItemState(userId),
    [usersStore, userId]
  );
  const selector = (0, import_react6.useCallback)(
    (state) => selectorFor_useUser(state, userId),
    [userId]
  );
  const result = useSyncExternalStoreWithSelector(
    usersStore.subscribe,
    getUserState,
    getUserState,
    selector,
    shallow
  );
  (0, import_react6.useEffect)(
    () => void usersStore.enqueue(userId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call usersStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the userId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the userId gets invalidated, the user would be fetched again.
  );
  return result;
}
function useUserSuspense_withClient(client, userId) {
  const usersStore = client[kInternal].usersStore;
  const getUserState = (0, import_react6.useCallback)(
    () => usersStore.getItemState(userId),
    [usersStore, userId]
  );
  const userState = getUserState();
  if (!userState || userState.isLoading) {
    throw usersStore.enqueue(userId);
  }
  if (userState.error) {
    throw userState.error;
  }
  if (!userState.data) {
    throw missingUserError(userId);
  }
  const state = (0, import_react6.useSyncExternalStore)(
    usersStore.subscribe,
    getUserState,
    getUserState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  return {
    isLoading: false,
    user: state.data,
    error: void 0
  };
}
function useRoomInfo_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal].roomsInfoStore;
  const getRoomInfoState = (0, import_react6.useCallback)(
    () => roomsInfoStore.getItemState(roomId),
    [roomsInfoStore, roomId]
  );
  const selector = (0, import_react6.useCallback)(
    (state) => selectorFor_useRoomInfo(state, roomId),
    [roomId]
  );
  const result = useSyncExternalStoreWithSelector(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState,
    selector,
    shallow
  );
  (0, import_react6.useEffect)(
    () => void roomsInfoStore.enqueue(roomId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call roomsInfoStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the roomId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the roomId gets invalidated, the room info would be fetched again.
  );
  return result;
}
function useRoomInfoSuspense_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal].roomsInfoStore;
  const getRoomInfoState = (0, import_react6.useCallback)(
    () => roomsInfoStore.getItemState(roomId),
    [roomsInfoStore, roomId]
  );
  const roomInfoState = getRoomInfoState();
  if (!roomInfoState || roomInfoState.isLoading) {
    throw roomsInfoStore.enqueue(roomId);
  }
  if (roomInfoState.error) {
    throw roomInfoState.error;
  }
  if (!roomInfoState.data) {
    throw missingRoomInfoError(roomId);
  }
  const state = (0, import_react6.useSyncExternalStore)(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  assert(state.data !== void 0, "Unexpected missing room info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function useGroupInfo_withClient(client, groupId) {
  const groupsInfoStore = client[kInternal].groupsInfoStore;
  const getGroupInfoState = (0, import_react6.useCallback)(
    () => groupsInfoStore.getItemState(groupId),
    [groupsInfoStore, groupId]
  );
  const selector = (0, import_react6.useCallback)(
    (state) => selectorFor_useGroupInfo(state, groupId),
    [groupId]
  );
  const result = useSyncExternalStoreWithSelector(
    groupsInfoStore.subscribe,
    getGroupInfoState,
    getGroupInfoState,
    selector,
    shallow
  );
  (0, import_react6.useEffect)(
    () => void groupsInfoStore.enqueue(groupId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call groupsInfoStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the groupId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the groupId gets invalidated, the group info would be fetched again.
  );
  return result;
}
function useGroupInfoSuspense_withClient(client, groupId) {
  const groupsInfoStore = client[kInternal].groupsInfoStore;
  const getGroupInfoState = (0, import_react6.useCallback)(
    () => groupsInfoStore.getItemState(groupId),
    [groupsInfoStore, groupId]
  );
  const groupInfoState = getGroupInfoState();
  if (!groupInfoState || groupInfoState.isLoading) {
    throw groupsInfoStore.enqueue(groupId);
  }
  if (groupInfoState.error) {
    throw groupInfoState.error;
  }
  if (!groupInfoState.data) {
    throw missingGroupInfoError(groupId);
  }
  const state = (0, import_react6.useSyncExternalStore)(
    groupsInfoStore.subscribe,
    getGroupInfoState,
    getGroupInfoState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  assert(state.data !== void 0, "Unexpected missing group info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function useAiChats(options) {
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  const queryKey = makeAiChatsQueryKey(options == null ? void 0 : options.query);
  useEnsureAiConnection(client);
  (0, import_react6.useEffect)(
    () => void store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(
    store.outputs.aiChats.getOrCreate(queryKey).signal,
    identity2,
    shallow
  );
}
function useAiChatsSuspense(options) {
  ensureNotServerSide();
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  const queryKey = makeAiChatsQueryKey(options == null ? void 0 : options.query);
  use(store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded());
  const result = useAiChats(options);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useAiChatMessages(chatId, options) {
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  (0, import_react6.useEffect)(
    () => void store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate((options == null ? void 0 : options.branchId) ?? null).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(
    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate((options == null ? void 0 : options.branchId) ?? null).signal
  );
}
function useAiChatMessagesSuspense(chatId, options) {
  ensureNotServerSide();
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  use(
    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate((options == null ? void 0 : options.branchId) ?? null).waitUntilLoaded()
  );
  const result = useAiChatMessages(chatId, options);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useAiChat(chatId) {
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  (0, import_react6.useEffect)(
    () => void store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(store.outputs.aiChatById.getOrCreate(chatId).signal);
}
function useAiChatSuspense(chatId) {
  ensureNotServerSide();
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  useEnsureAiConnection(client);
  use(store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded());
  const result = useAiChat(chatId);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useCreateAiChat() {
  const client = useClient();
  return (0, import_react6.useCallback)(
    (options) => {
      if (typeof options === "string") {
        options = { id: options };
      }
      client[kInternal].ai.getOrCreateChat(options.id, {
        title: options.title,
        metadata: options.metadata
      }).catch((err) => {
        fancy_console_exports.error(
          `Failed to create chat with ID "${options.id}": ${String(err)}`
        );
      });
    },
    [client]
  );
}
function useDeleteAiChat() {
  const client = useClient();
  return (0, import_react6.useCallback)(
    (chatId) => {
      client[kInternal].ai.deleteChat(chatId).catch((err) => {
        fancy_console_exports.error(
          `Failed to delete chat with ID "${chatId}": ${String(err)}`
        );
      });
    },
    [client]
  );
}
function useSendAiMessage(chatId, options) {
  const client = useClient();
  return (0, import_react6.useCallback)(
    (message) => {
      var _a5;
      const {
        text: messageText,
        chatId: messageOptionsChatId,
        copilotId: messageOptionsCopilotId,
        ...messageOptions
      } = typeof message === "string" ? { text: message } : message;
      const resolvedChatId = messageOptionsChatId ?? chatId ?? // The `useSendAiMessage` overloads prevent this scenario from happening
      // at the type level, and this error prevents it from happening at runtime.
      raise(
        "chatId must be provided to either `useSendAiMessage` or its returned function."
      );
      const messages = client[kInternal].ai.signals.getChatMessagesForBranchΣ(resolvedChatId).get();
      if (!messageOptionsCopilotId && !(options == null ? void 0 : options.copilotId)) {
        fancy_console_exports.warn(
          `No copilot ID was provided to useSendAiMessage when sending the message "${messageText.slice(
            0,
            20
          )}…". As a result, the message will use the chat's previous copilot ID, which could lead to unexpected behavior.
To ensure the correct copilot ID is used, specify it either through the hook as 'useSendAiMessage("${resolvedChatId}", { copilotId: "co_xxx" })' or via the function as 'sendAiMessage({ text: "${messageText.slice(
            0,
            20
          )}…", copilotId: "co_xxx" })'`
        );
      }
      const resolvedCopilotId = messageOptionsCopilotId ?? (options == null ? void 0 : options.copilotId) ?? client[kInternal].ai.getLastUsedCopilotId(resolvedChatId);
      const lastMessageId = ((_a5 = messages[messages.length - 1]) == null ? void 0 : _a5.id) ?? null;
      const content = [{ type: "text", text: messageText }];
      const newMessageId = client[kInternal].ai[kInternal].context.messagesStore.createOptimistically(
        resolvedChatId,
        "user",
        lastMessageId,
        content
      );
      const newMessage = client[kInternal].ai[kInternal].context.messagesStore.getMessageById(newMessageId);
      const targetMessageId = client[kInternal].ai[kInternal].context.messagesStore.createOptimistically(
        resolvedChatId,
        "assistant",
        newMessageId,
        resolvedCopilotId
      );
      void client[kInternal].ai.askUserMessageInChat(
        resolvedChatId,
        { id: newMessageId, parentMessageId: lastMessageId, content },
        targetMessageId,
        {
          stream: messageOptions.stream ?? (options == null ? void 0 : options.stream),
          copilotId: resolvedCopilotId,
          timeout: messageOptions.timeout ?? (options == null ? void 0 : options.timeout),
          knowledge: messageOptions.knowledge ?? (options == null ? void 0 : options.knowledge)
        }
      );
      return newMessage;
    },
    [
      client,
      chatId,
      options == null ? void 0 : options.copilotId,
      options == null ? void 0 : options.stream,
      options == null ? void 0 : options.timeout,
      options == null ? void 0 : options.knowledge
    ]
  );
}
function createSharedContext(client) {
  const useClient2 = () => client;
  function useSyncStatus2(options) {
    return useSyncStatus_withClient(client, options);
  }
  return {
    classic: {
      useClient: useClient2,
      useUser: (userId) => useUser_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),
      useGroupInfo: (groupId) => useGroupInfo_withClient(client, groupId),
      useIsInsideRoom,
      useErrorListener,
      useSyncStatus: useSyncStatus2,
      RegisterAiKnowledge,
      RegisterAiTool
    },
    suspense: {
      useClient: useClient2,
      useUser: (userId) => useUserSuspense_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),
      useGroupInfo: (groupId) => useGroupInfoSuspense_withClient(client, groupId),
      useIsInsideRoom,
      useErrorListener,
      useSyncStatus: useSyncStatus2,
      RegisterAiKnowledge,
      RegisterAiTool
    }
  };
}
function useEnsureNoLiveblocksProvider(options) {
  const existing = useClientOrNull();
  if (!(options == null ? void 0 : options.allowNesting) && existing !== null) {
    throw new Error(
      "You cannot nest multiple LiveblocksProvider instances in the same React tree."
    );
  }
}
function LiveblocksProviderWithClient(props) {
  useEnsureNoLiveblocksProvider(props);
  return (0, import_jsx_runtime2.jsx)(ClientContext.Provider, { value: props.client, children: props.children });
}
function LiveblocksProvider(props) {
  const { children, ...o } = props;
  const options = {
    publicApiKey: useInitial(o.publicApiKey),
    throttle: useInitial(o.throttle),
    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
    polyfills: useInitial(o.polyfills),
    largeMessageStrategy: useInitial(o.largeMessageStrategy),
    unstable_streamData: useInitial(o.unstable_streamData),
    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),
    authEndpoint: useInitialUnlessFunction(o.authEndpoint),
    resolveMentionSuggestions: useInitialUnlessFunction(
      o.resolveMentionSuggestions
    ),
    resolveUsers: useInitialUnlessFunction(o.resolveUsers),
    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
    resolveGroupsInfo: useInitialUnlessFunction(o.resolveGroupsInfo),
    baseUrl: useInitial(
      // @ts-expect-error - Hidden config options
      o.baseUrl
    ),
    enableDebugLogging: useInitial(
      // @ts-expect-error - Hidden config options
      o.enableDebugLogging
    )
  };
  const client = (0, import_react6.useMemo)(() => createClient(options), []);
  (0, import_react6.useEffect)(() => {
    return () => {
      client[kInternal].ai.disconnect();
    };
  }, [client]);
  return (0, import_jsx_runtime2.jsx)(LiveblocksProviderWithClient, { client, children });
}
function createLiveblocksContext(client) {
  return getOrCreateContextBundle(client);
}
function useUserThreads_experimental(options = {}) {
  const client = useClient();
  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);
  const queryKey = makeUserThreadsQueryKey(options.query);
  (0, import_react6.useEffect)(
    () => void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  (0, import_react6.useEffect)(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  return useSignal(
    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal
  );
}
function useUserThreadsSuspense_experimental(options = {}) {
  ensureNotServerSide();
  const client = useClient();
  const { store } = getLiveblocksExtrasForClient(client);
  const queryKey = makeUserThreadsQueryKey(options.query);
  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());
  const result = useUserThreads_experimental(options);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useInboxNotifications(options) {
  return useInboxNotifications_withClient(
    useClient(),
    identity2,
    shallow,
    options
  );
}
function useInboxNotificationThread(inboxNotificationId) {
  return useInboxNotificationThread_withClient(
    useClient(),
    inboxNotificationId
  );
}
function useMarkAllInboxNotificationsAsRead() {
  return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
  return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
  return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
  return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount(options) {
  return useUnreadInboxNotificationsCount_withClient(useClient(), options);
}
function useNotificationSettings() {
  return useNotificationSettings_withClient(useClient());
}
function useUpdateNotificationSettings() {
  return useUpdateNotificationSettings_withClient(useClient());
}
function useUser(userId) {
  const client = useClient();
  return useUser_withClient(client, userId);
}
function useRoomInfo(roomId) {
  return useRoomInfo_withClient(useClient(), roomId);
}
function useGroupInfo(groupId) {
  return useGroupInfo_withClient(useClient(), groupId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useAiChats = useAiChats;
var _useAiChat = useAiChat;
var _useAiChatMessages = useAiChatMessages;
function useSyncStatus_withClient(client, options) {
  const smooth = useInitial((options == null ? void 0 : options.smooth) ?? false);
  if (smooth) {
    return useSyncStatusSmooth_withClient(client);
  } else {
    return useSyncStatusImmediate_withClient(client);
  }
}
function useSyncStatusImmediate_withClient(client) {
  return (0, import_react6.useSyncExternalStore)(
    client.events.syncStatus.subscribe,
    client.getSyncStatus,
    client.getSyncStatus
  );
}
function useSyncStatusSmooth_withClient(client) {
  const getter = client.getSyncStatus;
  const [status, setStatus] = (0, import_react6.useState)(getter);
  const oldStatus = useLatest(getter());
  (0, import_react6.useEffect)(() => {
    let timeoutId;
    const unsub = client.events.syncStatus.subscribe(() => {
      const newStatus = getter();
      if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);
      } else {
        clearTimeout(timeoutId);
        setStatus(newStatus);
      }
    });
    return () => {
      clearTimeout(timeoutId);
      unsub();
    };
  }, [client, getter, oldStatus]);
  return status;
}
function useSyncStatus(options) {
  return useSyncStatus_withClient(useClient(), options);
}
function useErrorListener(callback) {
  const client = useClient();
  const savedCallback = useLatest(callback);
  (0, import_react6.useEffect)(
    () => client.events.error.subscribe((e) => savedCallback.current(e)),
    [client, savedCallback]
  );
}
function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
  if (shouldScrollOnLoad === false) return;
  if (!state.threads) return;
  const isWindowDefined = typeof window !== "undefined";
  if (!isWindowDefined) return;
  const hash = window.location.hash;
  const commentId = hash.slice(1);
  if (!commentId.startsWith("cm_")) return;
  const comment = document.getElementById(commentId);
  if (comment === null) return;
  const comments = state.threads.flatMap((thread) => thread.comments);
  const isCommentInThreads = comments.some(
    (comment2) => comment2.id === commentId
  );
  if (!isCommentInThreads) return;
  comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
  (0, import_react9.useEffect)(
    () => {
      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [state.isLoading]
  );
}
var noop2 = () => {
};
var identity3 = (x) => x;
var STABLE_EMPTY_LIST = Object.freeze([]);
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function selectorFor_useOthersConnectionIds(others) {
  return others.map((user) => user.connectionId);
}
function makeMutationContext(room) {
  const cannotUseUntil = "This mutation cannot be used until";
  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
  const needsStorage = `${cannotUseUntil} storage has been loaded`;
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(needsStorage);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(needsPresence);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(needsPresence);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
function getCurrentUserId(client) {
  const userId = client[kInternal].currentUserId.get();
  if (userId === void 0) {
    return "anonymous";
  }
  return userId;
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
  let bundle = _bundles2.get(client);
  if (!bundle) {
    bundle = makeRoomContextBundle(client);
    _bundles2.set(client, bundle);
  }
  return bundle;
}
function getRoomExtrasForClient(client) {
  let extras = _extras2.get(client);
  if (!extras) {
    extras = makeRoomExtrasForClient(client);
    _extras2.set(client, extras);
  }
  return extras;
}
function makeRoomExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  function onMutationFailure(optimisticId, context, innerError) {
    var _a5, _b;
    store.optimisticUpdates.remove(optimisticId);
    if (innerError instanceof HttpError) {
      if (innerError.status === 403) {
        const detailedMessage = [
          innerError.message,
          (_a5 = innerError.details) == null ? void 0 : _a5.suggestion,
          (_b = innerError.details) == null ? void 0 : _b.docs
        ].filter(Boolean).join("\n");
        fancy_console_exports.error(detailedMessage);
      }
      client[kInternal].emitError(context, innerError);
    } else {
      throw innerError;
    }
  }
  const threadsPollersByRoomId = new DefaultMap(
    (roomId) => makePoller(
      async (signal) => {
        try {
          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);
        } catch (err) {
          fancy_console_exports.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.ROOM_THREADS_POLL_INTERVAL,
      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }
    )
  );
  const versionsPollersByRoomId = new DefaultMap(
    (roomId) => makePoller(
      async (signal) => {
        try {
          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);
        } catch (err) {
          fancy_console_exports.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.HISTORY_VERSIONS_POLL_INTERVAL,
      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }
    )
  );
  const roomSubscriptionSettingsPollersByRoomId = new DefaultMap(
    (roomId) => makePoller(
      async (signal) => {
        try {
          return await store.refreshRoomSubscriptionSettings(roomId, signal);
        } catch (err) {
          fancy_console_exports.warn(`Polling subscription settings for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL,
      { maxStaleTimeMs: config.ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME }
    )
  );
  return {
    store,
    onMutationFailure,
    pollThreadsForRoomId: (roomId) => {
      const threadsPoller = threadsPollersByRoomId.getOrCreate(roomId);
      if (threadsPoller) {
        threadsPoller.markAsStale();
        threadsPoller.pollNowIfStale();
      }
    },
    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(
      threadsPollersByRoomId
    ),
    getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),
    getOrCreateSubscriptionSettingsPollerForRoomId: roomSubscriptionSettingsPollersByRoomId.getOrCreate.bind(
      roomSubscriptionSettingsPollersByRoomId
    )
  };
}
function makeRoomContextBundle(client) {
  function RoomProvider_withImplicitLiveblocksProvider(props) {
    return (0, import_jsx_runtime3.jsx)(LiveblocksProviderWithClient, { client, allowNesting: true, children: (0, import_jsx_runtime3.jsx)(RoomProvider, { ...props }) });
  }
  const shared = createSharedContext(client);
  const bundle = {
    RoomContext,
    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
    useRoom,
    useStatus,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useCreateThread,
    useDeleteThread,
    useEditThreadMetadata,
    useMarkThreadAsResolved,
    useMarkThreadAsUnresolved,
    useSubscribeToThread,
    useUnsubscribeFromThread,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    useMarkThreadAsRead,
    useThreadSubscription,
    useAttachmentUrl,
    useHistoryVersions,
    useHistoryVersionData,
    useRoomSubscriptionSettings,
    useUpdateRoomSubscriptionSettings,
    ...shared.classic,
    suspense: {
      RoomContext,
      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
      useRoom,
      useStatus,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useCreateThread,
      useDeleteThread,
      useEditThreadMetadata,
      useMarkThreadAsResolved,
      useMarkThreadAsUnresolved,
      useSubscribeToThread,
      useUnsubscribeFromThread,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction,
      useMarkThreadAsRead,
      useThreadSubscription,
      useAttachmentUrl: useAttachmentUrlSuspense,
      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,
      useHistoryVersions: useHistoryVersionsSuspense,
      useRoomSubscriptionSettings: useRoomSubscriptionSettingsSuspense,
      useUpdateRoomSubscriptionSettings,
      ...shared.suspense
    }
  };
  return Object.defineProperty(bundle, kInternal, {
    enumerable: false
  });
}
function RoomProvider(props) {
  const client = useClient();
  const [cache] = (0, import_react8.useState)(
    () => /* @__PURE__ */ new Map()
  );
  const stableEnterRoom = (0, import_react8.useCallback)(
    (roomId, options) => {
      const cached = cache.get(roomId);
      if (cached) return cached;
      const rv = client.enterRoom(roomId, options);
      const origLeave = rv.leave;
      rv.leave = () => {
        origLeave();
        cache.delete(roomId);
      };
      cache.set(roomId, rv);
      return rv;
    },
    [client, cache]
  );
  return (0, import_jsx_runtime3.jsx)(
    RoomProviderInner,
    {
      ...props,
      stableEnterRoom
    }
  );
}
function RoomProviderInner(props) {
  const client = useClient();
  const { id: roomId, stableEnterRoom } = props;
  if (true) {
    if (!roomId) {
      throw new Error(
        "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
      );
    }
    if (typeof roomId !== "string") {
      throw new Error("RoomProvider id property should be a string.");
    }
    const majorReactVersion = parseInt(import_react8.version) || 1;
    const requiredVersion = 18;
    errorIf(
      majorReactVersion < requiredVersion,
      `React ${requiredVersion} or higher is required (you’re on ${import_react8.version})`
    );
  }
  const frozenProps = useInitial(
    {
      initialPresence: props.initialPresence,
      initialStorage: props.initialStorage,
      autoConnect: props.autoConnect ?? typeof window !== "undefined"
    },
    roomId
  );
  const [{ room }, setRoomLeavePair] = (0, import_react8.useState)(
    () => stableEnterRoom(roomId, {
      ...frozenProps,
      autoConnect: false
      // Deliberately using false here on the first render, see below
    })
  );
  (0, import_react8.useEffect)(() => {
    const { store } = getRoomExtrasForClient(client);
    async function handleCommentEvent(message) {
      if (message.type === ServerMsgCode.THREAD_DELETED) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const info = await room.getThread(message.threadId);
      if (!info.thread) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const {
        thread,
        inboxNotification: maybeNotification,
        subscription: maybeSubscription
      } = info;
      const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);
      switch (message.type) {
        case ServerMsgCode.COMMENT_EDITED:
        case ServerMsgCode.THREAD_METADATA_UPDATED:
        case ServerMsgCode.THREAD_UPDATED:
        case ServerMsgCode.COMMENT_REACTION_ADDED:
        case ServerMsgCode.COMMENT_REACTION_REMOVED:
        case ServerMsgCode.COMMENT_DELETED:
          if (!existingThread) break;
          store.updateThreadifications(
            [thread],
            maybeNotification ? [maybeNotification] : [],
            maybeSubscription ? [maybeSubscription] : []
          );
          break;
        case ServerMsgCode.COMMENT_CREATED:
          store.updateThreadifications(
            [thread],
            maybeNotification ? [maybeNotification] : [],
            maybeSubscription ? [maybeSubscription] : []
          );
          break;
        default:
          break;
      }
    }
    return room.events.comments.subscribe(
      (message) => void handleCommentEvent(message)
    );
  }, [client, room]);
  (0, import_react8.useEffect)(() => {
    const pair = stableEnterRoom(roomId, frozenProps);
    setRoomLeavePair(pair);
    const { room: room2, leave } = pair;
    if (frozenProps.autoConnect) {
      room2.connect();
    }
    return () => {
      leave();
    };
  }, [roomId, frozenProps, stableEnterRoom]);
  return (0, import_jsx_runtime3.jsx)(RoomContext.Provider, { value: room, children: props.children });
}
function useRoom(options) {
  const room = useRoomOrNull();
  if (room === null && !(options == null ? void 0 : options.allowOutsideRoom)) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return room;
}
function useStatus() {
  const room = useRoom();
  const subscribe = room.events.status.subscribe;
  const getSnapshot = room.getStatus;
  const getServerSnapshot = room.getStatus;
  return (0, import_react8.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);
}
function useReportTextEditor(editor, rootKey) {
  const isReported = (0, import_react8.useRef)(false);
  const room = useRoom();
  (0, import_react8.useEffect)(() => {
    if (isReported.current) {
      return;
    }
    const unsubscribe = room.events.status.subscribe((status) => {
      if (status === "connected" && !isReported.current) {
        isReported.current = true;
        void room[kInternal].reportTextEditor(editor, rootKey);
      }
    });
    return unsubscribe;
  }, [room, editor, rootKey]);
}
function useYjsProvider() {
  const room = useRoom();
  const subscribe = (0, import_react8.useCallback)(
    (onStoreChange) => {
      return room[kInternal].yjsProviderDidChange.subscribe(onStoreChange);
    },
    [room]
  );
  const getSnapshot = (0, import_react8.useCallback)(() => {
    return room[kInternal].getYjsProvider();
  }, [room]);
  return (0, import_react8.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);
}
function useCreateTextMention() {
  const room = useRoom();
  return (0, import_react8.useCallback)(
    (mentionId, mention) => {
      room[kInternal].createTextMention(mentionId, mention).catch((err) => {
        fancy_console_exports.error(
          `Cannot create text mention for mention '${mentionId}'`,
          err
        );
      });
    },
    [room]
  );
}
function useDeleteTextMention() {
  const room = useRoom();
  return (0, import_react8.useCallback)(
    (mentionId) => {
      room[kInternal].deleteTextMention(mentionId).catch((err) => {
        fancy_console_exports.error(`Cannot delete text mention '${mentionId}'`, err);
      });
    },
    [room]
  );
}
function useResolveMentionSuggestions() {
  const client = useClient();
  return client[kInternal].resolveMentionSuggestions;
}
function useMentionSuggestionsCache() {
  const client = useClient();
  return client[kInternal].mentionSuggestionsCache;
}
function useBroadcastEvent() {
  const room = useRoom();
  return (0, import_react8.useCallback)(
    (event, options = { shouldQueueEventIfNotReady: false }) => {
      room.broadcastEvent(event, options);
    },
    [room]
  );
}
function useOthersListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  (0, import_react8.useEffect)(
    () => room.events.others.subscribe((event) => savedCallback.current(event)),
    [room, savedCallback]
  );
}
function useLostConnectionListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  (0, import_react8.useEffect)(
    () => room.events.lostConnection.subscribe(
      (event) => savedCallback.current(event)
    ),
    [room, savedCallback]
  );
}
function useEventListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  (0, import_react8.useEffect)(() => {
    const listener = (eventData) => {
      savedCallback.current(eventData);
    };
    return room.events.customEvent.subscribe(listener);
  }, [room, savedCallback]);
}
function useHistory() {
  return useRoom().history;
}
function useUndo() {
  return useHistory().undo;
}
function useRedo() {
  return useHistory().redo;
}
function useCanUndo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canUndo = room.history.canUndo;
  return (0, import_react8.useSyncExternalStore)(subscribe, canUndo, canUndo);
}
function useCanRedo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canRedo = room.history.canRedo;
  return (0, import_react8.useSyncExternalStore)(subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.self.subscribe;
  const getSnapshot = room.getSelf;
  const selector = maybeSelector ?? identity3;
  const wrappedSelector = (0, import_react8.useCallback)(
    (me) => me !== null ? selector(me) : null,
    [selector]
  );
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMyPresence() {
  const room = useRoom();
  const subscribe = room.events.myPresence.subscribe;
  const getSnapshot = room.getPresence;
  const presence = (0, import_react8.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);
  const setPresence = room.updatePresence;
  return [presence, setPresence];
}
function useUpdateMyPresence() {
  return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.others.subscribe;
  const getSnapshot = room.getOthers;
  const getServerSnapshot = alwaysEmptyList;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    selector ?? identity3,
    isEqual
  );
}
function useOthersMapped(itemSelector, itemIsEqual) {
  const wrappedSelector = (0, import_react8.useCallback)(
    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),
    [itemSelector]
  );
  const wrappedIsEqual = (0, import_react8.useCallback)(
    (a, b) => {
      const eq = itemIsEqual ?? Object.is;
      return a.length === b.length && a.every((atuple, index) => {
        const btuple = b[index];
        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
      });
    },
    [itemIsEqual]
  );
  return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
  return useOthers(selectorFor_useOthersConnectionIds, shallow);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
  const wrappedSelector = (0, import_react8.useCallback)(
    (others) => {
      const other2 = others.find((other3) => other3.connectionId === connectionId);
      return other2 !== void 0 ? selector(other2) : NOT_FOUND;
    },
    [connectionId, selector]
  );
  const wrappedIsEqual = (0, import_react8.useCallback)(
    (prev, curr) => {
      if (prev === NOT_FOUND || curr === NOT_FOUND) {
        return prev === curr;
      }
      const eq = isEqual ?? Object.is;
      return eq(prev, curr);
    },
    [isEqual]
  );
  const other = useOthers(wrappedSelector, wrappedIsEqual);
  if (other === NOT_FOUND) {
    throw new Error(
      `No such other user with connection id ${connectionId} exists`
    );
  }
  return other;
}
function useMutableStorageRoot() {
  const room = useRoom();
  const subscribe = room.events.storageDidLoad.subscribeOnce;
  const getSnapshot = room.getStorageSnapshot;
  const getServerSnapshot = alwaysNull;
  return (0, import_react8.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
  return [useMutableStorageRoot()];
}
function useStorage(selector, isEqual) {
  const room = useRoom();
  const rootOrNull = useMutableStorageRoot();
  const wrappedSelector = (0, import_react8.useCallback)(
    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
    [selector]
  );
  const subscribe = (0, import_react8.useCallback)(
    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,
    [room, rootOrNull]
  );
  const getSnapshot = (0, import_react8.useCallback)(() => {
    if (rootOrNull === null) {
      return null;
    } else {
      const root = rootOrNull;
      const imm = root.toImmutable();
      return imm;
    }
  }, [rootOrNull]);
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMutation(callback, deps) {
  const room = useRoom();
  return (0, import_react8.useMemo)(
    () => {
      return (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        room.batch(
          () => (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            callback(
              makeMutationContext(room),
              ...args
            )
          )
        )
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [room, ...deps]
  );
}
function useThreads(options = {}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);
  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
  const poller = getOrCreateThreadsPollerForRoomId(room.id);
  (0, import_react8.useEffect)(
    () => void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  (0, import_react8.useEffect)(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  const result = useSignal(
    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, result);
  return result;
}
function useCreateThread() {
  return useCreateRoomThread(useRoom().id);
}
function useCreateRoomThread(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (options) => {
      const body = options.body;
      const metadata = options.metadata ?? {};
      const attachments = options.attachments;
      const threadId = createThreadId();
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const newComment = {
        id: commentId,
        threadId,
        roomId,
        createdAt,
        type: "comment",
        userId: getCurrentUserId(client),
        body,
        reactions: [],
        attachments: attachments ?? []
      };
      const newThread = {
        id: threadId,
        type: "thread",
        createdAt,
        updatedAt: createdAt,
        roomId,
        metadata,
        comments: [newComment],
        resolved: false
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "create-thread",
        thread: newThread,
        roomId
      });
      const attachmentIds = attachments == null ? void 0 : attachments.map((attachment) => attachment.id);
      client[kInternal].httpClient.createThread({
        roomId,
        threadId,
        commentId,
        body,
        metadata,
        attachmentIds
      }).then(
        (thread) => {
          store.createThread(optimisticId, thread);
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "CREATE_THREAD_ERROR",
            roomId,
            threadId,
            commentId,
            body,
            metadata
          },
          err
        )
      );
      return newThread;
    },
    [client, roomId]
  );
}
function useDeleteThread() {
  return useDeleteRoomThread(useRoom().id);
}
function useDeleteRoomThread(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (threadId) => {
      var _a5, _b;
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const userId = getCurrentUserId(client);
      const existing = store.outputs.threads.get().get(threadId);
      if (((_b = (_a5 = existing == null ? void 0 : existing.comments) == null ? void 0 : _a5[0]) == null ? void 0 : _b.userId) !== userId) {
        throw new Error("Only the thread creator can delete the thread");
      }
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-thread",
        roomId,
        threadId,
        deletedAt: /* @__PURE__ */ new Date()
      });
      client[kInternal].httpClient.deleteThread({ roomId, threadId }).then(
        () => {
          store.deleteThread(threadId, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "DELETE_THREAD_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useEditThreadMetadata() {
  return useEditRoomThreadMetadata(useRoom().id);
}
function useEditRoomThreadMetadata(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (options) => {
      if (!options.metadata) {
        return;
      }
      const threadId = options.threadId;
      const metadata = options.metadata;
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "edit-thread-metadata",
        metadata,
        threadId,
        updatedAt
      });
      client[kInternal].httpClient.editThreadMetadata({ roomId, threadId, metadata }).then(
        (metadata2) => (
          // Replace the optimistic update by the real thing
          store.patchThread(threadId, optimisticId, { metadata: metadata2 }, updatedAt)
        ),
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "EDIT_THREAD_METADATA_ERROR",
            roomId,
            threadId,
            metadata
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useCreateComment() {
  return useCreateRoomComment(useRoom().id);
}
function useCreateRoomComment(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    ({ threadId, body, attachments }) => {
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const comment = {
        id: commentId,
        threadId,
        roomId,
        type: "comment",
        createdAt,
        userId: getCurrentUserId(client),
        body,
        reactions: [],
        attachments: attachments ?? []
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "create-comment",
        comment
      });
      const attachmentIds = attachments == null ? void 0 : attachments.map((attachment) => attachment.id);
      client[kInternal].httpClient.createComment({ roomId, threadId, commentId, body, attachmentIds }).then(
        (newComment) => {
          store.createComment(newComment, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "CREATE_COMMENT_ERROR",
            roomId,
            threadId,
            commentId,
            body
          },
          err
        )
      );
      return comment;
    },
    [client, roomId]
  );
}
function useEditComment() {
  return useEditRoomComment(useRoom().id);
}
function useEditRoomComment(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    ({ threadId, commentId, body, attachments }) => {
      const editedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);
      if (existing === void 0) {
        fancy_console_exports.warn(
          `Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`
        );
        return;
      }
      const comment = existing.comments.find(
        (comment2) => comment2.id === commentId
      );
      if (comment === void 0 || comment.deletedAt !== void 0) {
        fancy_console_exports.warn(
          `Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`
        );
        return;
      }
      const optimisticId = store.optimisticUpdates.add({
        type: "edit-comment",
        comment: {
          ...comment,
          editedAt,
          body,
          attachments: attachments ?? []
        }
      });
      const attachmentIds = attachments == null ? void 0 : attachments.map((attachment) => attachment.id);
      client[kInternal].httpClient.editComment({ roomId, threadId, commentId, body, attachmentIds }).then(
        (editedComment) => {
          store.editComment(threadId, optimisticId, editedComment);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "EDIT_COMMENT_ERROR", roomId, threadId, commentId, body },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useDeleteComment() {
  return useDeleteRoomComment(useRoom().id);
}
function useDeleteRoomComment(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    ({ threadId, commentId }) => {
      const deletedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-comment",
        threadId,
        commentId,
        deletedAt,
        roomId
      });
      client[kInternal].httpClient.deleteComment({ roomId, threadId, commentId }).then(
        () => {
          store.deleteComment(threadId, optimisticId, commentId, deletedAt);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "DELETE_COMMENT_ERROR", roomId, threadId, commentId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useAddReaction() {
  return useAddRoomCommentReaction(useRoom().id);
}
function useAddRoomCommentReaction(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    ({ threadId, commentId, emoji }) => {
      const createdAt = /* @__PURE__ */ new Date();
      const userId = getCurrentUserId(client);
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "add-reaction",
        threadId,
        commentId,
        reaction: {
          emoji,
          userId,
          createdAt
        }
      });
      client[kInternal].httpClient.addReaction({ roomId, threadId, commentId, emoji }).then(
        (addedReaction) => {
          store.addReaction(
            threadId,
            optimisticId,
            commentId,
            addedReaction,
            createdAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "ADD_REACTION_ERROR",
            roomId,
            threadId,
            commentId,
            emoji
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useRemoveReaction() {
  return useRemoveRoomCommentReaction(useRoom().id);
}
function useRemoveRoomCommentReaction(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    ({ threadId, commentId, emoji }) => {
      const userId = getCurrentUserId(client);
      const removedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "remove-reaction",
        threadId,
        commentId,
        emoji,
        userId,
        removedAt
      });
      client[kInternal].httpClient.removeReaction({ roomId, threadId, commentId, emoji }).then(
        () => {
          store.removeReaction(
            threadId,
            optimisticId,
            commentId,
            emoji,
            userId,
            removedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "REMOVE_REACTION_ERROR",
            roomId,
            threadId,
            commentId,
            emoji
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsRead() {
  return useMarkRoomThreadAsRead(useRoom().id);
}
function useMarkRoomThreadAsRead(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (threadId) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const inboxNotification = Object.values(
        store.outputs.notifications.get().notificationsById
      ).find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      if (!inboxNotification) return;
      const now = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId: inboxNotification.id,
        readAt: now
      });
      client[kInternal].httpClient.markRoomInboxNotificationAsRead({
        roomId,
        inboxNotificationId: inboxNotification.id
      }).then(
        () => {
          store.markInboxNotificationRead(
            inboxNotification.id,
            now,
            optimisticId
          );
        },
        (err) => {
          onMutationFailure(
            optimisticId,
            {
              type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
              roomId,
              inboxNotificationId: inboxNotification.id
            },
            err
          );
          return;
        }
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsResolved() {
  return useMarkRoomThreadAsResolved(useRoom().id);
}
function useMarkRoomThreadAsResolved(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-thread-as-resolved",
        threadId,
        updatedAt
      });
      client[kInternal].httpClient.markThreadAsResolved({ roomId, threadId }).then(
        () => {
          store.patchThread(
            threadId,
            optimisticId,
            { resolved: true },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "MARK_THREAD_AS_RESOLVED_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsUnresolved() {
  return useMarkRoomThreadAsUnresolved(useRoom().id);
}
function useMarkRoomThreadAsUnresolved(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-thread-as-unresolved",
        threadId,
        updatedAt
      });
      client[kInternal].httpClient.markThreadAsUnresolved({ roomId, threadId }).then(
        () => {
          store.patchThread(
            threadId,
            optimisticId,
            { resolved: false },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "MARK_THREAD_AS_UNRESOLVED_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useSubscribeToThread() {
  return useSubscribeToRoomThread(useRoom().id);
}
function useSubscribeToRoomThread(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (threadId) => {
      const subscribedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "subscribe-to-thread",
        threadId,
        subscribedAt
      });
      client[kInternal].httpClient.subscribeToThread({ roomId, threadId }).then(
        (subscription) => {
          store.createSubscription(subscription, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "SUBSCRIBE_TO_THREAD_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useUnsubscribeFromThread() {
  return useUnsubscribeFromRoomThread(useRoom().id);
}
function useUnsubscribeFromRoomThread(roomId) {
  const client = useClient();
  return (0, import_react8.useCallback)(
    (threadId) => {
      const unsubscribedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "unsubscribe-from-thread",
        threadId,
        unsubscribedAt
      });
      client[kInternal].httpClient.unsubscribeFromThread({ roomId, threadId }).then(
        () => {
          store.deleteSubscription(
            getSubscriptionKey("thread", threadId),
            optimisticId
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "UNSUBSCRIBE_FROM_THREAD_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useThreadSubscription(threadId) {
  return useRoomThreadSubscription(useRoom().id, threadId);
}
function useRoomThreadSubscription(roomId, threadId) {
  const client = useClient();
  const { store } = getRoomExtrasForClient(client);
  const subscriptionKey = (0, import_react8.useMemo)(
    () => getSubscriptionKey("thread", threadId),
    [threadId]
  );
  const subscribeToThread = useSubscribeToRoomThread(roomId);
  const unsubscribeFromThread = useUnsubscribeFromRoomThread(roomId);
  const subscribe = (0, import_react8.useCallback)(
    () => subscribeToThread(threadId),
    [subscribeToThread, threadId]
  );
  const unsubscribe = (0, import_react8.useCallback)(
    () => unsubscribeFromThread(threadId),
    [unsubscribeFromThread, threadId]
  );
  const signal = store.outputs.threadSubscriptions;
  const selector = (0, import_react8.useCallback)(
    (state) => {
      const subscription = state.subscriptions[subscriptionKey];
      const notification = state.notifications.find(
        (inboxNotification) => inboxNotification.kind === "thread" && inboxNotification.threadId === threadId
      );
      if (subscription === void 0) {
        return { status: "not-subscribed", subscribe, unsubscribe };
      }
      return {
        status: "subscribed",
        unreadSince: (notification == null ? void 0 : notification.readAt) ?? null,
        subscribe,
        unsubscribe
      };
    },
    [subscriptionKey, threadId, subscribe, unsubscribe]
  );
  return useSignal(signal, selector, shallow);
}
function useRoomSubscriptionSettings() {
  const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateSubscriptionSettingsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateSubscriptionSettingsPollerForRoomId(room.id);
  (0, import_react8.useEffect)(
    () => void store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  (0, import_react8.useEffect)(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  const settings = useSignal(
    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).signal
  );
  return (0, import_react8.useMemo)(() => {
    return [settings, updateRoomSubscriptionSettings];
  }, [settings, updateRoomSubscriptionSettings]);
}
function useRoomSubscriptionSettingsSuspense() {
  ensureNotServerSide();
  const client = useClient();
  const store = getRoomExtrasForClient(client).store;
  const room = useRoom();
  use(
    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded()
  );
  const [settings, updateRoomSubscriptionSettings] = useRoomSubscriptionSettings();
  assert(!settings.error, "Did not expect error");
  assert(!settings.isLoading, "Did not expect loading");
  return (0, import_react8.useMemo)(() => {
    return [settings, updateRoomSubscriptionSettings];
  }, [settings, updateRoomSubscriptionSettings]);
}
function useHistoryVersionData(versionId) {
  const [state, setState] = (0, import_react8.useState)({
    isLoading: true
  });
  const room = useRoom();
  (0, import_react8.useEffect)(() => {
    setState({ isLoading: true });
    const load = async () => {
      try {
        const response = await room[kInternal].getTextVersion(versionId);
        const buffer = await response.arrayBuffer();
        const data = new Uint8Array(buffer);
        setState({
          isLoading: false,
          data
        });
      } catch (error) {
        setState({
          isLoading: false,
          error: error instanceof Error ? error : new Error(
            "An unknown error occurred while loading this version"
          )
        });
      }
    };
    void load();
  }, [room, versionId]);
  return state;
}
function useHistoryVersions() {
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateVersionsPollerForRoomId(room.id);
  (0, import_react8.useEffect)(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  (0, import_react8.useEffect)(
    () => void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);
}
function useHistoryVersionsSuspense() {
  ensureNotServerSide();
  const client = useClient();
  const room = useRoom();
  const store = getRoomExtrasForClient(client).store;
  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());
  const result = useHistoryVersions();
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useUpdateRoomSubscriptionSettings() {
  const client = useClient();
  const room = useRoom();
  return (0, import_react8.useCallback)(
    (settings) => {
      const { store, onMutationFailure, pollThreadsForRoomId } = getRoomExtrasForClient(client);
      const userId = getCurrentUserId(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "update-room-subscription-settings",
        roomId: room.id,
        userId,
        settings
      });
      room.updateSubscriptionSettings(settings).then(
        (udpatedSettings) => {
          store.updateRoomSubscriptionSettings(
            room.id,
            optimisticId,
            udpatedSettings
          );
          if (settings.threads) {
            pollThreadsForRoomId(room.id);
          }
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR",
            roomId: room.id
          },
          err
        )
      );
    },
    [client, room]
  );
}
function useSuspendUntilPresenceReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useSelf(
    selector,
    isEqual
  );
}
function useOthersSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOthers(
    selector,
    isEqual
  );
}
function useOthersConnectionIdsSuspense() {
  useSuspendUntilPresenceReady();
  return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
  useSuspendUntilPresenceReady();
  return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
  useSuspendUntilStorageReady();
  return useStorage(
    selector,
    isEqual
  );
}
function useThreadsSuspense(options = {}) {
  ensureNotServerSide();
  const client = useClient();
  const room = useRoom();
  const { store } = getRoomExtrasForClient(client);
  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());
  const result = useThreads(options);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function selectorFor_useAttachmentUrl(state) {
  if (state === void 0 || (state == null ? void 0 : state.isLoading)) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  assert(state.data !== void 0, "Unexpected missing attachment URL");
  return {
    isLoading: false,
    url: state.data
  };
}
function useAttachmentUrl(attachmentId) {
  const room = useRoom();
  return useRoomAttachmentUrl(attachmentId, room.id);
}
function useRoomAttachmentUrl(attachmentId, roomId) {
  const client = useClient();
  const store = client[kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);
  const getAttachmentUrlState = (0, import_react8.useCallback)(
    () => store.getItemState(attachmentId),
    [store, attachmentId]
  );
  (0, import_react8.useEffect)(() => {
    void store.enqueue(attachmentId);
  }, [store, attachmentId]);
  return useSyncExternalStoreWithSelector(
    store.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState,
    selectorFor_useAttachmentUrl,
    shallow
  );
}
function useAttachmentUrlSuspense(attachmentId) {
  const room = useRoom();
  const { attachmentUrlsStore } = room[kInternal];
  const getAttachmentUrlState = (0, import_react8.useCallback)(
    () => attachmentUrlsStore.getItemState(attachmentId),
    [attachmentUrlsStore, attachmentId]
  );
  const attachmentUrlState = getAttachmentUrlState();
  if (!attachmentUrlState || attachmentUrlState.isLoading) {
    throw attachmentUrlsStore.enqueue(attachmentId);
  }
  if (attachmentUrlState.error) {
    throw attachmentUrlState.error;
  }
  const state = (0, import_react8.useSyncExternalStore)(
    attachmentUrlsStore.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  return {
    isLoading: false,
    url: state.data,
    error: void 0
  };
}
function useRoomPermissions(roomId) {
  const client = useClient();
  const store = getRoomExtrasForClient(client).store;
  return useSignal(store.permissionHints.getPermissionForRoomΣ(roomId));
}
function createRoomContext(client) {
  return getOrCreateRoomContextBundle(client);
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useThreads = useThreads;
var _useRoomSubscriptionSettings = useRoomSubscriptionSettings;
var _useHistoryVersions = useHistoryVersions;
var _useOther = useOther;
function _useOthers(...args) {
  return useOthers(...args);
}
var _useStorage = useStorage;
function _useSelf(...args) {
  return useSelf(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;

// node_modules/@liveblocks/react/dist/index.js
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);

export {
  PKG_NAME,
  PKG_VERSION,
  PKG_FORMAT,
  ClientSideSuspense,
  ClientContext,
  useClientOrNull,
  useClient,
  RoomContext,
  useLatest,
  RegisterAiKnowledge,
  RegisterAiTool,
  useSyncExternalStoreWithSelector,
  useSignal,
  getUmbrellaStoreForClient,
  useCreateAiChat,
  useDeleteAiChat,
  useSendAiMessage,
  LiveblocksProvider,
  createLiveblocksContext,
  useInboxNotifications,
  useMarkAllInboxNotificationsAsRead,
  useMarkInboxNotificationAsRead,
  useDeleteAllInboxNotifications,
  useDeleteInboxNotification,
  useUnreadInboxNotificationsCount,
  useNotificationSettings,
  useUpdateNotificationSettings,
  useRoomInfo,
  useGroupInfo,
  _useInboxNotificationThread,
  _useUser,
  _useUserThreads_experimental,
  _useAiChats,
  _useAiChat,
  _useAiChatMessages,
  useSyncStatus,
  useErrorListener,
  useStatus,
  useReportTextEditor,
  useYjsProvider,
  useCreateTextMention,
  useDeleteTextMention,
  useResolveMentionSuggestions,
  useMentionSuggestionsCache,
  useLostConnectionListener,
  useHistory,
  useUndo,
  useRedo,
  useCanUndo,
  useCanRedo,
  useOthersConnectionIds,
  useCreateRoomThread,
  useCreateComment,
  useCreateRoomComment,
  useEditComment,
  useEditRoomComment,
  useDeleteComment,
  useDeleteRoomComment,
  useAddRoomCommentReaction,
  useRemoveReaction,
  useRemoveRoomCommentReaction,
  useMarkThreadAsRead,
  useMarkRoomThreadAsRead,
  useMarkThreadAsResolved,
  useMarkRoomThreadAsResolved,
  useMarkThreadAsUnresolved,
  useMarkRoomThreadAsUnresolved,
  useSubscribeToThread,
  useUnsubscribeFromThread,
  useThreadSubscription,
  useRoomThreadSubscription,
  useHistoryVersionData,
  useUpdateRoomSubscriptionSettings,
  useAttachmentUrl,
  useRoomAttachmentUrl,
  useRoomPermissions,
  createRoomContext,
  _RoomProvider,
  _useBroadcastEvent,
  _useOthersListener,
  _useRoom,
  _useIsInsideRoom,
  _useAddReaction,
  _useMutation,
  _useCreateThread,
  _useDeleteThread,
  _useEditThreadMetadata,
  _useEventListener,
  _useMyPresence,
  _useOthersMapped,
  _useThreads,
  _useRoomSubscriptionSettings,
  _useHistoryVersions,
  _useOther,
  _useOthers,
  _useStorage,
  _useSelf,
  _useStorageRoot,
  _useUpdateMyPresence
};
//# sourceMappingURL=chunk-6EBPODIK.js.map
