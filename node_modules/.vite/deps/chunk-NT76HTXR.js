import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-4B2QHNJT.js";

// node_modules/@liveblocks/core/dist/index.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var PKG_NAME = "@liveblocks/core";
var PKG_VERSION = "3.7.1";
var PKG_FORMAT = "esm";
var g = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var crossLinkedDocs = "https://liveblocks.io/docs/errors/cross-linked";
var dupesDocs = "https://liveblocks.io/docs/errors/dupes";
var SPACE = " ";
function error(msg) {
  if (false) {
    console.error(msg);
  } else {
    throw new Error(msg);
  }
}
function detectDupes(pkgName, pkgVersion, pkgFormat) {
  const pkgId = Symbol.for(pkgName);
  const pkgBuildInfo = pkgFormat ? `${pkgVersion || "dev"} (${pkgFormat})` : pkgVersion || "dev";
  if (!g[pkgId]) {
    g[pkgId] = pkgBuildInfo;
  } else if (g[pkgId] === pkgBuildInfo) {
  } else {
    const msg = [
      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,
      "",
      "Conflicts:",
      `- ${pkgName} ${g[pkgId]} (already loaded)`,
      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`
    ].join("\n");
    error(msg);
  }
  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {
    error(
      [
        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,
        "",
        "Conflicts:",
        `- ${PKG_NAME} is at ${PKG_VERSION}`,
        `- ${pkgName} is at ${pkgVersion}`,
        "",
        "Always upgrade all Liveblocks packages to the same version number."
      ].join("\n")
    );
  }
}
function makeEventSource() {
  const _observers = /* @__PURE__ */ new Set();
  function subscribe(callback) {
    _observers.add(callback);
    return () => _observers.delete(callback);
  }
  function subscribeOnce(callback) {
    const unsub = subscribe((event) => {
      unsub();
      return callback(event);
    });
    return unsub;
  }
  async function waitUntil(predicate) {
    let unsub;
    return new Promise((res) => {
      unsub = subscribe((event) => {
        if (predicate === void 0 || predicate(event)) {
          res(event);
        }
      });
    }).finally(() => unsub == null ? void 0 : unsub());
  }
  function notify(event) {
    let called = false;
    for (const callback of _observers) {
      callback(event);
      called = true;
    }
    return called;
  }
  function count() {
    return _observers.size;
  }
  return {
    // Private/internal control over event emission
    notify,
    subscribe,
    subscribeOnce,
    count,
    waitUntil,
    dispose() {
      _observers.clear();
    },
    // Publicly exposable subscription API
    observable: {
      subscribe,
      subscribeOnce,
      waitUntil
    }
  };
}
function makeBufferableEventSource() {
  const eventSource2 = makeEventSource();
  let _buffer = null;
  function pause() {
    _buffer = [];
  }
  function unpause() {
    if (_buffer === null) {
      return;
    }
    for (const event of _buffer) {
      eventSource2.notify(event);
    }
    _buffer = null;
  }
  function notifyOrBuffer(event) {
    if (_buffer !== null) {
      _buffer.push(event);
      return false;
    } else {
      return eventSource2.notify(event);
    }
  }
  return {
    ...eventSource2,
    notify: notifyOrBuffer,
    pause,
    unpause,
    dispose() {
      eventSource2.dispose();
      if (_buffer !== null) {
        _buffer.length = 0;
      }
    }
  };
}
var freeze = false ? (
  /* istanbul ignore next */
  ((x) => x)
) : Object.freeze;
function raise(msg) {
  throw new Error(msg);
}
function entries(obj) {
  return Object.entries(obj);
}
function keys(obj) {
  return Object.keys(obj);
}
function values(obj) {
  return Object.values(obj);
}
function create(obj, descriptors) {
  if (typeof descriptors !== "undefined") {
    return Object.create(obj, descriptors);
  }
  return Object.create(obj);
}
function tryParseJson(rawMessage) {
  try {
    return JSON.parse(rawMessage);
  } catch (e) {
    return void 0;
  }
}
function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}
function b64decode(b64value) {
  try {
    const formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
    const decodedValue = decodeURIComponent(
      atob(formattedValue).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join("")
    );
    return decodedValue;
  } catch (err) {
    return atob(b64value);
  }
}
function compact(items) {
  return items.filter(
    (item) => item !== null && item !== void 0
  );
}
function compactObject(obj) {
  const newObj = { ...obj };
  Object.keys(obj).forEach((k) => {
    const key = k;
    if (newObj[key] === void 0) {
      delete newObj[key];
    }
  });
  return newObj;
}
function wait(millis) {
  return new Promise((res) => setTimeout(res, millis));
}
async function withTimeout(promise, millis, errmsg) {
  let timerID;
  const timer$ = new Promise((_, reject) => {
    timerID = setTimeout(() => {
      reject(new Error(errmsg));
    }, millis);
  });
  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));
}
function memoizeOnSuccess(factoryFn) {
  let cached = null;
  return () => {
    if (cached === null) {
      cached = factoryFn().catch((err) => {
        setTimeout(() => {
          cached = null;
        }, 5e3);
        throw err;
      });
    }
    return cached;
  };
}
function findLastIndex(arr, predicate) {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (predicate(arr[i], i, arr)) {
      return i;
    }
  }
  return -1;
}
var kSinks = Symbol("kSinks");
var kTrigger = Symbol("kTrigger");
var signalsToTrigger = null;
var trackedReads = null;
function batch(callback) {
  if (signalsToTrigger !== null) {
    callback();
    return;
  }
  signalsToTrigger = /* @__PURE__ */ new Set();
  try {
    callback();
  } finally {
    for (const signal of signalsToTrigger) {
      signal[kTrigger]();
    }
    signalsToTrigger = null;
  }
}
function enqueueTrigger(signal) {
  if (!signalsToTrigger) raise("Expected to be in an active batch");
  signalsToTrigger.add(signal);
}
function merge(target, patch) {
  let updated = false;
  const newValue = { ...target };
  Object.keys(patch).forEach((k) => {
    const key = k;
    const val = patch[key];
    if (newValue[key] !== val) {
      if (val === void 0) {
        delete newValue[key];
      } else {
        newValue[key] = val;
      }
      updated = true;
    }
  });
  return updated ? newValue : target;
}
var _a, _eventSource, _b;
var AbstractSignal = (_b = class {
  constructor(equals) {
    /** @internal */
    __publicField(this, "equals");
    __privateAdd(this, _eventSource);
    /** @internal */
    __publicField(this, _a);
    this.equals = equals ?? Object.is;
    __privateSet(this, _eventSource, makeEventSource());
    this[kSinks] = /* @__PURE__ */ new Set();
    this.get = this.get.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.subscribeOnce = this.subscribeOnce.bind(this);
  }
  dispose() {
    __privateGet(this, _eventSource).dispose();
    __privateSet(this, _eventSource, "(disposed)");
    this.equals = "(disposed)";
  }
  get hasWatchers() {
    if (__privateGet(this, _eventSource).count() > 0) return true;
    for (const sink of this[kSinks]) {
      if (sink.hasWatchers) {
        return true;
      }
    }
    return false;
  }
  [(_a = kSinks, kTrigger)]() {
    __privateGet(this, _eventSource).notify();
    for (const sink of this[kSinks]) {
      enqueueTrigger(sink);
    }
  }
  subscribe(callback) {
    if (__privateGet(this, _eventSource).count() === 0) {
      this.get();
    }
    return __privateGet(this, _eventSource).subscribe(callback);
  }
  subscribeOnce(callback) {
    const unsub = this.subscribe(() => {
      unsub();
      return callback();
    });
    return unsub;
  }
  waitUntil() {
    throw new Error("waitUntil not supported on Signals");
  }
  markSinksDirty() {
    for (const sink of this[kSinks]) {
      sink.markDirty();
    }
  }
  addSink(sink) {
    this[kSinks].add(sink);
  }
  removeSink(sink) {
    this[kSinks].delete(sink);
  }
  asReadonly() {
    return this;
  }
}, _eventSource = new WeakMap(), _b);
var _value, _a2;
var Signal = (_a2 = class extends AbstractSignal {
  constructor(value, equals) {
    super(equals);
    __privateAdd(this, _value);
    __privateSet(this, _value, freeze(value));
  }
  dispose() {
    super.dispose();
    __privateSet(this, _value, "(disposed)");
  }
  get() {
    trackedReads == null ? void 0 : trackedReads.add(this);
    return __privateGet(this, _value);
  }
  set(newValue) {
    batch(() => {
      if (typeof newValue === "function") {
        newValue = newValue(__privateGet(this, _value));
      }
      if (!this.equals(__privateGet(this, _value), newValue)) {
        __privateSet(this, _value, freeze(newValue));
        this.markSinksDirty();
        enqueueTrigger(this);
      }
    });
  }
}, _value = new WeakMap(), _a2);
var PatchableSignal = class extends Signal {
  constructor(data) {
    super(freeze(compactObject(data)));
  }
  set() {
    throw new Error("Don't call .set() directly, use .patch()");
  }
  /**
   * Patches the current object.
   */
  patch(patch) {
    super.set((old) => merge(old, patch));
  }
};
var INITIAL = Symbol();
var _prevValue, _dirty, _sources, _deps, _transform, __DerivedSignal_instances, recompute_fn, _a3;
var DerivedSignal = (_a3 = class extends AbstractSignal {
  constructor(deps, transform, equals) {
    super(equals);
    __privateAdd(this, __DerivedSignal_instances);
    __privateAdd(this, _prevValue);
    __privateAdd(this, _dirty);
    // When true, the value in #value may not be up-to-date and needs re-checking
    __privateAdd(this, _sources);
    __privateAdd(this, _deps);
    __privateAdd(this, _transform);
    __privateSet(this, _dirty, true);
    __privateSet(this, _prevValue, INITIAL);
    __privateSet(this, _deps, deps);
    __privateSet(this, _sources, /* @__PURE__ */ new Set());
    __privateSet(this, _transform, transform);
  }
  // prettier-ignore
  static from(...args) {
    const last = args.pop();
    if (typeof last !== "function")
      raise("Invalid .from() call, last argument expected to be a function");
    if (typeof args[args.length - 1] === "function") {
      const equals = last;
      const transform = args.pop();
      return new _a3(args, transform, equals);
    } else {
      const transform = last;
      return new _a3(args, transform);
    }
  }
  dispose() {
    for (const src of __privateGet(this, _sources)) {
      src.removeSink(this);
    }
    __privateSet(this, _prevValue, "(disposed)");
    __privateSet(this, _sources, "(disposed)");
    __privateSet(this, _deps, "(disposed)");
    __privateSet(this, _transform, "(disposed)");
  }
  get isDirty() {
    return __privateGet(this, _dirty);
  }
  markDirty() {
    if (!__privateGet(this, _dirty)) {
      __privateSet(this, _dirty, true);
      this.markSinksDirty();
    }
  }
  get() {
    if (__privateGet(this, _dirty)) {
      __privateMethod(this, __DerivedSignal_instances, recompute_fn).call(this);
    }
    trackedReads == null ? void 0 : trackedReads.add(this);
    return __privateGet(this, _prevValue);
  }
  /**
   * Called by the Signal system if one or more of the dependent signals have
   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate
   * the actual value if it's being watched, or any of their sinks are being
   * watched actively.
   */
  [kTrigger]() {
    if (!this.hasWatchers) {
      return;
    }
    const updated = __privateMethod(this, __DerivedSignal_instances, recompute_fn).call(this);
    if (updated) {
      super[kTrigger]();
    }
  }
}, _prevValue = new WeakMap(), _dirty = new WeakMap(), _sources = new WeakMap(), _deps = new WeakMap(), _transform = new WeakMap(), __DerivedSignal_instances = new WeakSet(), recompute_fn = function() {
  const oldTrackedReads = trackedReads;
  let derived;
  trackedReads = /* @__PURE__ */ new Set();
  try {
    derived = __privateGet(this, _transform).call(this, ...__privateGet(this, _deps).map((p) => p.get()));
  } finally {
    const oldSources = __privateGet(this, _sources);
    __privateSet(this, _sources, /* @__PURE__ */ new Set());
    for (const sig of trackedReads) {
      __privateGet(this, _sources).add(sig);
      oldSources.delete(sig);
    }
    for (const oldSource of oldSources) {
      oldSource.removeSink(this);
    }
    for (const newSource of __privateGet(this, _sources)) {
      newSource.addSink(this);
    }
    trackedReads = oldTrackedReads;
  }
  __privateSet(this, _dirty, false);
  if (!this.equals(__privateGet(this, _prevValue), derived)) {
    __privateSet(this, _prevValue, derived);
    return true;
  }
  return false;
}, _a3);
var _state, _a4;
var MutableSignal = (_a4 = class extends AbstractSignal {
  constructor(initialState) {
    super();
    __privateAdd(this, _state);
    __privateSet(this, _state, initialState);
  }
  dispose() {
    super.dispose();
    __privateSet(this, _state, "(disposed)");
  }
  get() {
    trackedReads == null ? void 0 : trackedReads.add(this);
    return __privateGet(this, _state);
  }
  /**
   * Invokes a callback function that is allowed to mutate the given state
   * value. Do not change the value outside of the callback.
   *
   * If the callback explicitly returns `false`, it's assumed that the state
   * was not changed.
   */
  mutate(callback) {
    batch(() => {
      const result = callback ? callback(__privateGet(this, _state)) : true;
      if (result !== null && typeof result === "object" && "then" in result) {
        raise("MutableSignal.mutate() does not support async callbacks");
      }
      if (result !== false) {
        this.markSinksDirty();
        enqueueTrigger(this);
      }
    });
  }
}, _state = new WeakMap(), _a4);
function bisectRight(arr, x, lt) {
  let lo = 0;
  let hi = arr.length;
  while (lo < hi) {
    const mid = lo + (hi - lo >> 1);
    if (lt(x, arr[mid])) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return lo;
}
var _data, _lt, _a5;
var SortedList = (_a5 = class {
  constructor(alreadySortedList, lt) {
    __privateAdd(this, _data);
    __privateAdd(this, _lt);
    __privateSet(this, _lt, lt);
    __privateSet(this, _data, alreadySortedList);
  }
  static with(lt) {
    return _a5.fromAlreadySorted([], lt);
  }
  static from(arr, lt) {
    const sorted = new _a5([], lt);
    for (const item of arr) {
      sorted.add(item);
    }
    return sorted;
  }
  static fromAlreadySorted(alreadySorted, lt) {
    return new _a5(alreadySorted, lt);
  }
  /**
   * Clones the sorted list to a new instance.
   */
  clone() {
    return new _a5(__privateGet(this, _data).slice(), __privateGet(this, _lt));
  }
  /**
   * Adds a new item to the sorted list, such that it remains sorted.
   */
  add(value) {
    const idx = bisectRight(__privateGet(this, _data), value, __privateGet(this, _lt));
    __privateGet(this, _data).splice(idx, 0, value);
  }
  /**
   * Removes all values from the sorted list, making it empty again.
   * Returns whether the list was mutated or not.
   */
  clear() {
    const hadData = __privateGet(this, _data).length > 0;
    __privateGet(this, _data).length = 0;
    return hadData;
  }
  /**
   * Removes the first value matching the predicate.
   * Returns whether the list was mutated or not.
   */
  removeBy(predicate, limit = Number.POSITIVE_INFINITY) {
    let deleted = 0;
    for (let i = 0; i < __privateGet(this, _data).length; i++) {
      if (predicate(__privateGet(this, _data)[i])) {
        __privateGet(this, _data).splice(i, 1);
        deleted++;
        if (deleted >= limit) {
          break;
        } else {
          i--;
        }
      }
    }
    return deleted > 0;
  }
  /**
   * Removes the given value from the sorted list, if it exists. The given
   * value must be `===` to one of the list items. Only the first entry will be
   * removed if the element exists in the sorted list multiple times.
   *
   * Returns whether the list was mutated or not.
   */
  remove(value) {
    const idx = __privateGet(this, _data).indexOf(value);
    if (idx >= 0) {
      __privateGet(this, _data).splice(idx, 1);
      return true;
    }
    return false;
  }
  at(index) {
    return __privateGet(this, _data)[index];
  }
  get length() {
    return __privateGet(this, _data).length;
  }
  *filter(predicate) {
    for (const item of __privateGet(this, _data)) {
      if (predicate(item)) {
        yield item;
      }
    }
  }
  // XXXX If we keep this, add unit tests. Or remove it.
  *findAllRight(predicate) {
    for (let i = __privateGet(this, _data).length - 1; i >= 0; i--) {
      const item = __privateGet(this, _data)[i];
      if (predicate(item, i)) {
        yield item;
      }
    }
  }
  [Symbol.iterator]() {
    return __privateGet(this, _data)[Symbol.iterator]();
  }
  *iterReversed() {
    for (let i = __privateGet(this, _data).length - 1; i >= 0; i--) {
      yield __privateGet(this, _data)[i];
    }
  }
  /** Finds the leftmost item that matches the predicate. */
  find(predicate, start) {
    const idx = this.findIndex(predicate, start);
    return idx > -1 ? __privateGet(this, _data).at(idx) : void 0;
  }
  /** Finds the leftmost index that matches the predicate. */
  findIndex(predicate, start = 0) {
    for (let i = Math.max(0, start); i < __privateGet(this, _data).length; i++) {
      if (predicate(__privateGet(this, _data)[i], i)) {
        return i;
      }
    }
    return -1;
  }
  /** Finds the rightmost item that matches the predicate. */
  findRight(predicate, start) {
    const idx = this.findIndexRight(predicate, start);
    return idx > -1 ? __privateGet(this, _data).at(idx) : void 0;
  }
  /** Finds the rightmost index that matches the predicate. */
  findIndexRight(predicate, start = __privateGet(this, _data).length - 1) {
    for (let i = Math.min(start, __privateGet(this, _data).length - 1); i >= 0; i--) {
      if (predicate(__privateGet(this, _data)[i], i)) {
        return i;
      }
    }
    return -1;
  }
  get rawArray() {
    return __privateGet(this, _data);
  }
}, _data = new WeakMap(), _lt = new WeakMap(), _a5);
var _byId, _chats, _a6;
var AiChatDB = (_a6 = class {
  constructor() {
    __privateAdd(this, _byId);
    // A map of chat id to chat details
    __privateAdd(this, _chats);
    // Sorted list of non-deleted chats, most recent first
    __publicField(this, "signal");
    __privateSet(this, _byId, /* @__PURE__ */ new Map());
    __privateSet(this, _chats, SortedList.from([], (c1, c2) => {
      const d2 = c2.lastMessageAt ?? c2.createdAt;
      const d1 = c1.lastMessageAt ?? c1.createdAt;
      return d2 < d1 ? true : d2 === d1 ? c2.id < c1.id : false;
    }));
    this.signal = new MutableSignal(this);
  }
  getEvenIfDeleted(chatId) {
    return __privateGet(this, _byId).get(chatId);
  }
  markDeleted(chatId) {
    const chat = __privateGet(this, _byId).get(chatId);
    if (chat === void 0 || chat.deletedAt !== void 0) return;
    this.upsert({
      ...chat,
      deletedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  upsert(chat) {
    this.signal.mutate(() => {
      const existingThread = __privateGet(this, _byId).get(chat.id);
      if (existingThread !== void 0) {
        if (existingThread.deletedAt !== void 0) return false;
        __privateGet(this, _chats).remove(existingThread);
        __privateGet(this, _byId).delete(existingThread.id);
      }
      if (chat.deletedAt === void 0) {
        __privateGet(this, _chats).add(chat);
      }
      __privateGet(this, _byId).set(chat.id, chat);
      return true;
    });
  }
  findMany(query) {
    return Array.from(
      __privateGet(this, _chats).filter((chat) => {
        if (query.metadata === void 0) return true;
        for (const [key, value] of Object.entries(query.metadata)) {
          if (value === null) {
            if (key in chat.metadata) return false;
          } else if (typeof value === "string") {
            if (chat.metadata[key] !== value) return false;
          } else {
            const chatValue = chat.metadata[key];
            if (!Array.isArray(chatValue) || !value.every((v) => chatValue.includes(v))) {
              return false;
            }
          }
        }
        return true;
      })
    );
  }
}, _byId = new WeakMap(), _chats = new WeakMap(), _a6);
function convertToCommentData(data) {
  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;
  const createdAt = new Date(data.createdAt);
  const reactions = data.reactions.map((reaction) => ({
    ...reaction,
    createdAt: new Date(reaction.createdAt)
  }));
  if (data.body) {
    return {
      ...data,
      reactions,
      createdAt,
      editedAt
    };
  } else {
    const deletedAt = new Date(data.deletedAt);
    return {
      ...data,
      reactions,
      createdAt,
      editedAt,
      deletedAt
    };
  }
}
function convertToThreadData(data) {
  const createdAt = new Date(data.createdAt);
  const updatedAt = new Date(data.updatedAt);
  const comments = data.comments.map(
    (comment) => convertToCommentData(comment)
  );
  return {
    ...data,
    createdAt,
    updatedAt,
    comments
  };
}
function convertToCommentUserReaction(data) {
  return {
    ...data,
    createdAt: new Date(data.createdAt)
  };
}
function convertToInboxNotificationData(data) {
  const notifiedAt = new Date(data.notifiedAt);
  const readAt = data.readAt ? new Date(data.readAt) : null;
  if ("activities" in data) {
    const activities = data.activities.map((activity) => ({
      ...activity,
      createdAt: new Date(activity.createdAt)
    }));
    return {
      ...data,
      notifiedAt,
      readAt,
      activities
    };
  }
  return {
    ...data,
    notifiedAt,
    readAt
  };
}
function convertToSubscriptionData(data) {
  const createdAt = new Date(data.createdAt);
  return {
    ...data,
    createdAt
  };
}
function convertToThreadDeleteInfo(data) {
  const deletedAt = new Date(data.deletedAt);
  return {
    ...data,
    deletedAt
  };
}
function convertToInboxNotificationDeleteInfo(data) {
  const deletedAt = new Date(data.deletedAt);
  return {
    ...data,
    deletedAt
  };
}
function convertToSubscriptionDeleteInfo(data) {
  const deletedAt = new Date(data.deletedAt);
  return {
    ...data,
    deletedAt
  };
}
function convertToGroupData(data) {
  const createdAt = new Date(data.createdAt);
  const updatedAt = new Date(data.updatedAt);
  const members = data.members.map((member) => ({
    ...member,
    addedAt: new Date(member.addedAt)
  }));
  return {
    ...data,
    createdAt,
    updatedAt,
    members
  };
}
function assertNever(_value2, errmsg) {
  throw new Error(errmsg);
}
function assert(condition, errmsg) {
  if (true) {
    if (!condition) {
      const err = new Error(errmsg);
      err.name = "Assertion failure";
      throw err;
    }
  }
}
function nn(value, errmsg = "Expected value to be non-nullable") {
  assert(value !== null && value !== void 0, errmsg);
  return value;
}
var fancy_console_exports = {};
__export(fancy_console_exports, {
  error: () => error2,
  errorWithTitle: () => errorWithTitle,
  warn: () => warn,
  warnWithTitle: () => warnWithTitle
});
var badge = "background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;";
var bold = "font-weight:600";
function wrap(method) {
  return typeof window === "undefined" || false ? console[method] : (
    /* istanbul ignore next */
    ((message, ...args) => console[method]("%cLiveblocks", badge, message, ...args))
  );
}
var warn = wrap("warn");
var error2 = wrap("error");
function wrapWithTitle(method) {
  return typeof window === "undefined" || false ? console[method] : (
    /* istanbul ignore next */
    ((title, message, ...args) => console[method](
      `%cLiveblocks%c ${title}`,
      badge,
      bold,
      message,
      ...args
    ))
  );
}
var warnWithTitle = wrapWithTitle("warn");
var errorWithTitle = wrapWithTitle("error");
function isDefined(value) {
  return value !== null && value !== void 0;
}
function isPlainObject(blob) {
  return blob !== null && typeof blob === "object" && Object.prototype.toString.call(blob) === "[object Object]";
}
function isStartsWithOperator(blob) {
  return isPlainObject(blob) && typeof blob.startsWith === "string";
}
var HttpError = class _HttpError extends Error {
  constructor(message, response, details) {
    super(message);
    __publicField(this, "response");
    __publicField(this, "details");
    this.name = "HttpError";
    this.response = response;
    this.details = details;
  }
  static async fromResponse(response) {
    let bodyAsText;
    try {
      bodyAsText = await response.text();
    } catch {
    }
    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;
    let bodyAsJsonObject;
    if (isPlainObject(bodyAsJson)) {
      bodyAsJsonObject = bodyAsJson;
    }
    let message = "";
    message || (message = typeof (bodyAsJsonObject == null ? void 0 : bodyAsJsonObject.message) === "string" ? bodyAsJsonObject.message : "");
    message || (message = typeof (bodyAsJsonObject == null ? void 0 : bodyAsJsonObject.error) === "string" ? bodyAsJsonObject.error : "");
    if (bodyAsJson === void 0) {
      message || (message = bodyAsText || "");
    }
    message || (message = response.statusText);
    let path;
    try {
      path = new URL(response.url).pathname;
    } catch {
    }
    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;
    const details = bodyAsJsonObject;
    return new _HttpError(message, response, details);
  }
  /**
   * Convenience accessor for response.status.
   */
  get status() {
    return this.response.status;
  }
};
var DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;
async function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {
  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;
  let attempt = 0;
  while (true) {
    attempt++;
    try {
      return await promiseFn();
    } catch (err) {
      if (shouldStopRetrying(err)) {
        throw err;
      }
      if (attempt >= maxTries) {
        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);
      }
    }
    const delay = backoff[attempt - 1] ?? fallbackBackoff;
    warn(
      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`
    );
    await wait(delay);
  }
}
function controlledPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [promise, resolve, reject];
}
function Promise_withResolvers() {
  const [promise, resolve, reject] = controlledPromise();
  return { promise, resolve, reject };
}
function replacer(_key, value) {
  return value !== null && typeof value === "object" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {
    sorted[key] = value[key];
    return sorted;
  }, {}) : value;
}
function stableStringify(value) {
  return JSON.stringify(value, replacer);
}
function stringifyOrLog(value) {
  try {
    return JSON.stringify(value);
  } catch (err) {
    console.error(`Could not stringify: ${err.message}`);
    console.error(value);
    throw err;
  }
}
var DEFAULT_SIZE = 50;
var BatchCall = class {
  constructor(input) {
    __publicField(this, "input");
    __publicField(this, "resolve");
    __publicField(this, "reject");
    __publicField(this, "promise");
    this.input = input;
    const { promise, resolve, reject } = Promise_withResolvers();
    this.promise = promise;
    this.resolve = resolve;
    this.reject = reject;
  }
};
var _queue, _callback, _size, _delay, _delayTimeoutId, _Batch_instances, clearDelayTimeout_fn, schedule_fn, flush_fn, _a7;
var Batch = (_a7 = class {
  constructor(callback, options) {
    __privateAdd(this, _Batch_instances);
    __privateAdd(this, _queue, []);
    __privateAdd(this, _callback);
    __privateAdd(this, _size);
    __privateAdd(this, _delay);
    __privateAdd(this, _delayTimeoutId);
    __publicField(this, "error", false);
    __privateSet(this, _callback, callback);
    __privateSet(this, _size, options.size ?? DEFAULT_SIZE);
    __privateSet(this, _delay, options.delay);
  }
  get(input) {
    const existingCall = __privateGet(this, _queue).find(
      (call2) => stableStringify(call2.input) === stableStringify(input)
    );
    if (existingCall) {
      return existingCall.promise;
    }
    const call = new BatchCall(input);
    __privateGet(this, _queue).push(call);
    __privateMethod(this, _Batch_instances, schedule_fn).call(this);
    return call.promise;
  }
  clear() {
    __privateSet(this, _queue, []);
    this.error = false;
    __privateMethod(this, _Batch_instances, clearDelayTimeout_fn).call(this);
  }
}, _queue = new WeakMap(), _callback = new WeakMap(), _size = new WeakMap(), _delay = new WeakMap(), _delayTimeoutId = new WeakMap(), _Batch_instances = new WeakSet(), clearDelayTimeout_fn = function() {
  if (__privateGet(this, _delayTimeoutId) !== void 0) {
    clearTimeout(__privateGet(this, _delayTimeoutId));
    __privateSet(this, _delayTimeoutId, void 0);
  }
}, schedule_fn = function() {
  if (__privateGet(this, _queue).length === __privateGet(this, _size)) {
    void __privateMethod(this, _Batch_instances, flush_fn).call(this);
  } else if (__privateGet(this, _queue).length === 1) {
    __privateMethod(this, _Batch_instances, clearDelayTimeout_fn).call(this);
    __privateSet(this, _delayTimeoutId, setTimeout(() => void __privateMethod(this, _Batch_instances, flush_fn).call(this), __privateGet(this, _delay)));
  }
}, flush_fn = async function() {
  if (__privateGet(this, _queue).length === 0) {
    return;
  }
  const calls = __privateGet(this, _queue).splice(0);
  const inputs = calls.map((call) => call.input);
  try {
    const results = await __privateGet(this, _callback).call(this, inputs);
    this.error = false;
    calls.forEach((call, index) => {
      const result = results == null ? void 0 : results[index];
      if (!Array.isArray(results)) {
        call.reject(new Error("Callback must return an array."));
      } else if (calls.length !== results.length) {
        call.reject(
          new Error(
            `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`
          )
        );
      } else if (result instanceof Error) {
        call.reject(result);
      } else {
        call.resolve(result);
      }
    });
  } catch (error3) {
    this.error = true;
    calls.forEach((call) => {
      call.reject(error3);
    });
  }
}, _a7);
function createBatchStore(batch2) {
  const signal = new MutableSignal(/* @__PURE__ */ new Map());
  function getCacheKey(args) {
    return stableStringify(args);
  }
  function update(entryOrEntries) {
    signal.mutate((cache) => {
      if (Array.isArray(entryOrEntries)) {
        for (const entry of entryOrEntries) {
          cache.set(entry.key, entry.state);
        }
      } else {
        cache.set(entryOrEntries.key, entryOrEntries.state);
      }
    });
  }
  function invalidate(inputs) {
    signal.mutate((cache) => {
      if (Array.isArray(inputs)) {
        for (const input of inputs) {
          cache.delete(getCacheKey(input));
        }
      } else {
        cache.clear();
      }
    });
  }
  async function enqueue(input) {
    const cacheKey = getCacheKey(input);
    const cache = signal.get();
    if (cache.has(cacheKey)) {
      return;
    }
    try {
      update({ key: cacheKey, state: { isLoading: true } });
      const result = await batch2.get(input);
      update({ key: cacheKey, state: { isLoading: false, data: result } });
    } catch (error3) {
      update({
        key: cacheKey,
        state: { isLoading: false, error: error3 }
      });
    }
  }
  function setData(entries2) {
    update(
      entries2.map((entry) => ({
        key: getCacheKey(entry[0]),
        state: { isLoading: false, data: entry[1] }
      }))
    );
  }
  function getItemState(input) {
    const cacheKey = getCacheKey(input);
    const cache = signal.get();
    return cache.get(cacheKey);
  }
  function getData(input) {
    var _a26;
    const cacheKey = getCacheKey(input);
    const cache = signal.get();
    return (_a26 = cache.get(cacheKey)) == null ? void 0 : _a26.data;
  }
  function _cacheKeys() {
    const cache = signal.get();
    return [...cache.keys()];
  }
  return {
    subscribe: signal.subscribe,
    enqueue,
    setData,
    getItemState,
    getData,
    invalidate,
    batch: batch2,
    _cacheKeys
  };
}
function chunk(array, size) {
  const chunks = [];
  for (let i = 0, j = array.length; i < j; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
var nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(
  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? "_" : "-",
  ""
);
var THREAD_ID_PREFIX = "th";
var COMMENT_ID_PREFIX = "cm";
var COMMENT_ATTACHMENT_ID_PREFIX = "at";
var INBOX_NOTIFICATION_ID_PREFIX = "in";
function createOptimisticId(prefix) {
  return `${prefix}_${nanoid()}`;
}
function createThreadId() {
  return createOptimisticId(THREAD_ID_PREFIX);
}
function createCommentId() {
  return createOptimisticId(COMMENT_ID_PREFIX);
}
function createCommentAttachmentId() {
  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);
}
function createInboxNotificationId() {
  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);
}
var _defaultFn, _a8;
var DefaultMap = (_a8 = class extends Map {
  /**
   * If the default function is not provided to the constructor, it has to be
   * provided in each .getOrCreate() call individually.
   */
  constructor(defaultFn, entries2) {
    super(entries2);
    __privateAdd(this, _defaultFn);
    __privateSet(this, _defaultFn, defaultFn);
  }
  /**
   * Gets the value at the given key, or creates it.
   *
   * Difference from normal Map: if the key does not exist, it will be created
   * on the fly using the factory function, and that value will get returned
   * instead of `undefined`.
   */
  getOrCreate(key, defaultFn) {
    if (super.has(key)) {
      return super.get(key);
    } else {
      const fn = defaultFn ?? __privateGet(this, _defaultFn) ?? raise("DefaultMap used without a factory function");
      const value = fn(key);
      this.set(key, value);
      return value;
    }
  }
}, _defaultFn = new WeakMap(), _a8);
var identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
function objectToQuery(obj) {
  let filterList = [];
  const entries2 = Object.entries(obj);
  const keyValuePairs = [];
  const keyValuePairsWithOperator = [];
  const indexedKeys = [];
  entries2.forEach(([key, value]) => {
    if (!identifierRegex.test(key)) {
      throw new Error("Key must only contain letters, numbers, _");
    }
    if (isSimpleValue(value)) {
      keyValuePairs.push([key, value]);
    } else if (isPlainObject(value)) {
      if (isStartsWithOperator(value)) {
        keyValuePairsWithOperator.push([key, value]);
      } else {
        indexedKeys.push([key, value]);
      }
    }
  });
  filterList = [
    ...getFiltersFromKeyValuePairs(keyValuePairs),
    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)
  ];
  indexedKeys.forEach(([key, value]) => {
    const nestedEntries = Object.entries(value);
    const nKeyValuePairs = [];
    const nKeyValuePairsWithOperator = [];
    nestedEntries.forEach(([nestedKey, nestedValue]) => {
      if (isStringEmpty(nestedKey)) {
        throw new Error("Key cannot be empty");
      }
      if (isSimpleValue(nestedValue)) {
        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);
      } else if (isStartsWithOperator(nestedValue)) {
        nKeyValuePairsWithOperator.push([
          formatFilterKey(key, nestedKey),
          nestedValue
        ]);
      }
    });
    filterList = [
      ...filterList,
      ...getFiltersFromKeyValuePairs(nKeyValuePairs),
      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)
    ];
  });
  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(" ");
}
var getFiltersFromKeyValuePairs = (keyValuePairs) => {
  const filters = [];
  keyValuePairs.forEach(([key, value]) => {
    filters.push({
      key,
      operator: ":",
      value
    });
  });
  return filters;
};
var getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {
  const filters = [];
  keyValuePairsWithOperator.forEach(([key, value]) => {
    if ("startsWith" in value && typeof value.startsWith === "string") {
      filters.push({
        key,
        operator: "^",
        value: value.startsWith
      });
    }
  });
  return filters;
};
var isSimpleValue = (value) => {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null;
};
var formatFilterKey = (key, nestedKey) => {
  if (nestedKey) {
    return `${key}[${quote(nestedKey)}]`;
  }
  return key;
};
var isStringEmpty = (value) => {
  return !value || value.toString().trim() === "";
};
function quote(input) {
  const result = JSON.stringify(input);
  if (typeof input !== "string") {
    return result;
  }
  if (result.includes("'")) {
    return result;
  }
  return `'${result.slice(1, -1).replace(/\\"/g, '"')}'`;
}
var PLACEHOLDER_BASE_URL = "https://localhost:9999";
var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
var TRAILING_SLASH_URL_REGEX = /\/(?:(?:\?|#).*)?$/;
function toURLSearchParams(params) {
  const result = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    if (value !== void 0 && value !== null) {
      result.set(key, value.toString());
    }
  }
  return result;
}
function urljoin(baseUrl, path, params) {
  const url2 = new URL(path, baseUrl);
  if (params !== void 0) {
    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();
  }
  return url2.toString();
}
function url(strings, ...values2) {
  return strings.reduce(
    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? "") + str
  );
}
function sanitizeUrl(url2) {
  if (url2.startsWith("www.")) {
    url2 = "https://" + url2;
  }
  if (url2 === "#") {
    return url2;
  }
  try {
    const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);
    const urlObject = new URL(
      url2,
      isAbsolute ? void 0 : PLACEHOLDER_BASE_URL
    );
    if (urlObject.protocol !== "http:" && urlObject.protocol !== "https:") {
      return null;
    }
    const hasTrailingSlash = TRAILING_SLASH_URL_REGEX.test(url2);
    const sanitizedUrl = (
      // 1. Origin, only for absolute URLs
      (isAbsolute ? urlObject.origin : "") + // 2. Pathname, with a trailing slash if the original URL had one
      (urlObject.pathname === "/" ? (
        // 2.a. Domain-only URLs, they always have their pathname set to "/"
        hasTrailingSlash ? "/" : ""
      ) : (
        // 2.b. URLs with a path
        hasTrailingSlash && !urlObject.pathname.endsWith("/") ? urlObject.pathname + "/" : urlObject.pathname
      )) + // 3. Search params
      urlObject.search + // 4. Hash
      urlObject.hash
    );
    return sanitizedUrl !== "" ? sanitizedUrl : null;
  } catch {
    return null;
  }
}
function generateUrl(url2, params, hash) {
  const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);
  const urlObject = new URL(url2, isAbsolute ? void 0 : PLACEHOLDER_BASE_URL);
  if (params !== void 0) {
    for (const [param, value] of Object.entries(params)) {
      if (value) {
        urlObject.searchParams.set(param, String(value));
      }
    }
  }
  if (!urlObject.hash && hash !== void 0) {
    urlObject.hash = `#${hash}`;
  }
  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, "");
}
function isUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}
function createApiClient({
  baseUrl,
  authManager,
  currentUserId,
  fetchPolyfill
}) {
  const httpClient = new HttpClient(baseUrl, fetchPolyfill);
  async function getThreadsSince(options) {
    const result = await httpClient.get(
      url`/v2/c/rooms/${options.roomId}/threads/delta`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        since: options.since.toISOString()
      },
      { signal: options.signal }
    );
    return {
      threads: {
        updated: result.data.map(convertToThreadData),
        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)
      },
      inboxNotifications: {
        updated: result.inboxNotifications.map(convertToInboxNotificationData),
        deleted: result.deletedInboxNotifications.map(
          convertToInboxNotificationDeleteInfo
        )
      },
      subscriptions: {
        updated: result.subscriptions.map(convertToSubscriptionData),
        deleted: result.deletedSubscriptions.map(
          convertToSubscriptionDeleteInfo
        )
      },
      requestedAt: new Date(result.meta.requestedAt),
      permissionHints: result.meta.permissionHints
    };
  }
  async function getThreads(options) {
    let query;
    if (options.query) {
      query = objectToQuery(options.query);
    }
    const PAGE_SIZE = 50;
    try {
      const result = await httpClient.get(
        url`/v2/c/rooms/${options.roomId}/threads`,
        await authManager.getAuthValue({
          requestedScope: "comments:read",
          roomId: options.roomId
        }),
        {
          cursor: options.cursor,
          query,
          limit: PAGE_SIZE
        }
      );
      return {
        threads: result.data.map(convertToThreadData),
        inboxNotifications: result.inboxNotifications.map(
          convertToInboxNotificationData
        ),
        subscriptions: result.subscriptions.map(convertToSubscriptionData),
        nextCursor: result.meta.nextCursor,
        requestedAt: new Date(result.meta.requestedAt),
        permissionHints: result.meta.permissionHints
      };
    } catch (err) {
      if (err instanceof HttpError && err.status === 404) {
        return {
          threads: [],
          inboxNotifications: [],
          subscriptions: [],
          nextCursor: null,
          //
          // HACK
          // requestedAt needs to be a *server* timestamp here. However, on
          // this 404 error response, there is no such timestamp. So out of
          // pure necessity we'll fall back to a local timestamp instead (and
          // allow for a possible 6 hour clock difference between client and
          // server).
          //
          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),
          permissionHints: {}
        };
      }
      throw err;
    }
  }
  async function createThread(options) {
    const commentId = options.commentId ?? createCommentId();
    const threadId = options.threadId ?? createThreadId();
    const thread = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        id: threadId,
        comment: {
          id: commentId,
          body: options.body,
          attachmentIds: options.attachmentIds
        },
        metadata: options.metadata
      }
    );
    return convertToThreadData(thread);
  }
  async function deleteThread(options) {
    await httpClient.delete(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function getThread(options) {
    const response = await httpClient.rawGet(
      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
    if (response.ok) {
      const json = await response.json();
      return {
        thread: convertToThreadData(json.thread),
        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0,
        subscription: json.subscription ? convertToSubscriptionData(json.subscription) : void 0
      };
    } else if (response.status === 404) {
      return {
        thread: void 0,
        inboxNotification: void 0,
        subscription: void 0
      };
    } else {
      throw new Error(
        `There was an error while getting thread ${options.threadId}.`
      );
    }
  }
  async function editThreadMetadata(options) {
    return await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      options.metadata
    );
  }
  async function createComment(options) {
    const commentId = options.commentId ?? createCommentId();
    const comment = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        id: commentId,
        body: options.body,
        attachmentIds: options.attachmentIds
      }
    );
    return convertToCommentData(comment);
  }
  async function editComment(options) {
    const comment = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        body: options.body,
        attachmentIds: options.attachmentIds
      }
    );
    return convertToCommentData(comment);
  }
  async function deleteComment(options) {
    await httpClient.delete(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function addReaction(options) {
    const reaction = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      { emoji: options.emoji }
    );
    return convertToCommentUserReaction(reaction);
  }
  async function removeReaction(options) {
    await httpClient.delete(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function markThreadAsResolved(options) {
    await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function markThreadAsUnresolved(options) {
    await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function subscribeToThread(options) {
    const subscription = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/subscribe`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
    return convertToSubscriptionData(subscription);
  }
  async function unsubscribeFromThread(options) {
    await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/unsubscribe`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function uploadAttachment(options) {
    const roomId = options.roomId;
    const abortSignal = options.signal;
    const attachment = options.attachment;
    const abortError = abortSignal ? new DOMException(
      `Upload of attachment ${options.attachment.id} was aborted.`,
      "AbortError"
    ) : void 0;
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      throw abortError;
    }
    const handleRetryError = (err) => {
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw abortError;
      }
      if (err instanceof HttpError && err.status === 413) {
        throw err;
      }
      return false;
    };
    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;
    const RETRY_ATTEMPTS = 10;
    const RETRY_DELAYS = [
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3,
      2e3
    ];
    function splitFileIntoParts(file) {
      const parts = [];
      let start = 0;
      while (start < file.size) {
        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);
        parts.push({
          partNumber: parts.length + 1,
          part: file.slice(start, end)
        });
        start = end;
      }
      return parts;
    }
    if (attachment.size <= ATTACHMENT_PART_SIZE) {
      return autoRetry(
        async () => httpClient.putBlob(
          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          attachment.file,
          { fileSize: attachment.size },
          { signal: abortSignal }
        ),
        RETRY_ATTEMPTS,
        RETRY_DELAYS,
        handleRetryError
      );
    } else {
      let uploadId;
      const uploadedParts = [];
      const createMultiPartUpload = await autoRetry(
        async () => httpClient.post(
          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          void 0,
          { signal: abortSignal },
          { fileSize: attachment.size }
        ),
        RETRY_ATTEMPTS,
        RETRY_DELAYS,
        handleRetryError
      );
      try {
        uploadId = createMultiPartUpload.uploadId;
        const parts = splitFileIntoParts(attachment.file);
        if (abortSignal == null ? void 0 : abortSignal.aborted) {
          throw abortError;
        }
        const batches = chunk(parts, 5);
        for (const parts2 of batches) {
          const uploadedPartsPromises = [];
          for (const { part, partNumber } of parts2) {
            uploadedPartsPromises.push(
              autoRetry(
                async () => httpClient.putBlob(
                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,
                  await authManager.getAuthValue({
                    requestedScope: "comments:read",
                    roomId
                  }),
                  part,
                  void 0,
                  { signal: abortSignal }
                ),
                RETRY_ATTEMPTS,
                RETRY_DELAYS,
                handleRetryError
              )
            );
          }
          uploadedParts.push(...await Promise.all(uploadedPartsPromises));
        }
        if (abortSignal == null ? void 0 : abortSignal.aborted) {
          throw abortError;
        }
        const sortedUploadedParts = uploadedParts.sort(
          (a, b) => a.partNumber - b.partNumber
        );
        return httpClient.post(
          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          { parts: sortedUploadedParts },
          { signal: abortSignal }
        );
      } catch (error3) {
        if (uploadId && (error3 == null ? void 0 : error3.name) && (error3.name === "AbortError" || error3.name === "TimeoutError")) {
          try {
            await httpClient.rawDelete(
              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,
              await authManager.getAuthValue({
                requestedScope: "comments:read",
                roomId
              })
            );
          } catch (error4) {
          }
        }
        throw error3;
      }
    }
  }
  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {
    const batch2 = new Batch(
      async (batchedAttachmentIds) => {
        const attachmentIds = batchedAttachmentIds.flat();
        const { urls } = await httpClient.post(
          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          { attachmentIds }
        );
        return urls.map(
          (url2) => url2 ?? new Error("There was an error while getting this attachment's URL")
        );
      },
      { delay: 50 }
    );
    return createBatchStore(batch2);
  });
  function getOrCreateAttachmentUrlsStore(roomId) {
    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);
  }
  function getAttachmentUrl(options) {
    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;
    return batch2.get(options.attachmentId);
  }
  async function uploadChatAttachment(options) {
    const { chatId, attachment, signal } = options;
    const userId = currentUserId.get();
    if (userId === void 0) {
      throw new Error("Attachment upload requires an authenticated user.");
    }
    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;
    if (options.attachment.file.size <= ATTACHMENT_PART_SIZE) {
      await httpClient.putBlob(
        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.file.name)}`,
        await authManager.getAuthValue({ requestedScope: "comments:read" }),
        attachment.file,
        { fileSize: attachment.file.size },
        { signal }
      );
    } else {
      const multipartUpload = await httpClient.post(
        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.file.name)}`,
        await authManager.getAuthValue({ requestedScope: "comments:read" }),
        void 0,
        { signal },
        { fileSize: attachment.file.size }
      );
      try {
        const uploadedParts = [];
        const parts = [];
        let start = 0;
        while (start < attachment.file.size) {
          const end = Math.min(
            start + ATTACHMENT_PART_SIZE,
            attachment.file.size
          );
          parts.push({
            number: parts.length + 1,
            part: attachment.file.slice(start, end)
          });
          start = end;
        }
        uploadedParts.push(
          ...await Promise.all(
            parts.map(async ({ number, part }) => {
              return await httpClient.putBlob(
                url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/${String(number)}`,
                await authManager.getAuthValue({
                  requestedScope: "comments:read"
                }),
                part,
                void 0,
                { signal }
              );
            })
          )
        );
        await httpClient.post(
          url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/complete`,
          await authManager.getAuthValue({ requestedScope: "comments:read" }),
          { parts: uploadedParts.sort((a, b) => a.number - b.number) },
          { signal }
        );
      } catch (err) {
        try {
          await httpClient.delete(
            url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}`,
            await authManager.getAuthValue({ requestedScope: "comments:read" })
          );
        } catch (err2) {
        }
        throw err;
      }
    }
  }
  const attachmentUrlsBatchStoresByChat = new DefaultMap((chatId) => {
    const batch2 = new Batch(
      async (batchedAttachmentIds) => {
        const attachmentIds = batchedAttachmentIds.flat();
        const { urls } = await httpClient.post(
          url`/v2/c/chats/${chatId}/attachments/presigned-urls`,
          await authManager.getAuthValue({
            requestedScope: "comments:read"
          }),
          { attachmentIds }
        );
        return urls.map(
          (url2) => url2 ?? new Error("There was an error while getting this attachment's URL")
        );
      },
      { delay: 50 }
    );
    return createBatchStore(batch2);
  });
  function getOrCreateChatAttachmentUrlsStore(chatId) {
    return attachmentUrlsBatchStoresByChat.getOrCreate(chatId);
  }
  function getChatAttachmentUrl(options) {
    const batch2 = getOrCreateChatAttachmentUrlsStore(options.chatId).batch;
    return batch2.get(options.attachmentId);
  }
  async function getSubscriptionSettings(options) {
    return httpClient.get(
      url`/v2/c/rooms/${options.roomId}/subscription-settings`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      void 0,
      {
        signal: options.signal
      }
    );
  }
  async function updateSubscriptionSettings(options) {
    return httpClient.post(
      url`/v2/c/rooms/${options.roomId}/subscription-settings`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      options.settings
    );
  }
  const markAsReadBatchesByRoom = new DefaultMap(
    (roomId) => new Batch(
      async (batchedInboxNotificationIds) => {
        const inboxNotificationIds = batchedInboxNotificationIds.flat();
        await httpClient.post(
          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,
          await authManager.getAuthValue({
            requestedScope: "comments:read",
            roomId
          }),
          { inboxNotificationIds }
        );
        return inboxNotificationIds;
      },
      { delay: 50 }
    )
  );
  async function markRoomInboxNotificationAsRead(options) {
    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);
    return batch2.get(options.inboxNotificationId);
  }
  async function createTextMention(options) {
    if (options.mention.kind !== "user" && options.mention.kind !== "group") {
      return assertNever(options.mention, "Unexpected mention kind");
    }
    await httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/text-mentions`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        userId: options.mention.kind === "user" ? options.mention.id : void 0,
        groupId: options.mention.kind === "group" ? options.mention.id : void 0,
        userIds: options.mention.kind === "group" ? options.mention.userIds : void 0,
        mentionId: options.mentionId
      }
    );
  }
  async function deleteTextMention(options) {
    await httpClient.rawDelete(
      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function getTextVersion(options) {
    return httpClient.rawGet(
      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function createTextVersion(options) {
    await httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/version`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
  }
  async function reportTextEditor(options) {
    await httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/text-metadata`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      {
        type: options.type,
        rootKey: options.rootKey
      }
    );
  }
  async function executeContextualPrompt(options) {
    const result = await httpClient.post(
      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,
      await authManager.getAuthValue({
        requestedScope: "room:read",
        roomId: options.roomId
      }),
      {
        prompt: options.prompt,
        context: {
          beforeSelection: options.context.beforeSelection,
          selection: options.context.selection,
          afterSelection: options.context.afterSelection
        },
        previous: options.previous
      },
      { signal: options.signal }
    );
    if (!result || result.content.length === 0) {
      throw new Error("No content returned from server");
    }
    return result.content[0].text;
  }
  async function listTextVersions(options) {
    const result = await httpClient.get(
      url`/v2/c/rooms/${options.roomId}/versions`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      })
    );
    return {
      versions: result.versions.map(({ createdAt, ...version }) => {
        return {
          createdAt: new Date(createdAt),
          ...version
        };
      }),
      requestedAt: new Date(result.meta.requestedAt)
    };
  }
  async function listTextVersionsSince(options) {
    const result = await httpClient.get(
      url`/v2/c/rooms/${options.roomId}/versions/delta`,
      await authManager.getAuthValue({
        requestedScope: "comments:read",
        roomId: options.roomId
      }),
      { since: options.since.toISOString() },
      { signal: options.signal }
    );
    return {
      versions: result.versions.map(({ createdAt, ...version }) => {
        return {
          createdAt: new Date(createdAt),
          ...version
        };
      }),
      requestedAt: new Date(result.meta.requestedAt)
    };
  }
  async function streamStorage(options) {
    const result = await httpClient.rawGet(
      url`/v2/c/rooms/${options.roomId}/storage`,
      await authManager.getAuthValue({
        requestedScope: "room:read",
        roomId: options.roomId
      })
    );
    return await result.json();
  }
  async function sendMessages(options) {
    return httpClient.rawPost(
      url`/v2/c/rooms/${options.roomId}/send-message`,
      await authManager.getAuthValue({
        requestedScope: "room:read",
        roomId: options.roomId
      }),
      {
        nonce: options.nonce,
        messages: options.messages
      }
    );
  }
  async function getInboxNotifications(options) {
    const PAGE_SIZE = 50;
    let query;
    if (options == null ? void 0 : options.query) {
      query = objectToQuery(options.query);
    }
    const json = await httpClient.get(
      url`/v2/c/inbox-notifications`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        cursor: options == null ? void 0 : options.cursor,
        limit: PAGE_SIZE,
        query
      }
    );
    const groups = json.groups.map(convertToGroupData);
    groupsStore.setData(groups.map((group) => [group.id, group]));
    return {
      inboxNotifications: json.inboxNotifications.map(
        convertToInboxNotificationData
      ),
      threads: json.threads.map(convertToThreadData),
      subscriptions: json.subscriptions.map(convertToSubscriptionData),
      nextCursor: json.meta.nextCursor,
      requestedAt: new Date(json.meta.requestedAt)
    };
  }
  async function getInboxNotificationsSince(options) {
    let query;
    if (options == null ? void 0 : options.query) {
      query = objectToQuery(options.query);
    }
    const json = await httpClient.get(
      url`/v2/c/inbox-notifications/delta`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      { since: options.since.toISOString(), query },
      { signal: options.signal }
    );
    return {
      inboxNotifications: {
        updated: json.inboxNotifications.map(convertToInboxNotificationData),
        deleted: json.deletedInboxNotifications.map(
          convertToInboxNotificationDeleteInfo
        )
      },
      threads: {
        updated: json.threads.map(convertToThreadData),
        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)
      },
      subscriptions: {
        updated: json.subscriptions.map(convertToSubscriptionData),
        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)
      },
      requestedAt: new Date(json.meta.requestedAt)
    };
  }
  async function getUnreadInboxNotificationsCount() {
    const { count } = await httpClient.get(
      url`/v2/c/inbox-notifications/count`,
      await authManager.getAuthValue({ requestedScope: "comments:read" })
    );
    return count;
  }
  async function markAllInboxNotificationsAsRead() {
    await httpClient.post(
      url`/v2/c/inbox-notifications/read`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        inboxNotificationIds: "all"
      }
    );
  }
  async function markInboxNotificationsAsRead(inboxNotificationIds) {
    await httpClient.post(
      url`/v2/c/inbox-notifications/read`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        inboxNotificationIds
      }
    );
  }
  const batchedMarkInboxNotificationsAsRead = new Batch(
    async (batchedInboxNotificationIds) => {
      const inboxNotificationIds = batchedInboxNotificationIds.flat();
      await markInboxNotificationsAsRead(inboxNotificationIds);
      return inboxNotificationIds;
    },
    { delay: 50 }
  );
  async function markInboxNotificationAsRead(inboxNotificationId) {
    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);
  }
  async function deleteAllInboxNotifications() {
    await httpClient.delete(
      url`/v2/c/inbox-notifications`,
      await authManager.getAuthValue({ requestedScope: "comments:read" })
    );
  }
  async function deleteInboxNotification(inboxNotificationId) {
    await httpClient.delete(
      url`/v2/c/inbox-notifications/${inboxNotificationId}`,
      await authManager.getAuthValue({ requestedScope: "comments:read" })
    );
  }
  async function getNotificationSettings(options) {
    return httpClient.get(
      url`/v2/c/notification-settings`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      void 0,
      { signal: options == null ? void 0 : options.signal }
    );
  }
  async function updateNotificationSettings(settings) {
    return httpClient.post(
      url`/v2/c/notification-settings`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      settings
    );
  }
  async function getUserThreads_experimental(options) {
    let query;
    if (options == null ? void 0 : options.query) {
      query = objectToQuery(options.query);
    }
    const PAGE_SIZE = 50;
    const json = await httpClient.get(
      url`/v2/c/threads`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      {
        cursor: options == null ? void 0 : options.cursor,
        query,
        limit: PAGE_SIZE
      }
    );
    return {
      threads: json.threads.map(convertToThreadData),
      inboxNotifications: json.inboxNotifications.map(
        convertToInboxNotificationData
      ),
      subscriptions: json.subscriptions.map(convertToSubscriptionData),
      nextCursor: json.meta.nextCursor,
      requestedAt: new Date(json.meta.requestedAt),
      permissionHints: json.meta.permissionHints
    };
  }
  async function getUserThreadsSince_experimental(options) {
    const json = await httpClient.get(
      url`/v2/c/threads/delta`,
      await authManager.getAuthValue({ requestedScope: "comments:read" }),
      { since: options.since.toISOString() },
      { signal: options.signal }
    );
    return {
      threads: {
        updated: json.threads.map(convertToThreadData),
        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)
      },
      inboxNotifications: {
        updated: json.inboxNotifications.map(convertToInboxNotificationData),
        deleted: json.deletedInboxNotifications.map(
          convertToInboxNotificationDeleteInfo
        )
      },
      subscriptions: {
        updated: json.subscriptions.map(convertToSubscriptionData),
        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)
      },
      requestedAt: new Date(json.meta.requestedAt),
      permissionHints: json.meta.permissionHints
    };
  }
  const batchedGetGroups = new Batch(
    async (batchedGroupIds) => {
      const groupIds = batchedGroupIds.flat();
      const { groups: plainGroups } = await httpClient.post(
        url`/v2/c/groups/find`,
        await authManager.getAuthValue({
          requestedScope: "comments:read"
        }),
        { groupIds }
      );
      const groups = /* @__PURE__ */ new Map();
      for (const group of plainGroups) {
        groups.set(group.id, convertToGroupData(group));
      }
      return groupIds.map((groupId) => groups.get(groupId));
    },
    { delay: 50 }
  );
  const groupsStore = createBatchStore(batchedGetGroups);
  function getGroup(groupId) {
    return batchedGetGroups.get(groupId);
  }
  return {
    // Room threads
    getThreads,
    getThreadsSince,
    createThread,
    getThread,
    deleteThread,
    editThreadMetadata,
    createComment,
    editComment,
    deleteComment,
    addReaction,
    removeReaction,
    markThreadAsResolved,
    markThreadAsUnresolved,
    subscribeToThread,
    unsubscribeFromThread,
    markRoomInboxNotificationAsRead,
    // Room subscription settings
    getSubscriptionSettings,
    updateSubscriptionSettings,
    // Room text editor
    createTextMention,
    deleteTextMention,
    getTextVersion,
    createTextVersion,
    reportTextEditor,
    listTextVersions,
    listTextVersionsSince,
    // Room attachments
    getAttachmentUrl,
    uploadAttachment,
    getOrCreateAttachmentUrlsStore,
    // User attachments
    uploadChatAttachment,
    getOrCreateChatAttachmentUrlsStore,
    getChatAttachmentUrl,
    // Room storage
    streamStorage,
    sendMessages,
    // Notifications
    getInboxNotifications,
    getInboxNotificationsSince,
    getUnreadInboxNotificationsCount,
    markAllInboxNotificationsAsRead,
    markInboxNotificationAsRead,
    deleteAllInboxNotifications,
    deleteInboxNotification,
    getNotificationSettings,
    updateNotificationSettings,
    // User threads
    getUserThreads_experimental,
    getUserThreadsSince_experimental,
    // Groups
    groupsStore,
    getGroup,
    // AI
    executeContextualPrompt
  };
}
function getBearerTokenFromAuthValue(authValue) {
  if (authValue.type === "public") {
    return authValue.publicApiKey;
  } else {
    return authValue.token.raw;
  }
}
var _baseUrl, _fetchPolyfill, _HttpClient_instances, rawFetch_fn, fetch_fn, _a9;
var HttpClient = (_a9 = class {
  constructor(baseUrl, fetchPolyfill) {
    __privateAdd(this, _HttpClient_instances);
    __privateAdd(this, _baseUrl);
    __privateAdd(this, _fetchPolyfill);
    __privateSet(this, _baseUrl, baseUrl);
    __privateSet(this, _fetchPolyfill, fetchPolyfill);
  }
  /**
   * Makes a GET request and returns the raw response.
   * Won't throw if the reponse is a non-2xx.
   * @deprecated Ideally, use .get() instead.
   */
  async rawGet(endpoint, authValue, params, options) {
    return await __privateMethod(this, _HttpClient_instances, rawFetch_fn).call(this, endpoint, authValue, options, params);
  }
  /**
   * Makes a POST request and returns the raw response.
   * Won't throw if the reponse is a non-2xx.
   * @deprecated Ideally, use .post() instead.
   */
  async rawPost(endpoint, authValue, body) {
    return await __privateMethod(this, _HttpClient_instances, rawFetch_fn).call(this, endpoint, authValue, {
      method: "POST",
      body: stringifyOrLog(body)
    });
  }
  /**
   * Makes a DELETE request and returns the raw response.
   * Won't throw if the reponse is a non-2xx.
   * @deprecated Ideally, use .delete() instead.
   */
  async rawDelete(endpoint, authValue) {
    return await __privateMethod(this, _HttpClient_instances, rawFetch_fn).call(this, endpoint, authValue, { method: "DELETE" });
  }
  /**
   * Makes a GET request, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async get(endpoint, authValue, params, options) {
    return await __privateMethod(this, _HttpClient_instances, fetch_fn).call(this, endpoint, authValue, options, params);
  }
  /**
   * Makes a POST request, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async post(endpoint, authValue, body, options, params) {
    return await __privateMethod(this, _HttpClient_instances, fetch_fn).call(this, endpoint, authValue, {
      ...options,
      method: "POST",
      body: stringifyOrLog(body)
    }, params);
  }
  /**
   * Makes a DELETE request, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async delete(endpoint, authValue) {
    return await __privateMethod(this, _HttpClient_instances, fetch_fn).call(this, endpoint, authValue, { method: "DELETE" });
  }
  /**
   * Makes a PUT request for a Blob body, and return the JSON response.
   * Will throw if the reponse is a non-2xx.
   */
  async putBlob(endpoint, authValue, blob, params, options) {
    return await __privateMethod(this, _HttpClient_instances, fetch_fn).call(this, endpoint, authValue, {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/octet-stream"
      },
      body: blob
    }, params);
  }
}, _baseUrl = new WeakMap(), _fetchPolyfill = new WeakMap(), _HttpClient_instances = new WeakSet(), rawFetch_fn = async function(endpoint, authValue, options, params) {
  if (!endpoint.startsWith("/v2/c/")) {
    raise("This client can only be used to make /v2/c/* requests");
  }
  const url2 = urljoin(__privateGet(this, _baseUrl), endpoint, params);
  return await __privateGet(this, _fetchPolyfill).call(this, url2, {
    ...options,
    headers: {
      // These headers are default, but can be overriden by custom headers
      "Content-Type": "application/json; charset=utf-8",
      // Possible header overrides
      ...options == null ? void 0 : options.headers,
      // Cannot be overriden by custom headers
      Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,
      "X-LB-Client": PKG_VERSION || "dev"
    }
  });
}, fetch_fn = async function(endpoint, authValue, options, params) {
  const response = await __privateMethod(this, _HttpClient_instances, rawFetch_fn).call(this, endpoint, authValue, options, params);
  if (!response.ok) {
    throw await HttpError.fromResponse(response);
  }
  let body;
  try {
    body = await response.json();
  } catch {
    body = {};
  }
  return body;
}, _a9);
function distance(state1, state2) {
  if (state1 === state2) {
    return [0, 0];
  }
  const chunks1 = state1.split(".");
  const chunks2 = state2.split(".");
  const minLen = Math.min(chunks1.length, chunks2.length);
  let shared = 0;
  for (; shared < minLen; shared++) {
    if (chunks1[shared] !== chunks2[shared]) {
      break;
    }
  }
  const up = chunks1.length - shared;
  const down = chunks2.length - shared;
  return [up, down];
}
function patterns(targetState, levels) {
  const parts = targetState.split(".");
  if (levels < 1 || levels > parts.length + 1) {
    throw new Error("Invalid number of levels");
  }
  const result = [];
  if (levels > parts.length) {
    result.push("*");
  }
  for (let i = parts.length - levels + 1; i < parts.length; i++) {
    const slice = parts.slice(0, i);
    if (slice.length > 0) {
      result.push(slice.join(".") + ".*");
    }
  }
  result.push(targetState);
  return result;
}
var _curr, _a10;
var SafeContext = (_a10 = class {
  constructor(initialContext) {
    __privateAdd(this, _curr);
    __privateSet(this, _curr, initialContext);
  }
  get current() {
    return __privateGet(this, _curr);
  }
  /**
   * Call a callback function that allows patching of the context, by
   * calling `context.patch()`. Patching is only allowed for the duration
   * of this window.
   */
  allowPatching(callback) {
    const self = this;
    let allowed = true;
    const patchableContext = {
      ...__privateGet(this, _curr),
      patch(patch) {
        if (allowed) {
          __privateSet(self, _curr, Object.assign({}, __privateGet(self, _curr), patch));
          for (const pair of Object.entries(patch)) {
            const [key, value] = pair;
            if (key !== "patch") {
              this[key] = value;
            }
          }
        } else {
          throw new Error("Can no longer patch stale context");
        }
      }
    };
    callback(patchableContext);
    allowed = false;
    return;
  }
}, _curr = new WeakMap(), _a10);
var nextId = 1;
var _runningState, _currentContext, _states, _currentStateOrNull, _allowedTransitions, _eventHub, _cleanupStack, _enterFns, _knownEventTypes, _FSM_instances, initialState_get, getStatesMatching_fn, getTargetFn_fn, exit_fn, enter_fn, transition_fn, _a11;
var FSM = (_a11 = class {
  constructor(initialContext) {
    __privateAdd(this, _FSM_instances);
    __publicField(this, "id");
    // Indicates whether this state machine is still being configured, has
    // started, or has terminated
    __privateAdd(this, _runningState);
    __privateAdd(this, _currentContext);
    __privateAdd(this, _states);
    __privateAdd(this, _currentStateOrNull);
    __privateAdd(this, _allowedTransitions);
    __privateAdd(this, _eventHub);
    __publicField(this, "events");
    //
    // The cleanup stack is a stack of (optional) callback functions that will
    // be run when exiting the current state. If a state (or state group) does
    // not have an exit handler, then the entry for that level may be
    // `undefined`, but there will be an explicit entry in the stack for it.
    //
    // This will always be true:
    //
    //   cleanupStack.length == currentState.split('.').length + 1
    //
    // Each stack level represents a different state "group".
    //
    // For example, if you are in a state named `foo.bar.qux`, then the stack
    // will contain the exit handler for `foo.bar.qux` (at the top), then
    // `foo.bar.*`, then `foo.*`, and finally, `*`.
    //
    __privateAdd(this, _cleanupStack);
    __privateAdd(this, _enterFns);
    // Used to provide better error messages
    __privateAdd(this, _knownEventTypes);
    this.id = nextId++;
    __privateSet(this, _runningState, 0);
    __privateSet(this, _currentStateOrNull, null);
    __privateSet(this, _states, /* @__PURE__ */ new Set());
    __privateSet(this, _enterFns, /* @__PURE__ */ new Map());
    __privateSet(this, _cleanupStack, []);
    __privateSet(this, _knownEventTypes, /* @__PURE__ */ new Set());
    __privateSet(this, _allowedTransitions, /* @__PURE__ */ new Map());
    __privateSet(this, _currentContext, new SafeContext(initialContext));
    __privateSet(this, _eventHub, {
      didReceiveEvent: makeEventSource(),
      willTransition: makeEventSource(),
      didIgnoreEvent: makeEventSource(),
      willExitState: makeEventSource(),
      didEnterState: makeEventSource()
    });
    this.events = {
      didReceiveEvent: __privateGet(this, _eventHub).didReceiveEvent.observable,
      willTransition: __privateGet(this, _eventHub).willTransition.observable,
      didIgnoreEvent: __privateGet(this, _eventHub).didIgnoreEvent.observable,
      willExitState: __privateGet(this, _eventHub).willExitState.observable,
      didEnterState: __privateGet(this, _eventHub).didEnterState.observable
    };
  }
  get currentState() {
    if (__privateGet(this, _currentStateOrNull) === null) {
      if (__privateGet(this, _runningState) === 0) {
        throw new Error("Not started yet");
      } else {
        throw new Error("Already stopped");
      }
    }
    return __privateGet(this, _currentStateOrNull);
  }
  /**
   * Starts the machine by entering the initial state.
   */
  start() {
    if (__privateGet(this, _runningState) !== 0) {
      throw new Error("State machine has already started");
    }
    __privateSet(this, _runningState, 1);
    __privateSet(this, _currentStateOrNull, __privateGet(this, _FSM_instances, initialState_get));
    __privateMethod(this, _FSM_instances, enter_fn).call(this, null);
    return this;
  }
  /**
   * Stops the state machine. Stopping the state machine will call exit
   * handlers for the current state, but not enter a new state.
   */
  stop() {
    if (__privateGet(this, _runningState) !== 1) {
      throw new Error("Cannot stop a state machine that hasn't started yet");
    }
    __privateMethod(this, _FSM_instances, exit_fn).call(this, null);
    __privateSet(this, _runningState, 2);
    __privateSet(this, _currentStateOrNull, null);
  }
  get context() {
    return __privateGet(this, _currentContext).current;
  }
  /**
   * Define an explicit finite state in the state machine.
   */
  addState(state) {
    if (__privateGet(this, _runningState) !== 0) {
      throw new Error("Already started");
    }
    __privateGet(this, _states).add(state);
    return this;
  }
  onEnter(nameOrPattern, enterFn) {
    if (__privateGet(this, _runningState) !== 0) {
      throw new Error("Already started");
    } else if (__privateGet(this, _enterFns).has(nameOrPattern)) {
      throw new Error(
        // TODO We _currently_ don't support multiple .onEnters() for the same
        // state, but this is not a fundamental limitation. Just not
        // implemented yet. If we wanted to, we could make this an array.
        `enter/exit function for ${nameOrPattern} already exists`
      );
    }
    __privateGet(this, _enterFns).set(nameOrPattern, enterFn);
    return this;
  }
  /**
   * Defines a promise-based state. When the state is entered, the promise is
   * created. When the promise resolves, the machine will transition to the
   * provided `onOK` target state. When the promise rejects, the machine will
   * transition to the `onError` target state.
   *
   * Optionally, a `maxTimeout` can be set. If the timeout happens before the
   * promise is settled, then the machine will also transition to the `onError`
   * target state.
   *
   * @param stateOrPattern  The state name, or state group pattern name.
   * @param promiseFn       The callback to be invoked when the state is entered.
   * @param onOK            The state to transition to when the promise resolves.
   * @param onError         The state to transition to when the promise
   *                        rejects, or when the timeout happens before the
   *                        promise has been settled.
   * @param maxTimeout      Optional timeout in milliseconds.
   *
   * When the promise callback function is invoked, it's provided with an
   * AbortSignal (2nd argument).
   * If a state transition happens while the promise is pending (for example,
   * an event, or a timeout happens), then an abort signal will be used to
   * indicate this. Implementers can use this abort signal to terminate the
   * in-flight promise, or ignore its results, etc.
   */
  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {
    return this.onEnter(nameOrPattern, () => {
      const abortController = new AbortController();
      const signal = abortController.signal;
      const timeoutId = maxTimeout ? setTimeout(() => {
        const reason = new Error("Timed out");
        __privateMethod(this, _FSM_instances, transition_fn).call(this, { type: "ASYNC_ERROR", reason }, onError);
      }, maxTimeout) : void 0;
      let done = false;
      void promiseFn(__privateGet(this, _currentContext).current, signal).then(
        // On OK
        (data) => {
          if (!signal.aborted) {
            done = true;
            __privateMethod(this, _FSM_instances, transition_fn).call(this, { type: "ASYNC_OK", data }, onOK);
          }
        },
        // On Error
        (reason) => {
          if (!signal.aborted) {
            done = true;
            __privateMethod(this, _FSM_instances, transition_fn).call(this, { type: "ASYNC_ERROR", reason }, onError);
          }
        }
      );
      return () => {
        clearTimeout(timeoutId);
        if (!done) {
          abortController.abort();
        }
      };
    });
  }
  /**
   * Define all allowed outgoing transitions for a state.
   *
   * The targets for each event can be defined as a function which returns the
   * next state to transition to. These functions can look at the `event` or
   * `context` params to conditionally decide which next state to transition
   * to.
   *
   * If you set it to `null`, then the transition will be explicitly forbidden
   * and throw an error. If you don't define a target for a transition, then
   * such events will get ignored.
   */
  addTransitions(nameOrPattern, mapping) {
    if (__privateGet(this, _runningState) !== 0) {
      throw new Error("Already started");
    }
    for (const srcState of __privateMethod(this, _FSM_instances, getStatesMatching_fn).call(this, nameOrPattern)) {
      let map = __privateGet(this, _allowedTransitions).get(srcState);
      if (map === void 0) {
        map = /* @__PURE__ */ new Map();
        __privateGet(this, _allowedTransitions).set(srcState, map);
      }
      for (const [type, target_] of Object.entries(mapping)) {
        if (map.has(type)) {
          throw new Error(
            `Trying to set transition "${type}" on "${srcState}" (via "${nameOrPattern}"), but a transition already exists there.`
          );
        }
        const target = target_;
        __privateGet(this, _knownEventTypes).add(type);
        if (target !== void 0) {
          const targetFn = typeof target === "function" ? target : () => target;
          map.set(type, targetFn);
        }
      }
    }
    return this;
  }
  /**
   * Like `.addTransition()`, but takes an (anonymous) transition whenever the
   * timer fires.
   *
   * @param stateOrPattern  The state name, or state group pattern name.
   * @param after           Number of milliseconds after which to take the
   *                        transition. If in the mean time, another transition
   *                        is taken, the timer will get cancelled.
   * @param target          The target state to go to.
   */
  addTimedTransition(stateOrPattern, after2, target) {
    return this.onEnter(stateOrPattern, () => {
      const ms = typeof after2 === "function" ? after2(__privateGet(this, _currentContext).current) : after2;
      const timeoutID = setTimeout(() => {
        __privateMethod(this, _FSM_instances, transition_fn).call(this, { type: "TIMER" }, target);
      }, ms);
      return () => {
        clearTimeout(timeoutID);
      };
    });
  }
  /**
   * Sends an event to the machine, which may cause an internal state
   * transition to happen. When that happens, will trigger side effects.
   */
  send(event) {
    if (!__privateGet(this, _knownEventTypes).has(event.type)) {
      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);
    }
    if (__privateGet(this, _runningState) === 2) {
      return;
    }
    const targetFn = __privateMethod(this, _FSM_instances, getTargetFn_fn).call(this, event.type);
    if (targetFn !== void 0) {
      return __privateMethod(this, _FSM_instances, transition_fn).call(this, event, targetFn);
    } else {
      __privateGet(this, _eventHub).didIgnoreEvent.notify(event);
    }
  }
}, _runningState = new WeakMap(), _currentContext = new WeakMap(), _states = new WeakMap(), _currentStateOrNull = new WeakMap(), _allowedTransitions = new WeakMap(), _eventHub = new WeakMap(), _cleanupStack = new WeakMap(), _enterFns = new WeakMap(), _knownEventTypes = new WeakMap(), _FSM_instances = new WeakSet(), initialState_get = function() {
  const result = __privateGet(this, _states).values()[Symbol.iterator]().next();
  if (result.done) {
    throw new Error("No states defined yet");
  } else {
    return result.value;
  }
}, getStatesMatching_fn = function(nameOrPattern) {
  const matches = [];
  if (nameOrPattern === "*") {
    for (const state of __privateGet(this, _states)) {
      matches.push(state);
    }
  } else if (nameOrPattern.endsWith(".*")) {
    const prefix = nameOrPattern.slice(0, -1);
    for (const state of __privateGet(this, _states)) {
      if (state.startsWith(prefix)) {
        matches.push(state);
      }
    }
  } else {
    const name = nameOrPattern;
    if (__privateGet(this, _states).has(name)) {
      matches.push(name);
    }
  }
  if (matches.length === 0) {
    throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);
  }
  return matches;
}, getTargetFn_fn = function(eventName) {
  var _a26;
  return (_a26 = __privateGet(this, _allowedTransitions).get(this.currentState)) == null ? void 0 : _a26.get(eventName);
}, /**
 * Exits the current state, and executes any necessary cleanup functions.
 * Call this before changing the current state to the next state.
 *
 * @param levels Defines how many "levels" of nesting will be
 * exited. For example, if you transition from `foo.bar.qux` to
 * `foo.bar.baz`, then the level is 1. But if you transition from
 * `foo.bar.qux` to `bla.bla`, then the level is 3.
 * If `null`, it will exit all levels.
 */
exit_fn = function(levels) {
  __privateGet(this, _eventHub).willExitState.notify(this.currentState);
  __privateGet(this, _currentContext).allowPatching((patchableContext) => {
    var _a26;
    levels = levels ?? __privateGet(this, _cleanupStack).length;
    for (let i = 0; i < levels; i++) {
      (_a26 = __privateGet(this, _cleanupStack).pop()) == null ? void 0 : _a26(patchableContext);
    }
  });
}, /**
 * Enters the current state, and executes any necessary onEnter handlers.
 * Call this directly _after_ setting the current state to the next state.
 */
enter_fn = function(levels) {
  const enterPatterns = patterns(
    this.currentState,
    levels ?? this.currentState.split(".").length + 1
  );
  __privateGet(this, _currentContext).allowPatching((patchableContext) => {
    for (const pattern of enterPatterns) {
      const enterFn = __privateGet(this, _enterFns).get(pattern);
      const cleanupFn = enterFn == null ? void 0 : enterFn(patchableContext);
      if (typeof cleanupFn === "function") {
        __privateGet(this, _cleanupStack).push(cleanupFn);
      } else {
        __privateGet(this, _cleanupStack).push(null);
      }
    }
  });
  __privateGet(this, _eventHub).didEnterState.notify(this.currentState);
}, transition_fn = function(event, target) {
  __privateGet(this, _eventHub).didReceiveEvent.notify(event);
  const oldState = this.currentState;
  const targetFn = typeof target === "function" ? target : () => target;
  const nextTarget = targetFn(event, __privateGet(this, _currentContext).current);
  let nextState;
  let effects = void 0;
  if (nextTarget === null) {
    __privateGet(this, _eventHub).didIgnoreEvent.notify(event);
    return;
  }
  if (typeof nextTarget === "string") {
    nextState = nextTarget;
  } else {
    nextState = nextTarget.target;
    effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];
  }
  if (!__privateGet(this, _states).has(nextState)) {
    throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);
  }
  __privateGet(this, _eventHub).willTransition.notify({ from: oldState, to: nextState });
  const [up, down] = distance(this.currentState, nextState);
  if (up > 0) {
    __privateMethod(this, _FSM_instances, exit_fn).call(this, up);
  }
  __privateSet(this, _currentStateOrNull, nextState);
  if (effects !== void 0) {
    const effectsToRun = effects;
    __privateGet(this, _currentContext).allowPatching((patchableContext) => {
      for (const effect of effectsToRun) {
        if (typeof effect === "function") {
          effect(patchableContext, event);
        } else {
          patchableContext.patch(effect);
        }
      }
    });
  }
  if (down > 0) {
    __privateMethod(this, _FSM_instances, enter_fn).call(this, down);
  }
}, _a11);
var ServerMsgCode = ((ServerMsgCode2) => {
  ServerMsgCode2[ServerMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ServerMsgCode2[ServerMsgCode2["USER_JOINED"] = 101] = "USER_JOINED";
  ServerMsgCode2[ServerMsgCode2["USER_LEFT"] = 102] = "USER_LEFT";
  ServerMsgCode2[ServerMsgCode2["BROADCASTED_EVENT"] = 103] = "BROADCASTED_EVENT";
  ServerMsgCode2[ServerMsgCode2["ROOM_STATE"] = 104] = "ROOM_STATE";
  ServerMsgCode2[ServerMsgCode2["INITIAL_STORAGE_STATE"] = 200] = "INITIAL_STORAGE_STATE";
  ServerMsgCode2[ServerMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  ServerMsgCode2[ServerMsgCode2["REJECT_STORAGE_OP"] = 299] = "REJECT_STORAGE_OP";
  ServerMsgCode2[ServerMsgCode2["UPDATE_YDOC"] = 300] = "UPDATE_YDOC";
  ServerMsgCode2[ServerMsgCode2["THREAD_CREATED"] = 400] = "THREAD_CREATED";
  ServerMsgCode2[ServerMsgCode2["THREAD_DELETED"] = 407] = "THREAD_DELETED";
  ServerMsgCode2[ServerMsgCode2["THREAD_METADATA_UPDATED"] = 401] = "THREAD_METADATA_UPDATED";
  ServerMsgCode2[ServerMsgCode2["THREAD_UPDATED"] = 408] = "THREAD_UPDATED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_CREATED"] = 402] = "COMMENT_CREATED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_EDITED"] = 403] = "COMMENT_EDITED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_DELETED"] = 404] = "COMMENT_DELETED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_REACTION_ADDED"] = 405] = "COMMENT_REACTION_ADDED";
  ServerMsgCode2[ServerMsgCode2["COMMENT_REACTION_REMOVED"] = 406] = "COMMENT_REACTION_REMOVED";
  return ServerMsgCode2;
})(ServerMsgCode || {});
var WebsocketCloseCodes = ((WebsocketCloseCodes2) => {
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_NORMAL"] = 1e3] = "CLOSE_NORMAL";
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_ABNORMAL"] = 1006] = "CLOSE_ABNORMAL";
  WebsocketCloseCodes2[WebsocketCloseCodes2["UNEXPECTED_CONDITION"] = 1011] = "UNEXPECTED_CONDITION";
  WebsocketCloseCodes2[WebsocketCloseCodes2["TRY_AGAIN_LATER"] = 1013] = "TRY_AGAIN_LATER";
  WebsocketCloseCodes2[WebsocketCloseCodes2["INVALID_MESSAGE_FORMAT"] = 4e3] = "INVALID_MESSAGE_FORMAT";
  WebsocketCloseCodes2[WebsocketCloseCodes2["NOT_ALLOWED"] = 4001] = "NOT_ALLOWED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_SECONDS"] = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS"] = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP"] = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM"] = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM";
  WebsocketCloseCodes2[WebsocketCloseCodes2["ROOM_ID_UPDATED"] = 4006] = "ROOM_ID_UPDATED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["KICKED"] = 4100] = "KICKED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["TOKEN_EXPIRED"] = 4109] = "TOKEN_EXPIRED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_WITHOUT_RETRY"] = 4999] = "CLOSE_WITHOUT_RETRY";
  return WebsocketCloseCodes2;
})(WebsocketCloseCodes || {});
function shouldDisconnect(code) {
  return code === 4999 || code >= 4e3 && code < 4100;
}
function shouldReauth(code) {
  return code >= 4100 && code < 4200;
}
function shouldRetryWithoutReauth(code) {
  return code === 1013 || code >= 4200 && code < 4300;
}
function isIdle(status) {
  return status === "initial" || status === "disconnected";
}
function toNewConnectionStatus(machine) {
  const state = machine.currentState;
  switch (state) {
    case "@ok.connected":
    case "@ok.awaiting-pong":
      return "connected";
    case "@idle.initial":
      return "initial";
    case "@auth.busy":
    case "@auth.backoff":
    case "@connecting.busy":
    case "@connecting.backoff":
    case "@idle.zombie":
      return machine.context.successCount > 0 ? "reconnecting" : "connecting";
    case "@idle.failed":
      return "disconnected";
    // istanbul ignore next
    default:
      return assertNever(state, "Unknown state");
  }
}
var BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];
var RESET_DELAY = BACKOFF_DELAYS[0] - 1;
var BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];
var HEARTBEAT_INTERVAL = 3e4;
var PONG_TIMEOUT = 2e3;
var AUTH_TIMEOUT = 1e4;
var SOCKET_CONNECT_TIMEOUT = 1e4;
var StopRetrying = class extends Error {
  constructor(reason) {
    super(reason);
  }
};
function nextBackoffDelay(currentDelay, delays) {
  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];
}
function increaseBackoffDelay(context) {
  context.patch({
    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)
  });
}
function increaseBackoffDelayAggressively(context) {
  context.patch({
    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)
  });
}
function resetSuccessCount(context) {
  context.patch({ successCount: 0 });
}
function log(level, message) {
  const logger = level === 2 ? error2 : level === 1 ? warn : (
    /* black hole */
    (() => {
    })
  );
  return () => {
    logger(message);
  };
}
function logPrematureErrorOrCloseEvent(e) {
  const conn = "Connection to Liveblocks websocket server";
  return (ctx) => {
    if (e instanceof Error) {
      warn(`${conn} could not be established. ${String(e)}`);
    } else {
      warn(
        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`
      );
    }
  };
}
function logCloseEvent(event) {
  const details = [`code: ${event.code}`];
  if (event.reason) {
    details.push(`reason: ${event.reason}`);
  }
  return (ctx) => {
    warn(
      `Connection to Liveblocks websocket server closed (${details.join(", ")}). Retrying in ${ctx.backoffDelay}ms.`
    );
  };
}
var logPermanentClose = log(
  1,
  "Connection to WebSocket closed permanently. Won't retry."
);
function isCloseEvent(error3) {
  return !(error3 instanceof Error) && error3.type === "close";
}
function enableTracing(machine) {
  const start = (/* @__PURE__ */ new Date()).getTime();
  function log2(...args) {
    warn(
      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,
      ...args
    );
  }
  const unsubs = [
    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),
    machine.events.willTransition.subscribe(
      ({ from, to }) => log2("Transitioning", from, "", to)
    ),
    machine.events.didIgnoreEvent.subscribe(
      (e) => log2("Ignored event", e.type, e, "(current state won't handle it)")
    )
    // machine.events.willExitState.subscribe((s) => log("Exiting state", s)),
    // machine.events.didEnterState.subscribe((s) => log("Entering state", s)),
  ];
  return () => {
    for (const unsub of unsubs) {
      unsub();
    }
  };
}
function defineConnectivityEvents(machine) {
  const statusDidChange = makeEventSource();
  const didConnect = makeEventSource();
  const didDisconnect = makeEventSource();
  let lastStatus = null;
  const unsubscribe = machine.events.didEnterState.subscribe(() => {
    const currStatus = toNewConnectionStatus(machine);
    if (currStatus !== lastStatus) {
      statusDidChange.notify(currStatus);
    }
    if (lastStatus === "connected" && currStatus !== "connected") {
      didDisconnect.notify();
    } else if (lastStatus !== "connected" && currStatus === "connected") {
      didConnect.notify();
    }
    lastStatus = currStatus;
  });
  return {
    statusDidChange: statusDidChange.observable,
    didConnect: didConnect.observable,
    didDisconnect: didDisconnect.observable,
    unsubscribe
  };
}
var assign = (patch) => (ctx) => ctx.patch(patch);
function createConnectionStateMachine(delegates, options) {
  const onMessage = makeBufferableEventSource();
  onMessage.pause();
  const onConnectionError = makeEventSource();
  function fireErrorEvent(message, code) {
    return () => {
      onConnectionError.notify({ message, code });
    };
  }
  const initialContext = {
    successCount: 0,
    authValue: null,
    socket: null,
    backoffDelay: RESET_DELAY
  };
  const machine = new FSM(initialContext).addState("@idle.initial").addState("@idle.failed").addState("@idle.zombie").addState("@auth.busy").addState("@auth.backoff").addState("@connecting.busy").addState("@connecting.backoff").addState("@ok.connected").addState("@ok.awaiting-pong");
  machine.addTransitions("*", {
    RECONNECT: {
      target: "@auth.backoff",
      effect: [increaseBackoffDelay, resetSuccessCount]
    },
    DISCONNECT: "@idle.initial"
  });
  machine.onEnter("@idle.*", resetSuccessCount).addTransitions("@idle.*", {
    CONNECT: (_, ctx) => (
      // If we still have a known authValue, try to reconnect to the socket directly,
      // otherwise, try to obtain a new authValue
      ctx.authValue !== null ? "@connecting.busy" : "@auth.busy"
    )
  });
  machine.addTransitions("@auth.backoff", {
    NAVIGATOR_ONLINE: {
      target: "@auth.busy",
      effect: assign({ backoffDelay: RESET_DELAY })
    }
  }).addTimedTransition(
    "@auth.backoff",
    (ctx) => ctx.backoffDelay,
    "@auth.busy"
  ).onEnterAsync(
    "@auth.busy",
    () => withTimeout(
      delegates.authenticate(),
      AUTH_TIMEOUT,
      "Timed out during auth"
    ),
    // On successful authentication
    (okEvent) => ({
      target: "@connecting.busy",
      effect: assign({
        authValue: okEvent.data
      })
    }),
    // Auth failed
    (failedEvent) => {
      if (failedEvent.reason instanceof StopRetrying) {
        return {
          target: "@idle.failed",
          effect: [
            log(2, failedEvent.reason.message),
            fireErrorEvent(failedEvent.reason.message, -1)
          ]
        };
      }
      return {
        target: "@auth.backoff",
        effect: [
          increaseBackoffDelay,
          log(
            2,
            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`
          )
        ]
      };
    }
  );
  const onSocketError = (event) => machine.send({ type: "EXPLICIT_SOCKET_ERROR", event });
  const onSocketClose = (event) => machine.send({ type: "EXPLICIT_SOCKET_CLOSE", event });
  const onSocketMessage = (event) => event.data === "pong" ? machine.send({ type: "PONG" }) : onMessage.notify(event);
  function teardownSocket(socket) {
    if (socket) {
      socket.removeEventListener("error", onSocketError);
      socket.removeEventListener("close", onSocketClose);
      socket.removeEventListener("message", onSocketMessage);
      socket.close();
    }
  }
  machine.addTransitions("@connecting.backoff", {
    NAVIGATOR_ONLINE: {
      target: "@connecting.busy",
      effect: assign({ backoffDelay: RESET_DELAY })
    }
  }).addTimedTransition(
    "@connecting.backoff",
    (ctx) => ctx.backoffDelay,
    "@connecting.busy"
  ).onEnterAsync(
    "@connecting.busy",
    //
    // Use the "createSocket" delegate function (provided to the
    // ManagedSocket) to create the actual WebSocket connection instance.
    // Then, set up all the necessary event listeners, and wait for the
    // "open" event to occur.
    //
    // When the "open" event happens, we're ready to transition to the
    // OK state. This is done by resolving the Promise.
    //
    async (ctx, signal) => {
      let capturedPrematureEvent = null;
      let unconfirmedSocket = null;
      const connect$ = new Promise(
        (resolve, rej) => {
          if (ctx.authValue === null) {
            throw new Error("No auth authValue");
          }
          const socket = delegates.createSocket(ctx.authValue);
          unconfirmedSocket = socket;
          function reject(event) {
            capturedPrematureEvent = event;
            socket.removeEventListener("message", onSocketMessage);
            rej(event);
          }
          const [actor$, didReceiveActor] = controlledPromise();
          if (!options.waitForActorId) {
            didReceiveActor();
          }
          function waitForActorId(event) {
            const serverMsg = tryParseJson(event.data);
            if ((serverMsg == null ? void 0 : serverMsg.type) === 104) {
              didReceiveActor();
            }
          }
          socket.addEventListener("message", onSocketMessage);
          if (options.waitForActorId) {
            socket.addEventListener("message", waitForActorId);
          }
          socket.addEventListener("error", reject);
          socket.addEventListener("close", reject);
          socket.addEventListener("open", () => {
            socket.addEventListener("error", onSocketError);
            socket.addEventListener("close", onSocketClose);
            const unsub = () => {
              socket.removeEventListener("error", reject);
              socket.removeEventListener("close", reject);
              socket.removeEventListener("message", waitForActorId);
            };
            void actor$.then(() => {
              resolve([socket, unsub]);
            });
          });
        }
      );
      return withTimeout(
        connect$,
        SOCKET_CONNECT_TIMEOUT,
        "Timed out during websocket connection"
      ).then(
        //
        // Part 3:
        // By now, our "open" event has fired, and the promise has been
        // resolved. Two possible scenarios:
        //
        // 1. The happy path. Most likely.
        // 2. Uh-oh. A premature close/error event has been observed. Let's
        //    reject the promise after all.
        //
        // Any close/error event that will get scheduled after this point
        // onwards, will be caught in the OK state, and dealt with
        // accordingly.
        //
        ([socket, unsub]) => {
          unsub();
          if (signal.aborted) {
            throw new Error("Aborted");
          }
          if (capturedPrematureEvent) {
            throw capturedPrematureEvent;
          }
          return socket;
        }
      ).catch((e) => {
        teardownSocket(unconfirmedSocket);
        throw e;
      });
    },
    // Only transition to OK state after a successfully opened WebSocket connection
    (okEvent) => ({
      target: "@ok.connected",
      effect: assign({
        socket: okEvent.data,
        backoffDelay: RESET_DELAY
      })
    }),
    // If the WebSocket connection cannot be established
    (failure) => {
      const err = failure.reason;
      if (err instanceof StopRetrying) {
        return {
          target: "@idle.failed",
          effect: [
            log(2, err.message),
            fireErrorEvent(err.message, -1)
          ]
        };
      }
      if (isCloseEvent(err)) {
        if (err.code === 4109) {
          return "@auth.busy";
        }
        if (shouldRetryWithoutReauth(err.code)) {
          return {
            target: "@connecting.backoff",
            effect: [
              increaseBackoffDelayAggressively,
              logPrematureErrorOrCloseEvent(err)
            ]
          };
        }
        if (shouldDisconnect(err.code)) {
          return {
            target: "@idle.failed",
            effect: [
              log(2, err.reason),
              fireErrorEvent(err.reason, err.code)
            ]
          };
        }
      }
      return {
        target: "@auth.backoff",
        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]
      };
    }
  );
  const sendHeartbeat = {
    target: "@ok.awaiting-pong",
    effect: (ctx) => {
      var _a26;
      (_a26 = ctx.socket) == null ? void 0 : _a26.send("ping");
    }
  };
  const maybeHeartbeat = () => {
    const doc = typeof document !== "undefined" ? document : void 0;
    const canZombie = (doc == null ? void 0 : doc.visibilityState) === "hidden" && delegates.canZombie();
    return canZombie ? "@idle.zombie" : sendHeartbeat;
  };
  machine.addTimedTransition("@ok.connected", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions("@ok.connected", {
    NAVIGATOR_OFFLINE: maybeHeartbeat,
    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.
    WINDOW_GOT_FOCUS: sendHeartbeat
  });
  machine.addTransitions("@idle.zombie", {
    WINDOW_GOT_FOCUS: "@connecting.backoff"
    // When in zombie state, the client will try to wake up automatically when the window regains focus
  });
  machine.onEnter("@ok.*", (ctx) => {
    ctx.patch({ successCount: ctx.successCount + 1 });
    const timerID = setTimeout(
      // On the next tick, start delivering all messages that have already
      // been received, and continue synchronous delivery of all future
      // incoming messages.
      onMessage.unpause,
      0
    );
    return (ctx2) => {
      teardownSocket(ctx2.socket);
      ctx2.patch({ socket: null });
      clearTimeout(timerID);
      onMessage.pause();
    };
  }).addTransitions("@ok.awaiting-pong", { PONG: "@ok.connected" }).addTimedTransition("@ok.awaiting-pong", PONG_TIMEOUT, {
    target: "@connecting.busy",
    // Log implicit connection loss and drop the current open socket
    effect: log(
      1,
      "Received no pong from server, assume implicit connection loss."
    )
  }).addTransitions("@ok.*", {
    // When a socket receives an error, this can cause the closing of the
    // socket, or not. So always check to see if the socket is still OPEN or
    // not. When still OPEN, don't transition.
    EXPLICIT_SOCKET_ERROR: (_, context) => {
      var _a26;
      if (((_a26 = context.socket) == null ? void 0 : _a26.readyState) === 1) {
        return null;
      }
      return {
        target: "@connecting.backoff",
        effect: increaseBackoffDelay
      };
    },
    EXPLICIT_SOCKET_CLOSE: (e) => {
      if (shouldDisconnect(e.event.code)) {
        return {
          target: "@idle.failed",
          effect: [
            logPermanentClose,
            fireErrorEvent(e.event.reason, e.event.code)
          ]
        };
      }
      if (shouldReauth(e.event.code)) {
        if (e.event.code === 4109) {
          return "@auth.busy";
        } else {
          return {
            target: "@auth.backoff",
            effect: [increaseBackoffDelay, logCloseEvent(e.event)]
          };
        }
      }
      if (shouldRetryWithoutReauth(e.event.code)) {
        return {
          target: "@connecting.backoff",
          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]
        };
      }
      return {
        target: "@connecting.backoff",
        effect: [increaseBackoffDelay, logCloseEvent(e.event)]
      };
    }
  });
  if (typeof document !== "undefined") {
    const doc = typeof document !== "undefined" ? document : void 0;
    const win = typeof window !== "undefined" ? window : void 0;
    const root = win ?? doc;
    machine.onEnter("*", (ctx) => {
      function onNetworkOffline() {
        machine.send({ type: "NAVIGATOR_OFFLINE" });
      }
      function onNetworkBackOnline() {
        machine.send({ type: "NAVIGATOR_ONLINE" });
      }
      function onVisibilityChange() {
        if ((doc == null ? void 0 : doc.visibilityState) === "visible") {
          machine.send({ type: "WINDOW_GOT_FOCUS" });
        }
      }
      win == null ? void 0 : win.addEventListener("online", onNetworkBackOnline);
      win == null ? void 0 : win.addEventListener("offline", onNetworkOffline);
      root == null ? void 0 : root.addEventListener("visibilitychange", onVisibilityChange);
      return () => {
        root == null ? void 0 : root.removeEventListener("visibilitychange", onVisibilityChange);
        win == null ? void 0 : win.removeEventListener("online", onNetworkBackOnline);
        win == null ? void 0 : win.removeEventListener("offline", onNetworkOffline);
        teardownSocket(ctx.socket);
      };
    });
  }
  const cleanups = [];
  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);
  cleanups.push(unsubscribe);
  if (options.enableDebugLogging) {
    cleanups.push(enableTracing(machine));
  }
  machine.start();
  return {
    machine,
    cleanups,
    // Observable events that will be emitted by this machine
    events: {
      statusDidChange,
      didConnect,
      didDisconnect,
      onMessage: onMessage.observable,
      onConnectionError: onConnectionError.observable
    }
  };
}
var _machine, _cleanups, _a12;
var ManagedSocket = (_a12 = class {
  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {
    __privateAdd(this, _machine);
    __privateAdd(this, _cleanups);
    __publicField(this, "events");
    const { machine, events, cleanups } = createConnectionStateMachine(
      delegates,
      { waitForActorId, enableDebugLogging }
    );
    __privateSet(this, _machine, machine);
    this.events = events;
    __privateSet(this, _cleanups, cleanups);
  }
  getStatus() {
    try {
      return toNewConnectionStatus(__privateGet(this, _machine));
    } catch {
      return "initial";
    }
  }
  /**
   * Returns the current auth authValue.
   */
  get authValue() {
    return __privateGet(this, _machine).context.authValue;
  }
  /**
   * Call this method to try to connect to a WebSocket. This only has an effect
   * if the machine is idle at the moment, otherwise this is a no-op.
   */
  connect() {
    __privateGet(this, _machine).send({ type: "CONNECT" });
  }
  /**
   * If idle, will try to connect. Otherwise, it will attempt to reconnect to
   * the socket, potentially obtaining a new authValue first, if needed.
   */
  reconnect() {
    __privateGet(this, _machine).send({ type: "RECONNECT" });
  }
  /**
   * Call this method to disconnect from the current WebSocket. Is going to be
   * a no-op if there is no active connection.
   */
  disconnect() {
    __privateGet(this, _machine).send({ type: "DISCONNECT" });
  }
  /**
   * Call this to stop the machine and run necessary cleanup functions. After
   * calling destroy(), you can no longer use this instance. Call this before
   * letting the instance get garbage collected.
   */
  destroy() {
    __privateGet(this, _machine).stop();
    let cleanup;
    while (cleanup = __privateGet(this, _cleanups).pop()) {
      cleanup();
    }
  }
  /**
   * Safely send a message to the current WebSocket connection. Will emit a log
   * message if this is somehow impossible.
   */
  send(data) {
    var _a26;
    const socket = (_a26 = __privateGet(this, _machine).context) == null ? void 0 : _a26.socket;
    if (socket === null) {
      warn("Cannot send: not connected yet", data);
    } else if (socket.readyState !== 1) {
      warn("Cannot send: WebSocket no longer open", data);
    } else {
      socket.send(data);
    }
  }
  /**
   * NOTE: Used by the E2E app only, to simulate explicit events.
   * Not ideal to keep exposed :(
   */
  _privateSendMachineEvent(event) {
    __privateGet(this, _machine).send(event);
  }
}, _machine = new WeakMap(), _cleanups = new WeakMap(), _a12);
var kInternal = Symbol();
function shallowArray(xs, ys) {
  if (xs.length !== ys.length) {
    return false;
  }
  for (let i = 0; i < xs.length; i++) {
    if (!Object.is(xs[i], ys[i])) {
      return false;
    }
  }
  return true;
}
function shallowObj(objA, objB) {
  if (!isPlainObject(objA) || !isPlainObject(objB)) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])
  );
}
function shallow(a, b) {
  if (Object.is(a, b)) {
    return true;
  }
  const isArrayA = Array.isArray(a);
  const isArrayB = Array.isArray(b);
  if (isArrayA || isArrayB) {
    if (!isArrayA || !isArrayB) {
      return false;
    }
    return shallowArray(a, b);
  }
  return shallowObj(a, b);
}
function shallow2(a, b) {
  if (!isPlainObject(a) || !isPlainObject(b)) {
    return shallow(a, b);
  }
  const keysA = Object.keys(a);
  if (keysA.length !== Object.keys(b).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])
  );
}
var __items, __childrenOf, __sorted, __primaryKey, __parentKeyFn, __lt, _a13;
var TreePool = (_a13 = class {
  constructor(primaryKey, parentKey, lt) {
    __privateAdd(this, __items);
    __privateAdd(this, __childrenOf);
    __privateAdd(this, __sorted);
    __privateAdd(this, __primaryKey);
    __privateAdd(this, __parentKeyFn);
    __privateAdd(this, __lt);
    __privateSet(this, __primaryKey, primaryKey);
    __privateSet(this, __parentKeyFn, parentKey);
    __privateSet(this, __lt, lt);
    __privateSet(this, __items, /* @__PURE__ */ new Map());
    __privateSet(this, __childrenOf, new DefaultMap(() => /* @__PURE__ */ new Set()));
    __privateSet(this, __sorted, SortedList.with(lt));
  }
  get(id) {
    return __privateGet(this, __items).get(id);
  }
  getOrThrow(id) {
    return this.get(id) ?? raise(`Item with id ${id} not found`);
  }
  get sorted() {
    return __privateGet(this, __sorted);
  }
  getParentId(id) {
    const item = this.getOrThrow(id);
    return __privateGet(this, __parentKeyFn).call(this, item);
  }
  getParent(id) {
    const parentId = this.getParentId(id);
    return parentId ? this.getOrThrow(parentId) : null;
  }
  getChildren(id) {
    const childIds = __privateGet(this, __childrenOf).get(id);
    if (!childIds) return [];
    return Array.from(childIds).map(
      (id2) => __privateGet(this, __items).get(id2)
      // eslint-disable-line no-restricted-syntax
    );
  }
  *walkUp(id, predicate) {
    const includeSelf = true;
    let nodeId = id;
    do {
      const item = this.getOrThrow(nodeId);
      if (includeSelf || nodeId !== id) {
        if (!predicate || predicate(item)) {
          yield item;
        }
      }
      nodeId = __privateGet(this, __parentKeyFn).call(this, item);
    } while (nodeId !== null);
  }
  // XXXX Generalize
  *walkLeft(id, predicate) {
    const self = this.getOrThrow(id);
    const siblings = SortedList.from(this.getSiblings(id), __privateGet(this, __lt));
    for (const sibling of siblings.iterReversed()) {
      if (__privateGet(this, __lt).call(this, self, sibling)) continue;
      if (!predicate || predicate(sibling)) {
        yield sibling;
      }
    }
  }
  // XXXX Generalize
  *walkRight(id, predicate) {
    const self = this.getOrThrow(id);
    const siblings = SortedList.from(this.getSiblings(id), __privateGet(this, __lt));
    for (const sibling of siblings) {
      if (__privateGet(this, __lt).call(this, sibling, self)) continue;
      if (!predicate || predicate(sibling)) {
        yield sibling;
      }
    }
  }
  // XXXX Generalize
  *walkDown(id, predicate) {
    const children = SortedList.from(this.getChildren(id), __privateGet(this, __lt)).rawArray;
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      yield* this.walkDown(
        __privateGet(this, __primaryKey).call(this, child),
        predicate
        // "depth-first",
        // true
      );
      if (!predicate || predicate(child)) {
        yield child;
      }
    }
  }
  /** Returns all siblings, not including the item itself. */
  getSiblings(id) {
    const self = this.getOrThrow(id);
    const parentId = this.getParentId(id);
    return this.getChildren(parentId).filter((item) => item !== self);
  }
  [Symbol.iterator]() {
    return __privateGet(this, __sorted)[Symbol.iterator]();
  }
  upsert(item) {
    const pk = __privateGet(this, __primaryKey).call(this, item);
    const existing = __privateGet(this, __items).get(pk);
    if (existing) {
      if (__privateGet(this, __parentKeyFn).call(this, existing) !== __privateGet(this, __parentKeyFn).call(this, item)) {
        throw new Error(
          "Cannot upsert parent ID changes that change the tree structure. Remove the entry first, and recreate it"
        );
      }
      __privateGet(this, __sorted).remove(existing);
    }
    __privateGet(this, __items).set(pk, item);
    __privateGet(this, __sorted).add(item);
    const parentId = __privateGet(this, __parentKeyFn).call(this, item);
    __privateGet(this, __childrenOf).getOrCreate(parentId).add(pk);
  }
  remove(pk) {
    const item = __privateGet(this, __items).get(pk);
    if (!item) return false;
    const childIds = __privateGet(this, __childrenOf).get(pk);
    if (childIds) {
      throw new Error(
        `Cannot remove item '${pk}' while it still has children. Remove children first.`
      );
    }
    const parentId = __privateGet(this, __parentKeyFn).call(this, item);
    const siblings = __privateGet(this, __childrenOf).get(parentId);
    if (siblings) {
      siblings.delete(pk);
      if (siblings.size === 0) {
        __privateGet(this, __childrenOf).delete(parentId);
      }
    }
    __privateGet(this, __sorted).remove(item);
    __privateGet(this, __childrenOf).delete(pk);
    __privateGet(this, __items).delete(pk);
    return true;
  }
  clear() {
    if (__privateGet(this, __items).size === 0) return false;
    __privateGet(this, __childrenOf).clear();
    __privateGet(this, __items).clear();
    __privateGet(this, __sorted).clear();
    return true;
  }
}, __items = new WeakMap(), __childrenOf = new WeakMap(), __sorted = new WeakMap(), __primaryKey = new WeakMap(), __parentKeyFn = new WeakMap(), __lt = new WeakMap(), _a13);
var Permission = ((Permission2) => {
  Permission2["Read"] = "room:read";
  Permission2["Write"] = "room:write";
  Permission2["PresenceWrite"] = "room:presence:write";
  Permission2["CommentsWrite"] = "comments:write";
  Permission2["CommentsRead"] = "comments:read";
  return Permission2;
})(Permission || {});
function canWriteStorage(scopes) {
  return scopes.includes(
    "room:write"
    /* Write */
  );
}
function canComment(scopes) {
  return scopes.includes(
    "comments:write"
    /* CommentsWrite */
  ) || scopes.includes(
    "room:write"
    /* Write */
  );
}
function isValidAuthTokenPayload(data) {
  return isPlainObject(data) && (data.k === "acc" || data.k === "id" || data.k === "sec-legacy");
}
function parseAuthToken(rawTokenString) {
  const tokenParts = rawTokenString.split(".");
  if (tokenParts.length !== 3) {
    throw new Error("Authentication error: invalid JWT token");
  }
  const payload = tryParseJson(b64decode(tokenParts[1]));
  if (!(payload && isValidAuthTokenPayload(payload))) {
    throw new Error(
      "Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
    );
  }
  return {
    raw: rawTokenString,
    parsed: payload
  };
}
var EMPTY_OBJECT = Object.freeze({});
var NULL_KEYWORD_CHARS = Array.from(new Set("null"));
var TRUE_KEYWORD_CHARS = Array.from(new Set("true"));
var FALSE_KEYWORD_CHARS = Array.from(new Set("false"));
var ALL_KEYWORD_CHARS = Array.from(new Set("nulltruefalse"));
function stripChar(str, chars) {
  const lastChar = str[str.length - 1];
  if (chars.includes(lastChar)) {
    return str.slice(0, -1);
  }
  return str;
}
var _sourceText, _cachedJson, _scanIndex, _escaped, _lastUnterminatedString, _lastTerminatedString, _stack, _IncrementalJsonParser_instances, inString_get, autocompleteTail_fn, catchup_fn, parse_fn, _a14;
var IncrementalJsonParser = (_a14 = class {
  constructor(text = "") {
    __privateAdd(this, _IncrementalJsonParser_instances);
    // Input
    __privateAdd(this, _sourceText, "");
    // Output
    __privateAdd(this, _cachedJson);
    /** How much we've already parsed */
    __privateAdd(this, _scanIndex, 0);
    /** Whether the last char processed was a backslash */
    __privateAdd(this, _escaped, false);
    /**
     * Start position of the last unterminated string, -1 if we're not inside
     * a string currently.
     *
     * Example: '{"a": "foo'
     *                 ^
     */
    __privateAdd(this, _lastUnterminatedString, -1);
    /**
     * Start position of the last fully terminated string we've seen.
     *
     * Example: '{"a": "foo'
     *            ^
     */
    __privateAdd(this, _lastTerminatedString, -1);
    /** The bracket stack of expected closing chars. For input '{"a": ["foo', the stack would be ['}', ']']. */
    __privateAdd(this, _stack, []);
    this.append(text);
  }
  get source() {
    return __privateGet(this, _sourceText);
  }
  get json() {
    if (__privateGet(this, _cachedJson) === void 0) {
      __privateSet(this, _cachedJson, __privateMethod(this, _IncrementalJsonParser_instances, parse_fn).call(this));
    }
    return __privateGet(this, _cachedJson);
  }
  append(delta) {
    if (delta) {
      if (__privateGet(this, _sourceText) === "") {
        delta = delta.trimStart();
      }
      __privateSet(this, _sourceText, __privateGet(this, _sourceText) + delta);
      __privateSet(this, _cachedJson, void 0);
    }
  }
}, _sourceText = new WeakMap(), _cachedJson = new WeakMap(), _scanIndex = new WeakMap(), _escaped = new WeakMap(), _lastUnterminatedString = new WeakMap(), _lastTerminatedString = new WeakMap(), _stack = new WeakMap(), _IncrementalJsonParser_instances = new WeakSet(), inString_get = function() {
  return __privateGet(this, _lastUnterminatedString) >= 0;
}, autocompleteTail_fn = function(output) {
  if (__privateGet(this, _IncrementalJsonParser_instances, inString_get)) {
    return "";
  }
  const lastChar = output.charAt(output.length - 1);
  if (lastChar === "") return "";
  if (lastChar === "-") {
    return "0";
  }
  if (!ALL_KEYWORD_CHARS.includes(lastChar)) return "";
  if (NULL_KEYWORD_CHARS.includes(lastChar)) {
    if (output.endsWith("nul")) return "l";
    if (output.endsWith("nu")) return "ll";
    if (output.endsWith("n")) return "ull";
  }
  if (TRUE_KEYWORD_CHARS.includes(lastChar)) {
    if (output.endsWith("tru")) return "e";
    if (output.endsWith("tr")) return "ue";
    if (output.endsWith("t")) return "rue";
  }
  if (FALSE_KEYWORD_CHARS.includes(lastChar)) {
    if (output.endsWith("fals")) return "e";
    if (output.endsWith("fal")) return "se";
    if (output.endsWith("fa")) return "lse";
    if (output.endsWith("f")) return "alse";
  }
  return "";
}, /**
 * Updates the internal parsing state by processing any new content
 * that has been appended since the last parse. This updates the state with
 * facts only. Any interpretation is left to the #parse() method.
 */
catchup_fn = function() {
  const newContent = __privateGet(this, _sourceText).slice(__privateGet(this, _scanIndex));
  for (let i = 0; i < newContent.length; i++) {
    const ch = newContent[i];
    const absolutePos = __privateGet(this, _scanIndex) + i;
    if (__privateGet(this, _IncrementalJsonParser_instances, inString_get)) {
      if (__privateGet(this, _escaped)) {
        __privateSet(this, _escaped, false);
      } else if (ch === "\\") {
        __privateSet(this, _escaped, true);
      } else if (ch === '"') {
        __privateSet(this, _lastTerminatedString, __privateGet(this, _lastUnterminatedString));
        __privateSet(this, _lastUnterminatedString, -1);
      }
    } else {
      if (ch === '"') {
        __privateSet(this, _lastUnterminatedString, absolutePos);
      } else if (ch === "{") {
        __privateGet(this, _stack).push("}");
      } else if (ch === "[") {
        __privateGet(this, _stack).push("]");
      } else if (ch === "}" && __privateGet(this, _stack).length > 0 && __privateGet(this, _stack)[__privateGet(this, _stack).length - 1] === "}") {
        __privateGet(this, _stack).pop();
      } else if (ch === "]" && __privateGet(this, _stack).length > 0 && __privateGet(this, _stack)[__privateGet(this, _stack).length - 1] === "]") {
        __privateGet(this, _stack).pop();
      }
    }
  }
  __privateSet(this, _scanIndex, __privateGet(this, _sourceText).length);
}, parse_fn = function() {
  __privateMethod(this, _IncrementalJsonParser_instances, catchup_fn).call(this);
  let result = __privateGet(this, _sourceText);
  if (result.charAt(0) !== "{") {
    return EMPTY_OBJECT;
  }
  if (result.endsWith("}")) {
    const quickCheck = tryParseJson(result);
    if (quickCheck) {
      return quickCheck;
    }
  }
  if (__privateGet(this, _IncrementalJsonParser_instances, inString_get)) {
    if (__privateGet(this, _escaped)) {
      result = result.slice(0, -1);
    }
    result += '"';
  }
  result = result.trimEnd();
  result = stripChar(result, ",.");
  result = result + __privateMethod(this, _IncrementalJsonParser_instances, autocompleteTail_fn).call(this, result);
  const suffix = __privateGet(this, _stack).reduceRight((acc, ch) => acc + ch, "");
  {
    const attempt = tryParseJson(result + suffix);
    if (attempt) {
      return attempt;
    }
  }
  if (__privateGet(this, _IncrementalJsonParser_instances, inString_get)) {
    result = result.slice(0, __privateGet(this, _lastUnterminatedString));
  } else {
    result = stripChar(result, ":");
    if (result.endsWith('"')) {
      result = result.slice(0, __privateGet(this, _lastTerminatedString));
    }
  }
  result = stripChar(result, ",");
  result += suffix;
  return tryParseJson(result) ?? EMPTY_OBJECT;
}, _a14);
function replaceOrAppend(content, newItem, keyFn, now2) {
  const existingIndex = findLastIndex(
    content,
    (item) => item.type === newItem.type && keyFn(item) === keyFn(newItem)
  );
  if (existingIndex > -1) {
    content[existingIndex] = newItem;
  } else {
    closePart(content[content.length - 1], now2);
    content.push(newItem);
  }
}
function closePart(prevPart, endedAt) {
  if ((prevPart == null ? void 0 : prevPart.type) === "reasoning") {
    prevPart.endedAt ?? (prevPart.endedAt = endedAt);
  }
}
function patchContentWithDelta(content, delta) {
  var _a26;
  if (delta === null)
    return;
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const lastPart = content[content.length - 1];
  switch (delta.type) {
    case "text-delta":
      if ((lastPart == null ? void 0 : lastPart.type) === "text") {
        lastPart.text += delta.textDelta;
      } else {
        closePart(lastPart, now2);
        content.push({ type: "text", text: delta.textDelta });
      }
      break;
    case "reasoning-delta":
      if ((lastPart == null ? void 0 : lastPart.type) === "reasoning") {
        lastPart.text += delta.textDelta;
      } else {
        closePart(lastPart, now2);
        content.push({
          type: "reasoning",
          text: delta.textDelta,
          startedAt: now2
        });
      }
      break;
    case "tool-stream": {
      const toolInvocation = createReceivingToolInvocation(
        delta.invocationId,
        delta.name
      );
      content.push(toolInvocation);
      break;
    }
    case "tool-delta": {
      if ((lastPart == null ? void 0 : lastPart.type) === "tool-invocation" && lastPart.stage === "receiving") {
        (_a26 = lastPart.__appendDelta) == null ? void 0 : _a26.call(lastPart, delta.delta);
      }
      break;
    }
    case "tool-invocation":
      replaceOrAppend(content, delta, (x) => x.invocationId, now2);
      break;
    case "retrieval":
      replaceOrAppend(content, delta, (x) => x.id, now2);
      break;
    default:
      return assertNever(delta, "Unhandled case");
  }
}
function createReceivingToolInvocation(invocationId, name, partialArgsText = "") {
  const parser = new IncrementalJsonParser(partialArgsText);
  return {
    type: "tool-invocation",
    stage: "receiving",
    invocationId,
    name,
    // --- Alternative implementation for FRONTEND only ------------------------
    get partialArgsText() {
      return parser.source;
    },
    // prettier-ignore
    get partialArgs() {
      return parser.json;
    },
    // prettier-ignore
    __appendDelta(delta) {
      parser.append(delta);
    }
    // prettier-ignore
    // ------------------------------------------------------------------------
  };
}
var DEFAULT_REQUEST_TIMEOUT = 4e3;
function defineAiTool() {
  return (def) => {
    return def;
  };
}
var __layers, _stack2, __cache, _KnowledgeStack_instances, recompute_fn2, _a15;
var KnowledgeStack = (_a15 = class {
  constructor() {
    __privateAdd(this, _KnowledgeStack_instances);
    __privateAdd(this, __layers);
    __privateAdd(this, _stack2);
    //                 /                \
    //      knowledge key               "layer" key
    //      (random, or optionally      (one entry per mounted component)
    //       set by user)
    __privateAdd(this, __cache);
    __privateSet(this, __layers, /* @__PURE__ */ new Set());
    __privateSet(this, _stack2, new DefaultMap(
      () => /* @__PURE__ */ new Map()
    ));
    __privateSet(this, __cache, void 0);
  }
  // Typically a useId()
  registerLayer(uniqueLayerId) {
    const layerKey = uniqueLayerId;
    if (__privateGet(this, __layers).has(layerKey))
      raise(`Layer '${layerKey}' already exists, provide a unique layer id`);
    __privateGet(this, __layers).add(layerKey);
    return layerKey;
  }
  deregisterLayer(layerKey) {
    __privateGet(this, __layers).delete(layerKey);
    let deleted = false;
    for (const [key, knowledge] of __privateGet(this, _stack2)) {
      if (knowledge.delete(layerKey)) {
        deleted = true;
      }
      if (knowledge.size === 0)
        __privateGet(this, _stack2).delete(key);
    }
    if (deleted) {
      this.invalidate();
    }
  }
  get() {
    return __privateGet(this, __cache) ?? __privateSet(this, __cache, __privateMethod(this, _KnowledgeStack_instances, recompute_fn2).call(this));
  }
  invalidate() {
    __privateSet(this, __cache, void 0);
  }
  updateKnowledge(layerKey, key, data) {
    if (!__privateGet(this, __layers).has(layerKey)) raise(`Unknown layer key: ${layerKey}`);
    __privateGet(this, _stack2).getOrCreate(key).set(layerKey, data);
    this.invalidate();
  }
}, __layers = new WeakMap(), _stack2 = new WeakMap(), __cache = new WeakMap(), _KnowledgeStack_instances = new WeakSet(), recompute_fn2 = function() {
  return Array.from(__privateGet(this, _stack2).values()).flatMap(
    (layer) => (
      // Return only the last item (returns [] when empty)
      Array.from(layer.values()).slice(-1).filter(isDefined)
    )
  );
}, _a15);
function now() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
var kWILDCARD = Symbol("*");
function createStore_forTools() {
  const toolsByChatId = new DefaultMap(
    (_chatId) => {
      return new DefaultMap((_name) => {
        return new Signal(void 0);
      });
    }
  );
  const globalOrScopedTool = new DefaultMap((nameAndChat) => {
    const [name, chatId] = tryParseJson(nameAndChat);
    return DerivedSignal.from(() => {
      var _a26;
      return (
        // A tool that's registered and scoped to a specific chat ID...
        ((_a26 = chatId !== void 0 ? toolsByChatId.getOrCreate(chatId).getOrCreate(name) : void 0) == null ? void 0 : _a26.get()) ?? // ...or a globally registered tool
        toolsByChatId.getOrCreate(kWILDCARD).getOrCreate(name).get()
      );
    });
  });
  function getTool(name, chatId) {
    const key = JSON.stringify(chatId !== void 0 ? [name, chatId] : [name]);
    return globalOrScopedTool.getOrCreate(key);
  }
  function registerTool(name, tool, chatId) {
    if (!tool.execute && !tool.render) {
      throw new Error(
        "A tool definition must have an execute() function, a render() function, or both."
      );
    }
    const key = chatId ?? kWILDCARD;
    toolsByChatId.getOrCreate(key).getOrCreate(name).set(tool);
    return () => unregisterTool(key, name);
  }
  function unregisterTool(chatId, name) {
    const tools = toolsByChatId.get(chatId);
    if (tools === void 0) return;
    const tool = tools.get(name);
    if (tool === void 0) return;
    tool.set(void 0);
  }
  function getToolDescriptions(chatId) {
    const globalTools = toolsByChatId.get(kWILDCARD);
    const scopedTools = toolsByChatId.get(chatId);
    return Array.from([
      ...(globalTools == null ? void 0 : globalTools.entries()) ?? [],
      ...(scopedTools == null ? void 0 : scopedTools.entries()) ?? []
    ]).flatMap(([name, tool]) => {
      const tool = tool.get();
      return tool && (tool.enabled ?? true) ? [{ name, description: tool.description, parameters: tool.parameters }] : [];
    });
  }
  return {
    getToolDescriptions,
    getTool,
    registerTool
  };
}
function createStore_forChatMessages(toolsStore, setToolResultFn) {
  const myMessages = /* @__PURE__ */ new Set();
  const handledInvocations = /* @__PURE__ */ new Set();
  const messagePoolByChatId = new DefaultMap(
    (_chatId) => new MutableSignal(
      new TreePool(
        (x) => x.id,
        (x) => x.parentId,
        (x, y) => x.createdAt < y.createdAt
      )
    )
  );
  const generatingMessages = new MutableSignal(
    /* @__PURE__ */ new Map()
  );
  function createOptimistically(chatId, role, parentId, third) {
    const id = `ms_${nanoid()}`;
    const createdAt = now();
    if (role === "user") {
      const content = third;
      upsert({
        id,
        chatId,
        role,
        parentId,
        createdAt,
        content,
        _optimistic: true
      });
    } else {
      const copilotId = third;
      upsert({
        id,
        chatId,
        role,
        parentId,
        createdAt,
        status: "generating",
        contentSoFar: [],
        copilotId,
        _optimistic: true
      });
    }
    return id;
  }
  function upsertMany(messages) {
    batch(() => {
      for (const message of messages) {
        upsert(message);
      }
    });
  }
  function remove(chatId, messageId) {
    const chatMsgs = messagePoolByChatId.get(chatId);
    if (!chatMsgs) return;
    const existing = chatMsgs.get().get(messageId);
    if (!existing || existing.deletedAt) return;
    if (existing.role === "assistant" && existing.status !== "completed") {
      upsert({ ...existing, deletedAt: now(), contentSoFar: [] });
    } else {
      upsert({ ...existing, deletedAt: now(), content: [] });
    }
  }
  function removeByChatId(chatId) {
    const chatMsgs = messagePoolByChatId.get(chatId);
    if (chatMsgs === void 0) return;
    chatMsgs.mutate((pool) => pool.clear());
  }
  function upsert(message) {
    batch(() => {
      var _a26;
      const chatMsgs = messagePoolByChatId.getOrCreate(message.chatId);
      chatMsgs.mutate((pool) => pool.upsert(message));
      if (message.role === "assistant" && message.status === "generating") {
        generatingMessages.mutate((lut) => {
          lut.set(message.id, structuredClone(message));
        });
      } else {
        generatingMessages.mutate((lut) => {
          lut.delete(message.id);
        });
      }
      if (message.role === "assistant" && message.status === "awaiting-tool") {
        if (myMessages.has(message.id)) {
          for (const toolInvocation of message.contentSoFar.filter(
            (part) => part.type === "tool-invocation" && part.stage === "executing"
          )) {
            if (!handledInvocations.has(toolInvocation.invocationId)) {
              handledInvocations.add(toolInvocation.invocationId);
            } else {
              continue;
            }
            const executeFn = (_a26 = toolsStore.getTool(toolInvocation.name, message.chatId).get()) == null ? void 0 : _a26.execute;
            if (executeFn) {
              (async () => {
                const result = await executeFn(toolInvocation.args, {
                  name: toolInvocation.name,
                  invocationId: toolInvocation.invocationId
                });
                return await setToolResultFn(
                  message.chatId,
                  message.id,
                  toolInvocation.invocationId,
                  result ?? { data: {} },
                  { copilotId: message.copilotId }
                  // TODO: Should we pass the other generation options (tools, knowledge) as well?
                );
              })().catch((err) => {
                error2(
                  `Error trying to respond to tool-call: ${String(err)} (in execute())`
                );
              });
            }
          }
        }
      } else {
        if (message.role === "assistant" && message.status === "generating") {
        } else {
          myMessages.delete(message.id);
        }
      }
    });
  }
  function addDelta(messageId, delta) {
    generatingMessages.mutate((lut) => {
      const message = lut.get(messageId);
      if (message === void 0) return false;
      patchContentWithDelta(message.contentSoFar, delta);
      lut.set(messageId, message);
      return true;
    });
  }
  function* iterGeneratingMessages() {
    for (const chatMsgs of messagePoolByChatId.values()) {
      for (const m of chatMsgs.get()) {
        if (m.role === "assistant" && m.status === "generating" && !m._optimistic) {
          yield m;
        }
      }
    }
  }
  function failAllPending() {
    batch(() => {
      generatingMessages.mutate((lut) => {
        let deleted = false;
        for (const [k, v] of lut) {
          if (!v._optimistic) {
            lut.delete(k);
            deleted = true;
          }
        }
        return deleted;
      });
      upsertMany(
        Array.from(iterGeneratingMessages()).map(
          (message) => ({
            ...message,
            status: "failed",
            errorReason: "Lost connection"
          })
        )
      );
    });
  }
  function getMessageById(messageId) {
    for (const messages of messagePoolByChatId.values()) {
      const message = messages.get().get(messageId);
      if (message) {
        return message;
      }
    }
    return void 0;
  }
  function first(iterable) {
    const result = iterable.next();
    return result.done ? void 0 : result.value;
  }
  function selectBranch(pool, preferredBranch) {
    function isAlive(message2) {
      if (!message2.deletedAt) {
        return true;
      }
      for (const _ of pool.walkDown(message2.id, (m) => !m.deletedAt)) {
        return true;
      }
      return false;
    }
    function selectSpine(leaf) {
      var _a26, _b2;
      const spine = [];
      let lastVisitedMessage = null;
      for (const message2 of pool.walkUp(leaf.id)) {
        const prev = ((_a26 = first(pool.walkLeft(message2.id, isAlive))) == null ? void 0 : _a26.id) ?? null;
        const next = ((_b2 = first(pool.walkRight(message2.id, isAlive))) == null ? void 0 : _b2.id) ?? null;
        if (!message2.deletedAt || prev || next) {
          const node = {
            ...message2,
            navigation: { parent: null, prev, next }
          };
          if (lastVisitedMessage !== null) {
            lastVisitedMessage.navigation.parent = node.id;
          }
          lastVisitedMessage = node;
          spine.push(node);
        }
      }
      return spine.reverse();
    }
    function fallback() {
      const latest = pool.sorted.findRight((m) => !m.deletedAt);
      return latest ? selectSpine(latest) : [];
    }
    if (preferredBranch === null) {
      return fallback();
    }
    const message = pool.get(preferredBranch);
    if (!message) {
      return fallback();
    }
    for (const current of pool.walkUp(message.id)) {
      for (const desc of pool.walkDown(current.id, (m) => !m.deletedAt)) {
        return selectSpine(desc);
      }
      if (!current.deletedAt) {
        return selectSpine(current);
      }
    }
    return fallback();
  }
  const immutableMessagesByBranch = new DefaultMap((chatId) => {
    return new DefaultMap((branchId) => {
      const messages = DerivedSignal.from(() => {
        const pool = messagePoolByChatId.getOrCreate(chatId).get();
        return selectBranch(pool, branchId);
      }, shallow2);
      return DerivedSignal.from(() => {
        const generatingMessages = generatingMessages.get();
        return messages.get().map((message) => {
          if (message.role !== "assistant" || message.status !== "generating") {
            return message;
          }
          const generatingMessage = generatingMessages.get(message.id);
          if (generatingMessage === void 0) return message;
          return {
            ...message,
            contentSoFar: generatingMessage.contentSoFar
          };
        });
      }, shallow);
    });
  });
  function getChatMessagesForBranch(chatId, branch) {
    return immutableMessagesByBranch.getOrCreate(chatId).getOrCreate(branch || null);
  }
  function getLastUsedCopilotId(chatId) {
    const pool = messagePoolByChatId.getOrCreate(chatId).get();
    const latest = pool.sorted.findRight(
      (m) => m.role === "assistant" && !m.deletedAt
    );
    return latest == null ? void 0 : latest.copilotId;
  }
  return {
    // Readers
    getMessageById,
    getChatMessagesForBranch,
    getLastUsedCopilotId,
    // Mutations
    createOptimistically,
    upsert,
    upsertMany,
    remove,
    removeByChatId,
    addDelta,
    failAllPending,
    markMine(messageId) {
      myMessages.add(messageId);
    },
    /**
     * Iterates over all my auto-executing messages.
     *
     * These are messages that match all these conditions:
     * - The message is an assistant message
     * - The message is owned by this client ("mine")
     * - The message is currently in "awaiting-tool" status
     * - The message has at least one tool invocation in "executing" stage
     * - The tool invocation has an execute() function defined
     */
    *getAutoExecutingMessageIds() {
      for (const messageId of myMessages) {
        const message = getMessageById(messageId);
        if ((message == null ? void 0 : message.role) === "assistant" && message.status === "awaiting-tool") {
          const isAutoExecuting = message.contentSoFar.some((part) => {
            if (part.type === "tool-invocation" && part.stage === "executing") {
              const tool = toolsStore.getTool(part.name, message.chatId).get();
              return typeof (tool == null ? void 0 : tool.execute) === "function";
            }
            return false;
          });
          if (isAutoExecuting) {
            yield message.id;
          }
        }
      }
    }
  };
}
function createStore_forUserAiChats() {
  const chatsDB = new AiChatDB();
  function upsertMany(chats) {
    batch(() => {
      for (const chat of chats) {
        chatsDB.upsert(chat);
      }
    });
  }
  function upsert(chat) {
    chatsDB.upsert(chat);
  }
  function markDeleted(chatId) {
    chatsDB.markDeleted(chatId);
  }
  function getChatById(chatId) {
    return chatsDB.getEvenIfDeleted(chatId);
  }
  function findMany(query) {
    return chatsDB.signal.get().findMany(query);
  }
  return {
    getChatById,
    findMany,
    // Mutations
    upsert,
    upsertMany,
    markDeleted
  };
}
function createAi(config) {
  const managedSocket = new ManagedSocket(
    config.delegates,
    config.enableDebugLogging,
    false
    // AI doesn't have actors (yet, but it will)
  );
  const chatsStore = createStore_forUserAiChats();
  const toolsStore = createStore_forTools();
  const messagesStore = createStore_forChatMessages(toolsStore, setToolResult);
  const context = {
    staticSessionInfoSig: new Signal(null),
    dynamicSessionInfoSig: new Signal(null),
    pendingCmds: /* @__PURE__ */ new Map(),
    chatsStore,
    messagesStore,
    toolsStore,
    knowledge: new KnowledgeStack()
  };
  const DELTA_THROTTLE = 25;
  let pendingDeltas = [];
  let deltaBatchTimer = null;
  function flushPendingDeltas() {
    const currentQueue = pendingDeltas;
    pendingDeltas = [];
    if (deltaBatchTimer !== null) {
      clearTimeout(deltaBatchTimer);
      deltaBatchTimer = null;
    }
    batch(() => {
      for (const { id, delta } of currentQueue) {
        context.messagesStore.addDelta(id, delta);
      }
    });
  }
  function enqueueDelta(id, delta) {
    pendingDeltas.push({ id, delta });
    if (deltaBatchTimer === null) {
      deltaBatchTimer = setTimeout(flushPendingDeltas, DELTA_THROTTLE);
    }
  }
  let lastTokenKey;
  function onStatusDidChange(_newStatus) {
    const authValue = managedSocket.authValue;
    if (authValue !== null) {
      const tokenKey = getBearerTokenFromAuthValue(authValue);
      if (tokenKey !== lastTokenKey) {
        lastTokenKey = tokenKey;
        if (authValue.type === "secret") {
          const token = authValue.token.parsed;
          context.staticSessionInfoSig.set({
            userId: token.k === "sec-legacy" ? token.id : token.uid,
            userInfo: token.k === "sec-legacy" ? token.info : token.ui
          });
        } else {
          context.staticSessionInfoSig.set({
            userId: void 0,
            userInfo: void 0
          });
        }
      }
    }
  }
  let _connectionLossTimerId;
  let _hasLostConnection = false;
  function handleConnectionLossEvent(newStatus) {
    if (newStatus === "reconnecting") {
      _connectionLossTimerId = setTimeout(() => {
        _hasLostConnection = true;
      }, config.lostConnectionTimeout);
    } else {
      clearTimeout(_connectionLossTimerId);
      if (_hasLostConnection) {
        _hasLostConnection = false;
      }
    }
  }
  function onDidConnect() {
  }
  function onDidDisconnect() {
    flushPendingDeltas();
  }
  function handleServerMessage(event) {
    if (typeof event.data !== "string")
      return;
    const msg = tryParseJson(event.data);
    if (!msg)
      return;
    const cmdId = "cmdId" in msg ? msg.cmdId : msg.event === "cmd-failed" ? msg.failedCmdId : void 0;
    const pendingCmd = context.pendingCmds.get(cmdId);
    if (cmdId && !pendingCmd) {
      warn("Ignoring unexpected command response. Already timed out, or not for us?", msg);
      return;
    }
    if ("event" in msg) {
      if (msg.event === "delta") {
        const { id, delta } = msg;
        enqueueDelta(id, delta);
      } else {
        batch(() => {
          flushPendingDeltas();
          switch (msg.event) {
            case "cmd-failed":
              pendingCmd == null ? void 0 : pendingCmd.reject(new Error(msg.error));
              break;
            case "settle": {
              context.messagesStore.upsert(msg.message);
              break;
            }
            case "warning":
              warn(msg.message);
              break;
            case "error":
              error2(msg.error);
              break;
            case "rebooted":
              context.messagesStore.failAllPending();
              break;
            case "sync":
              for (const m of msg["-messages"] ?? []) {
                context.messagesStore.remove(m.chatId, m.id);
              }
              for (const chatId of msg["-chats"] ?? []) {
                context.chatsStore.markDeleted(chatId);
                context.messagesStore.removeByChatId(chatId);
              }
              for (const chatId of msg.clear ?? []) {
                context.messagesStore.removeByChatId(chatId);
              }
              if (msg.chats) {
                context.chatsStore.upsertMany(msg.chats);
              }
              if (msg.messages) {
                context.messagesStore.upsertMany(msg.messages);
              }
              break;
            default:
              return assertNever(msg, "Unhandled case");
          }
        });
      }
    } else {
      switch (msg.cmd) {
        case "get-chats":
          context.chatsStore.upsertMany(msg.chats);
          break;
        case "get-or-create-chat":
          context.chatsStore.upsert(msg.chat);
          break;
        case "delete-chat":
          context.chatsStore.markDeleted(msg.chatId);
          context.messagesStore.removeByChatId(msg.chatId);
          break;
        case "get-message-tree":
          context.chatsStore.upsert(msg.chat);
          context.messagesStore.upsertMany(msg.messages);
          break;
        case "delete-message":
          context.messagesStore.remove(msg.chatId, msg.messageId);
          break;
        case "clear-chat":
          context.messagesStore.removeByChatId(msg.chatId);
          break;
        case "ask-in-chat":
          if (msg.sourceMessage) {
            context.messagesStore.upsert(msg.sourceMessage);
          }
          context.messagesStore.upsert(msg.targetMessage);
          break;
        case "abort-ai":
          break;
        case "set-tool-result":
          if (msg.ok) {
            context.messagesStore.upsert(msg.message);
          }
          break;
        default:
          return assertNever(msg, "Unhandled case");
      }
    }
    pendingCmd == null ? void 0 : pendingCmd.resolve(msg);
  }
  managedSocket.events.onMessage.subscribe(handleServerMessage);
  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);
  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);
  managedSocket.events.didConnect.subscribe(onDidConnect);
  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);
  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {
    if (true) {
      error2(
        `Connection to websocket server closed. Reason: ${message} (code: ${code}).`
      );
    }
  });
  function connectInitially() {
    if (managedSocket.getStatus() === "initial") {
      managedSocket.connect();
    }
  }
  async function sendClientMsgWithResponse(msg) {
    connectInitially();
    if (managedSocket.getStatus() !== "connected") {
      await managedSocket.events.didConnect.waitUntil();
    }
    const { promise, resolve, reject } = Promise_withResolvers();
    const abortSignal = AbortSignal.timeout(DEFAULT_REQUEST_TIMEOUT);
    abortSignal.addEventListener("abort", () => reject(abortSignal.reason), {
      once: true
    });
    const cmdId = nanoid(7);
    context.pendingCmds.set(cmdId, { resolve, reject });
    sendClientMsg({ ...msg, cmdId });
    return promise.finally(() => {
      context.pendingCmds.delete(cmdId);
    }).catch((err) => {
      error2(err.message);
      throw err;
    });
  }
  function sendClientMsg(msg) {
    managedSocket.send(
      JSON.stringify({
        ...msg
      })
    );
  }
  function getChats(options = {}) {
    return sendClientMsgWithResponse({
      cmd: "get-chats",
      cursor: options.cursor,
      query: options.query
    });
  }
  function getOrCreateChat(id, options) {
    return sendClientMsgWithResponse({
      cmd: "get-or-create-chat",
      id,
      options
    });
  }
  function getMessageTree(chatId) {
    return sendClientMsgWithResponse({
      cmd: "get-message-tree",
      chatId
    });
  }
  function registerKnowledgeLayer(uniqueLayerId) {
    return context.knowledge.registerLayer(uniqueLayerId);
  }
  function deregisterKnowledgeLayer(layerKey) {
    context.knowledge.deregisterLayer(layerKey);
  }
  function updateKnowledge(layerKey, data, key = nanoid()) {
    context.knowledge.updateKnowledge(layerKey, key, data);
  }
  async function setToolResult(chatId, messageId, invocationId, result, options) {
    const knowledge = context.knowledge.get();
    const tools = context.toolsStore.getToolDescriptions(chatId);
    const resp = await sendClientMsgWithResponse({
      cmd: "set-tool-result",
      chatId,
      messageId,
      invocationId,
      result,
      generationOptions: {
        copilotId: options == null ? void 0 : options.copilotId,
        stream: options == null ? void 0 : options.stream,
        timeout: options == null ? void 0 : options.timeout,
        // Knowledge and tools aren't coming from the options, but retrieved
        // from the global context
        knowledge: knowledge.length > 0 ? knowledge : void 0,
        tools: tools.length > 0 ? tools : void 0
      }
    });
    if (resp.ok) {
      messagesStore.markMine(resp.message.id);
    }
  }
  function handleBeforeUnload() {
    for (const messageId of context.messagesStore.getAutoExecutingMessageIds()) {
      sendClientMsgWithResponse({ cmd: "abort-ai", messageId }).catch(() => {
      });
    }
  }
  const win = typeof window !== "undefined" ? window : void 0;
  win == null ? void 0 : win.addEventListener("beforeunload", handleBeforeUnload, { once: true });
  return Object.defineProperty(
    {
      [kInternal]: {
        context
      },
      connectInitially,
      // reconnect: () => managedSocket.reconnect(),
      disconnect: () => managedSocket.disconnect(),
      getChats,
      getOrCreateChat,
      deleteChat: (chatId) => {
        return sendClientMsgWithResponse({ cmd: "delete-chat", chatId });
      },
      getMessageTree,
      deleteMessage: (chatId, messageId) => sendClientMsgWithResponse({ cmd: "delete-message", chatId, messageId }),
      clearChat: (chatId) => sendClientMsgWithResponse({ cmd: "clear-chat", chatId }),
      askUserMessageInChat: async (chatId, userMessage, targetMessageId, options) => {
        const globalKnowledge = context.knowledge.get();
        const requestKnowledge = (options == null ? void 0 : options.knowledge) || [];
        const combinedKnowledge = [...globalKnowledge, ...requestKnowledge];
        const tools = context.toolsStore.getToolDescriptions(chatId);
        messagesStore.markMine(targetMessageId);
        const resp = await sendClientMsgWithResponse({
          cmd: "ask-in-chat",
          chatId,
          sourceMessage: userMessage,
          targetMessageId,
          generationOptions: {
            copilotId: options == null ? void 0 : options.copilotId,
            stream: options == null ? void 0 : options.stream,
            timeout: options == null ? void 0 : options.timeout,
            // Combine global knowledge with request-specific knowledge
            knowledge: combinedKnowledge.length > 0 ? combinedKnowledge : void 0,
            tools: tools.length > 0 ? tools : void 0
          }
        });
        return resp;
      },
      abort: (messageId) => sendClientMsgWithResponse({ cmd: "abort-ai", messageId }),
      setToolResult,
      getStatus: () => managedSocket.getStatus(),
      signals: {
        getChatMessagesForBranch: context.messagesStore.getChatMessagesForBranch,
        getTool: context.toolsStore.getTool
      },
      getChatById: context.chatsStore.getChatById,
      queryChats: context.chatsStore.findMany,
      getLastUsedCopilotId: context.messagesStore.getLastUsedCopilotId,
      registerKnowledgeLayer,
      deregisterKnowledgeLayer,
      updateKnowledge,
      registerTool: context.toolsStore.registerTool
    },
    kInternal,
    { enumerable: false }
  );
}
function makeCreateSocketDelegateForAi(baseUrl, WebSocketPolyfill) {
  return (authValue) => {
    const ws = WebSocketPolyfill ?? (typeof WebSocket === "undefined" ? void 0 : WebSocket);
    if (ws === void 0) {
      throw new StopRetrying(
        "To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill."
      );
    }
    const url2 = new URL(baseUrl);
    url2.protocol = url2.protocol === "http:" ? "ws" : "wss";
    url2.pathname = "/ai/v6";
    if (authValue.type === "secret") {
      url2.searchParams.set("tok", authValue.token.raw);
    } else if (authValue.type === "public") {
      throw new Error("Public key not supported with AI Copilots");
    } else {
      return assertNever(authValue, "Unhandled case");
    }
    url2.searchParams.set("version", PKG_VERSION || "dev");
    return new ws(url2.toString());
  };
}
function createAuthManager(authOptions, onAuthenticate) {
  const authentication = prepareAuthentication(authOptions);
  const seenTokens = /* @__PURE__ */ new Set();
  const tokens = [];
  const expiryTimes = [];
  const requestPromises = /* @__PURE__ */ new Map();
  function reset() {
    seenTokens.clear();
    tokens.length = 0;
    expiryTimes.length = 0;
    requestPromises.clear();
  }
  function hasCorrespondingScopes(requestedScope, scopes) {
    if (requestedScope === "comments:read") {
      return scopes.includes(
        "comments:read"
        /* CommentsRead */
      ) || scopes.includes(
        "comments:write"
        /* CommentsWrite */
      ) || scopes.includes(
        "room:read"
        /* Read */
      ) || scopes.includes(
        "room:write"
        /* Write */
      );
    } else if (requestedScope === "room:read") {
      return scopes.includes(
        "room:read"
        /* Read */
      ) || scopes.includes(
        "room:write"
        /* Write */
      );
    }
    return false;
  }
  function getCachedToken(requestOptions) {
    const now2 = Math.ceil(Date.now() / 1e3);
    for (let i = tokens.length - 1; i >= 0; i--) {
      const token = tokens[i];
      const expiresAt = expiryTimes[i];
      if (expiresAt <= now2) {
        tokens.splice(i, 1);
        expiryTimes.splice(i, 1);
        continue;
      }
      if (token.parsed.k === "id") {
        return token;
      } else if (token.parsed.k === "acc") {
        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {
          return token;
        }
        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {
          if (!requestOptions.roomId) {
            if (resource.includes("*") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {
              return token;
            }
          } else if (resource.includes("*") && requestOptions.roomId.startsWith(resource.replace("*", "")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {
            return token;
          }
        }
      }
    }
    return void 0;
  }
  async function makeAuthRequest(options) {
    var _a26;
    const fetcher = ((_a26 = authOptions.polyfills) == null ? void 0 : _a26.fetch) ?? (typeof window === "undefined" ? void 0 : window.fetch);
    if (authentication.type === "private") {
      if (fetcher === void 0) {
        throw new StopRetrying(
          "To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill."
        );
      }
      const response = await fetchAuthEndpoint(fetcher, authentication.url, {
        room: options.roomId
      });
      const parsed = parseAuthToken(response.token);
      if (seenTokens.has(parsed.raw)) {
        throw new StopRetrying(
          "The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported."
        );
      }
      onAuthenticate == null ? void 0 : onAuthenticate(parsed.parsed);
      return parsed;
    }
    if (authentication.type === "custom") {
      const response = await authentication.callback(options.roomId);
      if (response && typeof response === "object") {
        if (typeof response.token === "string") {
          const parsed = parseAuthToken(response.token);
          onAuthenticate == null ? void 0 : onAuthenticate(parsed.parsed);
          return parsed;
        } else if (typeof response.error === "string") {
          const reason = `Authentication failed: ${"reason" in response && typeof response.reason === "string" ? response.reason : "Forbidden"}`;
          if (response.error === "forbidden") {
            throw new StopRetrying(reason);
          } else {
            throw new Error(reason);
          }
        }
      }
      throw new Error(
        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: "..." }'
      );
    }
    throw new Error(
      "Unexpected authentication type. Must be private or custom."
    );
  }
  async function getAuthValue(requestOptions) {
    if (authentication.type === "public") {
      return { type: "public", publicApiKey: authentication.publicApiKey };
    }
    const cachedToken = getCachedToken(requestOptions);
    if (cachedToken !== void 0) {
      return { type: "secret", token: cachedToken };
    }
    let currentPromise;
    if (requestOptions.roomId) {
      currentPromise = requestPromises.get(requestOptions.roomId);
      if (currentPromise === void 0) {
        currentPromise = makeAuthRequest(requestOptions);
        requestPromises.set(requestOptions.roomId, currentPromise);
      }
    } else {
      currentPromise = requestPromises.get("liveblocks-user-token");
      if (currentPromise === void 0) {
        currentPromise = makeAuthRequest(requestOptions);
        requestPromises.set("liveblocks-user-token", currentPromise);
      }
    }
    try {
      const token = await currentPromise;
      const BUFFER = 30;
      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;
      seenTokens.add(token.raw);
      if (token.parsed.k !== "sec-legacy") {
        tokens.push(token);
        expiryTimes.push(expiresAt);
      }
      return { type: "secret", token };
    } finally {
      if (requestOptions.roomId) {
        requestPromises.delete(requestOptions.roomId);
      } else {
        requestPromises.delete("liveblocks-user-token");
      }
    }
  }
  return {
    reset,
    getAuthValue
  };
}
function prepareAuthentication(authOptions) {
  const { publicApiKey, authEndpoint } = authOptions;
  if (authEndpoint !== void 0 && publicApiKey !== void 0) {
    throw new Error(
      "You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  }
  if (typeof publicApiKey === "string") {
    if (publicApiKey.startsWith("sk_")) {
      throw new Error(
        "Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    } else if (!publicApiKey.startsWith("pk_")) {
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    }
    return {
      type: "public",
      publicApiKey
    };
  }
  if (typeof authEndpoint === "string") {
    return {
      type: "private",
      url: authEndpoint
    };
  } else if (typeof authEndpoint === "function") {
    return {
      type: "custom",
      callback: authEndpoint
    };
  } else if (authEndpoint !== void 0) {
    throw new Error(
      "The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
    );
  }
  throw new Error(
    "Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}
async function fetchAuthEndpoint(fetch, endpoint, body) {
  const res = await fetch(endpoint, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: stringifyOrLog(body)
  });
  if (!res.ok) {
    const reason = `${(await res.text()).trim() || "reason not provided in auth response"} (${res.status} returned by POST ${endpoint})`;
    if (res.status === 401 || res.status === 403) {
      throw new StopRetrying(`Unauthorized: ${reason}`);
    } else {
      throw new Error(`Failed to authenticate: ${reason}`);
    }
  }
  let data;
  try {
    data = await res.json();
  } catch (er) {
    throw new Error(
      `Expected a JSON response when doing a POST request on "${endpoint}". ${String(
        er
      )}`
    );
  }
  if (!isPlainObject(data) || typeof data.token !== "string") {
    throw new Error(
      `Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${endpoint}", but got ${stringifyOrLog(
        data
      )}`
    );
  }
  const { token } = data;
  return { token };
}
var DEFAULT_BASE_URL = "https://api.liveblocks.io";
var MENTION_CHARACTER = "@";
var _bridgeActive = false;
function activateBridge(allowed) {
  _bridgeActive = allowed;
}
function sendToPanel(message, options) {
  if (typeof window === "undefined") {
    return;
  }
  const fullMsg = {
    ...message,
    source: "liveblocks-devtools-client"
  };
  if (!((options == null ? void 0 : options.force) || _bridgeActive)) {
    return;
  }
  window.postMessage(fullMsg, "*");
}
var eventSource = makeEventSource();
if (typeof window !== "undefined") {
  window.addEventListener("message", (event) => {
    var _a26;
    if (event.source === window && ((_a26 = event.data) == null ? void 0 : _a26.source) === "liveblocks-devtools-panel") {
      eventSource.notify(event.data);
    } else {
    }
  });
}
var onMessageFromPanel = eventSource.observable;
var VERSION = PKG_VERSION || "dev";
var _devtoolsSetupHasRun = false;
function setupDevTools(getAllRooms) {
  if (typeof window === "undefined") {
    return;
  }
  if (_devtoolsSetupHasRun) {
    return;
  }
  _devtoolsSetupHasRun = true;
  onMessageFromPanel.subscribe((msg) => {
    switch (msg.msg) {
      // When a devtool panel sends an explicit "connect" message back to this
      // live running client (in response to the "wake-up-devtools" message,
      // or when the devtool panel is opened for the first time), it means that it's okay to
      // start emitting messages.
      // Before this explicit acknowledgement, any call to sendToPanel() will
      // be a no-op.
      case "connect": {
        activateBridge(true);
        for (const roomId of getAllRooms()) {
          sendToPanel({
            msg: "room::available",
            roomId,
            clientVersion: VERSION
          });
        }
        break;
      }
    }
  });
  sendToPanel({ msg: "wake-up-devtools" }, { force: true });
}
var unsubsByRoomId = /* @__PURE__ */ new Map();
function stopSyncStream(roomId) {
  const unsubs = unsubsByRoomId.get(roomId) ?? [];
  unsubsByRoomId.delete(roomId);
  for (const unsub of unsubs) {
    unsub();
  }
}
function startSyncStream(room) {
  stopSyncStream(room.id);
  fullSync(room);
  unsubsByRoomId.set(room.id, [
    // When the connection status changes
    room.events.status.subscribe(() => partialSyncConnection(room)),
    // When storage initializes, send the update
    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),
    // Any time storage updates, send the new storage root
    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),
    // Any time "me" or "others" updates, send the new values accordingly
    room.events.self.subscribe(() => partialSyncMe(room)),
    room.events.others.subscribe(() => partialSyncOthers(room)),
    // Any time ydoc is updated, forward the update
    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),
    // Any time a custom room event is received, forward it
    room.events.customEvent.subscribe(
      (eventData) => forwardEvent(room, eventData)
    )
  ]);
}
function syncYdocUpdate(room, update) {
  sendToPanel({
    msg: "room::sync::ydoc",
    roomId: room.id,
    update
  });
}
var loadedAt = Date.now();
var eventCounter = 0;
function nextEventId() {
  return `event-${loadedAt}-${eventCounter++}`;
}
function forwardEvent(room, eventData) {
  sendToPanel({
    msg: "room::events::custom-event",
    roomId: room.id,
    event: {
      type: "CustomEvent",
      id: nextEventId(),
      key: "Event",
      connectionId: eventData.connectionId,
      payload: eventData.event
    }
  });
}
function partialSyncConnection(room) {
  sendToPanel({
    msg: "room::sync::partial",
    roomId: room.id,
    status: room.getStatus()
  });
}
function partialSyncStorage(room) {
  const root = room.getStorageSnapshot();
  if (root) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      storage: root.toTreeNode("root").payload
    });
  }
}
function partialSyncMe(room) {
  const me = room[kInternal].getSelf_forDevTools();
  if (me) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      me
    });
  }
}
function partialSyncOthers(room) {
  const others = room[kInternal].getOthers_forDevTools();
  if (others) {
    sendToPanel({
      msg: "room::sync::partial",
      roomId: room.id,
      others
    });
  }
}
function fullSync(room) {
  const root = room.getStorageSnapshot();
  const me = room[kInternal].getSelf_forDevTools();
  const others = room[kInternal].getOthers_forDevTools();
  room.fetchYDoc("");
  sendToPanel({
    msg: "room::sync::full",
    roomId: room.id,
    status: room.getStatus(),
    storage: (root == null ? void 0 : root.toTreeNode("root").payload) ?? null,
    me,
    others
  });
}
var roomChannelListeners = /* @__PURE__ */ new Map();
function stopRoomChannelListener(roomId) {
  const listener = roomChannelListeners.get(roomId);
  roomChannelListeners.delete(roomId);
  if (listener) {
    listener();
  }
}
function linkDevTools(roomId, room) {
  if (typeof window === "undefined") {
    return;
  }
  sendToPanel({ msg: "room::available", roomId, clientVersion: VERSION });
  stopRoomChannelListener(roomId);
  roomChannelListeners.set(
    roomId,
    // Returns the unsubscribe callback, that we store in the
    // roomChannelListeners registry
    onMessageFromPanel.subscribe((msg) => {
      switch (msg.msg) {
        // Sent by the devtool panel when it wants to receive the sync stream
        // for a room
        case "room::subscribe": {
          if (msg.roomId === roomId) {
            startSyncStream(room);
          }
          break;
        }
        case "room::unsubscribe": {
          if (msg.roomId === roomId) {
            stopSyncStream(roomId);
          }
          break;
        }
      }
    })
  );
}
function unlinkDevTools(roomId) {
  if (typeof window === "undefined") {
    return;
  }
  stopSyncStream(roomId);
  stopRoomChannelListener(roomId);
  sendToPanel({
    msg: "room::unavailable",
    roomId
  });
}
var _emittedWarnings = /* @__PURE__ */ new Set();
function warnOnce(message, key = message) {
  if (true) {
    if (!_emittedWarnings.has(key)) {
      _emittedWarnings.add(key);
      warn(message);
    }
  }
}
function warnOnceIf(condition, message, key = message) {
  if (typeof condition === "function" ? condition() : condition) {
    warnOnce(message, key);
  }
}
var kPlain = Symbol("notification-settings-plain");
function createNotificationSettings(plain) {
  const channels = [
    "email",
    "slack",
    "teams",
    "webPush"
  ];
  const descriptors = {
    [kPlain]: {
      value: plain,
      enumerable: false
    }
  };
  for (const channel of channels) {
    descriptors[channel] = {
      enumerable: true,
      /**
       * In the TypeScript standard library definitions, the built-in interface for a property descriptor
       * does not include a specialized type for the this context in the getter or setter functions.
       * As a result, both the get and set methods implicitly have this: any.
       * The reason is that property descriptors in JavaScript are used across various objects with
       * no enforced shape for this. And so the standard library definitions have to remain as broad as possible
       * to support any valid JavaScript usage (e.g `Object.defineProperty`).
       *
       * So we can safely tells that this getter is typed as `this: NotificationSettings` because we're
       * creating a well known shaped object  `NotificationSettings`.
       */
      get() {
        const value = this[kPlain][channel];
        if (typeof value === "undefined") {
          error2(
            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`
          );
          return null;
        }
        return value;
      }
    };
  }
  return create(null, descriptors);
}
function patchNotificationSettings(existing, patch) {
  const outcoming = createNotificationSettings({
    ...existing[kPlain]
  });
  for (const channel of keys(patch)) {
    const updates = patch[channel];
    if (updates !== void 0) {
      const kindUpdates = Object.fromEntries(
        entries(updates).filter(([, value]) => value !== void 0)
      );
      outcoming[kPlain][channel] = {
        ...outcoming[kPlain][channel],
        ...kindUpdates
      };
    }
  }
  return outcoming;
}
function isNotificationChannelEnabled(settings) {
  return settings !== null ? values(settings).every((enabled) => enabled === true) : false;
}
var MIN_CODE = 32;
var MAX_CODE = 126;
var NUM_DIGITS = MAX_CODE - MIN_CODE + 1;
var ZERO = nthDigit(0);
var ONE = nthDigit(1);
var ZERO_NINE = ZERO + nthDigit(-1);
function nthDigit(n) {
  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);
  if (code < MIN_CODE || code > MAX_CODE) {
    throw new Error(`Invalid n value: ${n}`);
  }
  return String.fromCharCode(code);
}
function makePosition(x, y) {
  if (x !== void 0 && y !== void 0) {
    return between(x, y);
  } else if (x !== void 0) {
    return after(x);
  } else if (y !== void 0) {
    return before(y);
  } else {
    return ONE;
  }
}
function before(pos) {
  const lastIndex = pos.length - 1;
  for (let i = 0; i <= lastIndex; i++) {
    const code = pos.charCodeAt(i);
    if (code <= MIN_CODE) {
      continue;
    }
    if (i === lastIndex) {
      if (code === MIN_CODE + 1) {
        return pos.substring(0, i) + ZERO_NINE;
      } else {
        return pos.substring(0, i) + String.fromCharCode(code - 1);
      }
    } else {
      return pos.substring(0, i + 1);
    }
  }
  return ONE;
}
function after(pos) {
  for (let i = 0; i <= pos.length - 1; i++) {
    const code = pos.charCodeAt(i);
    if (code >= MAX_CODE) {
      continue;
    }
    return pos.substring(0, i) + String.fromCharCode(code + 1);
  }
  return pos + ONE;
}
function between(lo, hi) {
  if (lo < hi) {
    return _between(lo, hi);
  } else if (lo > hi) {
    return _between(hi, lo);
  } else {
    throw new Error("Cannot compute value between two equal positions");
  }
}
function _between(lo, hi) {
  let index = 0;
  const loLen = lo.length;
  const hiLen = hi.length;
  while (true) {
    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;
    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;
    if (loCode === hiCode) {
      index++;
      continue;
    }
    if (hiCode - loCode === 1) {
      const size = index + 1;
      let prefix = lo.substring(0, size);
      if (prefix.length < size) {
        prefix += ZERO.repeat(size - prefix.length);
      }
      const suffix = lo.substring(size);
      const nines = "";
      return prefix + _between(suffix, nines);
    } else {
      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);
    }
  }
}
function takeN(pos, n) {
  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);
}
var MIN_NON_ZERO_CODE = MIN_CODE + 1;
function isPos(str) {
  if (str === "") {
    return false;
  }
  const lastIdx = str.length - 1;
  const last = str.charCodeAt(lastIdx);
  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {
    return false;
  }
  for (let i = 0; i < lastIdx; i++) {
    const code = str.charCodeAt(i);
    if (code < MIN_CODE || code > MAX_CODE) {
      return false;
    }
  }
  return true;
}
function convertToPos(str) {
  const codes = [];
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);
  }
  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {
    codes.length--;
  }
  return codes.length > 0 ? String.fromCharCode(...codes) : (
    // Edge case: the str was a 0-only string, which is invalid. Default back to .1
    ONE
  );
}
function asPos(str) {
  return isPos(str) ? str : convertToPos(str);
}
var OpCode = ((OpCode2) => {
  OpCode2[OpCode2["INIT"] = 0] = "INIT";
  OpCode2[OpCode2["SET_PARENT_KEY"] = 1] = "SET_PARENT_KEY";
  OpCode2[OpCode2["CREATE_LIST"] = 2] = "CREATE_LIST";
  OpCode2[OpCode2["UPDATE_OBJECT"] = 3] = "UPDATE_OBJECT";
  OpCode2[OpCode2["CREATE_OBJECT"] = 4] = "CREATE_OBJECT";
  OpCode2[OpCode2["DELETE_CRDT"] = 5] = "DELETE_CRDT";
  OpCode2[OpCode2["DELETE_OBJECT_KEY"] = 6] = "DELETE_OBJECT_KEY";
  OpCode2[OpCode2["CREATE_MAP"] = 7] = "CREATE_MAP";
  OpCode2[OpCode2["CREATE_REGISTER"] = 8] = "CREATE_REGISTER";
  return OpCode2;
})(OpCode || {});
function isAckOp(op) {
  return op.type === 5 && op.id === "ACK";
}
function createManagedPool(roomId, options) {
  const {
    getCurrentConnectionId,
    onDispatch,
    isStorageWritable = () => true
  } = options;
  let clock = 0;
  let opClock = 0;
  const nodes = /* @__PURE__ */ new Map();
  return {
    roomId,
    nodes,
    getNode: (id) => nodes.get(id),
    addNode: (id, node) => void nodes.set(id, node),
    deleteNode: (id) => void nodes.delete(id),
    generateId: () => `${getCurrentConnectionId()}:${clock++}`,
    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,
    dispatch(ops, reverse, storageUpdates) {
      onDispatch == null ? void 0 : onDispatch(ops, reverse, storageUpdates);
    },
    assertStorageIsWritable: () => {
      if (!isStorageWritable()) {
        throw new Error(
          "Cannot write to storage with a read only user, please ensure the user has write permissions"
        );
      }
    }
  };
}
function crdtAsLiveNode(value) {
  return value;
}
function HasParent(node, key, pos = asPos(key)) {
  return Object.freeze({ type: "HasParent", node, key, pos });
}
var NoParent = Object.freeze({ type: "NoParent" });
function Orphaned(oldKey, oldPos = asPos(oldKey)) {
  return Object.freeze({ type: "Orphaned", oldKey, oldPos });
}
var _pool, _id, _parent, _cachedImmutable, _cachedTreeNodeKey, _cachedTreeNode, _a16;
var AbstractCrdt = (_a16 = class {
  constructor() {
    //                  ^^^^^^^^^^^^ TODO: Make this an interface
    __privateAdd(this, _pool);
    __privateAdd(this, _id);
    __privateAdd(this, _parent, NoParent);
    /** This caches the result of the last .toImmutable() call for this Live node. */
    __privateAdd(this, _cachedImmutable);
    __privateAdd(this, _cachedTreeNodeKey);
    /** This caches the result of the last .toTreeNode() call for this Live node. */
    __privateAdd(this, _cachedTreeNode);
  }
  /** @internal */
  _getParentKeyOrThrow() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _parentPos() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.pos;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldPos;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _pool() {
    return __privateGet(this, _pool);
  }
  get roomId() {
    return __privateGet(this, _pool) ? __privateGet(this, _pool).roomId : null;
  }
  /** @internal */
  get _id() {
    return __privateGet(this, _id);
  }
  /** @internal */
  get parent() {
    return __privateGet(this, _parent);
  }
  /** @internal */
  get _parentKey() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        return null;
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _apply(op, _isLocal) {
    switch (op.type) {
      case 5: {
        if (this.parent.type === "HasParent") {
          return this.parent.node._detachChild(crdtAsLiveNode(this));
        }
        return { modified: false };
      }
    }
    return { modified: false };
  }
  /** @internal */
  _setParentLink(newParentNode, newParentKey) {
    switch (this.parent.type) {
      case "HasParent":
        if (this.parent.node !== newParentNode) {
          throw new Error("Cannot set parent: node already has a parent");
        } else {
          __privateSet(this, _parent, HasParent(newParentNode, newParentKey));
          return;
        }
      case "Orphaned":
      case "NoParent": {
        __privateSet(this, _parent, HasParent(newParentNode, newParentKey));
        return;
      }
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _attach(id, pool) {
    if (__privateGet(this, _id) || __privateGet(this, _pool)) {
      throw new Error("Cannot attach node: already attached");
    }
    pool.addNode(id, crdtAsLiveNode(this));
    __privateSet(this, _id, id);
    __privateSet(this, _pool, pool);
  }
  /** @internal */
  _detach() {
    if (__privateGet(this, _pool) && __privateGet(this, _id)) {
      __privateGet(this, _pool).deleteNode(__privateGet(this, _id));
    }
    switch (this.parent.type) {
      case "HasParent": {
        __privateSet(this, _parent, Orphaned(this.parent.key, this.parent.pos));
        break;
      }
      case "NoParent": {
        __privateSet(this, _parent, NoParent);
        break;
      }
      case "Orphaned": {
        break;
      }
      default:
        assertNever(this.parent, "Unknown state");
    }
    __privateSet(this, _pool, void 0);
  }
  /**
   * @internal
   *
   * Clear the Immutable cache, so that the next call to `.toImmutable()` will
   * recompute the equivalent Immutable value again.  Call this after every
   * mutation to the Live node.
   */
  invalidate() {
    if (__privateGet(this, _cachedImmutable) !== void 0 || __privateGet(this, _cachedTreeNode) !== void 0) {
      __privateSet(this, _cachedImmutable, void 0);
      __privateSet(this, _cachedTreeNode, void 0);
      if (this.parent.type === "HasParent") {
        this.parent.node.invalidate();
      }
    }
  }
  /**
   * @internal
   *
   * Return an snapshot of this Live tree for use in DevTools.
   */
  toTreeNode(key) {
    if (__privateGet(this, _cachedTreeNode) === void 0 || __privateGet(this, _cachedTreeNodeKey) !== key) {
      __privateSet(this, _cachedTreeNodeKey, key);
      __privateSet(this, _cachedTreeNode, this._toTreeNode(key));
    }
    return __privateGet(this, _cachedTreeNode);
  }
  /**
   * Return an immutable snapshot of this Live node and its children.
   */
  toImmutable() {
    if (__privateGet(this, _cachedImmutable) === void 0) {
      __privateSet(this, _cachedImmutable, this._toImmutable());
    }
    return __privateGet(this, _cachedImmutable);
  }
}, _pool = new WeakMap(), _id = new WeakMap(), _parent = new WeakMap(), _cachedImmutable = new WeakMap(), _cachedTreeNodeKey = new WeakMap(), _cachedTreeNode = new WeakMap(), _a16);
var CrdtType = ((CrdtType2) => {
  CrdtType2[CrdtType2["OBJECT"] = 0] = "OBJECT";
  CrdtType2[CrdtType2["LIST"] = 1] = "LIST";
  CrdtType2[CrdtType2["MAP"] = 2] = "MAP";
  CrdtType2[CrdtType2["REGISTER"] = 3] = "REGISTER";
  return CrdtType2;
})(CrdtType || {});
function isRootCrdt(crdt) {
  return crdt.type === 0 && !isChildCrdt(crdt);
}
function isChildCrdt(crdt) {
  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;
}
var _data2, _a17;
var LiveRegister = (_a17 = class extends AbstractCrdt {
  constructor(data) {
    super();
    __privateAdd(this, _data2);
    __privateSet(this, _data2, data);
  }
  get data() {
    return __privateGet(this, _data2);
  }
  /** @internal */
  static _deserialize([id, item], _parentToChildren, pool) {
    const register = new _a17(item.data);
    register._attach(id, pool);
    return register;
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error(
        "Cannot serialize register if parentId or parentKey is undefined"
      );
    }
    return [
      {
        type: 8,
        opId: pool == null ? void 0 : pool.generateOpId(),
        id: this._id,
        parentId,
        parentKey,
        data: this.data
      }
    ];
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveRegister if parent is missing");
    }
    return {
      type: 3,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
      data: this.data
    };
  }
  /** @internal */
  _attachChild(_op) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _detachChild(_crdt) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  /** @internal */
  _toTreeNode(key) {
    return {
      type: "Json",
      id: this._id ?? nanoid(),
      key,
      payload: __privateGet(this, _data2)
    };
  }
  /** @internal */
  _toImmutable() {
    return __privateGet(this, _data2);
  }
  clone() {
    return deepClone(this.data);
  }
}, _data2 = new WeakMap(), _a17);
function compareNodePosition(itemA, itemB) {
  const posA = itemA._parentPos;
  const posB = itemB._parentPos;
  return posA === posB ? 0 : posA < posB ? -1 : 1;
}
var _items, _implicitlyDeletedItems, _unacknowledgedSets, __LiveList_instances, applySetRemote_fn, applySetAck_fn, detachItemAssociatedToSetOperation_fn, applyRemoteInsert_fn, applyInsertAck_fn, applyInsertUndoRedo_fn, applySetUndoRedo_fn, applySetChildKeyRemote_fn, applySetChildKeyAck_fn, applySetChildKeyUndoRedo_fn, createAttachItemAndSort_fn, shiftItemPosition_fn, _a18;
var LiveList = (_a18 = class extends AbstractCrdt {
  constructor(items) {
    super();
    __privateAdd(this, __LiveList_instances);
    // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?
    __privateAdd(this, _items);
    __privateAdd(this, _implicitlyDeletedItems);
    __privateAdd(this, _unacknowledgedSets);
    __privateSet(this, _items, []);
    __privateSet(this, _implicitlyDeletedItems, /* @__PURE__ */ new WeakSet());
    __privateSet(this, _unacknowledgedSets, /* @__PURE__ */ new Map());
    let position = void 0;
    for (const item of items) {
      const newPosition = makePosition(position);
      const node = lsonToLiveNode(item);
      node._setParentLink(this, newPosition);
      __privateGet(this, _items).push(node);
      position = newPosition;
    }
  }
  /** @internal */
  static _deserialize([id], parentToChildren, pool) {
    const list = new _a18([]);
    list._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return list;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(list, crdt.parentKey);
      list._insertAndSort(child);
    }
    return list;
  }
  /**
   * @internal
   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'
   * so we mutate _unacknowledgedSets to avoid potential flickering
   * https://github.com/liveblocks/liveblocks/pull/1177
   *
   * This is quite unintuitive and should disappear as soon as
   * we introduce an explicit LiveList.Set operation
   */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool == null ? void 0 : pool.generateOpId(),
      type: 2,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const item of __privateGet(this, _items)) {
      const parentKey2 = item._getParentKeyOrThrow();
      const childOps = HACK_addIntentAndDeletedIdToOperation(
        item._toOps(this._id, parentKey2, pool),
        void 0
      );
      const childOpId = childOps[0].opId;
      if (childOpId !== void 0) {
        __privateGet(this, _unacknowledgedSets).set(parentKey2, childOpId);
      }
      ops.push(...childOps);
    }
    return ops;
  }
  /**
   * @internal
   *
   * Adds a new item into the sorted list, in the correct position.
   */
  _insertAndSort(item) {
    __privateGet(this, _items).push(item);
    this._sortItems();
  }
  /** @internal */
  _sortItems() {
    __privateGet(this, _items).sort(compareNodePosition);
    this.invalidate();
  }
  /** @internal */
  _indexOfPosition(position) {
    return __privateGet(this, _items).findIndex(
      (item) => item._getParentKeyOrThrow() === position
    );
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const item of __privateGet(this, _items)) {
      item._attach(pool.generateId(), pool);
    }
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const item of __privateGet(this, _items)) {
      item._detach();
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    let result;
    if (op.intent === "set") {
      if (source === 1) {
        result = __privateMethod(this, __LiveList_instances, applySetRemote_fn).call(this, op);
      } else if (source === 2) {
        result = __privateMethod(this, __LiveList_instances, applySetAck_fn).call(this, op);
      } else {
        result = __privateMethod(this, __LiveList_instances, applySetUndoRedo_fn).call(this, op);
      }
    } else {
      if (source === 1) {
        result = __privateMethod(this, __LiveList_instances, applyRemoteInsert_fn).call(this, op);
      } else if (source === 2) {
        result = __privateMethod(this, __LiveList_instances, applyInsertAck_fn).call(this, op);
      } else {
        result = __privateMethod(this, __LiveList_instances, applyInsertUndoRedo_fn).call(this, op);
      }
    }
    if (result.modified !== false) {
      this.invalidate();
    }
    return result;
  }
  /** @internal */
  _detachChild(child) {
    if (child) {
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(nn(this._id), parentKey, this._pool);
      const indexToDelete = __privateGet(this, _items).indexOf(child);
      if (indexToDelete === -1) {
        return {
          modified: false
        };
      }
      const [previousNode] = __privateGet(this, _items).splice(indexToDelete, 1);
      this.invalidate();
      child._detach();
      return {
        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),
        reverse
      };
    }
    return { modified: false };
  }
  /** @internal */
  _setChildKey(newKey, child, source) {
    if (source === 1) {
      return __privateMethod(this, __LiveList_instances, applySetChildKeyRemote_fn).call(this, newKey, child);
    } else if (source === 2) {
      return __privateMethod(this, __LiveList_instances, applySetChildKeyAck_fn).call(this, newKey, child);
    } else {
      return __privateMethod(this, __LiveList_instances, applySetChildKeyUndoRedo_fn).call(this, newKey, child);
    }
  }
  /** @internal */
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveList if parent is missing");
    }
    return {
      type: 1,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns the number of elements.
   */
  get length() {
    return __privateGet(this, _items).length;
  }
  /**
   * Adds one element to the end of the LiveList.
   * @param element The element to add to the end of the LiveList.
   */
  push(element) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    return this.insert(element, this.length);
  }
  /**
   * Inserts one element at a specified index.
   * @param element The element to insert.
   * @param index The index at which you want to insert the element.
   */
  insert(element, index) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    if (index < 0 || index > __privateGet(this, _items).length) {
      throw new Error(
        `Cannot insert list item at index "${index}". index should be between 0 and ${__privateGet(this, _items).length}`
      );
    }
    const before2 = __privateGet(this, _items)[index - 1] ? __privateGet(this, _items)[index - 1]._parentPos : void 0;
    const after2 = __privateGet(this, _items)[index] ? __privateGet(this, _items)[index]._parentPos : void 0;
    const position = makePosition(before2, after2);
    const value = lsonToLiveNode(element);
    value._setParentLink(this, position);
    this._insertAndSort(value);
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      this._pool.dispatch(
        value._toOps(this._id, position, this._pool),
        [{ type: 5, id }],
        /* @__PURE__ */ new Map([
          [this._id, makeUpdate(this, [insertDelta(index, value)])]
        ])
      );
    }
  }
  /**
   * Move one element from one index to another.
   * @param index The index of the element to move
   * @param targetIndex The index where the element should be after moving.
   */
  move(index, targetIndex) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    if (targetIndex < 0) {
      throw new Error("targetIndex cannot be less than 0");
    }
    if (targetIndex >= __privateGet(this, _items).length) {
      throw new Error(
        "targetIndex cannot be greater or equal than the list length"
      );
    }
    if (index < 0) {
      throw new Error("index cannot be less than 0");
    }
    if (index >= __privateGet(this, _items).length) {
      throw new Error("index cannot be greater or equal than the list length");
    }
    let beforePosition = null;
    let afterPosition = null;
    if (index < targetIndex) {
      afterPosition = targetIndex === __privateGet(this, _items).length - 1 ? void 0 : __privateGet(this, _items)[targetIndex + 1]._parentPos;
      beforePosition = __privateGet(this, _items)[targetIndex]._parentPos;
    } else {
      afterPosition = __privateGet(this, _items)[targetIndex]._parentPos;
      beforePosition = targetIndex === 0 ? void 0 : __privateGet(this, _items)[targetIndex - 1]._parentPos;
    }
    const position = makePosition(beforePosition, afterPosition);
    const item = __privateGet(this, _items)[index];
    const previousPosition = item._getParentKeyOrThrow();
    item._setParentLink(this, position);
    this._sortItems();
    if (this._pool && this._id) {
      const storageUpdates = /* @__PURE__ */ new Map([
        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]
      ]);
      this._pool.dispatch(
        [
          {
            type: 1,
            id: nn(item._id),
            opId: this._pool.generateOpId(),
            parentKey: position
          }
        ],
        [
          {
            type: 1,
            id: nn(item._id),
            parentKey: previousPosition
          }
        ],
        storageUpdates
      );
    }
  }
  /**
   * Deletes an element at the specified index
   * @param index The index of the element to delete
   */
  delete(index) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    if (index < 0 || index >= __privateGet(this, _items).length) {
      throw new Error(
        `Cannot delete list item at index "${index}". index should be between 0 and ${__privateGet(this, _items).length - 1}`
      );
    }
    const item = __privateGet(this, _items)[index];
    item._detach();
    const [prev] = __privateGet(this, _items).splice(index, 1);
    this.invalidate();
    if (this._pool) {
      const childRecordId = item._id;
      if (childRecordId) {
        const storageUpdates = /* @__PURE__ */ new Map();
        storageUpdates.set(
          nn(this._id),
          makeUpdate(this, [deleteDelta(index, prev)])
        );
        this._pool.dispatch(
          [
            {
              id: childRecordId,
              opId: this._pool.generateOpId(),
              type: 5
              /* DELETE_CRDT */
            }
          ],
          item._toOps(nn(this._id), item._getParentKeyOrThrow()),
          storageUpdates
        );
      }
    }
  }
  clear() {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    if (this._pool) {
      const ops = [];
      const reverseOps = [];
      const updateDelta = [];
      for (const item of __privateGet(this, _items)) {
        item._detach();
        const childId = item._id;
        if (childId) {
          ops.push({
            type: 5,
            id: childId,
            opId: this._pool.generateOpId()
          });
          reverseOps.push(
            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())
          );
          updateDelta.push(deleteDelta(0, item));
        }
      }
      __privateSet(this, _items, []);
      this.invalidate();
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    } else {
      for (const item of __privateGet(this, _items)) {
        item._detach();
      }
      __privateSet(this, _items, []);
      this.invalidate();
    }
  }
  set(index, item) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    if (index < 0 || index >= __privateGet(this, _items).length) {
      throw new Error(
        `Cannot set list item at index "${index}". index should be between 0 and ${__privateGet(this, _items).length - 1}`
      );
    }
    const existingItem = __privateGet(this, _items)[index];
    const position = existingItem._getParentKeyOrThrow();
    const existingId = existingItem._id;
    existingItem._detach();
    const value = lsonToLiveNode(item);
    value._setParentLink(this, position);
    __privateGet(this, _items)[index] = value;
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));
      const ops = HACK_addIntentAndDeletedIdToOperation(
        value._toOps(this._id, position, this._pool),
        existingId
      );
      __privateGet(this, _unacknowledgedSets).set(position, nn(ops[0].opId));
      const reverseOps = HACK_addIntentAndDeletedIdToOperation(
        existingItem._toOps(this._id, position, void 0),
        id
      );
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    }
  }
  /**
   * Returns an Array of all the elements in the LiveList.
   */
  toArray() {
    return __privateGet(this, _items).map(
      (entry) => liveNodeToLson(entry)
      //                               ^^^^^^^^
      //                               FIXME! This isn't safe.
    );
  }
  /**
   * Tests whether all elements pass the test implemented by the provided function.
   * @param predicate Function to test for each element, taking two arguments (the element and its index).
   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.
   */
  every(predicate) {
    return this.toArray().every(predicate);
  }
  /**
   * Creates an array with all elements that pass the test implemented by the provided function.
   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.
   * @returns An array with the elements that pass the test.
   */
  filter(predicate) {
    return this.toArray().filter(predicate);
  }
  /**
   * Returns the first element that satisfies the provided testing function.
   * @param predicate Function to execute on each value.
   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.
   */
  find(predicate) {
    return this.toArray().find(predicate);
  }
  /**
   * Returns the index of the first element in the LiveList that satisfies the provided testing function.
   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.
   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.
   */
  findIndex(predicate) {
    return this.toArray().findIndex(predicate);
  }
  /**
   * Executes a provided function once for each element.
   * @param callbackfn Function to execute on each element.
   */
  forEach(callbackfn) {
    return this.toArray().forEach(callbackfn);
  }
  /**
   * Get the element at the specified index.
   * @param index The index on the element to get.
   * @returns The element at the specified index or undefined.
   */
  get(index) {
    if (index < 0 || index >= __privateGet(this, _items).length) {
      return void 0;
    }
    return liveNodeToLson(__privateGet(this, _items)[index]);
  }
  /**
   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.
   * @param searchElement Element to locate.
   * @param fromIndex The index to start the search at.
   * @returns The first index of the element in the LiveList; -1 if not found.
   */
  indexOf(searchElement, fromIndex) {
    return this.toArray().indexOf(searchElement, fromIndex);
  }
  /**
   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.
   * @param searchElement Element to locate.
   * @param fromIndex The index at which to start searching backwards.
   * @returns
   */
  lastIndexOf(searchElement, fromIndex) {
    return this.toArray().lastIndexOf(searchElement, fromIndex);
  }
  /**
   * Creates an array populated with the results of calling a provided function on every element.
   * @param callback Function that is called for every element.
   * @returns An array with each element being the result of the callback function.
   */
  map(callback) {
    return __privateGet(this, _items).map(
      (entry, i) => callback(
        liveNodeToLson(entry),
        //                    ^^^^^^^^
        //                    FIXME! This isn't safe.
        i
      )
    );
  }
  /**
   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.
   * @param predicate Function to test for each element.
   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.
   */
  some(predicate) {
    return this.toArray().some(predicate);
  }
  [Symbol.iterator]() {
    return new LiveListIterator(__privateGet(this, _items));
  }
  /** @internal */
  _toTreeNode(key) {
    return {
      type: "LiveList",
      id: this._id ?? nanoid(),
      key,
      payload: __privateGet(this, _items).map(
        (item, index) => item.toTreeNode(index.toString())
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const result = __privateGet(this, _items).map((node) => node.toImmutable());
    return false ? result : Object.freeze(result);
  }
  clone() {
    return new _a18(__privateGet(this, _items).map((item) => item.clone()));
  }
}, _items = new WeakMap(), _implicitlyDeletedItems = new WeakMap(), _unacknowledgedSets = new WeakMap(), __LiveList_instances = new WeakSet(), applySetRemote_fn = function(op) {
  if (this._pool === void 0) {
    throw new Error("Can't attach child if managed pool is not present");
  }
  const { id, parentKey: key } = op;
  const child = creationOpToLiveNode(op);
  child._attach(id, this._pool);
  child._setParentLink(this, key);
  const deletedId = op.deletedId;
  const indexOfItemWithSamePosition = this._indexOfPosition(key);
  if (indexOfItemWithSamePosition !== -1) {
    const itemWithSamePosition = __privateGet(this, _items)[indexOfItemWithSamePosition];
    if (itemWithSamePosition._id === deletedId) {
      itemWithSamePosition._detach();
      __privateGet(this, _items)[indexOfItemWithSamePosition] = child;
      return {
        modified: makeUpdate(this, [
          setDelta(indexOfItemWithSamePosition, child)
        ]),
        reverse: []
      };
    } else {
      __privateGet(this, _implicitlyDeletedItems).add(itemWithSamePosition);
      __privateGet(this, _items)[indexOfItemWithSamePosition] = child;
      const delta = [
        setDelta(indexOfItemWithSamePosition, child)
      ];
      const deleteDelta2 = __privateMethod(this, __LiveList_instances, detachItemAssociatedToSetOperation_fn).call(this, op.deletedId);
      if (deleteDelta2) {
        delta.push(deleteDelta2);
      }
      return {
        modified: makeUpdate(this, delta),
        reverse: []
      };
    }
  } else {
    const updates = [];
    const deleteDelta2 = __privateMethod(this, __LiveList_instances, detachItemAssociatedToSetOperation_fn).call(this, op.deletedId);
    if (deleteDelta2) {
      updates.push(deleteDelta2);
    }
    this._insertAndSort(child);
    updates.push(insertDelta(this._indexOfPosition(key), child));
    return {
      reverse: [],
      modified: makeUpdate(this, updates)
    };
  }
}, applySetAck_fn = function(op) {
  if (this._pool === void 0) {
    throw new Error("Can't attach child if managed pool is not present");
  }
  const delta = [];
  const deletedDelta = __privateMethod(this, __LiveList_instances, detachItemAssociatedToSetOperation_fn).call(this, op.deletedId);
  if (deletedDelta) {
    delta.push(deletedDelta);
  }
  const unacknowledgedOpId = __privateGet(this, _unacknowledgedSets).get(op.parentKey);
  if (unacknowledgedOpId !== void 0) {
    if (unacknowledgedOpId !== op.opId) {
      return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };
    } else {
      __privateGet(this, _unacknowledgedSets).delete(op.parentKey);
    }
  }
  const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);
  const existingItem = __privateGet(this, _items).find((item) => item._id === op.id);
  if (existingItem !== void 0) {
    if (existingItem._parentKey === op.parentKey) {
      return {
        modified: delta.length > 0 ? makeUpdate(this, delta) : false,
        reverse: []
      };
    }
    if (indexOfItemWithSamePosition !== -1) {
      __privateGet(this, _implicitlyDeletedItems).add(
        __privateGet(this, _items)[indexOfItemWithSamePosition]
      );
      const [prevNode] = __privateGet(this, _items).splice(indexOfItemWithSamePosition, 1);
      delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));
    }
    const prevIndex = __privateGet(this, _items).indexOf(existingItem);
    existingItem._setParentLink(this, op.parentKey);
    this._sortItems();
    const newIndex = __privateGet(this, _items).indexOf(existingItem);
    if (newIndex !== prevIndex) {
      delta.push(moveDelta(prevIndex, newIndex, existingItem));
    }
    return {
      modified: delta.length > 0 ? makeUpdate(this, delta) : false,
      reverse: []
    };
  } else {
    const orphan = this._pool.getNode(op.id);
    if (orphan && __privateGet(this, _implicitlyDeletedItems).has(orphan)) {
      orphan._setParentLink(this, op.parentKey);
      __privateGet(this, _implicitlyDeletedItems).delete(orphan);
      this._insertAndSort(orphan);
      const recreatedItemIndex = __privateGet(this, _items).indexOf(orphan);
      return {
        modified: makeUpdate(this, [
          // If there is an item at this position, update is a set, else it's an insert
          indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),
          ...delta
        ]),
        reverse: []
      };
    } else {
      if (indexOfItemWithSamePosition !== -1) {
        __privateGet(this, _items).splice(indexOfItemWithSamePosition, 1);
      }
      const { newItem, newIndex } = __privateMethod(this, __LiveList_instances, createAttachItemAndSort_fn).call(this, op, op.parentKey);
      return {
        modified: makeUpdate(this, [
          // If there is an item at this position, update is a set, else it's an insert
          indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),
          ...delta
        ]),
        reverse: []
      };
    }
  }
}, /**
 * Returns the update delta of the deletion or null
 */
detachItemAssociatedToSetOperation_fn = function(deletedId) {
  if (deletedId === void 0 || this._pool === void 0) {
    return null;
  }
  const deletedItem = this._pool.getNode(deletedId);
  if (deletedItem === void 0) {
    return null;
  }
  const result = this._detachChild(deletedItem);
  if (result.modified === false) {
    return null;
  }
  return result.modified.updates[0];
}, applyRemoteInsert_fn = function(op) {
  if (this._pool === void 0) {
    throw new Error("Can't attach child if managed pool is not present");
  }
  const key = asPos(op.parentKey);
  const existingItemIndex = this._indexOfPosition(key);
  if (existingItemIndex !== -1) {
    __privateMethod(this, __LiveList_instances, shiftItemPosition_fn).call(this, existingItemIndex, key);
  }
  const { newItem, newIndex } = __privateMethod(this, __LiveList_instances, createAttachItemAndSort_fn).call(this, op, key);
  return {
    modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
    reverse: []
  };
}, applyInsertAck_fn = function(op) {
  const existingItem = __privateGet(this, _items).find((item) => item._id === op.id);
  const key = asPos(op.parentKey);
  const itemIndexAtPosition = this._indexOfPosition(key);
  if (existingItem) {
    if (existingItem._parentKey === key) {
      return {
        modified: false
      };
    } else {
      const oldPositionIndex = __privateGet(this, _items).indexOf(existingItem);
      if (itemIndexAtPosition !== -1) {
        __privateMethod(this, __LiveList_instances, shiftItemPosition_fn).call(this, itemIndexAtPosition, key);
      }
      existingItem._setParentLink(this, key);
      this._sortItems();
      const newIndex = this._indexOfPosition(key);
      if (newIndex === oldPositionIndex) {
        return { modified: false };
      }
      return {
        modified: makeUpdate(this, [
          moveDelta(oldPositionIndex, newIndex, existingItem)
        ]),
        reverse: []
      };
    }
  } else {
    const orphan = nn(this._pool).getNode(op.id);
    if (orphan && __privateGet(this, _implicitlyDeletedItems).has(orphan)) {
      orphan._setParentLink(this, key);
      __privateGet(this, _implicitlyDeletedItems).delete(orphan);
      this._insertAndSort(orphan);
      const newIndex = this._indexOfPosition(key);
      return {
        modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),
        reverse: []
      };
    } else {
      if (itemIndexAtPosition !== -1) {
        __privateMethod(this, __LiveList_instances, shiftItemPosition_fn).call(this, itemIndexAtPosition, key);
      }
      const { newItem, newIndex } = __privateMethod(this, __LiveList_instances, createAttachItemAndSort_fn).call(this, op, key);
      return {
        modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
        reverse: []
      };
    }
  }
}, applyInsertUndoRedo_fn = function(op) {
  var _a26, _b2, _c;
  const { id, parentKey: key } = op;
  const child = creationOpToLiveNode(op);
  if (((_a26 = this._pool) == null ? void 0 : _a26.getNode(id)) !== void 0) {
    return { modified: false };
  }
  child._attach(id, nn(this._pool));
  child._setParentLink(this, key);
  const existingItemIndex = this._indexOfPosition(key);
  let newKey = key;
  if (existingItemIndex !== -1) {
    const before2 = (_b2 = __privateGet(this, _items)[existingItemIndex]) == null ? void 0 : _b2._parentPos;
    const after2 = (_c = __privateGet(this, _items)[existingItemIndex + 1]) == null ? void 0 : _c._parentPos;
    newKey = makePosition(before2, after2);
    child._setParentLink(this, newKey);
  }
  this._insertAndSort(child);
  const newIndex = this._indexOfPosition(newKey);
  return {
    modified: makeUpdate(this, [insertDelta(newIndex, child)]),
    reverse: [{ type: 5, id }]
  };
}, applySetUndoRedo_fn = function(op) {
  var _a26;
  const { id, parentKey: key } = op;
  const child = creationOpToLiveNode(op);
  if (((_a26 = this._pool) == null ? void 0 : _a26.getNode(id)) !== void 0) {
    return { modified: false };
  }
  __privateGet(this, _unacknowledgedSets).set(key, nn(op.opId));
  const indexOfItemWithSameKey = this._indexOfPosition(key);
  child._attach(id, nn(this._pool));
  child._setParentLink(this, key);
  const newKey = key;
  if (indexOfItemWithSameKey !== -1) {
    const existingItem = __privateGet(this, _items)[indexOfItemWithSameKey];
    existingItem._detach();
    __privateGet(this, _items)[indexOfItemWithSameKey] = child;
    const reverse = HACK_addIntentAndDeletedIdToOperation(
      existingItem._toOps(nn(this._id), key, this._pool),
      op.id
    );
    const delta = [setDelta(indexOfItemWithSameKey, child)];
    const deletedDelta = __privateMethod(this, __LiveList_instances, detachItemAssociatedToSetOperation_fn).call(this, op.deletedId);
    if (deletedDelta) {
      delta.push(deletedDelta);
    }
    return {
      modified: makeUpdate(this, delta),
      reverse
    };
  } else {
    this._insertAndSort(child);
    __privateMethod(this, __LiveList_instances, detachItemAssociatedToSetOperation_fn).call(this, op.deletedId);
    const newIndex = this._indexOfPosition(newKey);
    return {
      reverse: [{ type: 5, id }],
      modified: makeUpdate(this, [insertDelta(newIndex, child)])
    };
  }
}, applySetChildKeyRemote_fn = function(newKey, child) {
  var _a26;
  if (__privateGet(this, _implicitlyDeletedItems).has(child)) {
    __privateGet(this, _implicitlyDeletedItems).delete(child);
    child._setParentLink(this, newKey);
    this._insertAndSort(child);
    const newIndex = __privateGet(this, _items).indexOf(child);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, child)]),
      reverse: []
    };
  }
  const previousKey = child._parentKey;
  if (newKey === previousKey) {
    return {
      modified: false
    };
  }
  const existingItemIndex = this._indexOfPosition(newKey);
  if (existingItemIndex === -1) {
    const previousIndex = __privateGet(this, _items).indexOf(child);
    child._setParentLink(this, newKey);
    this._sortItems();
    const newIndex = __privateGet(this, _items).indexOf(child);
    if (newIndex === previousIndex) {
      return {
        modified: false
      };
    }
    return {
      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
      reverse: []
    };
  } else {
    __privateGet(this, _items)[existingItemIndex]._setParentLink(
      this,
      makePosition(newKey, (_a26 = __privateGet(this, _items)[existingItemIndex + 1]) == null ? void 0 : _a26._parentPos)
    );
    const previousIndex = __privateGet(this, _items).indexOf(child);
    child._setParentLink(this, newKey);
    this._sortItems();
    const newIndex = __privateGet(this, _items).indexOf(child);
    if (newIndex === previousIndex) {
      return {
        modified: false
      };
    }
    return {
      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
      reverse: []
    };
  }
}, applySetChildKeyAck_fn = function(newKey, child) {
  var _a26, _b2;
  const previousKey = nn(child._parentKey);
  if (__privateGet(this, _implicitlyDeletedItems).has(child)) {
    const existingItemIndex = this._indexOfPosition(newKey);
    __privateGet(this, _implicitlyDeletedItems).delete(child);
    if (existingItemIndex !== -1) {
      __privateGet(this, _items)[existingItemIndex]._setParentLink(
        this,
        makePosition(newKey, (_a26 = __privateGet(this, _items)[existingItemIndex + 1]) == null ? void 0 : _a26._parentPos)
      );
    }
    child._setParentLink(this, newKey);
    this._insertAndSort(child);
    return {
      modified: false
    };
  } else {
    if (newKey === previousKey) {
      return {
        modified: false
      };
    }
    const previousIndex = __privateGet(this, _items).indexOf(child);
    const existingItemIndex = this._indexOfPosition(newKey);
    if (existingItemIndex !== -1) {
      __privateGet(this, _items)[existingItemIndex]._setParentLink(
        this,
        makePosition(newKey, (_b2 = __privateGet(this, _items)[existingItemIndex + 1]) == null ? void 0 : _b2._parentPos)
      );
    }
    child._setParentLink(this, newKey);
    this._sortItems();
    const newIndex = __privateGet(this, _items).indexOf(child);
    if (previousIndex === newIndex) {
      return {
        modified: false
      };
    } else {
      return {
        modified: makeUpdate(this, [
          moveDelta(previousIndex, newIndex, child)
        ]),
        reverse: []
      };
    }
  }
}, applySetChildKeyUndoRedo_fn = function(newKey, child) {
  var _a26;
  const previousKey = nn(child._parentKey);
  const previousIndex = __privateGet(this, _items).indexOf(child);
  const existingItemIndex = this._indexOfPosition(newKey);
  let actualNewKey = newKey;
  if (existingItemIndex !== -1) {
    actualNewKey = makePosition(
      newKey,
      (_a26 = __privateGet(this, _items)[existingItemIndex + 1]) == null ? void 0 : _a26._parentPos
    );
  }
  child._setParentLink(this, actualNewKey);
  this._sortItems();
  const newIndex = __privateGet(this, _items).indexOf(child);
  if (previousIndex === newIndex) {
    return {
      modified: false
    };
  }
  return {
    modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
    reverse: [
      {
        type: 1,
        id: nn(child._id),
        parentKey: previousKey
      }
    ]
  };
}, createAttachItemAndSort_fn = function(op, key) {
  const newItem = creationOpToLiveNode(op);
  newItem._attach(op.id, nn(this._pool));
  newItem._setParentLink(this, key);
  this._insertAndSort(newItem);
  const newIndex = this._indexOfPosition(key);
  return { newItem, newIndex };
}, shiftItemPosition_fn = function(index, key) {
  var _a26;
  const shiftedPosition = makePosition(
    key,
    __privateGet(this, _items).length > index + 1 ? (_a26 = __privateGet(this, _items)[index + 1]) == null ? void 0 : _a26._parentPos : void 0
  );
  __privateGet(this, _items)[index]._setParentLink(this, shiftedPosition);
}, _a18);
var _innerIterator, _a19;
var LiveListIterator = (_a19 = class {
  constructor(items) {
    __privateAdd(this, _innerIterator);
    __privateSet(this, _innerIterator, items[Symbol.iterator]());
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const result = __privateGet(this, _innerIterator).next();
    if (result.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const value = liveNodeToLson(result.value);
    return { value };
  }
}, _innerIterator = new WeakMap(), _a19);
function makeUpdate(liveList, deltaUpdates) {
  return {
    node: liveList,
    type: "LiveList",
    updates: deltaUpdates
  };
}
function setDelta(index, item) {
  return {
    index,
    type: "set",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function deleteDelta(index, deletedNode) {
  return {
    type: "delete",
    index,
    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode
  };
}
function insertDelta(index, item) {
  return {
    index,
    type: "insert",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function moveDelta(previousIndex, index, item) {
  return {
    type: "move",
    index,
    item: item instanceof LiveRegister ? item.data : item,
    previousIndex
  };
}
function HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {
  return ops.map((op, index) => {
    if (index === 0) {
      const firstOp = op;
      return {
        ...firstOp,
        intent: "set",
        deletedId
      };
    } else {
      return op;
    }
  });
}
var _map, _unacknowledgedSet, _a20;
var LiveMap = (_a20 = class extends AbstractCrdt {
  constructor(entries2) {
    super();
    __privateAdd(this, _map);
    __privateAdd(this, _unacknowledgedSet);
    __privateSet(this, _unacknowledgedSet, /* @__PURE__ */ new Map());
    if (entries2) {
      const mappedEntries = [];
      for (const [key, value] of entries2) {
        const node = lsonToLiveNode(value);
        node._setParentLink(this, key);
        mappedEntries.push([key, node]);
      }
      __privateSet(this, _map, new Map(mappedEntries));
    } else {
      __privateSet(this, _map, /* @__PURE__ */ new Map());
    }
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool == null ? void 0 : pool.generateOpId(),
      type: 7,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const [key, value] of __privateGet(this, _map)) {
      ops.push(...value._toOps(this._id, key, pool));
    }
    return ops;
  }
  /** @internal */
  static _deserialize([id, _item], parentToChildren, pool) {
    const map = new _a20();
    map._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return map;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(map, crdt.parentKey);
      __privateGet(map, _map).set(crdt.parentKey, child);
      map.invalidate();
    }
    return map;
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of __privateGet(this, _map)) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, parentKey, opId } = op;
    const key = parentKey;
    const child = creationOpToLiveNode(op);
    if (this._pool.getNode(id) !== void 0) {
      return { modified: false };
    }
    if (source === 2) {
      const lastUpdateOpId = __privateGet(this, _unacknowledgedSet).get(key);
      if (lastUpdateOpId === opId) {
        __privateGet(this, _unacknowledgedSet).delete(key);
        return { modified: false };
      } else if (lastUpdateOpId !== void 0) {
        return { modified: false };
      }
    } else if (source === 1) {
      __privateGet(this, _unacknowledgedSet).delete(key);
    }
    const previousValue = __privateGet(this, _map).get(key);
    let reverse;
    if (previousValue) {
      const thisId = nn(this._id);
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else {
      reverse = [{ type: 5, id }];
    }
    child._setParentLink(this, key);
    child._attach(id, this._pool);
    __privateGet(this, _map).set(key, child);
    this.invalidate();
    return {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      },
      reverse
    };
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const item of __privateGet(this, _map).values()) {
      item._detach();
    }
  }
  /** @internal */
  _detachChild(child) {
    const id = nn(this._id);
    const parentKey = nn(child._parentKey);
    const reverse = child._toOps(id, parentKey, this._pool);
    for (const [key, value] of __privateGet(this, _map)) {
      if (value === child) {
        __privateGet(this, _map).delete(key);
        this.invalidate();
      }
    }
    child._detach();
    const storageUpdate = {
      node: this,
      type: "LiveMap",
      updates: { [parentKey]: { type: "delete" } }
    };
    return { modified: storageUpdate, reverse };
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveMap if parent is missing");
    }
    return {
      type: 2,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns a specified element from the LiveMap.
   * @param key The key of the element to return.
   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.
   */
  get(key) {
    const value = __privateGet(this, _map).get(key);
    if (value === void 0) {
      return void 0;
    }
    return liveNodeToLson(value);
  }
  /**
   * Adds or updates an element with a specified key and a value.
   * @param key The key of the element to add. Should be a string.
   * @param value The value of the element to add. Should be serializable to JSON.
   */
  set(key, value) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    const oldValue = __privateGet(this, _map).get(key);
    if (oldValue) {
      oldValue._detach();
    }
    const item = lsonToLiveNode(value);
    item._setParentLink(this, key);
    __privateGet(this, _map).set(key, item);
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      item._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      });
      const ops = item._toOps(this._id, key, this._pool);
      __privateGet(this, _unacknowledgedSet).set(key, nn(ops[0].opId));
      this._pool.dispatch(
        item._toOps(this._id, key, this._pool),
        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5, id }],
        storageUpdates
      );
    }
  }
  /**
   * Returns the number of elements in the LiveMap.
   */
  get size() {
    return __privateGet(this, _map).size;
  }
  /**
   * Returns a boolean indicating whether an element with the specified key exists or not.
   * @param key The key of the element to test for presence.
   */
  has(key) {
    return __privateGet(this, _map).has(key);
  }
  /**
   * Removes the specified element by key.
   * @param key The key of the element to remove.
   * @returns true if an element existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    const item = __privateGet(this, _map).get(key);
    if (item === void 0) {
      return false;
    }
    item._detach();
    __privateGet(this, _map).delete(key);
    this.invalidate();
    if (this._pool && item._id) {
      const thisId = nn(this._id);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(thisId, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "delete" } }
      });
      this._pool.dispatch(
        [
          {
            type: 5,
            id: item._id,
            opId: this._pool.generateOpId()
          }
        ],
        item._toOps(thisId, key),
        storageUpdates
      );
    }
    return true;
  }
  /**
   * Returns a new Iterator object that contains the [key, value] pairs for each element.
   */
  entries() {
    const innerIterator = __privateGet(this, _map).entries();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const entry = iteratorValue.value;
        const key = entry[0];
        const value = liveNodeToLson(iteratorValue.value[1]);
        return {
          value: [key, value]
        };
      }
    };
  }
  /**
   * Same function object as the initial value of the entries method.
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Returns a new Iterator object that contains the keys for each element.
   */
  keys() {
    return __privateGet(this, _map).keys();
  }
  /**
   * Returns a new Iterator object that contains the values for each element.
   */
  values() {
    const innerIterator = __privateGet(this, _map).values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const value = liveNodeToLson(iteratorValue.value);
        return { value };
      }
    };
  }
  /**
   * Executes a provided function once per each key/value pair in the Map object, in insertion order.
   * @param callback Function to execute for each entry in the map.
   */
  forEach(callback) {
    for (const entry of this) {
      callback(entry[1], entry[0], this);
    }
  }
  /** @internal */
  _toTreeNode(key) {
    return {
      type: "LiveMap",
      id: this._id ?? nanoid(),
      key,
      payload: Array.from(__privateGet(this, _map).entries()).map(
        ([key2, val]) => val.toTreeNode(key2)
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of __privateGet(this, _map)) {
      result.set(key, value.toImmutable());
    }
    return freeze(result);
  }
  clone() {
    return new _a20(
      Array.from(__privateGet(this, _map)).map(([key, node]) => [key, node.clone()])
    );
  }
}, _map = new WeakMap(), _unacknowledgedSet = new WeakMap(), _a20);
var MAX_LIVE_OBJECT_SIZE = 128 * 1024;
var _map2, _propToLastUpdate, _a21, __LiveObject_static, buildRootAndParentToChildren_fn, __LiveObject_instances, applyUpdate_fn, applyDeleteObjectKey_fn;
var LiveObject = (_a21 = class extends AbstractCrdt {
  constructor(obj = {}) {
    super();
    __privateAdd(this, __LiveObject_instances);
    __privateAdd(this, _map2);
    __privateAdd(this, _propToLastUpdate);
    __privateSet(this, _propToLastUpdate, /* @__PURE__ */ new Map());
    const o = compactObject(obj);
    for (const key of Object.keys(o)) {
      const value = o[key];
      if (isLiveNode(value)) {
        value._setParentLink(this, key);
      }
    }
    __privateSet(this, _map2, new Map(Object.entries(o)));
  }
  /** @private Do not use this API directly */
  static _fromItems(items, pool) {
    var _a26;
    const [root, parentToChildren] = __privateMethod(_a26 = _a21, __LiveObject_static, buildRootAndParentToChildren_fn).call(_a26, items);
    return _a21._deserialize(
      root,
      parentToChildren,
      pool
    );
  }
  /** @internal */
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const opId = pool == null ? void 0 : pool.generateOpId();
    const ops = [];
    const op = {
      type: 4,
      id: this._id,
      opId,
      parentId,
      parentKey,
      data: {}
    };
    ops.push(op);
    for (const [key, value] of __privateGet(this, _map2)) {
      if (isLiveNode(value)) {
        ops.push(...value._toOps(this._id, key, pool));
      } else {
        op.data[key] = value;
      }
    }
    return ops;
  }
  /** @internal */
  static _deserialize([id, item], parentToChildren, pool) {
    const liveObj = new _a21(item.data);
    liveObj._attach(id, pool);
    return this._deserializeChildren(liveObj, parentToChildren, pool);
  }
  /** @internal */
  static _deserializeChildren(liveObj, parentToChildren, pool) {
    const children = parentToChildren.get(nn(liveObj._id));
    if (children === void 0) {
      return liveObj;
    }
    for (const [id, crdt] of children) {
      const child = deserializeToLson([id, crdt], parentToChildren, pool);
      if (isLiveStructure(child)) {
        child._setParentLink(liveObj, crdt.parentKey);
      }
      __privateGet(liveObj, _map2).set(crdt.parentKey, child);
      liveObj.invalidate();
    }
    return liveObj;
  }
  /** @internal */
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of __privateGet(this, _map2)) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  /** @internal */
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, opId, parentKey: key } = op;
    const child = creationOpToLson(op);
    if (this._pool.getNode(id) !== void 0) {
      if (__privateGet(this, _propToLastUpdate).get(key) === opId) {
        __privateGet(this, _propToLastUpdate).delete(key);
      }
      return { modified: false };
    }
    if (source === 0) {
      __privateGet(this, _propToLastUpdate).set(key, nn(opId));
    } else if (__privateGet(this, _propToLastUpdate).get(key) === void 0) {
    } else if (__privateGet(this, _propToLastUpdate).get(key) === opId) {
      __privateGet(this, _propToLastUpdate).delete(key);
      return { modified: false };
    } else {
      return { modified: false };
    }
    const thisId = nn(this._id);
    const previousValue = __privateGet(this, _map2).get(key);
    let reverse;
    if (isLiveNode(previousValue)) {
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else if (previousValue === void 0) {
      reverse = [{ type: 6, id: thisId, key }];
    } else {
      reverse = [
        {
          type: 3,
          id: thisId,
          data: { [key]: previousValue }
        }
      ];
    }
    __privateGet(this, _map2).set(key, child);
    this.invalidate();
    if (isLiveStructure(child)) {
      child._setParentLink(this, key);
      child._attach(id, this._pool);
    }
    return {
      reverse,
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [key]: { type: "update" } }
      }
    };
  }
  /** @internal */
  _detachChild(child) {
    if (child) {
      const id = nn(this._id);
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(id, parentKey, this._pool);
      for (const [key, value] of __privateGet(this, _map2)) {
        if (value === child) {
          __privateGet(this, _map2).delete(key);
          this.invalidate();
        }
      }
      child._detach();
      const storageUpdate = {
        node: this,
        type: "LiveObject",
        updates: {
          [parentKey]: { type: "delete" }
        }
      };
      return { modified: storageUpdate, reverse };
    }
    return { modified: false };
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const value of __privateGet(this, _map2).values()) {
      if (isLiveNode(value)) {
        value._detach();
      }
    }
  }
  /** @internal */
  _apply(op, isLocal) {
    if (op.type === 3) {
      return __privateMethod(this, __LiveObject_instances, applyUpdate_fn).call(this, op, isLocal);
    } else if (op.type === 6) {
      return __privateMethod(this, __LiveObject_instances, applyDeleteObjectKey_fn).call(this, op, isLocal);
    }
    return super._apply(op, isLocal);
  }
  /** @internal */
  _serialize() {
    const data = {};
    for (const [key, value] of __privateGet(this, _map2)) {
      if (!isLiveNode(value)) {
        data[key] = value;
      }
    }
    if (this.parent.type === "HasParent" && this.parent.node._id) {
      return {
        type: 0,
        parentId: this.parent.node._id,
        parentKey: this.parent.key,
        data
      };
    } else {
      return {
        type: 0,
        data
      };
    }
  }
  /**
   * Transform the LiveObject into a javascript object
   */
  toObject() {
    return Object.fromEntries(__privateGet(this, _map2));
  }
  /**
   * Adds or updates a property with a specified key and a value.
   * @param key The key of the property to add
   * @param value The value of the property to add
   */
  set(key, value) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    this.update({ [key]: value });
  }
  /**
   * Returns a specified property from the LiveObject.
   * @param key The key of the property to get
   */
  get(key) {
    return __privateGet(this, _map2).get(key);
  }
  /**
   * Deletes a key from the LiveObject
   * @param key The key of the property to delete
   */
  delete(key) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    const keyAsString = key;
    const oldValue = __privateGet(this, _map2).get(keyAsString);
    if (oldValue === void 0) {
      return;
    }
    if (this._pool === void 0 || this._id === void 0) {
      if (isLiveNode(oldValue)) {
        oldValue._detach();
      }
      __privateGet(this, _map2).delete(keyAsString);
      this.invalidate();
      return;
    }
    let reverse;
    if (isLiveNode(oldValue)) {
      oldValue._detach();
      reverse = oldValue._toOps(this._id, keyAsString);
    } else {
      reverse = [
        {
          type: 3,
          data: { [keyAsString]: oldValue },
          id: this._id
        }
      ];
    }
    __privateGet(this, _map2).delete(keyAsString);
    this.invalidate();
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: { [key]: { type: "delete" } }
    });
    this._pool.dispatch(
      [
        {
          type: 6,
          key: keyAsString,
          id: this._id,
          opId: this._pool.generateOpId()
        }
      ],
      reverse,
      storageUpdates
    );
  }
  /**
   * Adds or updates multiple properties at once with an object.
   * @param patch The object used to overrides properties
   */
  update(patch) {
    var _a26;
    (_a26 = this._pool) == null ? void 0 : _a26.assertStorageIsWritable();
    if (_a21.detectLargeObjects) {
      const data = {};
      for (const [key, value] of __privateGet(this, _map2)) {
        if (!isLiveNode(value)) {
          data[key] = value;
        }
      }
      for (const key of Object.keys(patch)) {
        const value = patch[key];
        if (value === void 0) continue;
        if (!isLiveNode(value)) {
          data[key] = value;
        }
      }
      const jsonString = JSON.stringify(data);
      const upperBoundSize = jsonString.length * 4;
      if (upperBoundSize > MAX_LIVE_OBJECT_SIZE) {
        const preciseSize = new TextEncoder().encode(jsonString).length;
        if (preciseSize > MAX_LIVE_OBJECT_SIZE) {
          throw new Error(
            `LiveObject size exceeded limit: ${preciseSize} bytes > ${MAX_LIVE_OBJECT_SIZE} bytes. See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits`
          );
        }
      }
    }
    if (this._pool === void 0 || this._id === void 0) {
      for (const key in patch) {
        const newValue = patch[key];
        if (newValue === void 0) {
          continue;
        }
        const oldValue = __privateGet(this, _map2).get(key);
        if (isLiveNode(oldValue)) {
          oldValue._detach();
        }
        if (isLiveNode(newValue)) {
          newValue._setParentLink(this, key);
        }
        __privateGet(this, _map2).set(key, newValue);
        this.invalidate();
      }
      return;
    }
    const ops = [];
    const reverseOps = [];
    const opId = this._pool.generateOpId();
    const updatedProps = {};
    const reverseUpdateOp = {
      id: this._id,
      type: 3,
      data: {}
    };
    const updateDelta = {};
    for (const key in patch) {
      const newValue = patch[key];
      if (newValue === void 0) {
        continue;
      }
      const oldValue = __privateGet(this, _map2).get(key);
      if (isLiveNode(oldValue)) {
        reverseOps.push(...oldValue._toOps(this._id, key));
        oldValue._detach();
      } else if (oldValue === void 0) {
        reverseOps.push({ type: 6, id: this._id, key });
      } else {
        reverseUpdateOp.data[key] = oldValue;
      }
      if (isLiveNode(newValue)) {
        newValue._setParentLink(this, key);
        newValue._attach(this._pool.generateId(), this._pool);
        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);
        const createCrdtOp = newAttachChildOps.find(
          (op) => op.parentId === this._id
        );
        if (createCrdtOp) {
          __privateGet(this, _propToLastUpdate).set(key, nn(createCrdtOp.opId));
        }
        ops.push(...newAttachChildOps);
      } else {
        updatedProps[key] = newValue;
        __privateGet(this, _propToLastUpdate).set(key, opId);
      }
      __privateGet(this, _map2).set(key, newValue);
      this.invalidate();
      updateDelta[key] = { type: "update" };
    }
    if (Object.keys(reverseUpdateOp.data).length !== 0) {
      reverseOps.unshift(reverseUpdateOp);
    }
    if (Object.keys(updatedProps).length !== 0) {
      ops.unshift({
        opId,
        id: this._id,
        type: 3,
        data: updatedProps
      });
    }
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: updateDelta
    });
    this._pool.dispatch(ops, reverseOps, storageUpdates);
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  toTreeNode(key) {
    return super.toTreeNode(key);
  }
  /** @internal */
  _toTreeNode(key) {
    const nodeId = this._id ?? nanoid();
    return {
      type: "LiveObject",
      id: nodeId,
      key,
      payload: Array.from(__privateGet(this, _map2).entries()).map(
        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: "Json", id: `${nodeId}:${key2}`, key: key2, payload: value }
      )
    };
  }
  /** @internal */
  _toImmutable() {
    const result = {};
    for (const [key, val] of __privateGet(this, _map2)) {
      result[key] = isLiveStructure(val) ? val.toImmutable() : val;
    }
    return false ? result : Object.freeze(result);
  }
  clone() {
    return new _a21(
      Object.fromEntries(
        Array.from(__privateGet(this, _map2)).map(([key, value]) => [
          key,
          isLiveStructure(value) ? value.clone() : deepClone(value)
        ])
      )
    );
  }
}, _map2 = new WeakMap(), _propToLastUpdate = new WeakMap(), __LiveObject_static = new WeakSet(), buildRootAndParentToChildren_fn = function(items) {
  const parentToChildren = /* @__PURE__ */ new Map();
  let root = null;
  for (const [id, crdt] of items) {
    if (isRootCrdt(crdt)) {
      root = [id, crdt];
    } else {
      const tuple = [id, crdt];
      const children = parentToChildren.get(crdt.parentId);
      if (children !== void 0) {
        children.push(tuple);
      } else {
        parentToChildren.set(crdt.parentId, [tuple]);
      }
    }
  }
  if (root === null) {
    throw new Error("Root can't be null");
  }
  return [root, parentToChildren];
}, __LiveObject_instances = new WeakSet(), applyUpdate_fn = function(op, isLocal) {
  let isModified = false;
  const id = nn(this._id);
  const reverse = [];
  const reverseUpdate = {
    type: 3,
    id,
    data: {}
  };
  for (const key in op.data) {
    const oldValue = __privateGet(this, _map2).get(key);
    if (isLiveNode(oldValue)) {
      reverse.push(...oldValue._toOps(id, key));
      oldValue._detach();
    } else if (oldValue !== void 0) {
      reverseUpdate.data[key] = oldValue;
    } else if (oldValue === void 0) {
      reverse.push({ type: 6, id, key });
    }
  }
  const updateDelta = {};
  for (const key in op.data) {
    const value = op.data[key];
    if (value === void 0) {
      continue;
    }
    if (isLocal) {
      __privateGet(this, _propToLastUpdate).set(key, nn(op.opId));
    } else if (__privateGet(this, _propToLastUpdate).get(key) === void 0) {
      isModified = true;
    } else if (__privateGet(this, _propToLastUpdate).get(key) === op.opId) {
      __privateGet(this, _propToLastUpdate).delete(key);
      continue;
    } else {
      continue;
    }
    const oldValue = __privateGet(this, _map2).get(key);
    if (isLiveNode(oldValue)) {
      oldValue._detach();
    }
    isModified = true;
    updateDelta[key] = { type: "update" };
    __privateGet(this, _map2).set(key, value);
    this.invalidate();
  }
  if (Object.keys(reverseUpdate.data).length !== 0) {
    reverse.unshift(reverseUpdate);
  }
  return isModified ? {
    modified: {
      node: this,
      type: "LiveObject",
      updates: updateDelta
    },
    reverse
  } : { modified: false };
}, applyDeleteObjectKey_fn = function(op, isLocal) {
  const key = op.key;
  if (__privateGet(this, _map2).has(key) === false) {
    return { modified: false };
  }
  if (!isLocal && __privateGet(this, _propToLastUpdate).get(key) !== void 0) {
    return { modified: false };
  }
  const oldValue = __privateGet(this, _map2).get(key);
  const id = nn(this._id);
  let reverse = [];
  if (isLiveNode(oldValue)) {
    reverse = oldValue._toOps(id, op.key);
    oldValue._detach();
  } else if (oldValue !== void 0) {
    reverse = [
      {
        type: 3,
        id,
        data: { [key]: oldValue }
      }
    ];
  }
  __privateGet(this, _map2).delete(key);
  this.invalidate();
  return {
    modified: {
      node: this,
      type: "LiveObject",
      updates: { [op.key]: { type: "delete" } }
    },
    reverse
  };
}, __privateAdd(_a21, __LiveObject_static), /**
 * Enable or disable detection of too large LiveObjects.
 * When enabled, throws an error if LiveObject static data exceeds 128KB, which
 * is the maximum value the server will be able to accept.
 * By default, this behavior is disabled to avoid the runtime performance
 * overhead on every LiveObject.set() or LiveObject.update() call.
 *
 * @experimental
 */
__publicField(_a21, "detectLargeObjects", false), _a21);
function creationOpToLiveNode(op) {
  return lsonToLiveNode(creationOpToLson(op));
}
function creationOpToLson(op) {
  switch (op.type) {
    case 8:
      return op.data;
    case 4:
      return new LiveObject(op.data);
    case 7:
      return new LiveMap();
    case 2:
      return new LiveList([]);
    default:
      return assertNever(op, "Unknown creation Op");
  }
}
function isSameNodeOrChildOf(node, parent) {
  if (node === parent) {
    return true;
  }
  if (node.parent.type === "HasParent") {
    return isSameNodeOrChildOf(node.parent.node, parent);
  }
  return false;
}
function deserialize([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3: {
      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function deserializeToLson([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3: {
      return crdt.data;
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function isLiveStructure(value) {
  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);
}
function isLiveNode(value) {
  return isLiveStructure(value) || isLiveRegister(value);
}
function isLiveList(value) {
  return value instanceof LiveList;
}
function isLiveMap(value) {
  return value instanceof LiveMap;
}
function isLiveObject(value) {
  return value instanceof LiveObject;
}
function isLiveRegister(value) {
  return value instanceof LiveRegister;
}
function cloneLson(value) {
  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);
}
function liveNodeToLson(obj) {
  if (obj instanceof LiveRegister) {
    return obj.data;
  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {
    return obj;
  } else {
    return assertNever(obj, "Unknown AbstractCrdt");
  }
}
function lsonToLiveNode(value) {
  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {
    return value;
  } else {
    return new LiveRegister(value);
  }
}
function getTreesDiffOperations(currentItems, newItems) {
  const ops = [];
  currentItems.forEach((_, id) => {
    if (!newItems.get(id)) {
      ops.push({
        type: 5,
        id
      });
    }
  });
  newItems.forEach((crdt, id) => {
    const currentCrdt = currentItems.get(id);
    if (currentCrdt) {
      if (crdt.type === 0) {
        if (currentCrdt.type !== 0 || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {
          ops.push({
            type: 3,
            id,
            data: crdt.data
          });
        }
      }
      if (crdt.parentKey !== currentCrdt.parentKey) {
        ops.push({
          type: 1,
          id,
          parentKey: nn(crdt.parentKey, "Parent key must not be missing")
        });
      }
    } else {
      switch (crdt.type) {
        case 3:
          ops.push({
            type: 8,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey,
            data: crdt.data
          });
          break;
        case 1:
          ops.push({
            type: 2,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
        case 0:
          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {
            throw new Error(
              "Internal error. Cannot serialize storage root into an operation"
            );
          }
          ops.push({
            type: 4,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey,
            data: crdt.data
          });
          break;
        case 2:
          ops.push({
            type: 7,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
      }
    }
  });
  return ops;
}
function mergeObjectStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return {
    ...second,
    updates
  };
}
function mergeMapStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return {
    ...second,
    updates
  };
}
function mergeListStorageUpdates(first, second) {
  const updates = first.updates;
  return {
    ...second,
    updates: updates.concat(second.updates)
  };
}
function mergeStorageUpdates(first, second) {
  if (first === void 0) {
    return second;
  }
  if (first.type === "LiveObject" && second.type === "LiveObject") {
    return mergeObjectStorageUpdates(first, second);
  } else if (first.type === "LiveMap" && second.type === "LiveMap") {
    return mergeMapStorageUpdates(first, second);
  } else if (first.type === "LiveList" && second.type === "LiveList") {
    return mergeListStorageUpdates(first, second);
  } else {
  }
  return second;
}
function captureStackTrace(msg, traceRoot) {
  const errorLike = { name: msg };
  if (typeof Error.captureStackTrace !== "function") {
    return void 0;
  }
  Error.captureStackTrace(errorLike, traceRoot);
  return errorLike.stack;
}
var _data3, _front, _back, _size2, _a22;
var Deque = (_a22 = class {
  constructor() {
    __privateAdd(this, _data3);
    __privateAdd(this, _front);
    __privateAdd(this, _back);
    __privateAdd(this, _size2);
    __privateSet(this, _data3, {});
    __privateSet(this, _front, 0);
    __privateSet(this, _back, 1);
    __privateSet(this, _size2, 0);
  }
  get length() {
    return __privateGet(this, _size2);
  }
  *[Symbol.iterator]() {
    const size = __privateGet(this, _size2);
    const front = __privateGet(this, _front);
    for (let i = 0; i < size; i++) {
      yield __privateGet(this, _data3)[front + i];
    }
  }
  push(value) {
    const values2 = Array.isArray(value) ? value : [value];
    if (__privateGet(this, _back) > Number.MAX_SAFE_INTEGER - values2.length - 1)
      raise("Deque full");
    for (const value2 of values2) {
      __privateGet(this, _data3)[__privateWrapper(this, _back)._++ - 1] = value2;
    }
    __privateSet(this, _size2, __privateGet(this, _size2) + values2.length);
  }
  pop() {
    if (__privateGet(this, _size2) < 1) return void 0;
    __privateWrapper(this, _back)._--;
    const value = __privateGet(this, _data3)[__privateGet(this, _back) - 1];
    delete __privateGet(this, _data3)[__privateGet(this, _back) - 1];
    __privateWrapper(this, _size2)._--;
    return value;
  }
  pushLeft(value) {
    const values2 = Array.isArray(value) ? value : [value];
    if (__privateGet(this, _front) < Number.MIN_SAFE_INTEGER + values2.length)
      raise("Deque full");
    for (let i = values2.length - 1; i >= 0; i--) {
      __privateGet(this, _data3)[--__privateWrapper(this, _front)._] = values2[i];
    }
    __privateSet(this, _size2, __privateGet(this, _size2) + values2.length);
  }
  popLeft() {
    if (__privateGet(this, _size2) < 1) return void 0;
    const value = __privateGet(this, _data3)[__privateGet(this, _front)];
    delete __privateGet(this, _data3)[__privateGet(this, _front)];
    __privateWrapper(this, _front)._++;
    __privateWrapper(this, _size2)._--;
    return value;
  }
}, _data3 = new WeakMap(), _front = new WeakMap(), _back = new WeakMap(), _size2 = new WeakMap(), _a22);
function isJsonScalar(data) {
  return data === null || typeof data === "string" || typeof data === "number" || typeof data === "boolean";
}
function isJsonArray(data) {
  return Array.isArray(data);
}
function isJsonObject(data) {
  return !isJsonScalar(data) && !isJsonArray(data);
}
var ClientMsgCode = ((ClientMsgCode2) => {
  ClientMsgCode2[ClientMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ClientMsgCode2[ClientMsgCode2["BROADCAST_EVENT"] = 103] = "BROADCAST_EVENT";
  ClientMsgCode2[ClientMsgCode2["FETCH_STORAGE"] = 200] = "FETCH_STORAGE";
  ClientMsgCode2[ClientMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  ClientMsgCode2[ClientMsgCode2["FETCH_YDOC"] = 300] = "FETCH_YDOC";
  ClientMsgCode2[ClientMsgCode2["UPDATE_YDOC"] = 301] = "UPDATE_YDOC";
  return ClientMsgCode2;
})(ClientMsgCode || {});
function makeUser(conn, presence) {
  const { connectionId, id, info } = conn;
  const canWrite = canWriteStorage(conn.scopes);
  return freeze(
    compactObject({
      connectionId,
      id,
      info,
      canWrite,
      canComment: canComment(conn.scopes),
      isReadOnly: !canWrite,
      // Deprecated, kept for backward-compatibility
      presence
    })
  );
}
var _internal, _userCache, _ManagedOthers_instances, _getUser_fn, invalidateUser_fn, _a23;
var ManagedOthers = (_a23 = class {
  constructor() {
    __privateAdd(this, _ManagedOthers_instances);
    // Track mutable state internally, but signal to the outside when the
    // observable derived state changes only
    __privateAdd(this, _internal);
    __privateAdd(this, _userCache);
    // The "clean" signal that is exposed to the outside world
    __publicField(this, "signal");
    __privateSet(this, _internal, new MutableSignal({
      connections: /* @__PURE__ */ new Map(),
      presences: /* @__PURE__ */ new Map()
    }));
    this.signal = DerivedSignal.from(
      __privateGet(this, _internal),
      (_ignore) => compact(
        Array.from(__privateGet(this, _internal).get().presences.keys()).map(
          (connectionId) => this.getUser(Number(connectionId))
        )
      )
    );
    __privateSet(this, _userCache, /* @__PURE__ */ new Map());
  }
  // Shorthand for .signal.get()
  get() {
    return this.signal.get();
  }
  connectionIds() {
    return __privateGet(this, _internal).get().connections.keys();
  }
  clearOthers() {
    __privateGet(this, _internal).mutate((state) => {
      state.connections.clear();
      state.presences.clear();
      __privateGet(this, _userCache).clear();
    });
  }
  getUser(connectionId) {
    const cachedUser = __privateGet(this, _userCache).get(connectionId);
    if (cachedUser) {
      return cachedUser;
    }
    const computedUser = __privateMethod(this, _ManagedOthers_instances, _getUser_fn).call(this, connectionId);
    if (computedUser) {
      __privateGet(this, _userCache).set(connectionId, computedUser);
      return computedUser;
    }
    return void 0;
  }
  /**
   * Records a known connection. This records the connection ID and the
   * associated metadata.
   */
  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {
    __privateGet(this, _internal).mutate((state) => {
      state.connections.set(
        connectionId,
        freeze({
          connectionId,
          id: metaUserId,
          info: metaUserInfo,
          scopes
        })
      );
      if (!state.presences.has(connectionId)) {
        return false;
      }
      return __privateMethod(this, _ManagedOthers_instances, invalidateUser_fn).call(this, connectionId);
    });
  }
  /**
   * Removes a known connectionId. Removes both the connection's metadata and
   * the presence information.
   */
  removeConnection(connectionId) {
    __privateGet(this, _internal).mutate((state) => {
      state.connections.delete(connectionId);
      state.presences.delete(connectionId);
      __privateMethod(this, _ManagedOthers_instances, invalidateUser_fn).call(this, connectionId);
    });
  }
  /**
   * Stores a new user from a full presence update. If the user already exists,
   * its known presence data is overwritten.
   */
  setOther(connectionId, presence) {
    __privateGet(this, _internal).mutate((state) => {
      state.presences.set(connectionId, freeze(compactObject(presence)));
      if (!state.connections.has(connectionId)) {
        return false;
      }
      return __privateMethod(this, _ManagedOthers_instances, invalidateUser_fn).call(this, connectionId);
    });
  }
  /**
   * Patches the presence data for an existing "other". If we don't know the
   * initial presence data for this user yet, discard this patch and await the
   * full .setOther() call first.
   */
  patchOther(connectionId, patch) {
    __privateGet(this, _internal).mutate((state) => {
      const oldPresence = state.presences.get(connectionId);
      if (oldPresence === void 0) {
        return false;
      }
      const newPresence = merge(oldPresence, patch);
      if (oldPresence === newPresence) {
        return false;
      }
      state.presences.set(connectionId, freeze(newPresence));
      return __privateMethod(this, _ManagedOthers_instances, invalidateUser_fn).call(this, connectionId);
    });
  }
}, _internal = new WeakMap(), _userCache = new WeakMap(), _ManagedOthers_instances = new WeakSet(), _getUser_fn = function(connectionId) {
  const state = __privateGet(this, _internal).get();
  const conn = state.connections.get(connectionId);
  const presence = state.presences.get(connectionId);
  if (conn !== void 0 && presence !== void 0) {
    return makeUser(conn, presence);
  }
  return void 0;
}, invalidateUser_fn = function(connectionId) {
  __privateGet(this, _userCache).delete(connectionId);
}, _a23);
var LiveblocksError = class _LiveblocksError extends Error {
  constructor(message, context, cause) {
    super(message, { cause });
    __publicField(this, "context");
    this.context = context;
    this.name = "LiveblocksError";
  }
  /** Convenience accessor for error.context.roomId (if available) */
  get roomId() {
    return this.context.roomId;
  }
  /** @internal Use `context.code` instead, to enable type narrowing */
  get code() {
    return this.context.code;
  }
  /**
   * Creates a LiveblocksError from a generic error, by attaching Liveblocks
   * contextual information like room ID, thread ID, etc.
   */
  static from(context, cause) {
    return new _LiveblocksError(
      defaultMessageFromContext(context),
      context,
      cause
    );
  }
};
function defaultMessageFromContext(context) {
  switch (context.type) {
    case "ROOM_CONNECTION_ERROR": {
      switch (context.code) {
        case 4001:
          return "Not allowed to connect to the room";
        case 4005:
          return "Room is already full";
        case 4006:
          return "Kicked out of the room, because the room ID changed";
        default:
          return "Could not connect to the room";
      }
    }
    case "AI_CONNECTION_ERROR": {
      switch (context.code) {
        case 4001:
          return "Not allowed to connect to ai";
        default:
          return "Could not connect to the room";
      }
    }
    case "CREATE_THREAD_ERROR":
      return "Could not create new thread";
    case "DELETE_THREAD_ERROR":
      return "Could not delete thread";
    case "EDIT_THREAD_METADATA_ERROR":
      return "Could not edit thread metadata";
    case "MARK_THREAD_AS_RESOLVED_ERROR":
      return "Could not mark thread as resolved";
    case "MARK_THREAD_AS_UNRESOLVED_ERROR":
      return "Could not mark thread as unresolved";
    case "SUBSCRIBE_TO_THREAD_ERROR":
      return "Could not subscribe to thread";
    case "UNSUBSCRIBE_FROM_THREAD_ERROR":
      return "Could not unsubscribe from thread";
    case "CREATE_COMMENT_ERROR":
      return "Could not create new comment";
    case "EDIT_COMMENT_ERROR":
      return "Could not edit comment";
    case "DELETE_COMMENT_ERROR":
      return "Could not delete comment";
    case "ADD_REACTION_ERROR":
      return "Could not add reaction";
    case "REMOVE_REACTION_ERROR":
      return "Could not remove reaction";
    case "MARK_INBOX_NOTIFICATION_AS_READ_ERROR":
      return "Could not mark inbox notification as read";
    case "DELETE_INBOX_NOTIFICATION_ERROR":
      return "Could not delete inbox notification";
    case "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR":
      return "Could not mark all inbox notifications as read";
    case "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR":
      return "Could not delete all inbox notifications";
    case "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR":
      return "Could not update room subscription settings";
    case "UPDATE_NOTIFICATION_SETTINGS_ERROR":
      return "Could not update notification settings";
    case "LARGE_MESSAGE_ERROR":
      return "Could not send large message";
    default:
      return assertNever(context, "Unhandled case");
  }
}
var MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;
function makeIdFactory(connectionId) {
  let count = 0;
  return () => `${connectionId}:${count++}`;
}
function userToTreeNode(key, user) {
  return {
    type: "User",
    id: `${user.connectionId}`,
    key,
    payload: {
      connectionId: user.connectionId,
      id: user.id,
      info: user.info,
      presence: user.presence,
      isReadOnly: !user.canWrite
    }
  };
}
function installBackgroundTabSpy() {
  const doc = typeof document !== "undefined" ? document : void 0;
  const inBackgroundSince = { current: null };
  function onVisibilityChange() {
    if ((doc == null ? void 0 : doc.visibilityState) === "hidden") {
      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();
    } else {
      inBackgroundSince.current = null;
    }
  }
  doc == null ? void 0 : doc.addEventListener("visibilitychange", onVisibilityChange);
  const unsub = () => {
    doc == null ? void 0 : doc.removeEventListener("visibilitychange", onVisibilityChange);
  };
  return [inBackgroundSince, unsub];
}
function createRoom(options, config) {
  const roomId = config.roomId;
  const initialPresence = options.initialPresence;
  const initialStorage = options.initialStorage;
  const httpClient = config.roomHttpClient;
  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();
  const delegates = {
    ...config.delegates,
    // A connection is allowed to go into "zombie state" only if all of the
    // following conditions apply:
    //
    // - The `backgroundKeepAliveTimeout` client option is configured
    // - The browser window has been in the background for at least
    //   `backgroundKeepAliveTimeout` milliseconds
    // - There are no pending changes
    //
    canZombie() {
      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== "synchronizing";
    }
  };
  const managedSocket = new ManagedSocket(
    delegates,
    config.enableDebugLogging
  );
  const context = {
    buffer: {
      flushTimerID: void 0,
      lastFlushedAt: 0,
      presenceUpdates: (
        // Queue up the initial presence message as a Full Presence update
        {
          type: "full",
          data: initialPresence
        }
      ),
      messages: [],
      storageOperations: []
    },
    staticSessionInfoSig: new Signal(null),
    dynamicSessionInfoSig: new Signal(null),
    myPresence: new PatchableSignal(initialPresence),
    others: new ManagedOthers(),
    initialStorage,
    idFactory: null,
    // The Yjs provider associated to this room
    yjsProvider: void 0,
    yjsProviderDidChange: makeEventSource(),
    // Storage
    pool: createManagedPool(roomId, {
      getCurrentConnectionId,
      onDispatch,
      isStorageWritable
    }),
    root: void 0,
    undoStack: [],
    redoStack: [],
    pausedHistory: null,
    activeBatch: null,
    unacknowledgedOps: /* @__PURE__ */ new Map(),
    // Debug
    opStackTraces: true ? /* @__PURE__ */ new Map() : void 0
  };
  let lastTokenKey;
  function onStatusDidChange(newStatus) {
    const authValue = managedSocket.authValue;
    if (authValue !== null) {
      const tokenKey = getBearerTokenFromAuthValue(authValue);
      if (tokenKey !== lastTokenKey) {
        lastTokenKey = tokenKey;
        if (authValue.type === "secret") {
          const token = authValue.token.parsed;
          context.staticSessionInfoSig.set({
            userId: token.k === "sec-legacy" ? token.id : token.uid,
            userInfo: token.k === "sec-legacy" ? token.info : token.ui
          });
        } else {
          context.staticSessionInfoSig.set({
            userId: void 0,
            userInfo: void 0
          });
        }
      }
    }
    eventHub.status.notify(newStatus);
    notifySelfChanged();
  }
  let _connectionLossTimerId;
  let _hasLostConnection = false;
  function handleConnectionLossEvent(newStatus) {
    if (newStatus === "reconnecting") {
      _connectionLossTimerId = setTimeout(() => {
        eventHub.lostConnection.notify("lost");
        _hasLostConnection = true;
        context.others.clearOthers();
        notify({ others: [{ type: "reset" }] });
      }, config.lostConnectionTimeout);
    } else {
      clearTimeout(_connectionLossTimerId);
      if (_hasLostConnection) {
        if (newStatus === "disconnected") {
          eventHub.lostConnection.notify("failed");
        } else {
          eventHub.lostConnection.notify("restored");
        }
        _hasLostConnection = false;
      }
    }
  }
  function onDidConnect() {
    context.buffer.presenceUpdates = {
      type: "full",
      data: (
        // Because context.me.current is a readonly object, we'll have to
        // make a copy here. Otherwise, type errors happen later when
        // "patching" my presence.
        { ...context.myPresence.get() }
      )
    };
    if (_getStorage$ !== null) {
      refreshStorage({ flush: false });
    }
    flushNowOrSoon();
  }
  function onDidDisconnect() {
    clearTimeout(context.buffer.flushTimerID);
  }
  managedSocket.events.onMessage.subscribe(handleServerMessage);
  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);
  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);
  managedSocket.events.didConnect.subscribe(onDidConnect);
  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);
  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {
    const type = "ROOM_CONNECTION_ERROR";
    const err = new LiveblocksError(message, { type, code, roomId });
    const didNotify = config.errorEventSource.notify(err);
    if (!didNotify) {
      if (true) {
        error2(
          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`
        );
      }
    }
  });
  function onDispatch(ops, reverse, storageUpdates) {
    if (true) {
      const stackTrace = captureStackTrace("Storage mutation", onDispatch);
      if (stackTrace) {
        for (const op of ops) {
          if (op.opId) {
            nn(context.opStackTraces).set(op.opId, stackTrace);
          }
        }
      }
    }
    if (context.activeBatch) {
      for (const op of ops) {
        context.activeBatch.ops.push(op);
      }
      for (const [key, value] of storageUpdates) {
        context.activeBatch.updates.storageUpdates.set(
          key,
          mergeStorageUpdates(
            context.activeBatch.updates.storageUpdates.get(key),
            value
          )
        );
      }
      context.activeBatch.reverseOps.pushLeft(reverse);
    } else {
      addToUndoStack(reverse);
      context.redoStack.length = 0;
      dispatchOps(ops);
      notify({ storageUpdates });
    }
  }
  function isStorageWritable() {
    var _a26;
    const scopes = (_a26 = context.dynamicSessionInfoSig.get()) == null ? void 0 : _a26.scopes;
    return scopes !== void 0 ? canWriteStorage(scopes) : true;
  }
  const eventHub = {
    status: makeEventSource(),
    // New/recommended API
    lostConnection: makeEventSource(),
    customEvent: makeEventSource(),
    self: makeEventSource(),
    myPresence: makeEventSource(),
    others: makeEventSource(),
    storageBatch: makeEventSource(),
    history: makeEventSource(),
    storageDidLoad: makeEventSource(),
    storageStatus: makeEventSource(),
    ydoc: makeEventSource(),
    comments: makeEventSource(),
    roomWillDestroy: makeEventSource()
  };
  async function createTextMention(mentionId, mention) {
    return httpClient.createTextMention({ roomId, mentionId, mention });
  }
  async function deleteTextMention(mentionId) {
    return httpClient.deleteTextMention({ roomId, mentionId });
  }
  async function reportTextEditor(type, rootKey) {
    await httpClient.reportTextEditor({ roomId, type, rootKey });
  }
  async function listTextVersions() {
    return httpClient.listTextVersions({ roomId });
  }
  async function listTextVersionsSince(options2) {
    return httpClient.listTextVersionsSince({
      roomId,
      since: options2.since,
      signal: options2.signal
    });
  }
  async function getTextVersion(versionId) {
    return httpClient.getTextVersion({ roomId, versionId });
  }
  async function createTextVersion() {
    return httpClient.createTextVersion({ roomId });
  }
  async function executeContextualPrompt(options2) {
    return httpClient.executeContextualPrompt({
      roomId,
      ...options2
    });
  }
  function* chunkOps(msg) {
    const { ops, ...rest } = msg;
    if (ops.length < 2) {
      throw new Error("Cannot split ops into smaller chunks");
    }
    const mid = Math.floor(ops.length / 2);
    const firstHalf = ops.slice(0, mid);
    const secondHalf = ops.slice(mid);
    for (const halfOps of [firstHalf, secondHalf]) {
      const half = { ops: halfOps, ...rest };
      const text = stringifyOrLog([half]);
      if (!isTooBigForWebSocket(text)) {
        yield text;
      } else {
        yield* chunkOps(half);
      }
    }
  }
  function* chunkMessages(messages) {
    if (messages.length < 2) {
      if (messages[0].type === 201) {
        yield* chunkOps(messages[0]);
        return;
      } else {
        throw new Error(
          "Cannot split into chunks smaller than the allowed message size"
        );
      }
    }
    const mid = Math.floor(messages.length / 2);
    const firstHalf = messages.slice(0, mid);
    const secondHalf = messages.slice(mid);
    for (const half of [firstHalf, secondHalf]) {
      const text = stringifyOrLog(half);
      if (!isTooBigForWebSocket(text)) {
        yield text;
      } else {
        yield* chunkMessages(half);
      }
    }
  }
  function isTooBigForWebSocket(text) {
    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {
      return false;
    }
    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;
  }
  function sendMessages(messages) {
    var _a26;
    const strategy = config.largeMessageStrategy ?? "default";
    const text = stringifyOrLog(messages);
    if (!isTooBigForWebSocket(text)) {
      return managedSocket.send(text);
    }
    switch (strategy) {
      case "default": {
        const type = "LARGE_MESSAGE_ERROR";
        const err = new LiveblocksError("Message is too large for websockets", {
          type
        });
        const didNotify = config.errorEventSource.notify(err);
        if (!didNotify) {
          error2(
            "Message is too large for websockets.  Configure largeMessageStrategy option or useErrorListener to handle this."
          );
        }
        return;
      }
      case "split": {
        warn("Message is too large for websockets, splitting into smaller chunks");
        for (const chunk2 of chunkMessages(messages)) {
          managedSocket.send(chunk2);
        }
        return;
      }
      case "experimental-fallback-to-http": {
        warn("Message is too large for websockets, so sending over HTTP instead");
        const nonce = ((_a26 = context.dynamicSessionInfoSig.get()) == null ? void 0 : _a26.nonce) ?? raise("Session is not authorized to send message over HTTP");
        void httpClient.sendMessages({ roomId, nonce, messages }).then((resp) => {
          if (!resp.ok && resp.status === 403) {
            managedSocket.reconnect();
          }
        });
        return;
      }
    }
  }
  const self = DerivedSignal.from(
    context.staticSessionInfoSig,
    context.dynamicSessionInfoSig,
    context.myPresence,
    (staticSession, dynamicSession, myPresence) => {
      if (staticSession === null || dynamicSession === null) {
        return null;
      } else {
        const canWrite = canWriteStorage(dynamicSession.scopes);
        return {
          connectionId: dynamicSession.actor,
          id: staticSession.userId,
          info: staticSession.userInfo,
          presence: myPresence,
          canWrite,
          canComment: canComment(dynamicSession.scopes)
        };
      }
    }
  );
  let _lastSelf;
  function notifySelfChanged() {
    const currSelf = self.get();
    if (currSelf !== null && currSelf !== _lastSelf) {
      eventHub.self.notify(currSelf);
      _lastSelf = currSelf;
    }
  }
  const selfAsTreeNode = DerivedSignal.from(
    self,
    (me) => me !== null ? userToTreeNode("Me", me) : null
  );
  function createOrUpdateRootFromMessage(message) {
    var _a26;
    if (message.items.length === 0) {
      throw new Error("Internal error: cannot load storage without items");
    }
    if (context.root !== void 0) {
      updateRoot(message.items);
    } else {
      context.root = LiveObject._fromItems(message.items, context.pool);
    }
    const canWrite = ((_a26 = self.get()) == null ? void 0 : _a26.canWrite) ?? true;
    const stackSizeBefore = context.undoStack.length;
    for (const key in context.initialStorage) {
      if (context.root.get(key) === void 0) {
        if (canWrite) {
          context.root.set(key, cloneLson(context.initialStorage[key]));
        } else {
          warn(
            `Attempted to populate missing storage key '${key}', but current user has no write access`
          );
        }
      }
    }
    context.undoStack.length = stackSizeBefore;
  }
  function updateRoot(items) {
    if (context.root === void 0) {
      return;
    }
    const currentItems = /* @__PURE__ */ new Map();
    for (const [id, node] of context.pool.nodes) {
      currentItems.set(id, node._serialize());
    }
    const ops = getTreesDiffOperations(currentItems, new Map(items));
    const result = applyOps(ops, false);
    notify(result.updates);
  }
  function _addToRealUndoStack(historyOps) {
    if (context.undoStack.length >= 50) {
      context.undoStack.shift();
    }
    context.undoStack.push(historyOps);
    onHistoryChange();
  }
  function addToUndoStack(historyOps) {
    if (context.pausedHistory !== null) {
      context.pausedHistory.pushLeft(historyOps);
    } else {
      _addToRealUndoStack(historyOps);
    }
  }
  function notify(updates) {
    const storageUpdates = updates.storageUpdates;
    const othersUpdates = updates.others;
    if (othersUpdates !== void 0 && othersUpdates.length > 0) {
      const others = context.others.get();
      for (const event of othersUpdates) {
        eventHub.others.notify({ ...event, others });
      }
    }
    if (updates.presence ?? false) {
      notifySelfChanged();
      eventHub.myPresence.notify(context.myPresence.get());
    }
    if (storageUpdates !== void 0 && storageUpdates.size > 0) {
      const updates2 = Array.from(storageUpdates.values());
      eventHub.storageBatch.notify(updates2);
    }
    notifyStorageStatus();
  }
  function getCurrentConnectionId() {
    const info = context.dynamicSessionInfoSig.get();
    if (info) {
      return info.actor;
    }
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function applyOps(rawOps, isLocal) {
    const output = {
      reverse: new Deque(),
      storageUpdates: /* @__PURE__ */ new Map(),
      presence: false
    };
    const createdNodeIds = /* @__PURE__ */ new Set();
    const ops = rawOps.map((op) => {
      if (op.type !== "presence" && !op.opId) {
        return { ...op, opId: context.pool.generateOpId() };
      } else {
        return op;
      }
    });
    for (const op of ops) {
      if (op.type === "presence") {
        const reverse = {
          type: "presence",
          data: {}
        };
        for (const key in op.data) {
          reverse.data[key] = context.myPresence.get()[key];
        }
        context.myPresence.patch(op.data);
        if (context.buffer.presenceUpdates === null) {
          context.buffer.presenceUpdates = { type: "partial", data: op.data };
        } else {
          for (const key in op.data) {
            context.buffer.presenceUpdates.data[key] = op.data[key];
          }
        }
        output.reverse.pushLeft(reverse);
        output.presence = true;
      } else {
        let source;
        if (isLocal) {
          source = 0;
        } else {
          const opId = nn(op.opId);
          if (true) {
            nn(context.opStackTraces).delete(opId);
          }
          const deleted = context.unacknowledgedOps.delete(opId);
          source = deleted ? 2 : 1;
        }
        const applyOpResult = applyOp(op, source);
        if (applyOpResult.modified) {
          const nodeId = applyOpResult.modified.node._id;
          if (!(nodeId && createdNodeIds.has(nodeId))) {
            output.storageUpdates.set(
              nn(applyOpResult.modified.node._id),
              mergeStorageUpdates(
                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),
                applyOpResult.modified
              )
            );
            output.reverse.pushLeft(applyOpResult.reverse);
          }
          if (op.type === 2 || op.type === 7 || op.type === 4) {
            createdNodeIds.add(nn(op.id));
          }
        }
      }
    }
    return {
      ops,
      reverse: Array.from(output.reverse),
      updates: {
        storageUpdates: output.storageUpdates,
        presence: output.presence
      }
    };
  }
  function applyOp(op, source) {
    if (isAckOp(op)) {
      return { modified: false };
    }
    switch (op.type) {
      case 6:
      case 3:
      case 5: {
        const node = context.pool.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        return node._apply(
          op,
          source === 0
          /* UNDOREDO_RECONNECT */
        );
      }
      case 1: {
        const node = context.pool.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        if (node.parent.type === "HasParent" && isLiveList(node.parent.node)) {
          return node.parent.node._setChildKey(
            asPos(op.parentKey),
            node,
            source
          );
        }
        return { modified: false };
      }
      case 4:
      case 2:
      case 7:
      case 8: {
        if (op.parentId === void 0) {
          return { modified: false };
        }
        const parentNode = context.pool.nodes.get(op.parentId);
        if (parentNode === void 0) {
          return { modified: false };
        }
        return parentNode._attachChild(op, source);
      }
    }
  }
  function updatePresence(patch, options2) {
    const oldValues = {};
    if (context.buffer.presenceUpdates === null) {
      context.buffer.presenceUpdates = {
        type: "partial",
        data: {}
      };
    }
    for (const key in patch) {
      const overrideValue = patch[key];
      if (overrideValue === void 0) {
        continue;
      }
      context.buffer.presenceUpdates.data[key] = overrideValue;
      oldValues[key] = context.myPresence.get()[key];
    }
    context.myPresence.patch(patch);
    if (context.activeBatch) {
      if (options2 == null ? void 0 : options2.addToHistory) {
        context.activeBatch.reverseOps.pushLeft({
          type: "presence",
          data: oldValues
        });
      }
      context.activeBatch.updates.presence = true;
    } else {
      flushNowOrSoon();
      if (options2 == null ? void 0 : options2.addToHistory) {
        addToUndoStack([{ type: "presence", data: oldValues }]);
      }
      notify({ presence: true });
    }
  }
  function onUpdatePresenceMessage(message) {
    if (message.targetActor !== void 0) {
      const oldUser = context.others.getUser(message.actor);
      context.others.setOther(message.actor, message.data);
      const newUser = context.others.getUser(message.actor);
      if (oldUser === void 0 && newUser !== void 0) {
        return { type: "enter", user: newUser };
      }
    } else {
      context.others.patchOther(message.actor, message.data), message;
    }
    const user = context.others.getUser(message.actor);
    if (user) {
      return {
        type: "update",
        updates: message.data,
        user
      };
    } else {
      return void 0;
    }
  }
  function onUserLeftMessage(message) {
    const user = context.others.getUser(message.actor);
    if (user) {
      context.others.removeConnection(message.actor);
      return { type: "leave", user };
    }
    return null;
  }
  function onRoomStateMessage(message) {
    context.dynamicSessionInfoSig.set({
      actor: message.actor,
      nonce: message.nonce,
      scopes: message.scopes
    });
    context.idFactory = makeIdFactory(message.actor);
    notifySelfChanged();
    for (const connectionId of context.others.connectionIds()) {
      const user = message.users[connectionId];
      if (user === void 0) {
        context.others.removeConnection(connectionId);
      }
    }
    for (const key in message.users) {
      const user = message.users[key];
      const connectionId = Number(key);
      context.others.setConnection(
        connectionId,
        user.id,
        user.info,
        user.scopes
      );
    }
    return { type: "reset" };
  }
  function canUndo() {
    return context.undoStack.length > 0;
  }
  function canRedo() {
    return context.redoStack.length > 0;
  }
  function onHistoryChange() {
    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });
  }
  function onUserJoinedMessage(message) {
    context.others.setConnection(
      message.actor,
      message.id,
      message.info,
      message.scopes
    );
    context.buffer.messages.push({
      type: 100,
      data: context.myPresence.get(),
      targetActor: message.actor
    });
    flushNowOrSoon();
    const user = context.others.getUser(message.actor);
    return user ? { type: "enter", user } : void 0;
  }
  function parseServerMessage(data) {
    if (!isJsonObject(data)) {
      return null;
    }
    return data;
  }
  function parseServerMessages(text) {
    const data = tryParseJson(text);
    if (data === void 0) {
      return null;
    } else if (isJsonArray(data)) {
      return compact(data.map((item) => parseServerMessage(item)));
    } else {
      return compact([parseServerMessage(data)]);
    }
  }
  function applyAndSendOps(offlineOps) {
    if (offlineOps.size === 0) {
      return;
    }
    const messages = [];
    const inOps = Array.from(offlineOps.values());
    const result = applyOps(inOps, true);
    messages.push({
      type: 201,
      ops: result.ops
    });
    notify(result.updates);
    sendMessages(messages);
  }
  function handleServerMessage(event) {
    var _a26;
    if (typeof event.data !== "string") {
      return;
    }
    const messages = parseServerMessages(event.data);
    if (messages === null || messages.length === 0) {
      return;
    }
    const updates = {
      storageUpdates: /* @__PURE__ */ new Map(),
      others: []
    };
    for (const message of messages) {
      switch (message.type) {
        case 101: {
          const userJoinedUpdate = onUserJoinedMessage(message);
          if (userJoinedUpdate) {
            updates.others.push(userJoinedUpdate);
          }
          break;
        }
        case 100: {
          const othersPresenceUpdate = onUpdatePresenceMessage(message);
          if (othersPresenceUpdate) {
            updates.others.push(othersPresenceUpdate);
          }
          break;
        }
        case 103: {
          const others = context.others.get();
          eventHub.customEvent.notify({
            connectionId: message.actor,
            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,
            event: message.event
          });
          break;
        }
        case 102: {
          const event2 = onUserLeftMessage(message);
          if (event2) {
            updates.others.push(event2);
          }
          break;
        }
        case 300: {
          eventHub.ydoc.notify(message);
          break;
        }
        case 104: {
          updates.others.push(onRoomStateMessage(message));
          break;
        }
        case 200: {
          processInitialStorage(message);
          break;
        }
        // Write event
        case 201: {
          const applyResult = applyOps(message.ops, false);
          for (const [key, value] of applyResult.updates.storageUpdates) {
            updates.storageUpdates.set(
              key,
              mergeStorageUpdates(updates.storageUpdates.get(key), value)
            );
          }
          break;
        }
        // Receiving a RejectedOps message in the client means that the server is no
        // longer in sync with the client. Trying to synchronize the client again by
        // rolling back particular Ops may be hard/impossible. It's fine to not try and
        // accept the out-of-sync reality and throw an error. We look at this kind of bug
        // as a developer-owned bug. In production, these errors are not expected to happen.
        case 299: {
          errorWithTitle(
            "Storage mutation rejection error",
            message.reason
          );
          if (true) {
            const traces = /* @__PURE__ */ new Set();
            for (const opId of message.opIds) {
              const trace = (_a26 = context.opStackTraces) == null ? void 0 : _a26.get(opId);
              if (trace) {
                traces.add(trace);
              }
            }
            if (traces.size > 0) {
              warnWithTitle(
                "The following function calls caused the rejected storage mutations:",
                `

${Array.from(traces).join("\n\n")}`
              );
            }
            throw new Error(
              `Storage mutations rejected by server: ${message.reason}`
            );
          }
          break;
        }
        case 400:
        case 407:
        case 401:
        case 408:
        case 405:
        case 406:
        case 402:
        case 403:
        case 404: {
          eventHub.comments.notify(message);
          break;
        }
      }
    }
    notify(updates);
  }
  function flushNowOrSoon() {
    const storageOps = context.buffer.storageOperations;
    if (storageOps.length > 0) {
      for (const op of storageOps) {
        context.unacknowledgedOps.set(nn(op.opId), op);
      }
      notifyStorageStatus();
    }
    if (managedSocket.getStatus() !== "connected") {
      context.buffer.storageOperations = [];
      return;
    }
    const now2 = Date.now();
    const elapsedMillis = now2 - context.buffer.lastFlushedAt;
    if (elapsedMillis >= config.throttleDelay) {
      const messagesToFlush = serializeBuffer();
      if (messagesToFlush.length === 0) {
        return;
      }
      sendMessages(messagesToFlush);
      context.buffer = {
        flushTimerID: void 0,
        lastFlushedAt: now2,
        messages: [],
        storageOperations: [],
        presenceUpdates: null
      };
    } else {
      clearTimeout(context.buffer.flushTimerID);
      context.buffer.flushTimerID = setTimeout(
        flushNowOrSoon,
        config.throttleDelay - elapsedMillis
      );
    }
  }
  function serializeBuffer() {
    const messages = [];
    if (context.buffer.presenceUpdates) {
      messages.push(
        context.buffer.presenceUpdates.type === "full" ? {
          type: 100,
          // Populating the `targetActor` field turns this message into
          // a Full Presence update message (not a patch), which will get
          // interpreted by other clients as such.
          targetActor: -1,
          data: context.buffer.presenceUpdates.data
        } : {
          type: 100,
          data: context.buffer.presenceUpdates.data
        }
      );
    }
    for (const event of context.buffer.messages) {
      messages.push(event);
    }
    if (context.buffer.storageOperations.length > 0) {
      messages.push({
        type: 201,
        ops: context.buffer.storageOperations
      });
    }
    return messages;
  }
  function updateYDoc(update, guid, isV2) {
    const clientMsg = {
      type: 301,
      update,
      guid,
      v2: isV2
    };
    context.buffer.messages.push(clientMsg);
    eventHub.ydoc.notify(clientMsg);
    flushNowOrSoon();
  }
  function broadcastEvent(event, options2 = {
    shouldQueueEventIfNotReady: false
  }) {
    if (managedSocket.getStatus() !== "connected" && !options2.shouldQueueEventIfNotReady) {
      return;
    }
    context.buffer.messages.push({
      type: 103,
      event
    });
    flushNowOrSoon();
  }
  function dispatchOps(ops) {
    const { storageOperations } = context.buffer;
    for (const op of ops) {
      storageOperations.push(op);
    }
    flushNowOrSoon();
  }
  let _getStorage$ = null;
  let _resolveStoragePromise = null;
  function processInitialStorage(message) {
    const unacknowledgedOps = new Map(context.unacknowledgedOps);
    createOrUpdateRootFromMessage(message);
    applyAndSendOps(unacknowledgedOps);
    _resolveStoragePromise == null ? void 0 : _resolveStoragePromise();
    notifyStorageStatus();
    eventHub.storageDidLoad.notify();
  }
  async function streamStorage() {
    if (!managedSocket.authValue) return;
    const items = await httpClient.streamStorage({ roomId });
    processInitialStorage({ type: 200, items });
  }
  function refreshStorage(options2) {
    const messages = context.buffer.messages;
    if (config.unstable_streamData) {
      void streamStorage();
    } else if (!messages.some(
      (msg) => msg.type === 200
      /* FETCH_STORAGE */
    )) {
      messages.push({
        type: 200
        /* FETCH_STORAGE */
      });
    }
    if (options2.flush) {
      flushNowOrSoon();
    }
  }
  function startLoadingStorage() {
    if (_getStorage$ === null) {
      refreshStorage({ flush: true });
      _getStorage$ = new Promise((resolve) => {
        _resolveStoragePromise = resolve;
      });
      notifyStorageStatus();
    }
    return _getStorage$;
  }
  function getStorageSnapshot() {
    const root = context.root;
    if (root !== void 0) {
      return root;
    } else {
      void startLoadingStorage();
      return null;
    }
  }
  async function getStorage() {
    if (context.root !== void 0) {
      return Promise.resolve({
        root: context.root
      });
    }
    await startLoadingStorage();
    return {
      root: nn(context.root)
    };
  }
  function fetchYDoc(vector, guid, isV2) {
    if (!context.buffer.messages.find((m) => {
      return m.type === 300 && m.vector === vector && m.guid === guid && m.v2 === isV2;
    })) {
      context.buffer.messages.push({
        type: 300,
        vector,
        guid,
        v2: isV2
      });
    }
    flushNowOrSoon();
  }
  function undo() {
    if (context.activeBatch) {
      throw new Error("undo is not allowed during a batch");
    }
    const historyOps = context.undoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    context.pausedHistory = null;
    const result = applyOps(historyOps, true);
    notify(result.updates);
    context.redoStack.push(result.reverse);
    onHistoryChange();
    for (const op of result.ops) {
      if (op.type !== "presence") {
        context.buffer.storageOperations.push(op);
      }
    }
    flushNowOrSoon();
  }
  function redo() {
    if (context.activeBatch) {
      throw new Error("redo is not allowed during a batch");
    }
    const historyOps = context.redoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    context.pausedHistory = null;
    const result = applyOps(historyOps, true);
    notify(result.updates);
    context.undoStack.push(result.reverse);
    onHistoryChange();
    for (const op of result.ops) {
      if (op.type !== "presence") {
        context.buffer.storageOperations.push(op);
      }
    }
    flushNowOrSoon();
  }
  function clear() {
    context.undoStack.length = 0;
    context.redoStack.length = 0;
  }
  function batch2(callback) {
    if (context.activeBatch) {
      return callback();
    }
    let returnValue = void 0;
    context.activeBatch = {
      ops: [],
      updates: {
        storageUpdates: /* @__PURE__ */ new Map(),
        presence: false,
        others: []
      },
      reverseOps: new Deque()
    };
    try {
      returnValue = callback();
    } finally {
      const currentBatch = context.activeBatch;
      context.activeBatch = null;
      if (currentBatch.reverseOps.length > 0) {
        addToUndoStack(Array.from(currentBatch.reverseOps));
      }
      if (currentBatch.ops.length > 0) {
        context.redoStack.length = 0;
      }
      if (currentBatch.ops.length > 0) {
        dispatchOps(currentBatch.ops);
      }
      notify(currentBatch.updates);
      flushNowOrSoon();
    }
    return returnValue;
  }
  function pauseHistory() {
    if (context.pausedHistory === null) {
      context.pausedHistory = new Deque();
    }
  }
  function resumeHistory() {
    const historyOps = context.pausedHistory;
    context.pausedHistory = null;
    if (historyOps !== null && historyOps.length > 0) {
      _addToRealUndoStack(Array.from(historyOps));
    }
  }
  const syncSourceForStorage = config.createSyncSource();
  function getStorageStatus() {
    if (context.root === void 0) {
      return _getStorage$ === null ? "not-loaded" : "loading";
    } else {
      return context.unacknowledgedOps.size === 0 ? "synchronized" : "synchronizing";
    }
  }
  let _lastStorageStatus = getStorageStatus();
  function notifyStorageStatus() {
    const storageStatus = getStorageStatus();
    if (_lastStorageStatus !== storageStatus) {
      _lastStorageStatus = storageStatus;
      eventHub.storageStatus.notify(storageStatus);
    }
    syncSourceForStorage.setSyncStatus(
      storageStatus === "synchronizing" ? "synchronizing" : "synchronized"
    );
  }
  function isPresenceReady() {
    return self.get() !== null;
  }
  async function waitUntilPresenceReady() {
    while (!isPresenceReady()) {
      const { promise, resolve } = Promise_withResolvers();
      const unsub1 = events.self.subscribeOnce(resolve);
      const unsub2 = events.status.subscribeOnce(resolve);
      await promise;
      unsub1();
      unsub2();
    }
  }
  function isStorageReady() {
    return getStorageSnapshot() !== null;
  }
  async function waitUntilStorageReady() {
    while (!isStorageReady()) {
      await getStorage();
    }
  }
  const others_forDevTools = DerivedSignal.from(
    context.others.signal,
    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))
  );
  const events = {
    status: eventHub.status.observable,
    lostConnection: eventHub.lostConnection.observable,
    customEvent: eventHub.customEvent.observable,
    others: eventHub.others.observable,
    self: eventHub.self.observable,
    myPresence: eventHub.myPresence.observable,
    storageBatch: eventHub.storageBatch.observable,
    history: eventHub.history.observable,
    storageDidLoad: eventHub.storageDidLoad.observable,
    storageStatus: eventHub.storageStatus.observable,
    ydoc: eventHub.ydoc.observable,
    comments: eventHub.comments.observable,
    roomWillDestroy: eventHub.roomWillDestroy.observable
  };
  async function getThreadsSince(options2) {
    return httpClient.getThreadsSince({
      roomId,
      since: options2.since,
      signal: options2.signal
    });
  }
  async function getThreads(options2) {
    return httpClient.getThreads({
      roomId,
      query: options2 == null ? void 0 : options2.query,
      cursor: options2 == null ? void 0 : options2.cursor
    });
  }
  async function getThread(threadId) {
    return httpClient.getThread({ roomId, threadId });
  }
  async function createThread(options2) {
    return httpClient.createThread({
      roomId,
      threadId: options2.threadId,
      commentId: options2.commentId,
      metadata: options2.metadata,
      body: options2.body,
      attachmentIds: options2.attachmentIds
    });
  }
  async function deleteThread(threadId) {
    return httpClient.deleteThread({ roomId, threadId });
  }
  async function editThreadMetadata({
    metadata,
    threadId
  }) {
    return httpClient.editThreadMetadata({ roomId, threadId, metadata });
  }
  async function markThreadAsResolved(threadId) {
    return httpClient.markThreadAsResolved({ roomId, threadId });
  }
  async function markThreadAsUnresolved(threadId) {
    return httpClient.markThreadAsUnresolved({
      roomId,
      threadId
    });
  }
  async function subscribeToThread(threadId) {
    return httpClient.subscribeToThread({ roomId, threadId });
  }
  async function unsubscribeFromThread(threadId) {
    return httpClient.unsubscribeFromThread({ roomId, threadId });
  }
  async function createComment(options2) {
    return httpClient.createComment({
      roomId,
      threadId: options2.threadId,
      commentId: options2.commentId,
      body: options2.body,
      attachmentIds: options2.attachmentIds
    });
  }
  async function editComment(options2) {
    return httpClient.editComment({
      roomId,
      threadId: options2.threadId,
      commentId: options2.commentId,
      body: options2.body,
      attachmentIds: options2.attachmentIds
    });
  }
  async function deleteComment({
    threadId,
    commentId
  }) {
    return httpClient.deleteComment({ roomId, threadId, commentId });
  }
  async function addReaction({
    threadId,
    commentId,
    emoji
  }) {
    return httpClient.addReaction({ roomId, threadId, commentId, emoji });
  }
  async function removeReaction({
    threadId,
    commentId,
    emoji
  }) {
    return await httpClient.removeReaction({
      roomId,
      threadId,
      commentId,
      emoji
    });
  }
  function prepareAttachment(file) {
    return {
      type: "localAttachment",
      status: "idle",
      id: createCommentAttachmentId(),
      name: file.name,
      size: file.size,
      mimeType: file.type,
      file
    };
  }
  async function uploadAttachment(attachment, options2 = {}) {
    return httpClient.uploadAttachment({
      roomId,
      attachment,
      signal: options2.signal
    });
  }
  function getAttachmentUrl(attachmentId) {
    return httpClient.getAttachmentUrl({ roomId, attachmentId });
  }
  function getSubscriptionSettings(options2) {
    return httpClient.getSubscriptionSettings({
      roomId,
      signal: options2 == null ? void 0 : options2.signal
    });
  }
  function updateSubscriptionSettings(settings) {
    return httpClient.updateSubscriptionSettings({ roomId, settings });
  }
  async function markInboxNotificationAsRead(inboxNotificationId) {
    await httpClient.markRoomInboxNotificationAsRead({
      roomId,
      inboxNotificationId
    });
  }
  const syncSourceForYjs = config.createSyncSource();
  function yjsStatusDidChange(status) {
    return syncSourceForYjs.setSyncStatus(
      status === "synchronizing" || status === "loading" ? "synchronizing" : "synchronized"
    );
  }
  return Object.defineProperty(
    {
      [kInternal]: {
        get presenceBuffer() {
          var _a26;
          return deepClone(((_a26 = context.buffer.presenceUpdates) == null ? void 0 : _a26.data) ?? null);
        },
        // prettier-ignore
        get undoStack() {
          return deepClone(context.undoStack);
        },
        // prettier-ignore
        get nodeCount() {
          return context.pool.nodes.size;
        },
        // prettier-ignore
        getYjsProvider() {
          return context.yjsProvider;
        },
        setYjsProvider(newProvider) {
          var _a26;
          (_a26 = context.yjsProvider) == null ? void 0 : _a26.off("status", yjsStatusDidChange);
          context.yjsProvider = newProvider;
          newProvider == null ? void 0 : newProvider.on("status", yjsStatusDidChange);
          context.yjsProviderDidChange.notify();
        },
        yjsProviderDidChange: context.yjsProviderDidChange.observable,
        // send metadata when using a text editor
        reportTextEditor,
        // create a text mention when using a text editor
        createTextMention,
        // delete a text mention when using a text editor
        deleteTextMention,
        // list versions of the document
        listTextVersions,
        // List versions of the document since the specified date
        listTextVersionsSince,
        // get a specific version
        getTextVersion,
        // create a version
        createTextVersion,
        // execute a contextual prompt
        executeContextualPrompt,
        // Support for the Liveblocks browser extension
        getSelf_forDevTools: () => selfAsTreeNode.get(),
        getOthers_forDevTools: () => others_forDevTools.get(),
        // prettier-ignore
        simulate: {
          // These exist only for our E2E testing app
          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: "EXPLICIT_SOCKET_CLOSE", event }),
          rawSend: (data) => managedSocket.send(data)
        },
        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)
      },
      id: roomId,
      subscribe: makeClassicSubscribeFn(
        roomId,
        events,
        config.errorEventSource
      ),
      connect: () => managedSocket.connect(),
      reconnect: () => managedSocket.reconnect(),
      disconnect: () => managedSocket.disconnect(),
      destroy: () => {
        var _a26;
        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;
        for (const source of Object.values(eventsExceptDestroy)) {
          source.dispose();
        }
        eventHub.roomWillDestroy.notify();
        (_a26 = context.yjsProvider) == null ? void 0 : _a26.off("status", yjsStatusDidChange);
        syncSourceForStorage.destroy();
        syncSourceForYjs.destroy();
        uninstallBgTabSpy();
        managedSocket.destroy();
        roomWillDestroy.dispose();
      },
      // Presence
      updatePresence,
      updateYDoc,
      broadcastEvent,
      // Storage
      batch: batch2,
      history: {
        undo,
        redo,
        canUndo,
        canRedo,
        clear,
        pause: pauseHistory,
        resume: resumeHistory
      },
      fetchYDoc,
      getStorage,
      getStorageSnapshot,
      getStorageStatus,
      isPresenceReady,
      isStorageReady,
      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),
      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),
      events,
      // Core
      getStatus: () => managedSocket.getStatus(),
      getSelf: () => self.get(),
      // Presence
      getPresence: () => context.myPresence.get(),
      getOthers: () => context.others.get(),
      // Comments
      getThreads,
      getThreadsSince,
      getThread,
      createThread,
      deleteThread,
      editThreadMetadata,
      markThreadAsResolved,
      markThreadAsUnresolved,
      subscribeToThread,
      unsubscribeFromThread,
      createComment,
      editComment,
      deleteComment,
      addReaction,
      removeReaction,
      prepareAttachment,
      uploadAttachment,
      getAttachmentUrl,
      // Notifications
      getNotificationSettings: getSubscriptionSettings,
      getSubscriptionSettings,
      updateNotificationSettings: updateSubscriptionSettings,
      updateSubscriptionSettings,
      markInboxNotificationAsRead
    },
    // Explictly make the internal field non-enumerable, to avoid aggressive
    // freezing when used with Immer
    kInternal,
    { enumerable: false }
  );
}
function makeClassicSubscribeFn(roomId, events, errorEvents) {
  function subscribeToLiveStructureDeeply(node, callback) {
    return events.storageBatch.subscribe((updates) => {
      const relatedUpdates = updates.filter(
        (update) => isSameNodeOrChildOf(update.node, node)
      );
      if (relatedUpdates.length > 0) {
        callback(relatedUpdates);
      }
    });
  }
  function subscribeToLiveStructureShallowly(node, callback) {
    return events.storageBatch.subscribe((updates) => {
      for (const update of updates) {
        if (update.node._id === node._id) {
          callback(update.node);
        }
      }
    });
  }
  function subscribe(first, second, options) {
    if (typeof first === "string" && isRoomEventName(first)) {
      if (typeof second !== "function") {
        throw new Error("Second argument must be a callback function");
      }
      const callback = second;
      switch (first) {
        case "event":
          return events.customEvent.subscribe(
            callback
          );
        case "my-presence":
          return events.myPresence.subscribe(callback);
        case "others": {
          const cb = callback;
          return events.others.subscribe((event) => {
            const { others, ...internalEvent } = event;
            return cb(others, internalEvent);
          });
        }
        case "error": {
          return errorEvents.subscribe((err) => {
            if (err.roomId === roomId) {
              return callback(err);
            }
          });
        }
        case "status":
          return events.status.subscribe(callback);
        case "lost-connection":
          return events.lostConnection.subscribe(
            callback
          );
        case "history":
          return events.history.subscribe(callback);
        case "storage-status":
          return events.storageStatus.subscribe(
            callback
          );
        case "comments":
          return events.comments.subscribe(
            callback
          );
        // istanbul ignore next
        default:
          return assertNever(
            first,
            `"${String(first)}" is not a valid event name`
          );
      }
    }
    if (second === void 0 || typeof first === "function") {
      if (typeof first === "function") {
        const storageCallback = first;
        return events.storageBatch.subscribe(storageCallback);
      } else {
        throw new Error("Please specify a listener callback");
      }
    }
    if (isLiveNode(first)) {
      const node = first;
      if (options == null ? void 0 : options.isDeep) {
        const storageCallback = second;
        return subscribeToLiveStructureDeeply(node, storageCallback);
      } else {
        const nodeCallback = second;
        return subscribeToLiveStructureShallowly(node, nodeCallback);
      }
    }
    throw new Error(
      `${String(first)} is not a value that can be subscribed to.`
    );
  }
  return subscribe;
}
function isRoomEventName(value) {
  return value === "my-presence" || value === "others" || value === "event" || value === "error" || value === "history" || value === "status" || value === "storage-status" || value === "lost-connection" || value === "connection" || value === "comments";
}
function makeAuthDelegateForRoom(roomId, authManager) {
  return async () => {
    return authManager.getAuthValue({ requestedScope: "room:read", roomId });
  };
}
function makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {
  return (authValue) => {
    const ws = WebSocketPolyfill ?? (typeof WebSocket === "undefined" ? void 0 : WebSocket);
    if (ws === void 0) {
      throw new StopRetrying(
        "To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill."
      );
    }
    const url2 = new URL(baseUrl);
    url2.protocol = url2.protocol === "http:" ? "ws" : "wss";
    url2.pathname = "/v7";
    url2.searchParams.set("roomId", roomId);
    if (authValue.type === "secret") {
      url2.searchParams.set("tok", authValue.token.raw);
    } else if (authValue.type === "public") {
      url2.searchParams.set("pubkey", authValue.publicApiKey);
    } else {
      return assertNever(authValue, "Unhandled case");
    }
    url2.searchParams.set("version", PKG_VERSION || "dev");
    return new ws(url2.toString());
  };
}
var MIN_THROTTLE = 16;
var MAX_THROTTLE = 1e3;
var DEFAULT_THROTTLE = 100;
var MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;
var MIN_LOST_CONNECTION_TIMEOUT = 200;
var RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;
var MAX_LOST_CONNECTION_TIMEOUT = 3e4;
var DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;
var RESOLVE_USERS_BATCH_DELAY = 50;
var RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;
var RESOLVE_GROUPS_INFO_BATCH_DELAY = 50;
function getBaseUrl(baseUrl) {
  if (typeof baseUrl === "string" && baseUrl.startsWith("http")) {
    return baseUrl;
  } else {
    return DEFAULT_BASE_URL;
  }
}
function createClient(options) {
  var _a26, _b2, _c;
  const clientOptions = options;
  const throttleDelay = clientOptions.__DANGEROUSLY_disableThrottling ? 0 : getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);
  const lostConnectionTimeout = getLostConnectionTimeout(
    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT
  );
  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(
    clientOptions.backgroundKeepAliveTimeout
  );
  const baseUrl = getBaseUrl(clientOptions.baseUrl);
  const currentUserId = new Signal(void 0);
  const authManager = createAuthManager(options, (token) => {
    const userId = token.k === "sec-legacy" ? token.id : token.uid;
    currentUserId.set(() => userId);
  });
  const fetchPolyfill = ((_a26 = clientOptions.polyfills) == null ? void 0 : _a26.fetch) || /* istanbul ignore next */
  ((_b2 = globalThis.fetch) == null ? void 0 : _b2.bind(globalThis));
  const httpClient = createApiClient({
    baseUrl,
    fetchPolyfill,
    currentUserId,
    authManager
  });
  const roomsById = /* @__PURE__ */ new Map();
  const ai = createAi({
    userId: currentUserId.get(),
    lostConnectionTimeout,
    backgroundKeepAliveTimeout: getBackgroundKeepAliveTimeout(
      clientOptions.backgroundKeepAliveTimeout
    ),
    polyfills: clientOptions.polyfills,
    delegates: {
      createSocket: makeCreateSocketDelegateForAi(
        baseUrl,
        (_c = clientOptions.polyfills) == null ? void 0 : _c.WebSocket
      ),
      authenticate: async () => {
        const resp = await authManager.getAuthValue({
          requestedScope: "room:read"
        });
        if (resp.type === "public") {
          throw new StopRetrying(
            "Cannot use AI Copilots with a public API key"
          );
        } else if (resp.token.parsed.k === "sec-legacy") {
          throw new StopRetrying("AI Copilots requires an ID or Access token");
        } else {
          if (!resp.token.parsed.ai) {
            throw new StopRetrying(
              "AI Copilots is not yet enabled for this account. To get started, see https://liveblocks.io/docs/get-started/ai-copilots#Quickstart"
            );
          }
        }
        return resp;
      },
      canZombie: () => false
    }
  });
  function teardownRoom(room) {
    unlinkDevTools(room.id);
    roomsById.delete(room.id);
    room.destroy();
  }
  function leaseRoom(details) {
    const leave = () => {
      const self = leave;
      if (!details.unsubs.delete(self)) {
        warn(
          "This leave function was already called. Calling it more than once has no effect."
        );
      } else {
        if (details.unsubs.size === 0) {
          teardownRoom(details.room);
        }
      }
    };
    details.unsubs.add(leave);
    return {
      room: details.room,
      leave
    };
  }
  function enterRoom(roomId, ...args) {
    var _a27, _b3;
    const existing = roomsById.get(roomId);
    if (existing !== void 0) {
      return leaseRoom(existing);
    }
    const options2 = args[0] ?? {};
    const initialPresence = (typeof options2.initialPresence === "function" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};
    const initialStorage = (typeof options2.initialStorage === "function" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};
    const newRoom = createRoom(
      { initialPresence, initialStorage },
      {
        roomId,
        throttleDelay,
        lostConnectionTimeout,
        backgroundKeepAliveTimeout,
        polyfills: clientOptions.polyfills,
        delegates: clientOptions.mockedDelegates ?? {
          createSocket: makeCreateSocketDelegateForRoom(
            roomId,
            baseUrl,
            (_a27 = clientOptions.polyfills) == null ? void 0 : _a27.WebSocket
          ),
          authenticate: makeAuthDelegateForRoom(roomId, authManager)
        },
        enableDebugLogging: clientOptions.enableDebugLogging,
        baseUrl,
        errorEventSource: liveblocksErrorSource,
        largeMessageStrategy: clientOptions.largeMessageStrategy,
        unstable_streamData: !!clientOptions.unstable_streamData,
        roomHttpClient: httpClient,
        createSyncSource
      }
    );
    const newRoomDetails = {
      room: newRoom,
      unsubs: /* @__PURE__ */ new Set()
    };
    roomsById.set(roomId, newRoomDetails);
    setupDevTools(() => Array.from(roomsById.keys()));
    linkDevTools(roomId, newRoom);
    const shouldConnect = options2.autoConnect ?? true;
    if (shouldConnect) {
      if (typeof atob === "undefined") {
        if (((_b3 = clientOptions.polyfills) == null ? void 0 : _b3.atob) === void 0) {
          throw new Error(
            "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
          );
        }
        global.atob = clientOptions.polyfills.atob;
      }
      newRoom.connect();
    }
    return leaseRoom(newRoomDetails);
  }
  function getRoom(roomId) {
    var _a27;
    const room = (_a27 = roomsById.get(roomId)) == null ? void 0 : _a27.room;
    return room ? room : null;
  }
  function logout() {
    authManager.reset();
    currentUserId.set(() => void 0);
    for (const { room } of roomsById.values()) {
      if (!isIdle(room.getStatus())) {
        room.reconnect();
      }
    }
  }
  const resolveUsers = clientOptions.resolveUsers;
  const batchedResolveUsers = new Batch(
    async (batchedUserIds) => {
      const userIds = batchedUserIds.flat();
      const users = await (resolveUsers == null ? void 0 : resolveUsers({ userIds }));
      warnOnceIf(
        !resolveUsers,
        "Set the resolveUsers option in createClient to specify user info."
      );
      return users ?? userIds.map(() => void 0);
    },
    { delay: RESOLVE_USERS_BATCH_DELAY }
  );
  const usersStore = createBatchStore(batchedResolveUsers);
  function invalidateResolvedUsers(userIds) {
    usersStore.invalidate(userIds);
  }
  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;
  const batchedResolveRoomsInfo = new Batch(
    async (batchedRoomIds) => {
      const roomIds = batchedRoomIds.flat();
      const roomsInfo = await (resolveRoomsInfo == null ? void 0 : resolveRoomsInfo({ roomIds }));
      warnOnceIf(
        !resolveRoomsInfo,
        "Set the resolveRoomsInfo option in createClient to specify room info."
      );
      return roomsInfo ?? roomIds.map(() => void 0);
    },
    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }
  );
  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);
  function invalidateResolvedRoomsInfo(roomIds) {
    roomsInfoStore.invalidate(roomIds);
  }
  const resolveGroupsInfo = clientOptions.resolveGroupsInfo;
  const batchedResolveGroupsInfo = new Batch(
    async (batchedGroupIds) => {
      const groupIds = batchedGroupIds.flat();
      const groupsInfo = await (resolveGroupsInfo == null ? void 0 : resolveGroupsInfo({ groupIds }));
      warnOnceIf(
        !resolveGroupsInfo,
        "Set the resolveGroupsInfo option in createClient to specify group info."
      );
      return groupsInfo ?? groupIds.map(() => void 0);
    },
    { delay: RESOLVE_GROUPS_INFO_BATCH_DELAY }
  );
  const groupsInfoStore = createBatchStore(batchedResolveGroupsInfo);
  function invalidateResolvedGroupsInfo(groupIds) {
    groupsInfoStore.invalidate(groupIds);
  }
  const mentionSuggestionsCache = /* @__PURE__ */ new Map();
  function invalidateResolvedMentionSuggestions() {
    mentionSuggestionsCache.clear();
  }
  const syncStatusSources = [];
  const syncStatusSignal = new Signal("synchronized");
  const liveblocksErrorSource = makeEventSource();
  function getSyncStatus() {
    const status = syncStatusSignal.get();
    return status === "synchronizing" ? status : "synchronized";
  }
  function recompute() {
    syncStatusSignal.set(
      syncStatusSources.some((src) => src.get() === "synchronizing") ? "synchronizing" : syncStatusSources.some((src) => src.get() === "has-local-changes") ? "has-local-changes" : "synchronized"
    );
  }
  function createSyncSource() {
    const source = new Signal("synchronized");
    syncStatusSources.push(source);
    const unsub = source.subscribe(() => recompute());
    function setSyncStatus(status) {
      source.set(status);
    }
    function destroy() {
      unsub();
      const index = syncStatusSources.findIndex((item) => item === source);
      if (index > -1) {
        const [ref] = syncStatusSources.splice(index, 1);
        const wasStillPending = ref.get() !== "synchronized";
        if (wasStillPending) {
          recompute();
        }
      }
    }
    return { setSyncStatus, destroy };
  }
  {
    const maybePreventClose = (e) => {
      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== "synchronized") {
        e.preventDefault();
      }
    };
    const win = typeof window !== "undefined" ? window : void 0;
    win == null ? void 0 : win.addEventListener("beforeunload", maybePreventClose);
  }
  async function getNotificationSettings(options2) {
    const plainSettings = await httpClient.getNotificationSettings(options2);
    const settings = createNotificationSettings(plainSettings);
    return settings;
  }
  async function updateNotificationSettings(settings) {
    const plainSettings = await httpClient.updateNotificationSettings(settings);
    const settingsObject = createNotificationSettings(plainSettings);
    return settingsObject;
  }
  const client = Object.defineProperty(
    {
      enterRoom,
      getRoom,
      logout,
      // Public inbox notifications API
      getInboxNotifications: httpClient.getInboxNotifications,
      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,
      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,
      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,
      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,
      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,
      deleteInboxNotification: httpClient.deleteInboxNotification,
      // Public notification settings API
      getNotificationSettings,
      updateNotificationSettings,
      // Advanced resolvers APIs
      resolvers: {
        invalidateUsers: invalidateResolvedUsers,
        invalidateRoomsInfo: invalidateResolvedRoomsInfo,
        invalidateGroupsInfo: invalidateResolvedGroupsInfo,
        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions
      },
      getSyncStatus,
      events: {
        error: liveblocksErrorSource,
        syncStatus: syncStatusSignal
      },
      // Internal
      [kInternal]: {
        currentUserId,
        mentionSuggestionsCache,
        ai,
        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,
        usersStore,
        roomsInfoStore,
        groupsInfoStore,
        getRoomIds() {
          return Array.from(roomsById.keys());
        },
        httpClient,
        // Type-level helper only, it's effectively only an identity-function at runtime
        as: () => client,
        createSyncSource,
        emitError: (context, cause) => {
          const error3 = LiveblocksError.from(context, cause);
          const didNotify = liveblocksErrorSource.notify(error3);
          if (!didNotify) {
            error2(error3.message);
          }
        }
      }
    },
    kInternal,
    {
      enumerable: false
    }
  );
  return client;
}
function checkBounds(option, value, min, max, recommendedMin) {
  if (typeof value !== "number" || value < min || max !== void 0 && value > max) {
    throw new Error(
      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`
    );
  }
  return value;
}
function getBackgroundKeepAliveTimeout(value) {
  if (value === void 0) return void 0;
  return checkBounds(
    "backgroundKeepAliveTimeout",
    value,
    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT
  );
}
function getThrottle(value) {
  return checkBounds("throttle", value, MIN_THROTTLE, MAX_THROTTLE);
}
function getLostConnectionTimeout(value) {
  return checkBounds(
    "lostConnectionTimeout",
    value,
    MIN_LOST_CONNECTION_TIMEOUT,
    MAX_LOST_CONNECTION_TIMEOUT,
    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT
  );
}
function isCommentBodyParagraph(element) {
  return "type" in element && element.type === "paragraph";
}
function isCommentBodyText(element) {
  return !("type" in element) && "text" in element && typeof element.text === "string";
}
function isCommentBodyMention(element) {
  return "type" in element && element.type === "mention";
}
function isCommentBodyLink(element) {
  return "type" in element && element.type === "link";
}
var commentBodyElementsGuards = {
  paragraph: isCommentBodyParagraph,
  text: isCommentBodyText,
  link: isCommentBodyLink,
  mention: isCommentBodyMention
};
var commentBodyElementsTypes = {
  paragraph: "block",
  text: "inline",
  link: "inline",
  mention: "inline"
};
function traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {
  if (!body || !(body == null ? void 0 : body.content)) {
    return;
  }
  const element = typeof elementOrVisitor === "string" ? elementOrVisitor : void 0;
  const type = element ? commentBodyElementsTypes[element] : "all";
  const guard = element ? commentBodyElementsGuards[element] : () => true;
  const visitor = typeof elementOrVisitor === "function" ? elementOrVisitor : possiblyVisitor;
  for (const block of body.content) {
    if (type === "all" || type === "block") {
      if (guard(block)) {
        visitor == null ? void 0 : visitor(block);
      }
    }
    if (type === "all" || type === "inline") {
      for (const inline of block.children) {
        if (guard(inline)) {
          visitor == null ? void 0 : visitor(inline);
        }
      }
    }
  }
}
function getMentionsFromCommentBody(body, predicate) {
  const mentionIds = /* @__PURE__ */ new Set();
  const mentions = [];
  traverseCommentBody(body, "mention", (mention) => {
    if (
      // If this mention isn't already in the list
      !mentionIds.has(mention.id) && // And the provided predicate is true
      (predicate ? predicate(mention) : true)
    ) {
      mentionIds.add(mention.id);
      mentions.push(mention);
    }
  });
  return mentions;
}
async function resolveMentionsInCommentBody(body, resolveUsers, resolveGroupsInfo) {
  const resolvedUsers = /* @__PURE__ */ new Map();
  const resolvedGroupsInfo = /* @__PURE__ */ new Map();
  if (!resolveUsers && !resolveGroupsInfo) {
    return {
      users: resolvedUsers,
      groups: resolvedGroupsInfo
    };
  }
  const mentions = getMentionsFromCommentBody(body);
  const userIds = mentions.filter((mention) => mention.kind === "user").map((mention) => mention.id);
  const groupIds = mentions.filter((mention) => mention.kind === "group").map((mention) => mention.id);
  const [users, groups] = await Promise.all([
    resolveUsers && userIds.length > 0 ? resolveUsers({ userIds }) : void 0,
    resolveGroupsInfo && groupIds.length > 0 ? resolveGroupsInfo({ groupIds }) : void 0
  ]);
  if (users) {
    for (const [index, userId] of userIds.entries()) {
      const user = users[index];
      if (user) {
        resolvedUsers.set(userId, user);
      }
    }
  }
  if (groups) {
    for (const [index, groupId] of groupIds.entries()) {
      const group = groups[index];
      if (group) {
        resolvedGroupsInfo.set(groupId, group);
      }
    }
  }
  return {
    users: resolvedUsers,
    groups: resolvedGroupsInfo
  };
}
var htmlEscapables = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var htmlEscapablesRegex = new RegExp(
  Object.keys(htmlEscapables).map((entity) => `\\${entity}`).join("|"),
  "g"
);
function htmlSafe(value) {
  return new HtmlSafeString([String(value)], []);
}
function joinHtml(strings) {
  if (strings.length <= 0) {
    return new HtmlSafeString([""], []);
  }
  return new HtmlSafeString(
    ["", ...Array(strings.length - 1).fill(""), ""],
    strings
  );
}
function escapeHtml(value) {
  if (value instanceof HtmlSafeString) {
    return value.toString();
  }
  if (Array.isArray(value)) {
    return joinHtml(value).toString();
  }
  return String(value).replace(
    htmlEscapablesRegex,
    (character) => htmlEscapables[character]
  );
}
var _strings, _values, _a24;
var HtmlSafeString = (_a24 = class {
  constructor(strings, values2) {
    __privateAdd(this, _strings);
    __privateAdd(this, _values);
    __privateSet(this, _strings, strings);
    __privateSet(this, _values, values2);
  }
  toString() {
    return __privateGet(this, _strings).reduce((result, str, i) => {
      return result + escapeHtml(nn(__privateGet(this, _values)[i - 1])) + str;
    });
  }
}, _strings = new WeakMap(), _values = new WeakMap(), _a24);
function html(strings, ...values2) {
  return new HtmlSafeString(strings, values2);
}
var markdownEscapables = {
  _: "\\_",
  "*": "\\*",
  "#": "\\#",
  "`": "\\`",
  "~": "\\~",
  "!": "\\!",
  "|": "\\|",
  "(": "\\(",
  ")": "\\)",
  "{": "\\{",
  "}": "\\}",
  "[": "\\[",
  "]": "\\]"
};
var markdownEscapablesRegex = new RegExp(
  Object.keys(markdownEscapables).map((entity) => `\\${entity}`).join("|"),
  "g"
);
function joinMarkdown(strings) {
  if (strings.length <= 0) {
    return new MarkdownSafeString([""], []);
  }
  return new MarkdownSafeString(
    ["", ...Array(strings.length - 1).fill(""), ""],
    strings
  );
}
function escapeMarkdown(value) {
  if (value instanceof MarkdownSafeString) {
    return value.toString();
  }
  if (Array.isArray(value)) {
    return joinMarkdown(value).toString();
  }
  return String(value).replace(
    markdownEscapablesRegex,
    (character) => markdownEscapables[character]
  );
}
var _strings2, _values2, _a25;
var MarkdownSafeString = (_a25 = class {
  constructor(strings, values2) {
    __privateAdd(this, _strings2);
    __privateAdd(this, _values2);
    __privateSet(this, _strings2, strings);
    __privateSet(this, _values2, values2);
  }
  toString() {
    return __privateGet(this, _strings2).reduce((result, str, i) => {
      return result + escapeMarkdown(nn(__privateGet(this, _values2)[i - 1])) + str;
    });
  }
}, _strings2 = new WeakMap(), _values2 = new WeakMap(), _a25);
function markdown(strings, ...values2) {
  return new MarkdownSafeString(strings, values2);
}
var stringifyCommentBodyPlainElements = {
  paragraph: ({ children }) => children,
  text: ({ element }) => element.text,
  link: ({ element }) => element.text ?? element.url,
  mention: ({ element, user, group }) => {
    return `@${(user == null ? void 0 : user.name) ?? (group == null ? void 0 : group.name) ?? element.id}`;
  }
};
var stringifyCommentBodyHtmlElements = {
  paragraph: ({ children }) => {
    return children ? html`<p>${htmlSafe(children)}</p>` : children;
  },
  text: ({ element }) => {
    let children = element.text;
    if (!children) {
      return html`${children}`;
    }
    if (element.bold) {
      children = html`<strong>${children}</strong>`;
    }
    if (element.italic) {
      children = html`<em>${children}</em>`;
    }
    if (element.strikethrough) {
      children = html`<s>${children}</s>`;
    }
    if (element.code) {
      children = html`<code>${children}</code>`;
    }
    return html`${children}`;
  },
  link: ({ element, href }) => {
    return html`<a href="${href}" target="_blank" rel="noopener noreferrer">${element.text ? html`${element.text}` : element.url}</a>`;
  },
  mention: ({ element, user, group }) => {
    return html`<span data-mention>@${(user == null ? void 0 : user.name) ? html`${user == null ? void 0 : user.name}` : (group == null ? void 0 : group.name) ? html`${group == null ? void 0 : group.name}` : element.id}</span>`;
  }
};
var stringifyCommentBodyMarkdownElements = {
  paragraph: ({ children }) => {
    return children;
  },
  text: ({ element }) => {
    let children = element.text;
    if (!children) {
      return children;
    }
    if (element.bold) {
      children = markdown`**${children}**`;
    }
    if (element.italic) {
      children = markdown`_${children}_`;
    }
    if (element.strikethrough) {
      children = markdown`~~${children}~~`;
    }
    if (element.code) {
      children = markdown`\`${children}\``;
    }
    return children;
  },
  link: ({ element, href }) => {
    return markdown`[${element.text ?? element.url}](${href})`;
  },
  mention: ({ element, user, group }) => {
    return markdown`@${(user == null ? void 0 : user.name) ?? (group == null ? void 0 : group.name) ?? element.id}`;
  }
};
async function stringifyCommentBody(body, options) {
  const format = (options == null ? void 0 : options.format) ?? "plain";
  const separator = (options == null ? void 0 : options.separator) ?? (format === "markdown" ? "\n\n" : "\n");
  const elements = {
    ...format === "html" ? stringifyCommentBodyHtmlElements : format === "markdown" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,
    ...options == null ? void 0 : options.elements
  };
  const { users: resolvedUsers, groups: resolvedGroupsInfo } = await resolveMentionsInCommentBody(
    body,
    options == null ? void 0 : options.resolveUsers,
    options == null ? void 0 : options.resolveGroupsInfo
  );
  const blocks = body.content.flatMap((block, blockIndex) => {
    switch (block.type) {
      case "paragraph": {
        const inlines = block.children.flatMap((inline, inlineIndex) => {
          if (isCommentBodyMention(inline)) {
            return inline.id ? [
              elements.mention(
                {
                  element: inline,
                  user: inline.kind === "user" ? resolvedUsers.get(inline.id) : void 0,
                  group: inline.kind === "group" ? resolvedGroupsInfo.get(inline.id) : void 0
                },
                inlineIndex
              )
            ] : [];
          }
          if (isCommentBodyLink(inline)) {
            const href = sanitizeUrl(inline.url);
            if (href === null) {
              return [
                elements.text(
                  {
                    element: { text: inline.text ?? inline.url }
                  },
                  inlineIndex
                )
              ];
            }
            return [
              elements.link(
                {
                  element: inline,
                  href
                },
                inlineIndex
              )
            ];
          }
          if (isCommentBodyText(inline)) {
            return [elements.text({ element: inline }, inlineIndex)];
          }
          return [];
        });
        return [
          elements.paragraph(
            { element: block, children: inlines.join("") },
            blockIndex
          )
        ];
      }
      default:
        return [];
    }
  });
  return blocks.join(separator);
}
function toPlainLson(lson) {
  if (lson instanceof LiveObject) {
    return {
      liveblocksType: "LiveObject",
      data: Object.fromEntries(
        Object.entries(lson.toObject()).flatMap(
          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []
        )
      )
    };
  } else if (lson instanceof LiveMap) {
    return {
      liveblocksType: "LiveMap",
      data: Object.fromEntries(
        [...lson].map(([key, value]) => [key, toPlainLson(value)])
      )
    };
  } else if (lson instanceof LiveList) {
    return {
      liveblocksType: "LiveList",
      data: [...lson].map((item) => toPlainLson(item))
    };
  } else {
    return lson;
  }
}
function throwUsageError(message) {
  if (true) {
    const usageError = new Error(message);
    usageError.name = "Usage error";
    errorWithTitle("Usage error", message);
    throw usageError;
  }
}
function errorIf(condition, message) {
  if (true) {
    if (condition) {
      throwUsageError(message);
    }
  }
}
var BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];
function makePoller(callback, intervalMs, options) {
  const startTime = performance.now();
  const doc = typeof document !== "undefined" ? document : void 0;
  const win = typeof window !== "undefined" ? window : void 0;
  const maxStaleTimeMs = (options == null ? void 0 : options.maxStaleTimeMs) ?? Number.POSITIVE_INFINITY;
  const context = {
    inForeground: (doc == null ? void 0 : doc.visibilityState) !== "hidden",
    lastSuccessfulPollAt: startTime,
    count: 0,
    backoff: 0
  };
  function mayPoll() {
    return context.count > 0 && context.inForeground;
  }
  const fsm = new FSM({}).addState("@idle").addState("@enabled").addState("@polling");
  fsm.addTransitions("@idle", { START: "@enabled" });
  fsm.addTransitions("@enabled", { STOP: "@idle", POLL: "@polling" });
  fsm.addTimedTransition(
    "@enabled",
    () => {
      const lastPoll = context.lastSuccessfulPollAt;
      const nextPoll = lastPoll + intervalMs;
      return Math.max(0, nextPoll - performance.now()) + context.backoff;
    },
    "@polling"
  );
  fsm.onEnterAsync(
    "@polling",
    async (_ctx, signal) => {
      await callback(signal);
      if (!signal.aborted) {
        context.lastSuccessfulPollAt = performance.now();
      }
    },
    // When OK
    () => {
      return {
        target: mayPoll() ? "@enabled" : "@idle",
        effect: () => {
          context.backoff = 0;
        }
      };
    },
    // When error
    () => {
      return {
        target: mayPoll() ? "@enabled" : "@idle",
        effect: () => {
          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];
        }
      };
    },
    3e4
    // Abort the poll if the callback takes more than 30 seconds to complete
  );
  function startOrStop() {
    if (mayPoll()) {
      fsm.send({ type: "START" });
    } else {
      fsm.send({ type: "STOP" });
    }
  }
  function inc() {
    context.count++;
    startOrStop();
  }
  function dec() {
    context.count--;
    if (context.count < 0) {
      context.count = 0;
    }
    startOrStop();
  }
  function pollNowIfStale() {
    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {
      fsm.send({ type: "POLL" });
    }
  }
  function markAsStale() {
    context.lastSuccessfulPollAt = performance.now() - maxStaleTimeMs - 1;
  }
  function setInForeground(inForeground) {
    context.inForeground = inForeground;
    startOrStop();
    pollNowIfStale();
  }
  function onVisibilityChange() {
    setInForeground((doc == null ? void 0 : doc.visibilityState) !== "hidden");
  }
  doc == null ? void 0 : doc.addEventListener("visibilitychange", onVisibilityChange);
  win == null ? void 0 : win.addEventListener("online", onVisibilityChange);
  win == null ? void 0 : win.addEventListener("focus", pollNowIfStale);
  fsm.start();
  return {
    inc,
    dec,
    pollNowIfStale,
    markAsStale,
    // Internal API, used by unit tests only to simulate visibility events
    setInForeground
  };
}
function getSubscriptionKey(subscription, subjectId) {
  if (typeof subscription === "string") {
    return `${subscription}:${subjectId}`;
  }
  return `${subscription.kind}:${subscription.subjectId}`;
}
var TextEditorType = ((TextEditorType2) => {
  TextEditorType2["Lexical"] = "lexical";
  TextEditorType2["TipTap"] = "tiptap";
  TextEditorType2["BlockNote"] = "blocknote";
  return TextEditorType2;
})(TextEditorType || {});
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);

// node_modules/@liveblocks/client/dist/index.js
var PKG_NAME2 = "@liveblocks/client";
var PKG_VERSION2 = "3.7.1";
var PKG_FORMAT2 = "esm";
detectDupes(PKG_NAME2, PKG_VERSION2, PKG_FORMAT2);

export {
  detectDupes,
  makeEventSource,
  raise,
  compactObject,
  findLastIndex,
  batch,
  Signal,
  DerivedSignal,
  MutableSignal,
  SortedList,
  assertNever,
  assert,
  nn,
  fancy_console_exports,
  isStartsWithOperator,
  HttpError,
  autoRetry,
  stableStringify,
  nanoid,
  createThreadId,
  createCommentId,
  createCommentAttachmentId,
  createInboxNotificationId,
  DefaultMap,
  sanitizeUrl,
  generateUrl,
  isUrl,
  ServerMsgCode,
  kInternal,
  shallow,
  shallow2,
  Permission,
  defineAiTool,
  MENTION_CHARACTER,
  warnOnce,
  createNotificationSettings,
  patchNotificationSettings,
  isNotificationChannelEnabled,
  LiveList,
  LiveMap,
  LiveObject,
  ClientMsgCode,
  LiveblocksError,
  createClient,
  isCommentBodyText,
  isCommentBodyMention,
  isCommentBodyLink,
  getMentionsFromCommentBody,
  stringifyCommentBody,
  toPlainLson,
  errorIf,
  makePoller,
  getSubscriptionKey,
  TextEditorType
};
//# sourceMappingURL=chunk-NT76HTXR.js.map
