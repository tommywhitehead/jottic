{
  "version": 3,
  "sources": ["../../@liveblocks/core/src/version.ts", "../../@liveblocks/core/src/dupe-detection.ts", "../../@liveblocks/core/src/lib/EventSource.ts", "../../@liveblocks/core/src/lib/freeze.ts", "../../@liveblocks/core/src/lib/utils.ts", "../../@liveblocks/core/src/lib/signals.ts", "../../@liveblocks/core/src/lib/SortedList.ts", "../../@liveblocks/core/src/AiChatDB.ts", "../../@liveblocks/core/src/convert-plain-data.ts", "../../@liveblocks/core/src/lib/assert.ts", "../../@liveblocks/core/src/lib/fancy-console.ts", "../../@liveblocks/core/src/lib/guards.ts", "../../@liveblocks/core/src/lib/autoRetry.ts", "../../@liveblocks/core/src/lib/controlledPromise.ts", "../../@liveblocks/core/src/lib/stringify.ts", "../../@liveblocks/core/src/lib/batch.ts", "../../@liveblocks/core/src/lib/chunk.ts", "../../@liveblocks/core/src/lib/nanoid.ts", "../../@liveblocks/core/src/lib/createIds.ts", "../../@liveblocks/core/src/lib/DefaultMap.ts", "../../@liveblocks/core/src/lib/objectToQuery.ts", "../../@liveblocks/core/src/lib/url.ts", "../../@liveblocks/core/src/api-client.ts", "../../@liveblocks/core/src/lib/fsm.ts", "../../@liveblocks/core/src/protocol/ServerMsg.ts", "../../@liveblocks/core/src/types/IWebSocket.ts", "../../@liveblocks/core/src/connection.ts", "../../@liveblocks/core/src/internal.ts", "../../@liveblocks/core/src/lib/shallow.ts", "../../@liveblocks/core/src/lib/TreePool.ts", "../../@liveblocks/core/src/protocol/AuthToken.ts", "../../@liveblocks/core/src/lib/IncrementalJsonParser.ts", "../../@liveblocks/core/src/types/ai.ts", "../../@liveblocks/core/src/ai.ts", "../../@liveblocks/core/src/auth-manager.ts", "../../@liveblocks/core/src/constants.ts", "../../@liveblocks/core/src/devtools/bridge.ts", "../../@liveblocks/core/src/devtools/index.ts", "../../@liveblocks/core/src/lib/warnings.ts", "../../@liveblocks/core/src/protocol/NotificationSettings.ts", "../../@liveblocks/core/src/lib/position.ts", "../../@liveblocks/core/src/protocol/Op.ts", "../../@liveblocks/core/src/crdts/AbstractCrdt.ts", "../../@liveblocks/core/src/protocol/SerializedCrdt.ts", "../../@liveblocks/core/src/crdts/LiveRegister.ts", "../../@liveblocks/core/src/crdts/LiveList.ts", "../../@liveblocks/core/src/crdts/LiveMap.ts", "../../@liveblocks/core/src/crdts/LiveObject.ts", "../../@liveblocks/core/src/crdts/liveblocks-helpers.ts", "../../@liveblocks/core/src/lib/debug.ts", "../../@liveblocks/core/src/lib/Deque.ts", "../../@liveblocks/core/src/lib/Json.ts", "../../@liveblocks/core/src/protocol/ClientMsg.ts", "../../@liveblocks/core/src/refs/ManagedOthers.ts", "../../@liveblocks/core/src/types/LiveblocksError.ts", "../../@liveblocks/core/src/room.ts", "../../@liveblocks/core/src/client.ts", "../../@liveblocks/core/src/comments/comment-body.ts", "../../@liveblocks/core/src/crdts/utils.ts", "../../@liveblocks/core/src/immutable.ts", "../../@liveblocks/core/src/lib/abortController.ts", "../../@liveblocks/core/src/lib/deprecation.ts", "../../@liveblocks/core/src/lib/Poller.ts", "../../@liveblocks/core/src/protocol/Subscriptions.ts", "../../@liveblocks/core/src/types/Others.ts", "../../@liveblocks/core/src/index.ts", "../../@liveblocks/client/src/index.ts", "../../@liveblocks/client/src/version.ts"],
  "sourcesContent": ["declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/core\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n", "import { PKG_NAME, PKG_VERSION } from \"./version\";\n\nconst g = (\n  typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof window !== \"undefined\"\n      ? window\n      : typeof global !== \"undefined\"\n        ? global\n        : {}\n) as { [key: symbol]: string };\n\nconst crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nconst dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nconst SPACE = \" \"; // Important space to make sure links in errors are clickable in all browsers\n\nfunction error(msg: string): void {\n  if (process.env.NODE_ENV === \"production\") {\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\n\n/**\n * Throws an error if multiple copies of a Liveblocks package are being loaded\n * at runtime. This likely indicates a packaging issue with the project.\n */\nexport function detectDupes(\n  pkgName: string,\n  pkgVersion: string | false, // false if not built yet\n  pkgFormat: string | false // false if not built yet\n): void {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat\n    ? `${pkgVersion || \"dev\"} (${pkgFormat})`\n    : pkgVersion || \"dev\";\n\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n    // Allow it, see https://github.com/liveblocks/liveblocks/pull/1004\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${\n        dupesDocs + SPACE\n      }`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`,\n    ].join(\"\\n\");\n    error(msg);\n  }\n\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${\n          crossLinkedDocs + SPACE\n        }`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\",\n      ].join(\"\\n\")\n    );\n  }\n}\n", "export type Callback<T> = (event: T) => void;\nexport type UnsubscribeCallback = () => void;\n\nexport type Observable<T> = {\n  /**\n   * Register a callback function to be called whenever the event source emits\n   * an event.\n   */\n  subscribe(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Register a one-time callback function to be called whenever the event\n   * source emits an event. After the event fires, the callback is\n   * auto-unsubscribed.\n   */\n  subscribeOnce(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Returns a promise that will resolve when an event is emitted by this\n   * event source. Optionally, specify a predicate that has to match. The first\n   * event matching that predicate will then resolve the promise.\n   */\n  waitUntil(predicate?: (event: T) => boolean): Promise<T>;\n};\n\nexport type EventSource<T> = Observable<T> & {\n  /**\n   * Notify all subscribers about the event. Will return `false` if there\n   * weren't any subscribers at the time the .notify() was called, or `true` if\n   * there was at least one subscriber.\n   */\n  notify(event: T): boolean;\n  /**\n   * Returns the number of active subscribers.\n   */\n  count(): number;\n  /**\n   * Observable instance, which can be used to subscribe to this event source\n   * in a readonly fashion. Safe to publicly expose.\n   */\n  observable: Observable<T>;\n  /**\n   * Disposes of this event source.\n   *\n   * Will clears all registered event listeners. None of the registered\n   * functions will ever get called again.\n   *\n   * WARNING!\n   * Be careful when using this API, because the subscribers may not have any\n   * idea they won't be notified anymore.\n   */\n  // NOTE: This can eventually become [Symbol.dispose] when it's widely\n  // available in all browsers\n  dispose(): void;\n};\n\nexport type BufferableEventSource<T> = EventSource<T> & {\n  /**\n   * Pauses event delivery until unpaused. Any .notify() calls made while\n   * paused will get buffered into memory and emitted later.\n   */\n  pause(): void;\n  /**\n   * Emits all in-memory buffered events, and unpauses. Any .notify() calls\n   * made after this will be synchronously delivered again.\n   */\n  unpause(): void;\n};\n\nexport type EventEmitter<T> = (event: T) => void;\n\n/**\n * makeEventSource allows you to generate a subscribe/notify pair of functions\n * to make subscribing easy and to get notified about events.\n *\n * The events are anonymous, so you can use it to define events, like so:\n *\n *   const event1 = makeEventSource();\n *   const event2 = makeEventSource();\n *\n *   event1.subscribe(foo);\n *   event1.subscribe(bar);\n *   event2.subscribe(qux);\n *\n *   // Unsubscription is pretty standard\n *   const unsub = event2.subscribe(foo);\n *   unsub();\n *\n *   event1.notify();  // Now foo and bar will get called\n *   event2.notify();  // Now qux will get called (but foo will not, since it's unsubscribed)\n *\n */\nexport function makeEventSource<T>(): EventSource<T> {\n  const _observers = new Set<Callback<T>>();\n\n  function subscribe(callback: Callback<T>): UnsubscribeCallback {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n\n  function subscribeOnce(callback: Callback<T>): UnsubscribeCallback {\n    const unsub = subscribe((event: T) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n\n  async function waitUntil(predicate?: (event: T) => boolean): Promise<T> {\n    let unsub: () => void | undefined;\n    return new Promise<T>((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === undefined || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n\n  function notify(event: T) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n\n  function count() {\n    return _observers.size;\n  }\n\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n\n    waitUntil,\n\n    dispose(): void {\n      _observers.clear();\n    },\n\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil,\n    },\n  };\n}\n\nexport function makeBufferableEventSource<T>(): BufferableEventSource<T> {\n  const eventSource = makeEventSource<T>();\n  let _buffer: T[] | null = null;\n\n  function pause(): void {\n    _buffer = [];\n  }\n\n  function unpause(): void {\n    if (_buffer === null) {\n      // Already unpaused\n      return;\n    }\n\n    for (const event of _buffer) {\n      eventSource.notify(event);\n    }\n    _buffer = null;\n  }\n\n  function notifyOrBuffer(event: T) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource.notify(event);\n    }\n  }\n\n  return {\n    ...eventSource,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n\n    dispose(): void {\n      eventSource.dispose();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    },\n  };\n}\n", "/**\n * Freezes the given argument, but only in development builds. In production\n * builds, this is a no-op for performance reasons.\n */\nexport const freeze: typeof Object.freeze =\n  process.env.NODE_ENV === \"production\"\n    ? /* istanbul ignore next */ (((x: unknown) => x) as typeof Object.freeze)\n    : Object.freeze;\n", "import type { Json } from \"./Json\";\n\ndeclare const brand: unique symbol;\nexport type Brand<T, TBrand extends string> = T & { [brand]: TBrand };\n\nexport type ISODateString = Brand<string, \"ISODateString\">;\n\nexport type DistributiveOmit<T, K extends PropertyKey> = T extends any\n  ? Omit<T, K>\n  : never;\n\n// export type DistributivePick<T, K extends keyof T> = T extends any\n//   ? Pick<T, K>\n//   : never;\n\nexport type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\n\nexport type WithOptional<T, K extends keyof T> = Omit<T, K> & {\n  [P in K]?: T[P];\n};\n\n/**\n * Throw an error, but as an expression instead of a statement.\n */\nexport function raise(msg: string): never {\n  throw new Error(msg);\n}\n\n/**\n * Drop-in replacement for Object.entries() that retains better types.\n */\nexport function entries<\n  O extends { [key: string]: unknown },\n  K extends keyof O,\n>(obj: O): [K, O[K]][] {\n  return Object.entries(obj) as [K, O[K]][];\n}\n\n/**\n * Drop-in replacement for Object.keys() that retains better types.\n */\nexport function keys<O extends { [key: string]: unknown }, K extends keyof O>(\n  obj: O\n): K[] {\n  return Object.keys(obj) as K[];\n}\n\n/**\n * Drop-in replacement for Object.values() that retains better types.\n */\nexport function values<O extends Record<string, unknown>>(\n  obj: O\n): O[keyof O][] {\n  return Object.values(obj) as O[keyof O][];\n}\n\n/**\n * Drop-in replacement for Object.create() that retains better types.\n */\nexport function create<O extends Record<string, unknown>>(\n  obj: O | null,\n  descriptors?: PropertyDescriptorMap & ThisType<O>\n): O {\n  if (typeof descriptors !== \"undefined\") {\n    return Object.create(obj, descriptors) as O;\n  }\n\n  return Object.create(obj) as O;\n}\n\n/**\n * Creates a new object by mapping a function over all values. Keys remain the\n * same. Think Array.prototype.map(), but for values in an object.\n */\nexport function mapValues<V, O extends Record<string, unknown>>(\n  obj: O,\n  mapFn: (value: O[keyof O], key: keyof O) => V\n): { [K in keyof O]: V } {\n  const result = {} as { [K in keyof O]: V };\n  for (const pair of Object.entries(obj)) {\n    const key: keyof O = pair[0];\n    if (key === \"__proto__\") {\n      // Avoid setting dangerous __proto__ keys\n      continue;\n    }\n    const value = pair[1] as O[keyof O];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\n\n/**\n * Alternative to JSON.parse() that will not throw in production. If the passed\n * string cannot be parsed, this will return `undefined`.\n */\nexport function tryParseJson(rawMessage: string): Json | undefined {\n  try {\n    // eslint-disable-next-line no-restricted-syntax\n    return JSON.parse(rawMessage) as Json;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Deep-clones a JSON-serializable value.\n *\n * NOTE: We should be able to replace `deepClone` by `structuredClone` once\n * we've upgraded to Node 18.\n */\nexport function deepClone<T extends Json>(value: T): T {\n  // NOTE: In this case, the combination of JSON.parse() and JSON.stringify\n  // won't lead to type unsafety, so this use case is okay.\n  // eslint-disable-next-line no-restricted-syntax\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n\n/**\n * Decode base64 string.\n */\nexport function b64decode(b64value: string): string {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue)\n        .split(\"\")\n        .map(function (c) {\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\n\n/**\n * Mutates the array in-place by removing the first occurrence of `item` from\n * the array.\n */\nexport function remove<T>(array: T[], item: T): void {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n      break;\n    }\n  }\n}\n\n/**\n * Removes null and undefined values from the array, and reflects this in the\n * output type.\n */\nexport function compact<T>(items: readonly T[]): NonNullable<T>[] {\n  return items.filter(\n    (item: T): item is NonNullable<T> => item !== null && item !== undefined\n  );\n}\n\nexport type RemoveUndefinedValues<T> = {\n  [K in keyof T]-?: Exclude<T[K], undefined>;\n};\n\n/**\n * Returns a new object instance where all explictly-undefined values are\n * removed.\n */\nexport function compactObject<O extends Record<string, unknown>>(\n  obj: O\n): RemoveUndefinedValues<O> {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k as keyof O;\n    if (newObj[key] === undefined) {\n      delete newObj[key];\n    }\n  });\n  return newObj as RemoveUndefinedValues<O>;\n}\n\n/**\n * Returns a promise that resolves after the given number of milliseconds.\n */\nexport function wait(millis: number): Promise<void> {\n  return new Promise((res) => setTimeout(res, millis));\n}\n\n/**\n * Returns whatever the given promise returns, but will be rejected with\n * a \"Timed out\" error if the given promise does not return or reject within\n * the given timeout period (in milliseconds).\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  millis: number,\n  errmsg: string\n): Promise<T> {\n  let timerID: ReturnType<typeof setTimeout> | undefined;\n  const timer$ = new Promise<never>((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return (\n    Promise\n      // Race the given promise against the timer. Whichever one finishes\n      // first wins the race.\n      .race([promise, timer$])\n\n      // Either way, clear the timeout, no matter who won\n      .finally(() => clearTimeout(timerID))\n  );\n}\n\n/**\n * Memoize a promise factory, so that each subsequent call will return the same\n * pending or success promise. If the promise rejects, will retain that failed\n * promise for a small time period, after which the next attempt will reset the\n * memoized value.\n */\nexport function memoizeOnSuccess<T>(\n  factoryFn: () => Promise<T>\n): () => Promise<T> {\n  let cached: Promise<T> | null = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        //\n        // Keep returning the failed promise for any calls to the memoized\n        // promise for the next 5 seconds. This time period is a bit arbitrary,\n        // but exists to make this play nicely with frameworks like React.\n        //\n        // In React, after a component is suspended and its promise is\n        // rejected, React will re-render the component, and expect the next\n        // call to this function to return the rejected promise, so its error\n        // can be shown. If we immediately reset this value, then such next\n        // render would instantly trigger a new promise which would trigger an\n        // infinite loop and keeping the component in loading state forever.\n        //\n        setTimeout(() => {\n          cached = null;\n        }, 5_000);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n/**\n * Polyfill for Array.prototype.findLastIndex()\n */\nexport function findLastIndex<T>(\n  arr: T[],\n  predicate: (value: T, index: number, obj: T[]) => boolean\n): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function iso(s: string): ISODateString {\n  return new Date(s).toISOString() as ISODateString;\n}\n", "import type {\n  Callback,\n  EventSource,\n  Observable,\n  UnsubscribeCallback,\n} from \"../lib/EventSource\";\nimport { makeEventSource } from \"../lib/EventSource\";\nimport { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { compactObject, raise } from \"../lib/utils\";\n\nconst kSinks = Symbol(\"kSinks\");\nconst kTrigger = Symbol(\"kTrigger\");\n\n//\n// Before the batch is run, all sinks (recursively all the way down) are marked\n// dirty. This already is enough if we only ever use .get() calls.\n//\n// However, to ensure active subscription notifications also work, we need to\n// keep track of which Signals to notify. Any time the value of a Signal\n// changes, the Signal itself will notify its own subscribers, but \"sinks\" are\n// not \"normal\" subscribers.\n//\n// By treating sinks slightly differently, we can keep track of sink uniqueness\n// across the entire signal network, ensuring a sink will only be notified once\n// if more than one of its dependent Signals have changed.\n//\n// For example:\n//\n//      A\n//    /   \\\n//   B     C\n//    \\   /\n//      D - - - - ( has 1 normal subscriber )\n//\n// Here, B and C are sinks of A, and D is a sink of both B and C.\n//\n// Here's what will happen when A changes:\n//\n// - If A changes, then all sinks (B, C, and D) will be marked dirty.\n//\n// - Because some of A's sinks are being watched (in this case, D has at least\n//   one subscriber), A will trigger B and C that its value has changed.\n//\n// - Both B and C re-evaluate and may or may not have changed. Three\n//   possibilities:\n//   1. Neither B and C have changed → D will *NOT* be triggered\n//   2. Either B or C has changed    → D *will* be triggered\n//   3. Both B and C have changed    → D *will* be triggered (but only once!)\n//\n// - If in the previous step D has been triggered, it will re-evaluate. If it\n//   has changed itself, it will notify its normal subscriber.\n//\nlet signalsToTrigger: Set<AbstractSignal<any>> | null = null;\n\n//\n// If a derived signal is currently being computed, there is a global \"signals\n// that have been read\" registry that every call to `someSignal.get()` will\n// register itself under.\n//\nlet trackedReads: Set<AbstractSignal<any>> | null = null;\n\n/**\n * Runs a callback function that is allowed to change multiple signals. At the\n * end of the batch, all changed signals will be notified (at most once).\n *\n * Nesting batches is supported.\n */\nexport function batch(callback: Callback<void>): void {\n  if (signalsToTrigger !== null) {\n    // Already inside another batch, just run this inner callback\n    callback();\n    return;\n  }\n\n  signalsToTrigger = new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\n\n/**\n * Ensures that the signal will be notified at the end of the current batch.\n * This should only be called within a batch callback. It's safe to call this\n * while notifications are being rolled out.\n */\nfunction enqueueTrigger(signal: AbstractSignal<any>) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\n\n/**\n * Patches a target object by \"merging in\" the provided fields. Patch\n * fields that are explicitly-undefined will delete keys from the target\n * object. Will return a new object.\n *\n * Important guarantee:\n * If the patch effectively did not mutate the target object because the\n * patch fields have the same value as the original, then the original\n * object reference will be returned.\n */\nexport function merge<T>(target: T, patch: Partial<T>): T {\n  let updated = false;\n  const newValue = { ...target };\n\n  Object.keys(patch).forEach((k) => {\n    const key = k as keyof T;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === undefined) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val as T[keyof T];\n      }\n      updated = true;\n    }\n  });\n\n  return updated ? newValue : target;\n}\n\nexport type SignalType<S extends ISignal<any>> =\n  S extends ISignal<infer T> ? T : never;\n\nexport interface ISignal<T> {\n  get(): T;\n  subscribe(callback: Callback<void>): UnsubscribeCallback;\n  addSink(sink: DerivedSignal<unknown>): void;\n  removeSink(sink: DerivedSignal<unknown>): void;\n}\n\n/**\n * Base functionality every Signal implementation needs.\n */\nabstract class AbstractSignal<T> implements ISignal<T>, Observable<void> {\n  /** @internal */\n  protected readonly equals: (a: T, b: T) => boolean;\n  readonly #eventSource: EventSource<void>;\n  /** @internal */\n  public readonly [kSinks]: Set<DerivedSignal<unknown>>;\n\n  constructor(equals?: (a: T, b: T) => boolean) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource<void>();\n    this[kSinks] = new Set();\n\n    // Bind common methods to self\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n\n  dispose(): void {\n    this.#eventSource.dispose();\n\n    // @ts-expect-error make disposed object completely unusable\n    this.#eventSource = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.equals = \"(disposed)\";\n  }\n\n  // Concrete subclasses implement this method in different ways\n  abstract get(): T;\n\n  get hasWatchers(): boolean {\n    if (this.#eventSource.count() > 0) return true;\n\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public [kTrigger](): void {\n    this.#eventSource.notify();\n\n    // While Signals are being triggered in the current unroll, we can enqueue\n    // more signals to trigger (which will get added to the current unroll)\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n\n  subscribe(callback: Callback<void>): UnsubscribeCallback {\n    // If this is the first subscriber, we need to perform an initial .get()\n    // now in case this is a DerivedSignal that has not been evaluated yet. The\n    // reason we need to do this is that the .get() itself will register this\n    // signal as sinks of the dependent signals, so we will actually get\n    // notified here when one of the dependent signals changes.\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n\n  subscribeOnce(callback: Callback<void>): UnsubscribeCallback {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n\n  waitUntil(): never {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n\n  markSinksDirty(): void {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n\n  addSink(sink: DerivedSignal<unknown>): void {\n    this[kSinks].add(sink);\n  }\n\n  removeSink(sink: DerivedSignal<unknown>): void {\n    this[kSinks].delete(sink);\n  }\n\n  asReadonly(): ISignal<T> {\n    return this;\n  }\n}\n\n// NOTE: This class is pretty similar to the Signal.State proposal\nexport class Signal<T> extends AbstractSignal<T> {\n  #value: T;\n\n  constructor(value: T, equals?: (a: T, b: T) => boolean) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n\n  dispose(): void {\n    super.dispose();\n    // @ts-expect-error make disposed object completely unusable\n    this.#value = \"(disposed)\";\n  }\n\n  get(): T {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n\n  set(newValue: T | ((oldValue: T) => T)): void {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = (newValue as (oldValue: T) => T)(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n}\n\nexport class PatchableSignal<J extends JsonObject> extends Signal<J> {\n  constructor(data: J) {\n    super(freeze(compactObject(data)));\n  }\n\n  set(): void {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n\n  /**\n   * Patches the current object.\n   */\n  patch(patch: Partial<J>): void {\n    super.set((old) => merge(old, patch));\n  }\n}\n\n/**\n * Placeholder for a deferred computation that has yet to happen on-demand in\n * the future.\n */\nconst INITIAL = Symbol();\n\n// NOTE: This class is pretty similar to the Signal.Computed proposal\nexport class DerivedSignal<T> extends AbstractSignal<T> {\n  #prevValue: T;\n  #dirty: boolean; // When true, the value in #value may not be up-to-date and needs re-checking\n\n  #sources: Set<ISignal<unknown>>;\n  readonly #deps: readonly ISignal<unknown>[];\n  readonly #transform: (...values: unknown[]) => T;\n\n  // Overload 1\n  static from<Ts extends unknown[], V>(...args: [...signals: { [K in keyof Ts]: ISignal<Ts[K]> }, transform: (...values: Ts) => V]): DerivedSignal<V>; // prettier-ignore\n  // Overload 2\n  static from<Ts extends unknown[], V>(...args: [...signals: { [K in keyof Ts]: ISignal<Ts[K]> }, transform: (...values: Ts) => V, equals: (a: V, b: V) => boolean]): DerivedSignal<V>; // prettier-ignore\n  static from<Ts extends unknown[], V>(\n    // prettier-ignore\n    ...args: [\n      ...signals: { [K in keyof Ts]: ISignal<Ts[K]> },\n      transform: (...values: Ts) => V,\n      equals?: (a: V, b: V) => boolean,\n    ]\n  ): DerivedSignal<V> {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n\n    if (typeof args[args.length - 1] === \"function\") {\n      // Overload 2\n      const equals = last as (a: V, b: V) => boolean;\n      const transform = args.pop() as (...values: unknown[]) => V;\n      return new DerivedSignal(args as ISignal<unknown>[], transform, equals);\n    } else {\n      // Overload 1\n      const transform = last as (...values: unknown[]) => V;\n      return new DerivedSignal(args as ISignal<unknown>[], transform);\n    }\n  }\n\n  private constructor(\n    deps: ISignal<unknown>[],\n    transform: (...values: unknown[]) => T,\n    equals?: (a: T, b: T) => boolean\n  ) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL as unknown as T;\n    this.#deps = deps;\n    this.#sources = new Set();\n    this.#transform = transform;\n  }\n\n  dispose(): void {\n    for (const src of this.#sources) {\n      src.removeSink(this as DerivedSignal<unknown>);\n    }\n\n    // @ts-expect-error make disposed object completely unusable\n    this.#prevValue = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#sources = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#deps = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#transform = \"(disposed)\";\n  }\n\n  get isDirty(): boolean {\n    return this.#dirty;\n  }\n\n  #recompute(): boolean {\n    const oldTrackedReads = trackedReads;\n\n    let derived;\n    trackedReads = new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = new Set();\n\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this as DerivedSignal<unknown>);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this as DerivedSignal<unknown>);\n      }\n\n      trackedReads = oldTrackedReads;\n    }\n\n    this.#dirty = false;\n\n    // Only emit a change to watchers if the value actually changed\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n\n  markDirty(): void {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n\n  get(): T {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  public [kTrigger](): void {\n    if (!this.hasWatchers) {\n      // If there are no watchers for this signal, we don't need to\n      // re-evaluate. We can postpone re-evaluation until the next .get() call.\n      return;\n    }\n\n    // Re-evaluate the current derived signal's value and if needed,\n    // notify sinks. At this point, all sinks should already have been\n    // marked dirty, so we won't have to do that again here now.\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger](); // Actually notify subscribers\n    }\n  }\n}\n\n/**\n * A MutableSignal is a bit like Signal, except its state is managed by\n * a single value whose reference does not change but is mutated.\n *\n * Similar to how useSyncExternalState() works in React, there is a way to read\n * the current state at any point in time synchronously, and a way to update\n * its reference.\n */\nexport class MutableSignal<T extends object> extends AbstractSignal<T> {\n  readonly #state: T;\n\n  constructor(initialState: T) {\n    super();\n    this.#state = initialState;\n  }\n\n  dispose(): void {\n    super.dispose();\n    // @ts-expect-error make disposed object completely unusable\n    this.#state = \"(disposed)\";\n  }\n\n  get(): T {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback?: (state: T) => void | boolean): void {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n}\n", "/**\n * Returns the insertion index for the given item.\n */\nfunction bisectRight<T>(arr: readonly T[], x: T, lt: (a: T, b: T) => boolean) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + ((hi - lo) >> 1); // equiv of Math.floor((lo + hi) / 2)\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n\n/**\n * A datastructure to keep elements in ascending order, as defined by the \"less\n * than\" function you provide. The elements will be ordered according to\n * whatever you define as the \"less than\" for this element type, so that every\n * element is less than its successor in the list.\n *\n * const sorted = SortedList.from(\n *   [{ id: 4 }, { id: 1 }, { id: 9 }, { id: 4 }],\n *   (a, b) => a.id < b.id)\n * )\n * sorted.add({ id: 5 })\n * sorted.remove({ id: 4 })  // Assuming it's the same obj ref!\n *\n * Array.from(sorted)\n * [{ id: 1 }, { id: 4 }, { id: 5 }, { id: 9 }])\n */\nexport class SortedList<T> {\n  #data: T[];\n  #lt: (a: T, b: T) => boolean;\n\n  private constructor(alreadySortedList: T[], lt: (a: T, b: T) => boolean) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n\n  public static with<T>(lt: (a: T, b: T) => boolean): SortedList<T> {\n    return SortedList.fromAlreadySorted([], lt);\n  }\n\n  public static from<T>(\n    arr: readonly T[],\n    lt: (a: T, b: T) => boolean\n  ): SortedList<T> {\n    const sorted = new SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n\n  public static fromAlreadySorted<T>(\n    alreadySorted: T[],\n    lt: (a: T, b: T) => boolean\n  ): SortedList<T> {\n    return new SortedList(alreadySorted, lt);\n  }\n\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  public clone(): SortedList<T> {\n    return new SortedList(this.#data.slice(), this.#lt);\n  }\n\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value: T): void {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n  }\n\n  /**\n   * Removes all values from the sorted list, making it empty again.\n   * Returns whether the list was mutated or not.\n   */\n  clear(): boolean {\n    const hadData = this.#data.length > 0;\n    this.#data.length = 0;\n    return hadData;\n  }\n\n  /**\n   * Removes the first value matching the predicate.\n   * Returns whether the list was mutated or not.\n   */\n  removeBy(\n    predicate: (item: T) => boolean,\n    limit: number = Number.POSITIVE_INFINITY\n  ): boolean {\n    let deleted = 0;\n    for (let i = 0; i < this.#data.length; i++) {\n      if (predicate(this.#data[i])) {\n        this.#data.splice(i, 1);\n        deleted++;\n        if (deleted >= limit) {\n          break;\n        } else {\n          i--;\n        }\n      }\n    }\n    return deleted > 0;\n  }\n\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   *\n   * Returns whether the list was mutated or not.\n   */\n  remove(value: T): boolean {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  at(index: number): T | undefined {\n    return this.#data[index];\n  }\n\n  get length(): number {\n    return this.#data.length;\n  }\n\n  *filter(predicate: (value: T) => boolean): IterableIterator<T> {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n\n  // XXXX If we keep this, add unit tests. Or remove it.\n  *findAllRight(\n    predicate: (value: T, index: number) => unknown\n  ): IterableIterator<T> {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      const item = this.#data[i];\n      if (predicate(item, i)) {\n        yield item;\n      }\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.#data[Symbol.iterator]();\n  }\n\n  *iterReversed(): IterableIterator<T> {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      yield this.#data[i];\n    }\n  }\n\n  /** Finds the leftmost item that matches the predicate. */\n  find(\n    predicate: (value: T, index: number) => unknown,\n    start?: number\n  ): T | undefined {\n    const idx = this.findIndex(predicate, start);\n    return idx > -1 ? this.#data.at(idx)! : undefined; // eslint-disable-line no-restricted-syntax\n  }\n\n  /** Finds the leftmost index that matches the predicate. */\n  findIndex(\n    predicate: (value: T, index: number) => unknown,\n    start = 0\n  ): number {\n    for (let i = Math.max(0, start); i < this.#data.length; i++) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /** Finds the rightmost item that matches the predicate. */\n  findRight(\n    predicate: (value: T, index: number) => unknown,\n    start?: number\n  ): T | undefined {\n    const idx = this.findIndexRight(predicate, start);\n    return idx > -1 ? this.#data.at(idx)! : undefined; // eslint-disable-line no-restricted-syntax\n  }\n\n  /** Finds the rightmost index that matches the predicate. */\n  findIndexRight(\n    predicate: (value: T, index: number) => unknown,\n    start = this.#data.length - 1\n  ): number {\n    for (let i = Math.min(start, this.#data.length - 1); i >= 0; i--) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  get rawArray(): readonly T[] {\n    return this.#data;\n  }\n}\n", "import { MutableSignal } from \"./lib/signals\";\nimport { SortedList } from \"./lib/SortedList\";\nimport type { ISODateString } from \"./lib/utils\";\nimport type { AiChat, AiChatsQuery } from \"./types/ai\";\n\nexport class AiChatDB {\n  #byId: Map<string, AiChat>; // A map of chat id to chat details\n  #chats: SortedList<Omit<AiChat, \"deletedAt\">>; // Sorted list of non-deleted chats, most recent first\n\n  public readonly signal: MutableSignal<this>;\n\n  constructor() {\n    this.#byId = new Map();\n    this.#chats = SortedList.from<Omit<AiChat, \"deletedAt\">>([], (c1, c2) => {\n      // Sort by 'lastMessageAt' if available, otherwise 'createdAt' (most recent first)\n      const d2 = c2.lastMessageAt ?? c2.createdAt;\n      const d1 = c1.lastMessageAt ?? c1.createdAt;\n      return d2 < d1 ? true : d2 === d1 ? c2.id < c1.id : false;\n    });\n\n    this.signal = new MutableSignal(this);\n  }\n\n  public getEvenIfDeleted(chatId: string): AiChat | undefined {\n    return this.#byId.get(chatId);\n  }\n\n  public markDeleted(chatId: string): void {\n    const chat = this.#byId.get(chatId);\n    if (chat === undefined || chat.deletedAt !== undefined) return;\n    this.upsert({\n      ...chat,\n      deletedAt: new Date().toISOString() as ISODateString,\n    });\n  }\n\n  public upsert(chat: AiChat): void {\n    this.signal.mutate(() => {\n      // If the chat already exists, remove it before deciding whether to add the incoming one\n      const existingThread = this.#byId.get(chat.id);\n      if (existingThread !== undefined) {\n        if (existingThread.deletedAt !== undefined) return false;\n\n        this.#chats.remove(existingThread);\n        this.#byId.delete(existingThread.id);\n      }\n\n      // We only add non-deleted chats to the chat list\n      if (chat.deletedAt === undefined) {\n        this.#chats.add(chat);\n      }\n      this.#byId.set(chat.id, chat);\n      return true;\n    });\n  }\n\n  public findMany(query: AiChatsQuery): Omit<AiChat, \"deletedAt\">[] {\n    return Array.from(\n      this.#chats.filter((chat) => {\n        // If metadata query is not provided, include all chats\n        if (query.metadata === undefined) return true;\n\n        for (const [key, value] of Object.entries(query.metadata)) {\n          // If the value is null, check that the key does not exist in the chat's metadata\n          if (value === null) {\n            if (key in chat.metadata) return false;\n          }\n          // If the metadata key is a string, check for an exact match against the chat's metadata\n          else if (typeof value === \"string\") {\n            if (chat.metadata[key] !== value) return false;\n          }\n          // If the metadata key is an array, ensure all values are present in the chat's metadata array\n          else {\n            const chatValue = chat.metadata[key];\n            if (\n              !Array.isArray(chatValue) ||\n              !value.every((v) => chatValue.includes(v))\n            ) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      })\n    );\n  }\n}\n", "import type {\n  BaseMetadata,\n  CommentData,\n  CommentDataPlain,\n  CommentUserReaction,\n  CommentUserReactionPlain,\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./protocol/Comments\";\nimport type { GroupData, GroupDataPlain } from \"./protocol/Groups\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./protocol/InboxNotifications\";\nimport type {\n  SubscriptionData,\n  SubscriptionDataPlain,\n  SubscriptionDeleteInfo,\n  SubscriptionDeleteInfoPlain,\n  UserSubscriptionData,\n  UserSubscriptionDataPlain,\n} from \"./protocol/Subscriptions\";\n\n/**\n * Converts a plain comment data object (usually returned by the API) to a comment data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment data object (usually returned by the API)\n * @returns The rich comment data object that can be used by the client.\n */\nexport function convertToCommentData(data: CommentDataPlain): CommentData {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : undefined;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt),\n  }));\n\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt,\n    };\n  }\n}\n\n/**\n * Converts a plain thread data object (usually returned by the API) to a thread data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain thread data object (usually returned by the API)\n * @returns The rich thread data object that can be used by the client.\n */\nexport function convertToThreadData<M extends BaseMetadata>(\n  data: ThreadDataPlain<M>\n): ThreadData<M> {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n\n  const comments = data.comments.map((comment) =>\n    convertToCommentData(comment)\n  );\n\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments,\n  };\n}\n\n/**\n * Converts a plain comment reaction object (usually returned by the API) to a comment reaction object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment reaction object (usually returned by the API)\n * @returns The rich comment reaction object that can be used by the client.\n */\nexport function convertToCommentUserReaction(\n  data: CommentUserReactionPlain\n): CommentUserReaction {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt),\n  };\n}\n\n/**\n * Converts a plain inbox notification data object (usually returned by the API) to an inbox notification data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain inbox notification data object (usually returned by the API)\n * @returns The rich inbox notification data object that can be used by the client.\n */\nexport function convertToInboxNotificationData(\n  data: InboxNotificationDataPlain\n): InboxNotificationData {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt),\n    }));\n\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities,\n    };\n  }\n\n  return {\n    ...data,\n    notifiedAt,\n    readAt,\n  };\n}\n\n/**\n * Converts a plain subscription data object (usually returned by the API) to a subscription data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain subscription data object (usually returned by the API)\n * @returns The rich subscription data object that can be used by the client.\n */\nexport function convertToSubscriptionData(\n  data: SubscriptionDataPlain\n): SubscriptionData {\n  const createdAt = new Date(data.createdAt);\n\n  return {\n    ...data,\n    createdAt,\n  };\n}\n\n/**\n * Converts a plain user subscription data object (usually returned by the API) to a user subscription data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain user subscription data object (usually returned by the API)\n * @returns The rich user subscription data object that can be used by the client.\n */\nexport function convertToUserSubscriptionData(\n  data: UserSubscriptionDataPlain\n): UserSubscriptionData {\n  const createdAt = new Date(data.createdAt);\n\n  return {\n    ...data,\n    createdAt,\n  };\n}\n\nexport function convertToThreadDeleteInfo(\n  data: ThreadDeleteInfoPlain\n): ThreadDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToInboxNotificationDeleteInfo(\n  data: InboxNotificationDeleteInfoPlain\n): InboxNotificationDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToSubscriptionDeleteInfo(\n  data: SubscriptionDeleteInfoPlain\n): SubscriptionDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToGroupData(data: GroupDataPlain): GroupData {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const members = data.members.map((member) => ({\n    ...member,\n    addedAt: new Date(member.addedAt),\n  }));\n\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    members,\n  };\n}\n", "/**\n * Helper function that can be used to implement exhaustive switch statements\n * with TypeScript. Example usage:\n *\n *    type Fruit = \"🍎\" | \"🍌\";\n *\n *    switch (fruit) {\n *      case \"🍎\":\n *      case \"🍌\":\n *        return doSomething();\n *\n *      default:\n *        return assertNever(fruit, \"Unknown fruit\");\n *    }\n *\n * If now the Fruit union is extended (i.e. add \"🍒\"), TypeScript will catch\n * this *statically*, rather than at runtime, and force you to handle the\n * 🍒 case.\n */\n// istanbul ignore next\nexport function assertNever(_value: never, errmsg: string): never {\n  throw new Error(errmsg);\n}\n\n/**\n * Asserts that a certain condition holds. If it does not hold, will throw\n * a runtime error in dev mode.\n *\n * In production, nothing is asserted and this acts as a no-op.\n */\nexport function assert(condition: boolean, errmsg: string): asserts condition {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\n\n/**\n * Asserts that a given value is non-nullable. This is similar to TypeScript's\n * `!` operator, but will throw an error at runtime (dev-mode only) indicating\n * an incorrect assumption.\n *\n * Instead of:\n *\n *     foo!.bar\n *\n * Use:\n *\n *     nn(foo).bar\n *\n */\nexport function nn<T>(\n  value: T,\n  errmsg: string = \"Expected value to be non-nullable\"\n): NonNullable<T> {\n  assert(value !== null && value !== undefined, errmsg);\n  return value as NonNullable<T>;\n}\n", "/* eslint-disable rulesdir/console-must-be-fancy */\n\nconst badge =\n  \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nconst bold = \"font-weight:600\";\n\nfunction wrap(\n  method: \"log\" | \"warn\" | \"error\"\n): (message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (message, ...args) =>\n        console[method](\"%cLiveblocks\", badge, message, ...args);\n}\n\n// export const log = wrap(\"log\");\nexport const warn = wrap(\"warn\");\nexport const error = wrap(\"error\");\n\nfunction wrapWithTitle(\n  method: \"log\" | \"warn\" | \"error\"\n): (title: string, message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (title, message, ...args) =>\n        console[method](\n          `%cLiveblocks%c ${title}`,\n          badge,\n          bold,\n          message,\n          ...args\n        );\n}\n\n// export const logWithTitle = wrapWithTitle(\"log\");\nexport const warnWithTitle = wrapWithTitle(\"warn\");\nexport const errorWithTitle = wrapWithTitle(\"error\");\n", "export function isDefined<T>(value: T): value is NonNullable<T> {\n  return value !== null && value !== undefined;\n}\n\nexport function isPlainObject(\n  blob: unknown\n): blob is { [key: string]: unknown } {\n  // Implementation borrowed from pojo decoder, see\n  // https://github.com/nvie/decoders/blob/78849f843193647eb6b5307240387bdcff7161fb/src/lib/objects.js#L10-L41\n  return (\n    blob !== null &&\n    typeof blob === \"object\" &&\n    Object.prototype.toString.call(blob) === \"[object Object]\"\n  );\n}\n\n/**\n * Check if value is of shape { startsWith: string }\n */\nexport function isStartsWithOperator(\n  blob: unknown\n): blob is { startsWith: string } {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\n", "import * as console from \"./fancy-console\";\nimport { isPlainObject } from \"./guards\";\nimport type { JsonObject } from \"./Json\";\nimport { tryParseJson, wait } from \"./utils\";\n\nexport class HttpError extends Error {\n  public response: Response;\n  public details?: JsonObject;\n\n  private constructor(\n    message: string,\n    response: Response,\n    details?: JsonObject\n  ) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n\n  static async fromResponse(response: Response): Promise<HttpError> {\n    // Try to extract `message` and `details` from the response, and\n    // construct the HttpError instance\n    let bodyAsText: string | undefined;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n      // Ignore\n    }\n\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : undefined;\n\n    let bodyAsJsonObject: JsonObject | undefined;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n\n    let message = \"\";\n    message ||=\n      typeof bodyAsJsonObject?.message === \"string\"\n        ? bodyAsJsonObject.message\n        : \"\";\n    message ||=\n      typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === undefined) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n\n    let path: string | undefined;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n      // Ignore\n    }\n    message +=\n      path !== undefined\n        ? ` (got status ${response.status} from ${path})`\n        : ` (got status ${response.status})`;\n\n    const details = bodyAsJsonObject;\n    return new HttpError(message, response, details);\n  }\n\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status(): number {\n    return this.response.status;\n  }\n}\n\nconst DONT_RETRY_4XX = (x: unknown) =>\n  x instanceof HttpError && x.status >= 400 && x.status < 500;\n\n/**\n * Wraps a promise factory. Will create promises until one succeeds. If\n * a promise rejects, it will retry calling the factory for at most `maxTries`\n * times. Between each attempt, it will inject a a backoff delay (in millis)\n * from the given array. If the array contains fewer items then `maxTries`,\n * then the last backoff number will be used indefinitely.\n *\n * If the last attempt is rejected too, the returned promise will fail too.\n *\n * @param promiseFn The promise factory to execute\n * @param maxTries The number of total tries (must be >=1)\n * @param backoff An array of timings to inject between each promise attempt\n * @param shouldStopRetrying An optional function to not auto-retry on certain errors\n */\nexport async function autoRetry<T>(\n  promiseFn: () => Promise<T>,\n  maxTries: number,\n  backoff: number[],\n  shouldStopRetrying: (err: any) => boolean = DONT_RETRY_4XX\n): Promise<T> {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n\n  let attempt = 0;\n\n  while (true) {\n    attempt++;\n\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n\n      if (attempt >= maxTries) {\n        // Fail the entire promise right now\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n\n    // Do another retry\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n\n    console.warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n", "export type ControlledPromise<T> = {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: unknown) => void;\n};\n\n/**\n * Returns a pair of a Promise, and a resolve function that can be passed\n * around to resolve the promise \"from anywhere\".\n *\n * The Promise will remain unresolved, until the resolve function is called.\n * Once the resolve function is called with a value, the Promise will resolve\n * to that value.\n *\n * Calling the resolve function beyond the first time is a no-op.\n */\nexport function controlledPromise<T>(): [\n  promise: Promise<T>,\n  resolve: (value: T) => void,\n  reject: (reason: unknown) => void,\n] {\n  let resolve: ((value: T) => void) | undefined;\n  let reject: ((reason: unknown) => void) | undefined;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  // eslint-disable-next-line no-restricted-syntax\n  return [promise, resolve!, reject!];\n}\n\n/**\n * Drop-in replacement for the ES2024 Promise.withResolvers() API.\n */\nexport function Promise_withResolvers<T>(): ControlledPromise<T> {\n  const [promise, resolve, reject] = controlledPromise<T>();\n  return { promise, resolve, reject };\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\n\nfunction replacer(_key: string, value: unknown) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value)\n    ? Object.keys(value)\n        .sort()\n        .reduce((sorted, key) => {\n          // @ts-expect-error this is fine\n          sorted[key] = value[key];\n          return sorted;\n        }, {})\n    : value;\n}\n\n/**\n * Like JSON.stringify(), but using stable (sorted) object key order, so that\n * it returns the same value for the same keys, no matter their order.\n */\nexport function stableStringify(value: unknown): string {\n  return JSON.stringify(value, replacer);\n}\n\n/**\n * Drop-in replacement for JSON.stringify(), which will log any payload to the\n * console if it could not be stringified somehow.\n */\nexport function stringifyOrLog(value: unknown): string {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    /* eslint-disable rulesdir/console-must-be-fancy */\n    console.error(`Could not stringify: ${(err as Error).message}`);\n    console.error(value);\n    /* eslint-enable rulesdir/console-must-be-fancy */\n    throw err;\n  }\n}\n", "import type { AsyncResult } from \"./AsyncResult\";\nimport { Promise_withResolvers } from \"./controlledPromise\";\nimport type { Callback, UnsubscribeCallback } from \"./EventSource\";\nimport { MutableSignal } from \"./signals\";\nimport { stableStringify } from \"./stringify\";\n\nconst DEFAULT_SIZE = 50;\n\ntype Resolve<T> = (value: T) => void;\ntype Reject = (reason?: unknown) => void;\n\nexport type BatchCallback<O, I> = (\n  inputs: I[]\n) => (O | Error)[] | Promise<(O | Error)[]>;\n\nexport type BatchStore<O, I> = {\n  subscribe: (callback: Callback<void>) => UnsubscribeCallback;\n  enqueue: (input: I) => Promise<void>;\n  setData: (entries: [I, O][]) => void;\n  getItemState: (input: I) => AsyncResult<O> | undefined;\n  getData: (input: I) => O | undefined;\n  invalidate: (inputs?: I[]) => void;\n\n  /**\n   * @internal\n   */\n  readonly batch: Batch<O, I>;\n\n  /**\n   * @internal\n   *\n   * Only for testing.\n   */\n  _cacheKeys: () => string[];\n};\n\ninterface BatchOptions {\n  /**\n   * How many calls to batch together at most.\n   */\n  size?: number;\n\n  /**\n   * How long to wait before flushing the batch.\n   */\n  delay: number;\n}\n\nclass BatchCall<O, I> {\n  readonly input: I;\n  readonly resolve: Resolve<O>;\n  readonly reject: Reject;\n  readonly promise: Promise<O>;\n\n  constructor(input: I) {\n    this.input = input;\n\n    const { promise, resolve, reject } = Promise_withResolvers<O>();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n}\n\n/**\n * Batch calls to a function, either by number of calls or by a maximum delay.\n */\nexport class Batch<O, I> {\n  #queue: BatchCall<O, I>[] = [];\n  #callback: BatchCallback<O, I>;\n  #size: number;\n  #delay: number;\n  #delayTimeoutId?: ReturnType<typeof setTimeout>;\n  public error = false;\n\n  constructor(callback: BatchCallback<O, I>, options: BatchOptions) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n\n  #clearDelayTimeout(): void {\n    if (this.#delayTimeoutId !== undefined) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = undefined;\n    }\n  }\n\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      // If the queue is full, flush it immediately.\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      // If the call is the first in the queue, schedule a flush.\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n\n  async #flush(): Promise<void> {\n    // If the queue is empty, don't call the callback.\n    if (this.#queue.length === 0) {\n      return;\n    }\n\n    // Empty the queue and get its calls.\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n\n    try {\n      // Call the batch callback with the queued arguments.\n      const results = await this.#callback(inputs);\n      this.error = false;\n\n      // Resolve or reject each call.\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error) {\n      this.error = true;\n\n      // Reject all calls if the whole batch errored or was rejected.\n      calls.forEach((call) => {\n        call.reject(error);\n      });\n    }\n  }\n\n  get(input: I): Promise<O> {\n    // Check if there's already an identical call in the queue.\n    const existingCall = this.#queue.find(\n      (call) => stableStringify(call.input) === stableStringify(input)\n    );\n\n    // If an existing call exists, return its promise.\n    if (existingCall) {\n      return existingCall.promise;\n    }\n\n    // If no existing call exists, add the call to the queue and schedule a flush.\n    const call = new BatchCall<O, I>(input);\n    this.#queue.push(call);\n    this.#schedule();\n\n    return call.promise;\n  }\n\n  clear(): void {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n}\n\n/**\n * Create a store around a Batch.\n * Each call will be cached and get its own state in addition to being batched.\n */\nexport function createBatchStore<O, I>(batch: Batch<O, I>): BatchStore<O, I> {\n  const signal = new MutableSignal(new Map<string, AsyncResult<O>>());\n\n  function getCacheKey(args: I): string {\n    return stableStringify(args);\n  }\n\n  function update(\n    entryOrEntries:\n      | {\n          key: string;\n          state: AsyncResult<O>;\n        }\n      | {\n          key: string;\n          state: AsyncResult<O>;\n        }[]\n  ) {\n    signal.mutate((cache) => {\n      if (Array.isArray(entryOrEntries)) {\n        for (const entry of entryOrEntries) {\n          cache.set(entry.key, entry.state);\n        }\n      } else {\n        cache.set(entryOrEntries.key, entryOrEntries.state);\n      }\n    });\n  }\n\n  function invalidate(inputs?: I[]): void {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        // Invalidate the specific calls.\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        // Invalidate all calls.\n        cache.clear();\n      }\n    });\n  }\n\n  async function enqueue(input: I): Promise<void> {\n    const cacheKey = getCacheKey(input);\n\n    // If this call already has a state, return early.\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n\n    try {\n      // Set the state to loading.\n      update({ key: cacheKey, state: { isLoading: true } });\n\n      // Wait for the batch to process this call.\n      const result = await batch.get(input);\n\n      // Set the state to the result.\n      update({ key: cacheKey, state: { isLoading: false, data: result } });\n    } catch (error) {\n      // // TODO: Differentiate whole batch errors from individual errors.\n      // if (batch.error) {\n      //   // If the whole batch errored, clear the state.\n      //   // TODO: Keep track of retries and only clear the state a few times because it will be retried each time.\n      //   //       Also implement exponential backoff to delay retries to avoid hammering `resolveUsers`.\n      //   update(cacheKey, undefined);\n      // } else {\n      //   // Otherwise, keep individual errors to avoid repeatedly loading the same error.\n      //   update(cacheKey, {\n      //     isLoading: false,\n      //     error: error as Error,\n      //   });\n      // }\n\n      // If there was an error (for various reasons), set the state to the error.\n      update({\n        key: cacheKey,\n        state: { isLoading: false, error: error as Error },\n      });\n    }\n  }\n\n  function setData(entries: [I, O][]): void {\n    update(\n      entries.map((entry) => ({\n        key: getCacheKey(entry[0]),\n        state: { isLoading: false, data: entry[1] },\n      }))\n    );\n  }\n\n  function getItemState(input: I): AsyncResult<O> | undefined {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n\n  function getData(input: I): O | undefined {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey)?.data;\n  }\n\n  /** @internal - Only for testing */\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    setData,\n    getItemState,\n    getData,\n    invalidate,\n\n    batch,\n    _cacheKeys,\n  };\n}\n", "export function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n\n  return chunks;\n}\n", "// Inlined version of 3.3.7 of nanoid.js\n// https://www.npmjs.com/package/nanoid/v/3.3.7?activeTab=code\nexport const nanoid = (t = 21): string =>\n  crypto\n    .getRandomValues(new Uint8Array(t))\n    .reduce(\n      (t, e) =>\n        (t +=\n          (e &= 63) < 36\n            ? e.toString(36)\n            : e < 62\n              ? (e - 26).toString(36).toUpperCase()\n              : e < 63\n                ? \"_\"\n                : \"-\"),\n      \"\"\n    );\n", "import { nanoid } from \"./nanoid\";\n\nconst THREAD_ID_PREFIX = \"th\";\nconst COMMENT_ID_PREFIX = \"cm\";\nconst COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nconst INBOX_NOTIFICATION_ID_PREFIX = \"in\";\n\nfunction createOptimisticId(prefix: string): string {\n  return `${prefix}_${nanoid()}`;\n}\n\nexport function createThreadId(): string {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\n\nexport function createCommentId(): string {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\n\nexport function createCommentAttachmentId(): string {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\n\nexport function createInboxNotificationId(): string {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n", "import { raise } from \"./utils\";\n\n/**\n * Like ES6 map, but takes a default (factory) function which will be used\n * to create entries for missing keys on the fly.\n *\n * Useful for code like:\n *\n *   const map = new DefaultMap(() => []);\n *   map.getOrCreate('foo').push('hello');\n *   map.getOrCreate('foo').push('world');\n *   map.getOrCreate('foo')\n *   // ['hello', 'world']\n *\n */\nexport class DefaultMap<K, V> extends Map<K, V> {\n  #defaultFn?: (key: K) => V;\n\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(\n    defaultFn?: (key: K) => V,\n    entries?: readonly (readonly [K, V])[] | null\n  ) {\n    super(entries);\n    this.#defaultFn = defaultFn;\n  }\n\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key: K, defaultFn?: (key: K) => V): V {\n    if (super.has(key)) {\n      // eslint-disable-next-line no-restricted-syntax\n      return super.get(key)!;\n    } else {\n      const fn =\n        defaultFn ??\n        this.#defaultFn ??\n        raise(\"DefaultMap used without a factory function\");\n\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n}\n", "import { isPlainObject, isStartsWithOperator } from \"./guards\";\n\n/**\n * Converts an object to a query string\n * Example:\n * ```ts\n * const query = objectToQuery({\n *   resolved: true,\n *   metadata: {\n *     status: \"open\",\n *     priority: 3,\n *     org: {\n *       startsWith: \"liveblocks:\",\n *     },\n *   },\n * });\n *\n * console.log(query);\n * // resolved:true AND metadata[\"status\"]:open AND metadata[\"priority\"]:3 AND metadata[\"org\"]^\"liveblocks:\"\n * ```\n */\ntype SimpleFilterValue = string | number | boolean | null;\ntype OperatorFilterValue = { startsWith: string };\n\ntype FilterValue = SimpleFilterValue | OperatorFilterValue;\n\ntype Filter = NumberFilter | StringFilter | BooleanFilter | NullFilter;\n\ntype NumberFilter = {\n  key: string;\n  operator: \":\";\n  value: number;\n};\n\ntype StringFilter = {\n  key: string;\n  operator: \":\" | \"^\";\n  value: string;\n};\n\ntype BooleanFilter = {\n  key: string;\n  operator: \":\";\n  value: boolean;\n};\n\ntype NullFilter = {\n  key: string;\n  operator: \":\";\n  value: null;\n};\n\n/**\n * Converts an object to a query string\n * @example\n * ```ts\n * const query = objectToQuery({\n *  metadata: {\n *    status: \"open\",\n *    priority: 3,\n *    org: {\n *      startsWith: \"liveblocks:\",\n *    },\n *  },\n * });\n * console.log(query);\n * // metadata[\"status\"]:\"open\" AND metadata[\"priority\"]:3 AND metadata[\"org\"]^\"liveblocks:\"\n * ```\n * @example\n * ```ts\n * const query = objectToQuery({\n *  resolved: true,\n *  roomId: {\n *   startsWith: \"engineering:\",\n *  },\n * });\n * console.log(query);\n * // resolved:true AND roomId^\"engineering:\"\n * ```\n *\n */\n\nconst identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\nexport function objectToQuery(obj: {\n  [key: string]:\n    | FilterValue\n    | { [key: string]: FilterValue | undefined }\n    | undefined;\n}): string {\n  let filterList: Filter[] = [];\n  const entries = Object.entries(obj);\n\n  const keyValuePairs: [string, string | number | boolean | null][] = [];\n  const keyValuePairsWithOperator: [string, Record<\"startsWith\", string>][] =\n    [];\n  const indexedKeys: [string, Record<string, FilterValue | undefined>][] = [];\n\n  entries.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator),\n  ];\n\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs: [string, SimpleFilterValue][] = [];\n    const nKeyValuePairsWithOperator: [string, OperatorFilterValue][] = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue,\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator),\n    ];\n  });\n\n  return filterList\n    .map(({ key, operator, value }) => `${key}${operator}${quote(value)}`)\n    .join(\" \");\n}\n\nconst getFiltersFromKeyValuePairs = (\n  keyValuePairs: [string, string | number | boolean | null][]\n): Filter[] => {\n  const filters: Filter[] = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value,\n    });\n  });\n\n  return filters;\n};\n\nconst getFiltersFromKeyValuePairsWithOperator = (\n  keyValuePairsWithOperator: [string, { startsWith: string }][]\n): Filter[] => {\n  const filters: Filter[] = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith,\n      });\n    }\n  });\n\n  return filters;\n};\n\nconst isSimpleValue = (value: unknown) => {\n  return (\n    typeof value === \"string\" ||\n    typeof value === \"number\" ||\n    typeof value === \"boolean\" ||\n    value === null\n  );\n};\n\nconst formatFilterKey = (key: string, nestedKey?: string) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\n\nconst isStringEmpty = (value: string) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n/**\n * Quotes and escapes a string. Prefer to use single quotes when possible, but\n * falls back to JSON.stringify() (which uses double-quotes) when necessary.\n */\nexport function quote(input: unknown): string {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  if (result.includes(\"'\")) {\n    return result;\n  }\n\n  // See if we can turn this string into a single-quoted string, because those\n  // generally are more readable in URLs\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n", "import type { Brand } from \"./utils\";\n\nconst PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst TRAILING_SLASH_URL_REGEX = /\\/(?:(?:\\?|#).*)?$/;\n\nexport type QueryParams =\n  | Record<string, string | number | null | undefined>\n  | URLSearchParams;\n\n/**\n * Safely but conveniently build a URLSearchParams instance from a given\n * dictionary of values. For example:\n *\n *   {\n *     \"foo\": \"bar+qux/baz\",\n *     \"empty\": \"\",\n *     \"n\": 42,\n *     \"nope\": undefined,\n *     \"alsonope\": null,\n *   }\n *\n * Will produce a value that will get serialized as\n * `foo=bar%2Bqux%2Fbaz&empty=&n=42`.\n *\n * Notice how the number is converted to its string representation\n * automatically and the `null`/`undefined` values simply don't end up in the\n * URL.\n */\nfunction toURLSearchParams(\n  params: Record<string, string | number | null | undefined>\n): URLSearchParams {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== undefined && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\n\n/**\n * Concatenates a path to an existing URL.\n */\nexport function urljoin(\n  baseUrl: string | URL,\n  path: string,\n  params?: QueryParams\n): string {\n  // First, sanitize by removing user/passwd/search/hash parts from the URL\n  const url = new URL(path, baseUrl);\n  if (params !== undefined) {\n    url.search = (\n      params instanceof URLSearchParams ? params : toURLSearchParams(params)\n    ).toString();\n  }\n  return url.toString();\n}\n\n/**\n * A string that is guaranteed to be URL safe (where all arguments are properly\n * encoded), only obtainable as the result of using `url` template strings.\n */\nexport type URLSafeString = Brand<string, \"URLSafeString\">;\n\n/**\n * Builds a URL where each \"hole\" in the template string will automatically be\n * encodeURIComponent()-escaped, so it's impossible to build invalid URLs.\n */\nexport function url(\n  strings: TemplateStringsArray,\n  ...values: string[]\n): URLSafeString {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  ) as URLSafeString;\n}\n\n/**\n * Sanitize a URL (normalize www URLs, handle relative URLs, prevent XSS attacks, etc.)\n *\n * Accepted URLs:\n * - Absolute URLs with an http or https protocol (e.g. https://liveblocks.io)\n * - Absolute URLs with a `www` prefix (e.g. www.liveblocks.io)\n * - Relative URLs (e.g. /path/to/page)\n * - Hash-only URLs (e.g. #hash)\n *\n * The presence/absence of trailing slashes is preserved.\n * Rejected URLs are returned as `null`.\n */\nexport function sanitizeUrl(url: string): string | null {\n  // If the URL starts with \"www.\", normalize it as an HTTPS URL\n  if (url.startsWith(\"www.\")) {\n    url = \"https://\" + url;\n  }\n\n  // If the URL is an empty hash, return it as is.\n  if (url === \"#\") {\n    return url;\n  }\n\n  try {\n    const isAbsolute = ABSOLUTE_URL_REGEX.test(url);\n    const urlObject = new URL(\n      url,\n      isAbsolute ? undefined : PLACEHOLDER_BASE_URL\n    );\n\n    if (urlObject.protocol !== \"http:\" && urlObject.protocol !== \"https:\") {\n      return null;\n    }\n\n    const hasTrailingSlash = TRAILING_SLASH_URL_REGEX.test(url);\n\n    // Instead of using URL.toString(), we rebuild the URL manually\n    // to preserve the presence/absence of trailing slashes.\n    const sanitizedUrl =\n      // 1. Origin, only for absolute URLs\n      (isAbsolute ? urlObject.origin : \"\") +\n      // 2. Pathname, with a trailing slash if the original URL had one\n      (urlObject.pathname === \"/\"\n        ? // 2.a. Domain-only URLs, they always have their pathname set to \"/\"\n          hasTrailingSlash\n          ? \"/\"\n          : \"\"\n        : // 2.b. URLs with a path\n          hasTrailingSlash && !urlObject.pathname.endsWith(\"/\")\n          ? urlObject.pathname + \"/\"\n          : urlObject.pathname) +\n      // 3. Search params\n      urlObject.search +\n      // 4. Hash\n      urlObject.hash;\n\n    return sanitizedUrl !== \"\" ? sanitizedUrl : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Construct a URL with optional parameters and hash.\n */\nexport function generateUrl(\n  url: string,\n  params?: Record<string, string | number | undefined>,\n  hash?: string\n): string {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(url);\n  const urlObject = new URL(url, isAbsolute ? undefined : PLACEHOLDER_BASE_URL);\n\n  if (params !== undefined) {\n    for (const [param, value] of Object.entries(params)) {\n      if (value) {\n        urlObject.searchParams.set(param, String(value));\n      }\n    }\n  }\n\n  // Only add the new hash if the URL does not already have one\n  if (!urlObject.hash && hash !== undefined) {\n    urlObject.hash = `#${hash}`;\n  }\n\n  return isAbsolute\n    ? urlObject.href\n    : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\nexport function isUrl(string: string): boolean {\n  try {\n    new URL(string);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n", "import type { AuthManager, AuthValue } from \"./auth-manager\";\nimport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToGroupData,\n  convertToInboxNotificationData,\n  convertToInboxNotificationDeleteInfo,\n  convertToSubscriptionData,\n  convertToSubscriptionDeleteInfo,\n  convertToThreadData,\n  convertToThreadDeleteInfo,\n} from \"./convert-plain-data\";\nimport { assertNever } from \"./lib/assert\";\nimport { autoRetry, HttpError } from \"./lib/autoRetry\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Batch, createBatchStore } from \"./lib/batch\";\nimport { chunk } from \"./lib/chunk\";\nimport { createCommentId, createThreadId } from \"./lib/createIds\";\nimport type { DateToString } from \"./lib/DateToString\";\nimport { DefaultMap } from \"./lib/DefaultMap\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { objectToQuery } from \"./lib/objectToQuery\";\nimport type { Signal } from \"./lib/signals\";\nimport { stringifyOrLog as stringify } from \"./lib/stringify\";\nimport type { QueryParams, URLSafeString } from \"./lib/url\";\nimport { url, urljoin } from \"./lib/url\";\nimport { raise } from \"./lib/utils\";\nimport type {\n  ContextualPromptContext,\n  ContextualPromptResponse,\n} from \"./protocol/Ai\";\nimport type { Permission } from \"./protocol/AuthToken\";\nimport type { ClientMsg } from \"./protocol/ClientMsg\";\nimport type {\n  BaseMetadata,\n  CommentAttachment,\n  CommentBody,\n  CommentData,\n  CommentDataPlain,\n  CommentLocalAttachment,\n  CommentUserReaction,\n  CommentUserReactionPlain,\n  QueryMetadata,\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./protocol/Comments\";\nimport type { GroupData, GroupDataPlain } from \"./protocol/Groups\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./protocol/InboxNotifications\";\nimport type { MentionData } from \"./protocol/MentionData\";\nimport type {\n  NotificationSettingsPlain,\n  PartialNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nimport type { RoomSubscriptionSettings } from \"./protocol/RoomSubscriptionSettings\";\nimport type { IdTuple, SerializedCrdt } from \"./protocol/SerializedCrdt\";\nimport type {\n  SubscriptionData,\n  SubscriptionDataPlain,\n  SubscriptionDeleteInfo,\n  SubscriptionDeleteInfoPlain,\n} from \"./protocol/Subscriptions\";\nimport type { HistoryVersion } from \"./protocol/VersionHistory\";\nimport type { TextEditorType } from \"./types/Others\";\nimport type { Patchable } from \"./types/Patchable\";\nimport { PKG_VERSION } from \"./version\";\n\nexport interface RoomHttpApi<M extends BaseMetadata> {\n  getThreads(options: {\n    roomId: string;\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }): Promise<{\n    threads: ThreadData<M>[];\n    inboxNotifications: InboxNotificationData[];\n    subscriptions: SubscriptionData[];\n    requestedAt: Date;\n    nextCursor: string | null;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  getThreadsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  createThread({\n    roomId,\n    metadata,\n    body,\n    commentId,\n    threadId,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<ThreadData<M>>;\n\n  getThread(options: { roomId: string; threadId: string }): Promise<{\n    thread?: ThreadData<M>;\n    inboxNotification?: InboxNotificationData;\n    subscription?: SubscriptionData;\n  }>;\n\n  deleteThread({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  editThreadMetadata({\n    roomId,\n    metadata,\n    threadId,\n  }: {\n    roomId: string;\n    metadata: Patchable<M>;\n    threadId: string;\n  }): Promise<M>;\n\n  createComment({\n    roomId,\n    threadId,\n    commentId,\n    body,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  editComment({\n    roomId,\n    threadId,\n    commentId,\n    body,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  deleteComment({\n    roomId,\n    threadId,\n    commentId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  addReaction({\n    roomId,\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<CommentUserReaction>;\n\n  removeReaction({\n    roomId,\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  markThreadAsResolved({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  markThreadAsUnresolved({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  subscribeToThread({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<SubscriptionData>;\n\n  unsubscribeFromThread({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  // Notifications\n  markRoomInboxNotificationAsRead({\n    roomId,\n    inboxNotificationId,\n  }: {\n    roomId: string;\n    inboxNotificationId: string;\n  }): Promise<string>;\n\n  getSubscriptionSettings({\n    roomId,\n    signal,\n  }: {\n    roomId: string;\n    signal?: AbortSignal;\n  }): Promise<RoomSubscriptionSettings>;\n\n  updateSubscriptionSettings({\n    roomId,\n    settings,\n  }: {\n    roomId: string;\n    settings: Partial<RoomSubscriptionSettings>;\n  }): Promise<RoomSubscriptionSettings>;\n\n  // Attachments\n  getAttachmentUrl(options: {\n    roomId: string;\n    attachmentId: string;\n  }): Promise<string>;\n\n  uploadAttachment({\n    roomId,\n    attachment,\n    signal,\n  }: {\n    roomId: string;\n    attachment: CommentLocalAttachment;\n    signal?: AbortSignal;\n  }): Promise<CommentAttachment>;\n\n  getOrCreateAttachmentUrlsStore(roomId: string): BatchStore<string, string>;\n\n  uploadChatAttachment({\n    chatId,\n    attachment,\n    signal,\n  }: {\n    chatId: string;\n    attachment: { id: string; file: File };\n    signal?: AbortSignal;\n  }): Promise<void>;\n\n  getOrCreateChatAttachmentUrlsStore(\n    chatId: string\n  ): BatchStore<string, string>;\n  getChatAttachmentUrl(options: { attachmentId: string }): Promise<string>;\n\n  // Text editor\n  createTextMention({\n    roomId,\n    mentionId,\n    mention,\n  }: {\n    roomId: string;\n    mentionId: string;\n    mention: MentionData;\n  }): Promise<void>;\n\n  deleteTextMention({\n    roomId,\n    mentionId,\n  }: {\n    roomId: string;\n    mentionId: string;\n  }): Promise<void>;\n\n  getTextVersion({\n    roomId,\n    versionId,\n  }: {\n    roomId: string;\n    versionId: string;\n  }): Promise<Response>;\n\n  createTextVersion({ roomId }: { roomId: string }): Promise<void>;\n\n  reportTextEditor({\n    roomId,\n    type,\n    rootKey,\n  }: {\n    roomId: string;\n    type: TextEditorType;\n    rootKey: string;\n  }): Promise<void>;\n\n  listTextVersions({ roomId }: { roomId: string }): Promise<{\n    versions: {\n      type: \"historyVersion\";\n      kind: \"yjs\";\n      id: string;\n      authors: {\n        id: string;\n      }[];\n      createdAt: Date;\n    }[];\n    requestedAt: Date;\n  }>;\n\n  listTextVersionsSince({\n    roomId,\n    since,\n    signal,\n  }: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    versions: {\n      type: \"historyVersion\";\n      kind: \"yjs\";\n      id: string;\n      authors: {\n        id: string;\n      }[];\n      createdAt: Date;\n    }[];\n    requestedAt: Date;\n  }>;\n\n  streamStorage(options: {\n    roomId: string;\n  }): Promise<IdTuple<SerializedCrdt>[]>;\n\n  sendMessages<P extends JsonObject, E extends Json>(options: {\n    roomId: string;\n    nonce: string | undefined;\n    messages: ClientMsg<P, E>[];\n  }): Promise<Response>;\n\n  executeContextualPrompt({\n    roomId,\n    prompt,\n    context,\n    signal,\n  }: {\n    roomId: string;\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }): Promise<string>;\n}\n\nexport interface NotificationHttpApi<M extends BaseMetadata> {\n  getInboxNotifications(options?: {\n    cursor?: string;\n    query?: { roomId?: string; kind?: string };\n  }): Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<M>[];\n    subscriptions: SubscriptionData[];\n    nextCursor: string | null;\n    requestedAt: Date;\n  }>;\n\n  getInboxNotificationsSince(options: {\n    since: Date;\n    query?: { roomId?: string; kind?: string };\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n  }>;\n\n  getUnreadInboxNotificationsCount(): Promise<number>;\n\n  markAllInboxNotificationsAsRead(): Promise<void>;\n\n  markInboxNotificationAsRead(inboxNotificationId: string): Promise<void>;\n\n  deleteAllInboxNotifications(): Promise<void>;\n\n  deleteInboxNotification(inboxNotificationId: string): Promise<void>;\n\n  getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettingsPlain>;\n\n  updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettingsPlain>;\n}\n\nexport interface LiveblocksHttpApi<M extends BaseMetadata>\n  extends RoomHttpApi<M>,\n    NotificationHttpApi<M> {\n  getUserThreads_experimental(options?: {\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }): Promise<{\n    threads: ThreadData<M>[];\n    inboxNotifications: InboxNotificationData[];\n    subscriptions: SubscriptionData[];\n    nextCursor: string | null;\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  getUserThreadsSince_experimental(options: {\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  groupsStore: BatchStore<GroupData | undefined, string>;\n\n  getGroup(groupId: string): Promise<GroupData | undefined>;\n}\n\nexport function createApiClient<M extends BaseMetadata>({\n  baseUrl,\n  authManager,\n  currentUserId,\n  fetchPolyfill,\n}: {\n  baseUrl: string;\n  authManager: AuthManager;\n  currentUserId: Signal<string | undefined>;\n  fetchPolyfill: typeof fetch;\n}): LiveblocksHttpApi<M> {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n\n  /* -------------------------------------------------------------------------------------------------\n   * Threads (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getThreadsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const result = await httpClient.get<{\n      data: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        since: options.since.toISOString(),\n      },\n      { signal: options.signal }\n    );\n\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      subscriptions: {\n        updated: result.subscriptions.map(convertToSubscriptionData),\n        deleted: result.deletedSubscriptions.map(\n          convertToSubscriptionDeleteInfo\n        ),\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints,\n    };\n  }\n\n  async function getThreads(options: {\n    roomId: string;\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }) {\n    let query: string | undefined;\n\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const PAGE_SIZE = 50;\n\n    try {\n      const result = await httpClient.get<{\n        data: ThreadDataPlain<M>[];\n        inboxNotifications: InboxNotificationDataPlain[];\n        subscriptions: SubscriptionDataPlain[];\n        deletedThreads: ThreadDeleteInfoPlain[];\n        deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n        deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n        meta: {\n          requestedAt: string;\n          nextCursor: string | null;\n          permissionHints: Record<string, Permission[]>;\n        };\n      }>(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId,\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE,\n        }\n      );\n\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        subscriptions: result.subscriptions.map(convertToSubscriptionData),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints,\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        // If the room does (not) yet exist, the response will be a 404 error\n        // response which we'll interpret as an empty list of threads.\n        return {\n          threads: [],\n          inboxNotifications: [],\n          subscriptions: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1000),\n          permissionHints: {},\n        };\n      }\n\n      throw err;\n    }\n  }\n\n  async function createThread(options: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n\n    const thread = await httpClient.post<ThreadDataPlain<M>>(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          attachmentIds: options.attachmentIds,\n        },\n        metadata: options.metadata,\n      }\n    );\n\n    return convertToThreadData<M>(thread);\n  }\n\n  async function deleteThread(options: { roomId: string; threadId: string }) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function getThread(options: { roomId: string; threadId: string }) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    if (response.ok) {\n      const json = (await response.json()) as {\n        thread: ThreadDataPlain<M>;\n        inboxNotification?: InboxNotificationDataPlain;\n        subscription?: SubscriptionDataPlain;\n      };\n\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification\n          ? convertToInboxNotificationData(json.inboxNotification)\n          : undefined,\n        subscription: json.subscription\n          ? convertToSubscriptionData(json.subscription)\n          : undefined,\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: undefined,\n        inboxNotification: undefined,\n        subscription: undefined,\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n\n  async function editThreadMetadata(options: {\n    roomId: string;\n    metadata: Patchable<M>;\n    threadId: string;\n  }) {\n    return await httpClient.post<M>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      options.metadata\n    );\n  }\n\n  async function createComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post<CommentDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        attachmentIds: options.attachmentIds,\n      }\n    );\n    return convertToCommentData(comment);\n  }\n\n  async function editComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    const comment = await httpClient.post<CommentDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds,\n      }\n    );\n\n    return convertToCommentData(comment);\n  }\n\n  async function deleteComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function addReaction(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const reaction = await httpClient.post<CommentUserReactionPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      { emoji: options.emoji }\n    );\n\n    return convertToCommentUserReaction(reaction);\n  }\n\n  async function removeReaction(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    await httpClient.delete<CommentDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function markThreadAsResolved(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function markThreadAsUnresolved(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function subscribeToThread(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    const subscription = await httpClient.post<SubscriptionDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/subscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    return convertToSubscriptionData(subscription);\n  }\n\n  async function unsubscribeFromThread(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/unsubscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Attachments (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function uploadAttachment(options: {\n    roomId: string;\n    attachment: CommentLocalAttachment;\n    signal?: AbortSignal;\n  }): Promise<CommentAttachment> {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n\n    const abortError = abortSignal\n      ? new DOMException(\n          `Upload of attachment ${options.attachment.id} was aborted.`,\n          \"AbortError\"\n        )\n      : undefined;\n\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n\n    const handleRetryError = (err: Error) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n\n      return false;\n    };\n\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024; // 5 MB\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,\n    ];\n\n    function splitFileIntoParts(file: File) {\n      const parts: { partNumber: number; part: Blob }[] = [];\n\n      let start = 0;\n\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end),\n        });\n\n        start = end;\n      }\n\n      return parts;\n    }\n\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      // If the file is small enough, upload it in a single request\n      return autoRetry(\n        async () =>\n          httpClient.putBlob<CommentAttachment>(\n            url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            attachment.file,\n            { fileSize: attachment.size },\n            { signal: abortSignal }\n          ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      // Otherwise, upload it in multiple parts\n      let uploadId: string | undefined;\n      const uploadedParts: {\n        etag: string;\n        partNumber: number;\n      }[] = [];\n\n      // Create a multi-part upload\n      const createMultiPartUpload = await autoRetry(\n        async () =>\n          httpClient.post<{\n            uploadId: string;\n            key: string;\n          }>(\n            url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            undefined,\n            { signal: abortSignal },\n            { fileSize: attachment.size }\n          ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n\n        const parts = splitFileIntoParts(attachment.file);\n\n        // Check if the upload was aborted\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n\n        const batches = chunk(parts, 5);\n\n        // Batches are uploaded one after the other\n        for (const parts of batches) {\n          const uploadedPartsPromises: Promise<{\n            partNumber: number;\n            etag: string;\n          }>[] = [];\n\n          for (const { part, partNumber } of parts) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () =>\n                  httpClient.putBlob<{\n                    partNumber: number;\n                    etag: string;\n                  }>(\n                    url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                    await authManager.getAuthValue({\n                      requestedScope: \"comments:read\",\n                      roomId,\n                    }),\n                    part,\n                    undefined,\n                    { signal: abortSignal }\n                  ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n\n          // Parts are uploaded in parallel\n          uploadedParts.push(...(await Promise.all(uploadedPartsPromises)));\n        }\n\n        // Check if the upload was aborted\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n\n        return httpClient.post<CommentAttachment>(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId,\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error) {\n        if (\n          uploadId &&\n          (error as Error)?.name &&\n          ((error as Error).name === \"AbortError\" ||\n            (error as Error).name === \"TimeoutError\")\n        ) {\n          try {\n            // Abort the multi-part upload if it was created\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId,\n              })\n            );\n          } catch (error) {\n            // Ignore the error, we are probably offline\n          }\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap<\n    string,\n    BatchStore<string, string>\n  >((roomId) => {\n    const batch = new Batch<string, string>(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post<{\n          urls: (string | null)[];\n        }>(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId,\n          }),\n          { attachmentIds }\n        );\n\n        return urls.map(\n          (url) =>\n            url ??\n            new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch);\n  });\n\n  function getOrCreateAttachmentUrlsStore(\n    roomId: string\n  ): BatchStore<string, string> {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n\n  function getAttachmentUrl(options: { roomId: string; attachmentId: string }) {\n    const batch = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch.get(options.attachmentId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Attachments (Chat level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function uploadChatAttachment(options: {\n    chatId: string;\n    attachment: {\n      id: string;\n      file: File;\n    };\n    signal?: AbortSignal;\n  }): Promise<void> {\n    const { chatId, attachment, signal } = options;\n    const userId = currentUserId.get();\n    if (userId === undefined) {\n      throw new Error(\"Attachment upload requires an authenticated user.\");\n    }\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024; // 5 MB\n\n    if (options.attachment.file.size <= ATTACHMENT_PART_SIZE) {\n      await httpClient.putBlob(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        attachment.file,\n        { fileSize: attachment.file.size },\n        { signal }\n      );\n    } else {\n      const multipartUpload = await httpClient.post<{\n        uploadId: string;\n        key: string;\n      }>(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        undefined,\n        { signal },\n        { fileSize: attachment.file.size }\n      );\n\n      try {\n        const uploadedParts: { etag: string; number: number }[] = [];\n\n        const parts: { number: number; part: Blob }[] = [];\n        let start = 0;\n        while (start < attachment.file.size) {\n          const end = Math.min(\n            start + ATTACHMENT_PART_SIZE,\n            attachment.file.size\n          );\n          parts.push({\n            number: parts.length + 1,\n            part: attachment.file.slice(start, end),\n          });\n          start = end;\n        }\n\n        uploadedParts.push(\n          ...(await Promise.all(\n            parts.map(async ({ number, part }) => {\n              return await httpClient.putBlob<{\n                etag: string;\n                number: number;\n              }>(\n                url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/${String(number)}`,\n                await authManager.getAuthValue({\n                  requestedScope: \"comments:read\",\n                }),\n                part,\n                undefined,\n                { signal }\n              );\n            })\n          ))\n        );\n\n        await httpClient.post(\n          url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/complete`,\n          await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n          { parts: uploadedParts.sort((a, b) => a.number - b.number) },\n          { signal }\n        );\n      } catch (err) {\n        try {\n          await httpClient.delete(\n            url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}`,\n            await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n          );\n        } catch (err) {\n          // Ignore the error, we are probably offline\n        }\n        throw err;\n      }\n    }\n  }\n\n  const attachmentUrlsBatchStoresByChat = new DefaultMap<\n    string,\n    BatchStore<string, string>\n  >((chatId) => {\n    const batch = new Batch<string, string>(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post<{\n          urls: (string | null)[];\n        }>(\n          url`/v2/c/chats/${chatId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n          }),\n          { attachmentIds }\n        );\n\n        return urls.map(\n          (url) =>\n            url ??\n            new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch);\n  });\n\n  function getOrCreateChatAttachmentUrlsStore(\n    chatId: string\n  ): BatchStore<string, string> {\n    return attachmentUrlsBatchStoresByChat.getOrCreate(chatId);\n  }\n\n  function getChatAttachmentUrl(options: {\n    chatId: string;\n    attachmentId: string;\n  }) {\n    const batch = getOrCreateChatAttachmentUrlsStore(options.chatId).batch;\n    return batch.get(options.attachmentId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Notifications (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getSubscriptionSettings(options: {\n    roomId: string;\n    signal?: AbortSignal;\n  }): Promise<RoomSubscriptionSettings> {\n    return httpClient.get<RoomSubscriptionSettings>(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      undefined,\n      {\n        signal: options.signal,\n      }\n    );\n  }\n\n  async function updateSubscriptionSettings(options: {\n    roomId: string;\n    settings: Partial<RoomSubscriptionSettings>;\n  }): Promise<RoomSubscriptionSettings> {\n    return httpClient.post<RoomSubscriptionSettings>(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      options.settings\n    );\n  }\n\n  const markAsReadBatchesByRoom = new DefaultMap<string, Batch<string, string>>(\n    (roomId) =>\n      new Batch<string, string>(\n        async (batchedInboxNotificationIds) => {\n          const inboxNotificationIds = batchedInboxNotificationIds.flat();\n          // This method (and the following batch handling) isn't the same as the one in\n          // src/notifications.ts, this one is room-based: /v2/c/rooms/<roomId>/inbox-notifications/read.\n          //\n          // The reason for this is that unlike the room-based Comments ones, the Notifications endpoints\n          // don't work with a public key. Since `markThreadAsRead` needs to mark the related inbox notifications\n          // as read, this room-based method is necessary to keep all Comments features working with a public key.\n          await httpClient.post(\n            url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            { inboxNotificationIds }\n          );\n          return inboxNotificationIds;\n        },\n        { delay: 50 }\n      )\n  );\n\n  async function markRoomInboxNotificationAsRead(options: {\n    roomId: string;\n    inboxNotificationId: string;\n  }) {\n    const batch = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch.get(options.inboxNotificationId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Text editor (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function createTextMention(options: {\n    roomId: string;\n    mentionId: string;\n    mention: MentionData;\n  }) {\n    if (options.mention.kind !== \"user\" && options.mention.kind !== \"group\") {\n      return assertNever(options.mention, \"Unexpected mention kind\");\n    }\n\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        userId:\n          options.mention.kind === \"user\" ? options.mention.id : undefined,\n        groupId:\n          options.mention.kind === \"group\" ? options.mention.id : undefined,\n        userIds:\n          options.mention.kind === \"group\"\n            ? options.mention.userIds\n            : undefined,\n        mentionId: options.mentionId,\n      }\n    );\n  }\n\n  async function deleteTextMention(options: {\n    roomId: string;\n    mentionId: string;\n  }) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function getTextVersion(options: {\n    roomId: string;\n    versionId: string;\n  }) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function createTextVersion(options: { roomId: string }) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function reportTextEditor(options: {\n    roomId: string;\n    type: TextEditorType;\n    rootKey: string;\n  }) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey,\n      }\n    );\n  }\n\n  async function executeContextualPrompt(options: {\n    roomId: string;\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }): Promise<string> {\n    const result = await httpClient.post<{\n      content: { type: \"text\"; text: string }[];\n    }>(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId,\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection,\n        },\n        previous: options.previous,\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n\n  async function listTextVersions(options: { roomId: string }) {\n    const result = await httpClient.get<{\n      versions: DateToString<HistoryVersion>[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version,\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt),\n    };\n  }\n\n  async function listTextVersionsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const result = await httpClient.get<{\n      versions: DateToString<HistoryVersion>[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version,\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt),\n    };\n  }\n\n  async function streamStorage(options: { roomId: string }) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId,\n      })\n    );\n    return (await result.json()) as IdTuple<SerializedCrdt>[];\n  }\n\n  async function sendMessages<P extends JsonObject, E extends Json>(options: {\n    roomId: string;\n    nonce: string | undefined;\n    messages: ClientMsg<P, E>[];\n  }) {\n    return httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/send-message`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId,\n      }),\n      {\n        nonce: options.nonce,\n        messages: options.messages,\n      }\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Inbox notifications (User-level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getInboxNotifications(options?: {\n    cursor?: string;\n    query?: { roomId?: string; kind?: string };\n  }) {\n    const PAGE_SIZE = 50;\n\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      groups: GroupDataPlain[];\n      meta: {\n        requestedAt: string;\n        nextCursor: string | null;\n      };\n    }>(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE,\n        query,\n      }\n    );\n\n    const groups = json.groups.map(convertToGroupData);\n\n    // Instead of being returned publicly, the user's groups are put in\n    // a separate store which is also used for on-demand fetching.\n    groupsStore.setData(groups.map((group) => [group.id, group]));\n\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n    };\n  }\n\n  async function getInboxNotificationsSince(options: {\n    since: Date;\n    query?: { roomId?: string; kind?: string };\n    signal?: AbortSignal;\n  }) {\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString(), query },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo),\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n    };\n  }\n\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get<{ count: number }>(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n    return count;\n  }\n\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\",\n      }\n    );\n  }\n\n  async function markInboxNotificationsAsRead(inboxNotificationIds: string[]) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds,\n      }\n    );\n  }\n\n  const batchedMarkInboxNotificationsAsRead = new Batch<string, string>(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n\n  async function deleteInboxNotification(inboxNotificationId: string) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Notifications settings (Project level)\n   * -------------------------------------------------------------------------------------------------\n   */\n  async function getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettingsPlain> {\n    return httpClient.get<NotificationSettingsPlain>(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      undefined,\n      { signal: options?.signal }\n    );\n  }\n\n  async function updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettingsPlain> {\n    return httpClient.post<NotificationSettingsPlain>(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * User threads\n   * -------------------------------------------------------------------------------------------------\n   */\n  async function getUserThreads_experimental(options?: {\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<M>>;\n    };\n  }) {\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const PAGE_SIZE = 50;\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        nextCursor: string | null;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE,\n      }\n    );\n\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints,\n    };\n  }\n\n  async function getUserThreadsSince_experimental<\n    M extends BaseMetadata,\n  >(options: { since: Date; signal?: AbortSignal }) {\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<M>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo),\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints,\n    };\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Groups\n   * -------------------------------------------------------------------------------------------------\n   */\n\n  const batchedGetGroups = new Batch(\n    async (batchedGroupIds: string[]) => {\n      const groupIds = batchedGroupIds.flat();\n      const { groups: plainGroups } = await httpClient.post<{\n        groups: GroupDataPlain[];\n      }>(\n        url`/v2/c/groups/find`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n        }),\n        { groupIds }\n      );\n\n      const groups = new Map<string, GroupData>();\n\n      for (const group of plainGroups) {\n        groups.set(group.id, convertToGroupData(group));\n      }\n\n      return groupIds.map((groupId) => groups.get(groupId));\n    },\n    { delay: 50 }\n  );\n  const groupsStore = createBatchStore(batchedGetGroups);\n\n  function getGroup(groupId: string) {\n    return batchedGetGroups.get(groupId);\n  }\n\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    subscribeToThread,\n    unsubscribeFromThread,\n    markRoomInboxNotificationAsRead,\n    // Room subscription settings\n    getSubscriptionSettings,\n    updateSubscriptionSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // User attachments\n    uploadChatAttachment,\n    getOrCreateChatAttachmentUrlsStore,\n    getChatAttachmentUrl,\n    // Room storage\n    streamStorage,\n    sendMessages,\n    // Notifications\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getNotificationSettings,\n    updateNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // Groups\n    groupsStore,\n    getGroup,\n    // AI\n    executeContextualPrompt,\n  };\n}\n\nexport function getBearerTokenFromAuthValue(authValue: AuthValue): string {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\n\n/**\n * @internal\n *\n * Small HTTP client for client-only REST API requests (e.g. /v2/c/* URLs).\n * These URLs all use public key, ID token, or access token authorization. This\n * HTTP client can be shared and used by both the Liveblocks Client and\n * Liveblocks Room instances internally to talk to our client-only REST API\n * backend.\n */\nclass HttpClient {\n  #baseUrl: string;\n  #fetchPolyfill: typeof fetch;\n\n  constructor(baseUrl: string, fetchPolyfill: typeof fetch) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:    👈 This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<Response> {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n\n    const url = urljoin(this.#baseUrl, endpoint, params);\n    return await this.#fetchPolyfill(url, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n\n        // Possible header overrides\n        ...options?.headers,\n\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\",\n      },\n    });\n  }\n\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:   👈 This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails (🤔)\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<T> {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n\n    let body;\n    try {\n      body = (await response.json()) as T;\n    } catch {\n      // TODO This looks wrong 🤔 !\n      // TODO Should we not be throwing this error if something fails to parse?\n      body = {} as T;\n    }\n    return body;\n  }\n\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  public async rawGet(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  public async rawPost(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    body?: JsonObject\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringify(body),\n    });\n  }\n\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  public async rawDelete(\n    endpoint: URLSafeString,\n    authValue: AuthValue\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async get<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<T> {\n    return await this.#fetch<T>(endpoint, authValue, options, params);\n  }\n\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async post<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    body?: JsonObject,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">,\n    params?: QueryParams\n  ): Promise<T> {\n    return await this.#fetch<T>(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringify(body),\n      },\n      params\n    );\n  }\n\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async delete<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue\n  ): Promise<T> {\n    return await this.#fetch<T>(endpoint, authValue, { method: \"DELETE\" });\n  }\n\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async putBlob<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    blob?: Blob,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<T> {\n    return await this.#fetch<T>(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\",\n        },\n        body: blob,\n      },\n      params\n    );\n  }\n}\n", "/**\n * A generic Finite State Machine (FSM) implementation.\n *\n * This is a generic implementation that is not Liveblocks specific. We could\n * put this in a separate NPM package if we wanted to make this more reusable.\n */\n\nimport type { EventSource, Observable } from \"./EventSource\";\nimport { makeEventSource } from \"./EventSource\";\n\n/**\n * Built-in event sent by .addTimedTransition().\n */\nexport type TimerEvent = { readonly type: \"TIMER\" };\n\n/**\n * Built-in events sent by .onEnterAsync().\n */\nexport type AsyncOKEvent<T> = {\n  readonly type: \"ASYNC_OK\";\n  readonly data: T;\n};\nexport type AsyncErrorEvent = {\n  readonly type: \"ASYNC_ERROR\";\n  readonly reason: unknown;\n};\n\nexport type BaseEvent = { readonly type: string };\nexport type BuiltinEvent = TimerEvent | AsyncOKEvent<unknown> | AsyncErrorEvent;\n\nexport type Patchable<TContext> = Readonly<TContext> & {\n  patch(patch: Partial<TContext>): void;\n};\n\nexport type CleanupFn<TContext> = (context: Patchable<TContext>) => void;\nexport type EnterFn<TContext> = (\n  context: Patchable<TContext>\n) => void | CleanupFn<TContext>;\n\nexport type TargetFn<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = (\n  event: TEvent,\n  context: Readonly<TContext>\n) => TState | TargetObject<TContext, TEvent, TState> | null;\n\nexport type Effect<TContext, TEvent extends BaseEvent> = (\n  context: Patchable<TContext>,\n  event: TEvent\n) => void;\n\n/**\n * \"Expanded\" object form to specify a target state with.\n */\nexport type TargetObject<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = {\n  target: TState;\n\n  /**\n   * Emit a side effect (other than assigning to the context) when this\n   * transition is taken.\n   */\n  effect: Effect<TContext, TEvent> | Effect<TContext, TEvent>[];\n};\n\nexport type Target<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> =\n  | TState // Static, e.g. 'complete'\n  | TargetObject<TContext, TEvent, TState>\n  | TargetFn<TContext, TEvent, TState>; // Dynamic, e.g. (context) => context.x ? 'complete' : 'other'\n\ntype Groups<T extends string> = T extends `${infer G}.${infer Rest}`\n  ? G | `${G}.${Groups<Rest>}`\n  : never;\nexport type Wildcard<T extends string> = \"*\" | `${Groups<T>}.*`;\n\nfunction distance(state1: string, state2: string): [number, number] {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\n\nfunction patterns<TState extends string>(\n  targetState: TState,\n  levels: number\n): (Wildcard<TState> | TState)[] {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n\n  const result: (Wildcard<TState> | TState)[] = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push((slice.join(\".\") + \".*\") as Wildcard<TState>);\n    }\n  }\n\n  result.push(targetState);\n\n  return result;\n}\n\nclass SafeContext<TContext extends object> {\n  #curr: Readonly<TContext>;\n\n  constructor(initialContext: TContext) {\n    this.#curr = initialContext;\n  }\n\n  get current(): Readonly<TContext> {\n    return this.#curr;\n  }\n\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback: (context: Patchable<TContext>) => void): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    let allowed = true;\n\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch: Partial<TContext>): void {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n\n          // Also patch the temporary mutable context helper itself, in case\n          // there are multiple calls in a succession that need\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair as [\n              keyof TContext,\n              TContext[keyof TContext],\n            ];\n            if (key !== \"patch\") {\n              (this as TContext)[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      },\n    };\n    callback(patchableContext);\n\n    // If ever the patch function is called after this temporary window,\n    // disallow it\n    allowed = false;\n    return;\n  }\n}\n\nenum RunningState {\n  NOT_STARTED_YET, // Machine can be set up during this phase\n  STARTED,\n  STOPPED,\n}\n\nlet nextId = 1;\n\nexport class FSM<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> {\n  public id: number;\n\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState: RunningState;\n\n  readonly #currentContext: SafeContext<TContext>;\n\n  #states: Set<TState>;\n  #currentStateOrNull: TState | null;\n\n  #allowedTransitions: Map<\n    TState,\n    Map<TEvent[\"type\"], TargetFn<TContext, TEvent, TState>>\n  >;\n\n  readonly #eventHub: {\n    readonly didReceiveEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willTransition: EventSource<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willExitState: EventSource<TState>;\n    readonly didEnterState: EventSource<TState>;\n  };\n\n  public readonly events: {\n    readonly didReceiveEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willTransition: Observable<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willExitState: Observable<TState>;\n    readonly didEnterState: Observable<TState>;\n  };\n\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack: (CleanupFn<TContext> | null)[];\n\n  #enterFns: Map<TState | Wildcard<TState>, EnterFn<TContext>>;\n\n  // Used to provide better error messages\n  #knownEventTypes: Set<string>;\n\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState(): TState {\n    // Return the first state ever defined as the initial state\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n\n  public get currentState(): TState {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === RunningState.NOT_STARTED_YET) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  public start(): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"State machine has already started\");\n    }\n\n    this.#runningState = RunningState.STARTED;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  public stop(): void {\n    if (this.#runningState !== RunningState.STARTED) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = RunningState.STOPPED;\n    this.#currentStateOrNull = null;\n  }\n\n  constructor(initialContext: Readonly<TContext>) {\n    this.id = nextId++;\n    this.#runningState = RunningState.NOT_STARTED_YET;\n    this.#currentStateOrNull = null;\n    this.#states = new Set();\n    this.#enterFns = new Map();\n    this.#cleanupStack = [];\n    this.#knownEventTypes = new Set();\n    this.#allowedTransitions = new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource(),\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable,\n    };\n  }\n\n  public get context(): Readonly<TContext> {\n    return this.#currentContext.current;\n  }\n\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  public addState(state: TState): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n\n  public onEnter(\n    nameOrPattern: TState | Wildcard<TState>,\n    enterFn: EnterFn<TContext>\n  ): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  public onEnterAsync<T>(\n    nameOrPattern: TState | Wildcard<TState>,\n    promiseFn: (context: Readonly<TContext>, signal: AbortSignal) => Promise<T>,\n    onOK: Target<TContext, AsyncOKEvent<T>, TState>,\n    onError: Target<TContext, AsyncErrorEvent, TState>,\n    maxTimeout?: number\n  ): this {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      const timeoutId = maxTimeout\n        ? setTimeout(() => {\n            const reason = new Error(\"Timed out\");\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }, maxTimeout)\n        : undefined;\n\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data: T) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n\n        // On Error\n        (reason: unknown) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n\n  #getStatesMatching(nameOrPattern: TState | Wildcard<TState>): TState[] {\n    const matches: TState[] = [];\n\n    // We're trying to match a group pattern here, i.e. `foo.*` (which might\n    // match `foo.bar` and `foo.qux` states)\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1); // Strip only the \"*\", keep the \".\"\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      // Just a single, explicit state name\n      const name = nameOrPattern as TState;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n\n    return matches;\n  }\n\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  public addTransitions(\n    nameOrPattern: TState | Wildcard<TState>,\n    mapping: {\n      [E in TEvent as E[\"type\"]]?: Target<TContext, E, TState> | null;\n    }\n  ): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === undefined) {\n        map = new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n\n        const target = target_ as\n          | Target<TContext, TEvent, TState>\n          | null\n          | undefined;\n        this.#knownEventTypes.add(type);\n\n        if (target !== undefined) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  public addTimedTransition(\n    stateOrPattern: TState | Wildcard<TState>,\n    after: number | ((context: Readonly<TContext>) => number),\n    target: Target<TContext, TimerEvent, TState>\n  ): this {\n    return this.onEnter(stateOrPattern, () => {\n      const ms =\n        typeof after === \"function\"\n          ? after(this.#currentContext.current)\n          : after;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n\n  #getTargetFn(\n    eventName: TEvent[\"type\"]\n  ): TargetFn<TContext, TEvent, TState> | undefined {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels: number | null) {\n    this.#eventHub.willExitState.notify(this.currentState);\n\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels: number | null) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n      }\n    });\n\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  public send(event: TEvent): void {\n    // Throw if the event is unknown, which may likely be a configuration error\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n\n    if (this.#runningState === RunningState.STOPPED) {\n      // Ignore all events sent to the machine after it has stopped. This is\n      // similar to how we ignore events sent to the machine after it\n      // transitioned to a phase in which the event won't be handled: it would\n      // also get ignored.\n      // However, if the machine _hasn't started yet_, we still let it throw an\n      // error, because then it's most likely a usage error.\n      return;\n    }\n\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== undefined) {\n      return this.#transition(event, targetFn);\n    } else {\n      // Ignore the event otherwise\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n\n  #transition<E extends TEvent | BuiltinEvent>(\n    event: E,\n    target: Target<TContext, E, TState>\n  ) {\n    this.#eventHub.didReceiveEvent.notify(event);\n\n    const oldState = this.currentState;\n\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState: TState;\n    let effects: Effect<TContext, E>[] | undefined = undefined;\n    if (nextTarget === null) {\n      // Do not transition\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect)\n        ? nextTarget.effect\n        : [nextTarget.effect];\n    }\n\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n\n    this.#currentStateOrNull = nextState; // NOTE: Could stay the same, but... there could be an action to execute here\n    if (effects !== undefined) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            // May mutate context\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n}\n\n/** @internal - For unit tests only */\nexport { distance, patterns };\n", "import type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"./BaseUserMeta\";\nimport type { Op } from \"./Op\";\nimport type { IdTuple, SerializedCrdt } from \"./SerializedCrdt\";\n\nexport enum ServerMsgCode {\n  // For Presence\n  UPDATE_PRESENCE = 100,\n  USER_JOINED = 101,\n  USER_LEFT = 102,\n  BROADCASTED_EVENT = 103,\n  ROOM_STATE = 104,\n\n  // For Storage\n  INITIAL_STORAGE_STATE = 200,\n  UPDATE_STORAGE = 201,\n  REJECT_STORAGE_OP = 299,\n\n  // For Yjs Docs\n  UPDATE_YDOC = 300,\n\n  // For Comments\n  THREAD_CREATED = 400,\n  THREAD_DELETED = 407,\n  THREAD_METADATA_UPDATED = 401,\n  THREAD_UPDATED = 408,\n  COMMENT_CREATED = 402,\n  COMMENT_EDITED = 403,\n  COMMENT_DELETED = 404,\n  COMMENT_REACTION_ADDED = 405,\n  COMMENT_REACTION_REMOVED = 406,\n}\n\n/**\n * Messages that can be sent from the server to the client.\n */\nexport type ServerMsg<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> =\n  // For Presence\n  | UpdatePresenceServerMsg<P> // Broadcasted\n  | UserJoinServerMsg<U> // Broadcasted\n  | UserLeftServerMsg // Broadcasted\n  | BroadcastedEventServerMsg<E> // Broadcasted\n  | RoomStateServerMsg<U> // For a single client\n\n  // For Storage\n  | InitialDocumentStateServerMsg // For a single client\n  | UpdateStorageServerMsg // Broadcasted\n  | RejectedStorageOpServerMsg // For a single client\n  | YDocUpdateServerMsg // For receiving doc from backend\n\n  // Comments\n  | CommentsEventServerMsg;\n\nexport type CommentsEventServerMsg =\n  | ThreadCreatedEvent\n  | ThreadDeletedEvent\n  | ThreadMetadataUpdatedEvent\n  | ThreadUpdatedEvent\n  | CommentCreatedEvent\n  | CommentEditedEvent\n  | CommentDeletedEvent\n  | CommentReactionAdded\n  | CommentReactionRemoved;\n\ntype ThreadCreatedEvent = {\n  type: ServerMsgCode.THREAD_CREATED;\n  threadId: string;\n};\n\ntype ThreadDeletedEvent = {\n  type: ServerMsgCode.THREAD_DELETED;\n  threadId: string;\n};\n\ntype ThreadMetadataUpdatedEvent = {\n  type: ServerMsgCode.THREAD_METADATA_UPDATED;\n  threadId: string;\n};\n\ntype ThreadUpdatedEvent = {\n  type: ServerMsgCode.THREAD_UPDATED;\n  threadId: string;\n};\n\ntype CommentCreatedEvent = {\n  type: ServerMsgCode.COMMENT_CREATED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentEditedEvent = {\n  type: ServerMsgCode.COMMENT_EDITED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentDeletedEvent = {\n  type: ServerMsgCode.COMMENT_DELETED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentReactionAdded = {\n  type: ServerMsgCode.COMMENT_REACTION_ADDED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\ntype CommentReactionRemoved = {\n  type: ServerMsgCode.COMMENT_REACTION_REMOVED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User updated their presence. For example, when a user moves their cursor.\n *\n * In most cases, the data payload will only include the fields from the\n * Presence that have been changed since the last announcement. However, after\n * a new user joins a room, a \"full presence\" will be announced so the newly\n * connected user will get each other's user full presence at least once. In\n * those cases, the `targetActor` field indicates the newly connected client,\n * so all other existing clients can ignore this broadcasted message.\n */\nexport type UpdatePresenceServerMsg<P extends JsonObject> =\n  //\n  // Full Presence™ message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * When set, signifies that this is a Full Presence™ update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      /**\n       * The partial or full Presence of a User. If the `targetActor` field is set,\n       * this will be the full Presence, otherwise it only contain the fields that\n       * have changed since the last broadcast.\n       */\n      readonly data: P;\n    }\n\n  //\n  // Partial Presence™ message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * Not set for partial presence updates.\n       */\n      readonly targetActor?: undefined;\n      /**\n       * A partial Presence patch to apply to the User. It will only contain the\n       * fields that have changed since the last broadcast.\n       */\n      readonly data: Partial<P>;\n    };\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has joined the Room.\n */\nexport type UserJoinServerMsg<U extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.USER_JOINED;\n  readonly actor: number;\n  /**\n   * The id of the User that has been set in the authentication endpoint.\n   * Useful to get additional information about the connected user.\n   */\n  readonly id: U[\"id\"];\n  /**\n   * Additional user information that has been set in the authentication\n   * endpoint.\n   */\n  readonly info: U[\"info\"];\n  /**\n   * Informs the client what (public) permissions this (other) User has.\n   */\n  readonly scopes: string[];\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has left the Room.\n */\nexport type UserLeftServerMsg = {\n  readonly type: ServerMsgCode.USER_LEFT;\n  readonly actor: number;\n};\n\n/**\n * Sent by the WebSocket server when the ydoc is updated or when requested based on stateVector passed.\n * Contains a base64 encoded update\n */\nexport type YDocUpdateServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_YDOC;\n  readonly update: string;\n  readonly isSync: boolean; // dropped after 1.2, we use presence of stateVector instead\n  readonly stateVector: string | null; // server's state vector, sent in response to fetch\n  readonly guid?: string; // an optional guid to identify which subdoc this update to\n  readonly v2?: boolean; // whether this is a v2 update\n  readonly remoteSnapshotHash: string; // The hash of snapshot of server's document. Used to detect if the client has the latest version of the document.\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User broadcasted an Event to everyone in the Room.\n */\nexport type BroadcastedEventServerMsg<E extends Json> = {\n  readonly type: ServerMsgCode.BROADCASTED_EVENT;\n  /**\n   * The User who broadcast the Event. Absent when this event is broadcast from\n   * the REST API in the backend.\n   */\n  readonly actor: number;\n  /**\n   * The arbitrary payload of the Event. This can be any JSON value. Clients\n   * will have to manually verify/decode this event.\n   */\n  readonly event: E;\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * joining the Room, to provide the initial state of the Room. The payload\n * includes a list of all other Users that already are in the Room.\n */\nexport type RoomStateServerMsg<U extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.ROOM_STATE;\n\n  /**\n   * Informs the client what their actor ID is going to be.\n   * @since v1.2 (WS API v7)\n   */\n  readonly actor: number;\n\n  /**\n   * Secure nonce for the current session.\n   * @since v1.2 (WS API v7)\n   */\n  readonly nonce: string;\n\n  /**\n   * Informs the client what permissions the current User (self) has.\n   * @since v1.2 (WS API v7)\n   */\n  readonly scopes: string[];\n\n  readonly users: {\n    readonly [otherActor: number]: U & { scopes: string[] };\n  };\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * joining the Room, to provide the initial Storage state of the Room. The\n * payload includes the entire Storage document.\n */\nexport type InitialDocumentStateServerMsg = {\n  readonly type: ServerMsgCode.INITIAL_STORAGE_STATE;\n  readonly items: IdTuple<SerializedCrdt>[];\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a change occurred in the Storage document.\n *\n * The payload of this message contains a list of Ops (aka incremental\n * mutations to make to the initially loaded document).\n */\nexport type UpdateStorageServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_STORAGE;\n  readonly ops: Op[];\n};\n\n/**\n * Sent by the WebSocket server to the client to indicate that certain opIds\n * have been received but were rejected because they caused mutations that are\n * incompatible with the Room's schema.\n */\nexport type RejectedStorageOpServerMsg = {\n  readonly type: ServerMsgCode.REJECT_STORAGE_OP;\n  readonly opIds: string[];\n  readonly reason: string;\n};\n", "export interface IWebSocketEvent {\n  type: string;\n}\n\nexport interface IWebSocketCloseEvent extends IWebSocketEvent {\n  readonly code: WebsocketCloseCodes;\n  readonly wasClean: boolean;\n  readonly reason: string;\n}\n\nexport interface IWebSocketMessageEvent extends IWebSocketEvent {\n  readonly data: string | Buffer | ArrayBuffer | readonly Buffer[];\n}\n\nexport interface IWebSocketInstance {\n  readonly CONNECTING: number; // 0\n  readonly OPEN: number; // 1\n  readonly CLOSING: number; // 2\n  readonly CLOSED: number; // 3\n\n  readonly readyState: number;\n\n  addEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  removeEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  close(): void;\n  send(data: string): void;\n}\n\n/**\n * Either the browser-based WebSocket API or Node.js' WebSocket API (from the\n * 'ws' package).\n *\n * This type defines the minimal WebSocket API that Liveblocks needs from\n * a WebSocket implementation, and is a minimal subset of the browser-based\n * WebSocket APIs and Node.js' WebSocket API so that both implementations are\n * assignable to this type.\n */\nexport interface IWebSocket {\n  new (address: string): IWebSocketInstance;\n}\n\n/**\n * The following ranges will be respected by the client:\n *\n *   10xx: client will reauthorize (just like 41xx)\n *   40xx: client will disconnect\n *   41xx: client will reauthorize\n *   42xx: client will retry without reauthorizing (currently not used)\n *\n */\nexport enum WebsocketCloseCodes {\n  /** Normal close of connection, the connection fulfilled its purpose. */\n  CLOSE_NORMAL = 1000,\n  /** Unexpected error happened with the network/infra level. In spirit akin to HTTP 503 */\n  CLOSE_ABNORMAL = 1006,\n  /** Unexpected error happened. In spirit akin to HTTP 500 */\n  UNEXPECTED_CONDITION = 1011,\n  /** Please back off for now, but try again in a few moments */\n  TRY_AGAIN_LATER = 1013,\n  /** Message wasn't understood, disconnect */\n  INVALID_MESSAGE_FORMAT = 4000,\n  /** Server refused to allow connection. Re-authorizing won't help. Disconnect. In spirit akin to HTTP 403 */\n  NOT_ALLOWED = 4001,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002,\n  /** Unused */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004,\n  /** Room is full, disconnect */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005,\n  /** The room's ID was updated, disconnect */\n  ROOM_ID_UPDATED = 4006,\n  /** The server kicked the connection from the room. */\n  KICKED = 4100,\n  /** The auth token is expired, reauthorize to get a fresh one. In spirit akin to HTTP 401 */\n  TOKEN_EXPIRED = 4109,\n  /** Disconnect immediately */\n  CLOSE_WITHOUT_RETRY = 4999,\n}\n\nexport function shouldDisconnect(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.CLOSE_WITHOUT_RETRY ||\n    ((code as number) >= 4000 && (code as number) < 4100)\n  );\n}\n\nexport function shouldReauth(code: WebsocketCloseCodes): boolean {\n  return (code as number) >= 4100 && (code as number) < 4200;\n}\n\nexport function shouldRetryWithoutReauth(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.TRY_AGAIN_LATER ||\n    ((code as number) >= 4200 && (code as number) < 4300)\n  );\n}\n", "import { assertNever } from \"./lib/assert\";\nimport { controlledPromise } from \"./lib/controlledPromise\";\nimport type { Observable } from \"./lib/EventSource\";\nimport { makeBufferableEventSource, makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { BuiltinEvent, Patchable, Target } from \"./lib/fsm\";\nimport { FSM } from \"./lib/fsm\";\nimport type { Json } from \"./lib/Json\";\nimport { tryParseJson, withTimeout } from \"./lib/utils\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type {\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport {\n  shouldDisconnect,\n  shouldReauth,\n  shouldRetryWithoutReauth,\n  WebsocketCloseCodes,\n} from \"./types/IWebSocket\";\n\n/**\n * Returns a human-readable status indicating the current connection status of\n * a Room, as returned by `room.getStatus()`. Can be used to implement\n * a connection status badge.\n */\nexport type Status =\n  | \"initial\"\n  | \"connecting\"\n  | \"connected\"\n  | \"reconnecting\"\n  | \"disconnected\";\n\n/**\n * Whether or not the status is an \"idle\" state. Here, idle means that nothing\n * will happen until some action is taken. Unsurprisingly, these statuses match\n * the start and end states of the state machine.\n */\nexport function isIdle(status: Status): status is \"initial\" | \"disconnected\" {\n  return status === \"initial\" || status === \"disconnected\";\n}\n\n/**\n * Used to report about app-level reconnection issues.\n *\n * Normal (quick) reconnects won't be reported as a \"lost connection\". Instead,\n * the application will only get an event if the reconnection attempts by the\n * client are taking (much) longer than usual. Definitely a situation you want\n * to inform your users about, for example, by throwing a toast message on\n * screen, or show a \"trying to reconnect\" banner.\n */\nexport type LostConnectionEvent =\n  | \"lost\" // the client is trying to reconnect to Liveblocks, but it's taking (much) longer than usual\n  | \"restored\" // the client did reconnect after all\n  | \"failed\"; // the client was told to stop trying\n\n/**\n * Maps internal machine state to the public Status API.\n */\nfunction toNewConnectionStatus(machine: FSM<Context, Event, State>): Status {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n\n    case \"@idle.initial\":\n      return \"initial\";\n\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n\n    case \"@idle.failed\":\n      return \"disconnected\";\n\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\n\n/**\n * Events that can be sent to the machine externally.\n */\ntype Event =\n  // Public events that can be called on the connection manager\n  | { type: \"CONNECT\" } // e.g. when trying to enter a room\n  | { type: \"RECONNECT\" } // e.g. user asking for an explicit reconnect of the socket\n  | { type: \"DISCONNECT\" } // e.g. leaving the room\n  | { type: \"WINDOW_GOT_FOCUS\" } // e.g. user's browser tab is refocused\n  | { type: \"NAVIGATOR_ONLINE\" } // e.g. browser gets back online\n  | { type: \"NAVIGATOR_OFFLINE\" } // e.g. browser goes offline\n\n  // Events that the connection manager will internally deal with\n  | { type: \"PONG\" }\n  | { type: \"EXPLICIT_SOCKET_ERROR\"; event: IWebSocketEvent }\n  | { type: \"EXPLICIT_SOCKET_CLOSE\"; event: IWebSocketCloseEvent }\n\n  // Only used by the E2E testing app, to simulate a pong timeout :(\n  | { type: \"PONG_TIMEOUT\" };\n\ntype State =\n  | \"@idle.initial\"\n  | \"@idle.failed\"\n  | \"@idle.zombie\"\n  | \"@auth.busy\"\n  | \"@auth.backoff\"\n  | \"@connecting.busy\"\n  | \"@connecting.backoff\"\n  | \"@ok.connected\"\n  | \"@ok.awaiting-pong\";\n\n/**\n * Arbitrary record that will be used as the authentication \"authValue\". It's the\n * value that is returned by calling the authentication delegate, and will get\n * passed to the connection factory delegate. This value will be remembered by\n * the connection manager, but its value will not be interpreted, so it can be\n * any value (except null).\n */\nexport type BaseAuthResult = NonNullable<Json>;\n\ntype Context = {\n  /**\n   * Count the number of times the machine reaches an \"@ok.*\" state. Once the\n   * machine reaches idle state again, this count is reset to 0 again.\n   *\n   * This lets us distinguish:\n   * - If successCount = 0, then it's an initial \"connecting\" state.\n   * - If successCount > 0, then it's an \"reconnecting\" state.\n   */\n  successCount: number;\n\n  /**\n   * Will be populated with the last known auth authValue.\n   */\n  authValue: BaseAuthResult | null;\n\n  /**\n   * The current active WebSocket connection to the room. If this is not null\n   * on the context, then the socket has successfully been opened.\n   */\n  socket: IWebSocketInstance | null;\n\n  /**\n   * The current retry delay when automatically retrying. Will get bumped to\n   * the next \"tier\" every time a connection attempt fails. Reset every time\n   * a connection succeeded.\n   */\n  backoffDelay: number;\n};\n\nconst BACKOFF_DELAYS = [250, 500, 1_000, 2_000, 4_000, 8_000, 10_000] as const;\n\n// Resetting the delay happens upon success. We could reset to 0, but that\n// would risk no delay, which generally isn't wise. Instead, we'll reset it to\n// the lowest safe delay minus 1 millisecond. The reason is that every time\n// a retry happens, the retry delay will first be bumped to the next \"tier\".\nconst RESET_DELAY = BACKOFF_DELAYS[0] - 1;\n\n/**\n * Used to back off from WebSocket reconnection attempts after a known\n * Liveblocks issue, like \"room full\" or a \"rate limit\" error.\n */\nconst BACKOFF_DELAYS_SLOW = [2_000, 30_000, 60_000, 300_000] as const;\n\n/**\n * The client will send a PING to the server every 30 seconds, after which it\n * must receive a PONG back within the next 2 seconds. If that doesn't happen,\n * this is interpreted as an implicit connection loss event.\n */\nconst HEARTBEAT_INTERVAL = 30_000;\nconst PONG_TIMEOUT = 2_000;\n\n/**\n * Maximum amount of time that the authentication delegate take to return an\n * auth authValue, or else we consider authentication timed out.\n */\nconst AUTH_TIMEOUT = 10_000;\n\n/**\n * Maximum amount of time that the socket connect delegate may take to return\n * an opened WebSocket connection, or else we consider the attempt timed out.\n */\nconst SOCKET_CONNECT_TIMEOUT = 10_000;\n\n/**\n * Special error class that can be thrown during authentication to stop the\n * connection manager from retrying.\n */\nexport class StopRetrying extends Error {\n  constructor(reason: string) {\n    super(reason);\n  }\n}\n\nfunction nextBackoffDelay(\n  currentDelay: number,\n  delays: readonly number[]\n): number {\n  return (\n    delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1]\n  );\n}\n\nfunction increaseBackoffDelay(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS),\n  });\n}\n\nfunction increaseBackoffDelayAggressively(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW),\n  });\n}\n\nfunction resetSuccessCount(context: Patchable<Context>) {\n  context.patch({ successCount: 0 });\n}\n\nenum LogLevel {\n  INFO,\n  WARN,\n  ERROR,\n}\n\n/**\n * Generic \"log\" effect. Use it in `effect` handlers of state transitions.\n */\nfunction log(level: LogLevel, message: string) {\n  const logger =\n    level === LogLevel.ERROR\n      ? console.error\n      : level === LogLevel.WARN\n        ? console.warn\n        : /* black hole */ () => {};\n  return () => {\n    logger(message);\n  };\n}\n\nfunction logPrematureErrorOrCloseEvent(e: IWebSocketEvent | Error) {\n  // Produce a useful log message\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx: Readonly<Context>) => {\n    if (e instanceof Error) {\n      console.warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      console.warn(\n        isCloseEvent(e)\n          ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.`\n          : `${conn} could not be established.`\n      );\n    }\n  };\n}\n\nfunction logCloseEvent(event: IWebSocketCloseEvent) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx: Readonly<Context>) => {\n    console.warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\n\nconst logPermanentClose = log(\n  LogLevel.WARN,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\n\nfunction isCloseEvent(\n  error: IWebSocketEvent | Error\n): error is IWebSocketCloseEvent {\n  return !(error instanceof Error) && error.type === \"close\";\n}\n\nexport type Delegates<T extends BaseAuthResult> = {\n  authenticate: () => Promise<T>;\n  createSocket: (authValue: T) => IWebSocketInstance;\n  canZombie: () => boolean;\n};\n\n// istanbul ignore next\nfunction enableTracing(machine: FSM<Context, Event, State>) {\n  const start = new Date().getTime();\n\n  function log(...args: unknown[]) {\n    console.warn(\n      `${((new Date().getTime() - start) / 1000).toFixed(2)} [FSM #${\n        machine.id\n      }]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(({ from, to }) =>\n      log(\"Transitioning\", from, \"→\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe((e) =>\n      log(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    ),\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\n\nfunction defineConnectivityEvents(machine: FSM<Context, Event, State>) {\n  // Emitted whenever a new WebSocket connection attempt succeeds\n  const statusDidChange = makeEventSource<Status>();\n  const didConnect = makeEventSource<void>();\n  const didDisconnect = makeEventSource<void>();\n\n  let lastStatus: Status | null = null;\n\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe,\n  };\n}\n\nconst assign = (patch: Partial<Context>) => (ctx: Patchable<Context>) =>\n  ctx.patch(patch);\n\n/**\n * A ConnectionError is a partial data structure to help build a proper\n * LiveblocksError down the line.\n */\ntype ConnectionError = { message: string; code: number };\n\nfunction createConnectionStateMachine<T extends BaseAuthResult>(\n  delegates: Delegates<T>,\n  options: {\n    enableDebugLogging: boolean;\n    /** In protocol V7, the actor will no longer be available on the token.\n     * Instead, the `actor` will be sent to the client via a ROOM_STATE message\n     * over an established WebSocket connection. If this setting is set to\n     * `true`, the state machine will only jump to \"connected\" state _after_\n     * this message has been received. If this setting is `false`, the machine\n     * won't wait for the actor to be received, and instead jump to \"connected\"\n     * as soon as the WebSocket connection is established. */\n    waitForActorId: boolean;\n  }\n) {\n  // Create observable event sources, which this machine will call into when\n  // specific events happen\n  const onMessage = makeBufferableEventSource<IWebSocketMessageEvent>();\n  onMessage.pause(); // Pause all message delivery until status is OPEN\n\n  // Emitted whenever the server deliberately closes the connection for\n  // a specific Liveblocks reason\n  const onConnectionError = makeEventSource<ConnectionError>();\n\n  function fireErrorEvent(message: string, code: number) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n\n  const initialContext: Context & { authValue: T | null } = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY,\n  };\n\n  // The `machine` is the actual finite state machine instance that will\n  // maintain the WebSocket's connection\n  const machine = new FSM<Context, Event, State>(initialContext)\n    .addState(\"@idle.initial\")\n    .addState(\"@idle.failed\")\n    .addState(\"@idle.zombie\")\n    .addState(\"@auth.busy\")\n    .addState(\"@auth.backoff\")\n    .addState(\"@connecting.busy\")\n    .addState(\"@connecting.backoff\")\n    .addState(\"@ok.connected\")\n    .addState(\"@ok.awaiting-pong\");\n\n  //\n  // Configure events that can happen from anywhere\n  //\n  // It's always possible to explicitly get a .reconnect() or .disconnect()\n  // from the user.\n  //\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount],\n    },\n\n    DISCONNECT: \"@idle.initial\",\n  });\n\n  //\n  // Configure the @idle.* states\n  //\n  machine\n    .onEnter(\"@idle.*\", resetSuccessCount)\n\n    .addTransitions(\"@idle.*\", {\n      CONNECT: (_, ctx) =>\n        // If we still have a known authValue, try to reconnect to the socket directly,\n        // otherwise, try to obtain a new authValue\n        ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\",\n    });\n\n  //\n  // Configure the @auth.* states\n  //\n  machine\n    .addTransitions(\"@auth.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@auth.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@auth.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@auth.busy\"\n    )\n\n    .onEnterAsync(\n      \"@auth.busy\",\n\n      () =>\n        withTimeout(\n          delegates.authenticate(),\n          AUTH_TIMEOUT,\n          \"Timed out during auth\"\n        ),\n\n      // On successful authentication\n      (okEvent) => ({\n        target: \"@connecting.busy\",\n        effect: assign({\n          authValue: okEvent.data,\n        }),\n      }),\n\n      // Auth failed\n      (failedEvent) => {\n        if (failedEvent.reason instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, failedEvent.reason.message),\n              fireErrorEvent(failedEvent.reason.message, -1),\n            ],\n          };\n        }\n\n        return {\n          target: \"@auth.backoff\",\n          effect: [\n            increaseBackoffDelay,\n            log(\n              LogLevel.ERROR,\n              `Authentication failed: ${\n                failedEvent.reason instanceof Error\n                  ? failedEvent.reason.message\n                  : String(failedEvent.reason)\n              }`\n            ),\n          ],\n        };\n      }\n    );\n\n  //\n  // Configure the @connecting.* states\n  //\n\n  // Function references\n  const onSocketError = (event: IWebSocketEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n\n  const onSocketClose = (event: IWebSocketCloseEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n\n  const onSocketMessage = (event: IWebSocketMessageEvent) =>\n    event.data === \"pong\"\n      ? machine.send({ type: \"PONG\" })\n      : onMessage.notify(event);\n\n  function teardownSocket(socket: IWebSocketInstance | null) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n\n  machine\n    .addTransitions(\"@connecting.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@connecting.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@connecting.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@connecting.busy\"\n    )\n\n    .onEnterAsync(\n      \"@connecting.busy\",\n\n      //\n      // Use the \"createSocket\" delegate function (provided to the\n      // ManagedSocket) to create the actual WebSocket connection instance.\n      // Then, set up all the necessary event listeners, and wait for the\n      // \"open\" event to occur.\n      //\n      // When the \"open\" event happens, we're ready to transition to the\n      // OK state. This is done by resolving the Promise.\n      //\n      async (ctx, signal) => {\n        let capturedPrematureEvent: IWebSocketEvent | null = null;\n        let unconfirmedSocket: IWebSocketInstance | null = null;\n\n        const connect$ = new Promise<[IWebSocketInstance, () => void]>(\n          (resolve, rej) => {\n            // istanbul ignore next\n            if (ctx.authValue === null) {\n              throw new Error(\"No auth authValue\"); // This should never happen\n            }\n\n            const socket = delegates.createSocket(ctx.authValue as T);\n            unconfirmedSocket = socket;\n\n            function reject(event: IWebSocketEvent) {\n              capturedPrematureEvent = event;\n              socket.removeEventListener(\"message\", onSocketMessage);\n              rej(event);\n            }\n\n            const [actor$, didReceiveActor] = controlledPromise<void>();\n            if (!options.waitForActorId) {\n              // Mark the promise as \"resolved\" immediately, so we won't wait\n              // for a ROOM_STATE message to happen.\n              didReceiveActor();\n            }\n\n            /** Waits until actor is received (from the ROOM_STATE message) */\n            function waitForActorId(event: IWebSocketMessageEvent) {\n              const serverMsg = tryParseJson(event.data as string) as\n                | Record<string, Json>\n                | undefined;\n              if (serverMsg?.type === ServerMsgCode.ROOM_STATE) {\n                didReceiveActor();\n              }\n            }\n\n            //\n            // Part 1:\n            // The `error` and `close` event handlers marked (*) are installed\n            // here only temporarily, just to handle this promise-based state.\n            // When those get triggered, we reject this promise.\n            //\n            socket.addEventListener(\"message\", onSocketMessage);\n            if (options.waitForActorId) {\n              socket.addEventListener(\"message\", waitForActorId);\n            }\n            socket.addEventListener(\"error\", reject); // (*)\n            socket.addEventListener(\"close\", reject); // (*)\n            socket.addEventListener(\"open\", () => {\n              //\n              // Part 2:\n              // The \"open\" event just fired, so the server accepted our\n              // attempt to connect. We'll go on and resolve() our promise as\n              // a result.\n              //\n              // However, we cannot safely remove our error/close rejection\n              // handlers _just yet_. There is a small, unlikely-but-possible\n              // edge case: if (and only if) any close/error events are\n              // _already_ queued up in the event queue before this handler is\n              // invoked, then those will fire before our promise will be\n              // resolved.\n              //\n              // Scenario:\n              // - Event queue is empty, listeners are installed\n              // - Two events synchronously get scheduled in the event queue: [<open event>, <close event>]\n              // - The open handler is invoked (= this very callback)\n              // - Event queue now looks like: [<close event>]\n              // - We happily continue and resolve the promise\n              // - Event queue now looks like: [<close event>, <our resolved promise>]\n              // - Close event handler fires, but we already resolved promise! 😣\n              //\n              // This is what's called a \"premature\" event here, we'll deal\n              // with it in part 3.\n              //\n              socket.addEventListener(\"error\", onSocketError);\n              socket.addEventListener(\"close\", onSocketClose);\n              const unsub = () => {\n                socket.removeEventListener(\"error\", reject); // Remove (*)\n                socket.removeEventListener(\"close\", reject); // Remove (*)\n                socket.removeEventListener(\"message\", waitForActorId);\n              };\n\n              // Resolve the promise only once we received the actor ID from\n              // the server. This will act like a traffic light, going green\n              // only once the actor is received. If the machine is configured\n              // not to wait for the actor, the traffic light will already be\n              // green.\n              // All messages received in the mean time while waiting for the\n              // green light will be played back to the client after the\n              // transition to \"connected\".\n              void actor$.then(() => {\n                resolve([socket, unsub]);\n              });\n            });\n          }\n        );\n\n        return withTimeout(\n          connect$,\n          SOCKET_CONNECT_TIMEOUT,\n          \"Timed out during websocket connection\"\n        )\n          .then(\n            //\n            // Part 3:\n            // By now, our \"open\" event has fired, and the promise has been\n            // resolved. Two possible scenarios:\n            //\n            // 1. The happy path. Most likely.\n            // 2. Uh-oh. A premature close/error event has been observed. Let's\n            //    reject the promise after all.\n            //\n            // Any close/error event that will get scheduled after this point\n            // onwards, will be caught in the OK state, and dealt with\n            // accordingly.\n            //\n            ([socket, unsub]) => {\n              unsub();\n\n              if (signal.aborted) {\n                // Trigger cleanup logic in .catch() below. At this point, the\n                // promise is already cancelled, so none of the ok/err\n                // transitions will take place.\n                throw new Error(\"Aborted\");\n              }\n\n              if (capturedPrematureEvent) {\n                throw capturedPrematureEvent; // Take failure transition\n              }\n\n              return socket;\n            }\n          )\n          .catch((e) => {\n            teardownSocket(unconfirmedSocket);\n            throw e;\n          });\n      },\n\n      // Only transition to OK state after a successfully opened WebSocket connection\n      (okEvent) => ({\n        target: \"@ok.connected\",\n        effect: assign({\n          socket: okEvent.data,\n          backoffDelay: RESET_DELAY,\n        }),\n      }),\n\n      // If the WebSocket connection cannot be established\n      (failure) => {\n        const err = failure.reason as IWebSocketEvent | StopRetrying | Error;\n\n        // Stop retrying if this promise explicitly tells us so. This should,\n        // in the case of a WebSocket connection attempt only be the case if\n        // there is a configuration error.\n        if (err instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, err.message),\n              fireErrorEvent(err.message, -1),\n            ],\n          };\n        }\n\n        // If the server actively refuses the connection attempt, stop trying.\n        if (isCloseEvent(err)) {\n          // The default fall-through behavior is going to be reauthorizing\n          // with a back-off strategy. If we know the token was expired however\n          // we can reauthorize immediately (without back-off).\n          if (err.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            return \"@auth.busy\";\n          }\n\n          if (shouldRetryWithoutReauth(err.code)) {\n            // Retry after backoff, but don't get a new token\n            return {\n              target: \"@connecting.backoff\",\n              effect: [\n                increaseBackoffDelayAggressively,\n                logPrematureErrorOrCloseEvent(err),\n              ],\n            };\n          }\n\n          // If the token was not allowed we can stop trying because getting\n          // another token for the same user won't help\n          if (shouldDisconnect(err.code)) {\n            return {\n              target: \"@idle.failed\",\n              effect: [\n                log(LogLevel.ERROR, err.reason),\n                fireErrorEvent(err.reason, err.code),\n              ],\n            };\n          }\n        }\n\n        // In all other (unknown) cases, always re-authenticate (but after a back-off)\n        return {\n          target: \"@auth.backoff\",\n          effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)],\n        };\n      }\n    );\n\n  //\n  // Configure the @ok.* states\n  //\n  // Keeps a heartbeat alive with the server whenever in the @ok.* state group.\n  // 30 seconds after entering the \"@ok.connected\" state, it will emit\n  // a heartbeat, and awaits a PONG back that should arrive within 2 seconds.\n  // If this happens, then it transitions back to normal \"connected\" state, and\n  // the cycle repeats. If the PONG is not received timely, then we interpret\n  // it as an implicit connection loss, and transition to reconnect (throw away\n  // this socket, and open a new one).\n  //\n\n  const sendHeartbeat: Target<Context, Event | BuiltinEvent, State> = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    },\n  };\n\n  const maybeHeartbeat: Target<Context, Event | BuiltinEvent, State> = () => {\n    // If the browser tab isn't visible currently, ask the application if going\n    // zombie is fine\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const canZombie =\n      doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n\n  machine\n    .addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat)\n    .addTransitions(\"@ok.connected\", {\n      NAVIGATOR_OFFLINE: maybeHeartbeat, // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n      WINDOW_GOT_FOCUS: sendHeartbeat,\n    });\n\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\", // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n\n  machine\n    .onEnter(\"@ok.*\", (ctx) => {\n      ctx.patch({ successCount: ctx.successCount + 1 });\n\n      const timerID = setTimeout(\n        // On the next tick, start delivering all messages that have already\n        // been received, and continue synchronous delivery of all future\n        // incoming messages.\n        onMessage.unpause,\n        0\n      );\n\n      // ...but when *leaving* OK state, always tear down the old socket. It's\n      // no longer valid.\n      return (ctx) => {\n        teardownSocket(ctx.socket);\n        ctx.patch({ socket: null });\n        clearTimeout(timerID);\n        onMessage.pause();\n      };\n    })\n\n    .addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" })\n    .addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n      target: \"@connecting.busy\",\n      // Log implicit connection loss and drop the current open socket\n      effect: log(\n        LogLevel.WARN,\n        \"Received no pong from server, assume implicit connection loss.\"\n      ),\n    })\n\n    .addTransitions(\"@ok.*\", {\n      // When a socket receives an error, this can cause the closing of the\n      // socket, or not. So always check to see if the socket is still OPEN or\n      // not. When still OPEN, don't transition.\n      EXPLICIT_SOCKET_ERROR: (_, context) => {\n        if (context.socket?.readyState === 1 /* WebSocket.OPEN */) {\n          // TODO Do we need to forward this error to the client?\n          return null; /* Do not leave OK state, socket is still usable */\n        }\n\n        return {\n          target: \"@connecting.backoff\",\n          effect: increaseBackoffDelay,\n        };\n      },\n\n      EXPLICIT_SOCKET_CLOSE: (e) => {\n        // Server instructed us to stop retrying, so move to failed state\n        if (shouldDisconnect(e.event.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              logPermanentClose,\n              fireErrorEvent(e.event.reason, e.event.code),\n            ],\n          };\n        }\n\n        if (shouldReauth(e.event.code)) {\n          if (e.event.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            // Token expiry is a special case, we can reauthorize immediately\n            // (without back-off)\n            return \"@auth.busy\";\n          } else {\n            return {\n              target: \"@auth.backoff\",\n              effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n            };\n          }\n        }\n\n        if (shouldRetryWithoutReauth(e.event.code)) {\n          // If this is a custom Liveblocks server close reason, back off more\n          // aggressively, and emit a Liveblocks error event...\n          return {\n            target: \"@connecting.backoff\",\n            effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)],\n          };\n        }\n\n        // Consider any other close event a temporary network hiccup, and retry\n        // after a normal backoff delay\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n        };\n      },\n    });\n\n  // Lastly, register an event handler to listen for window-focus events as\n  // soon as the machine starts, and use it to send itself \"WINDOW_GOT_FOCUS\"\n  // events.\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const win = typeof window !== \"undefined\" ? window : undefined;\n    const root = win ?? doc;\n\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n\n        // Also tear down the old socket when stopping the machine, if there is one\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n\n  const cleanups = [];\n\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } =\n    defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n\n  // Install debug logging\n  // istanbul ignore next\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n\n  // Start the machine\n  machine.start();\n\n  return {\n    machine,\n    cleanups,\n\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable,\n    },\n  };\n}\n\n/**\n * The ManagedSocket will set up a WebSocket connection to a room, and maintain\n * that connection over time.\n *\n * It's a light wrapper around the actual FSM that implements the logic,\n * exposing just a few safe actions and events that can be called or observed\n * from the outside.\n */\nexport class ManagedSocket<T extends BaseAuthResult> {\n  #machine: FSM<Context, Event, State>;\n  #cleanups: (() => void)[];\n\n  public readonly events: {\n    /**\n     * Emitted when the WebSocket connection goes in or out of \"connected\"\n     * state.\n     */\n    readonly statusDidChange: Observable<Status>;\n    /**\n     * Emitted when the WebSocket connection is first opened.\n     */\n    readonly didConnect: Observable<void>;\n    /**\n     * Emitted when the current WebSocket connection is lost and the socket\n     * becomes useless. A new WebSocket connection must be made after this to\n     * restore connectivity.\n     */\n    readonly didDisconnect: Observable<void>; // Deliberate close, a connection loss, etc.\n\n    /**\n     * Emitted for every incoming message from the currently active WebSocket\n     * connection.\n     */\n    readonly onMessage: Observable<IWebSocketMessageEvent>;\n\n    /**\n     * Emitted whenever a connection gets closed for a known error reason, e.g.\n     * max number of connections, max number of messages, etc.\n     */\n    readonly onConnectionError: Observable<ConnectionError>;\n  };\n\n  constructor(\n    delegates: Delegates<T>,\n    enableDebugLogging: boolean = false,\n    waitForActorId: boolean = true\n  ) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n\n  getStatus(): Status {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue(): T | null {\n    return this.#machine.context.authValue as T | null;\n  }\n\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  public connect(): void {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  public reconnect(): void {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  public disconnect(): void {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  public destroy(): void {\n    this.#machine.stop();\n\n    let cleanup: (() => void) | undefined;\n    while ((cleanup = this.#cleanups.pop())) {\n      cleanup();\n    }\n  }\n\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  public send(data: string): void {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      console.warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1 /* WebSocket.OPEN */) {\n      console.warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  public _privateSendMachineEvent(event: Event): void {\n    this.#machine.send(event);\n  }\n}\n", "/**\n * Use this symbol to brand an object property as internal.\n *\n * @example\n * Object.defineProperty(\n *   {\n *     public,\n *     [kInternal]: {\n *       private\n *     },\n *   },\n *   kInternal,\n *   {\n *     enumerable: false,\n *   }\n * );\n */\nexport const kInternal = Symbol();\n", "import { isPlainObject } from \"./guards\";\n\nfunction shallowArray(xs: unknown[], ys: unknown[]): boolean {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction shallowObj(objA: unknown, objB: unknown): boolean {\n  // Only try to compare keys/values if these objects are both \"pojos\" (plain\n  // old JavaScript objects)\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(objB, key) &&\n      Object.is(objA[key], objB[key])\n  );\n}\n\n/**\n * Shallowly compares two given values.\n *\n * - Two simple values are considered equal if they're strictly equal\n * - Two arrays are considered equal if their members are strictly equal\n * - Two objects are considered equal if their values are strictly equal\n *\n * Testing goes one level deep.\n */\nexport function shallow(a: unknown, b: unknown): boolean {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n\n    return shallowArray(a, b);\n  }\n\n  return shallowObj(a, b);\n}\n\n/**\n * Two-level deep shallow check.\n * Useful for checking equality of { isLoading: false, myData: [ ... ] } like\n * data structures, where you want to do a shallow comparison on the \"data\"\n * key.\n *\n * NOTE: Works on objects only, not on arrays!\n */\nexport function shallow2(a: unknown, b: unknown): boolean {\n  if (!isPlainObject(a) || !isPlainObject(b)) {\n    return shallow(a, b);\n  }\n\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])\n  );\n}\n", "import { DefaultMap } from \"./DefaultMap\";\nimport { SortedList } from \"./SortedList\";\nimport { raise } from \"./utils\";\n\ntype PK = string;\n\n/**\n * A \"tree pool\" is a data structure that allows for easy insertion, deletion,\n * mutation, sorting, and accessing of an object pool of objects that have\n * tree-like relationships.\n *\n *   const pool = new TreePool<Simpson>(\n *     x => x.id,\n *     x => x.parent,\n *     (a, b) => a.name < b.name,\n *   );\n *\n * The first argument is a function that returns the primary key of an item.\n * The second argument is a function that returns the parent ID for an item (or null if its a root).\n * The third argument is a function that returns how to compare two items, to\n *   return queries in sorted order.\n *\n * To insert elements into the pool:\n *\n *   pool.upsert({ id: \"1\", name: \"Homer\" });\n *   pool.upsert({ id: \"2\", name: \"Marge\" });\n *   pool.upsert({ id: \"3\", name: \"Bart\", parent: \"2\" });\n *   pool.upsert({ id: \"4\", name: \"Lisa\", parent: \"2\" });\n *   pool.upsert({ id: \"5\", name: \"Maggie\", parent: \"2\" });\n *\n * To get all items in the pool:\n *\n *   // Items are sorted by the given comparison function, in this case\n *   // alphabetically, so: Bart, Homer, Lisa, Maggie, Marge\n *   Array.from(pool)  // [{ id: \"3\", name: \"Bart\", parent: \"2\" }, ...]\n *\n * To get all children:\n *\n *   // All kids are added as children of Marge\n *   pool.getChildren(\"1\")  // [] (Homer has no kids)\n *   pool.getChildren(\"2\")  // [Bart, Lisa, Maggie] (= alphabetically)\n *\n * To get all \"roots\":\n *   pool.getChildren(null)  // [Homer, Marge] (= alphabetically)\n *\n * To get all siblings:\n *   pool.getSiblings(\"3\")  // [Lisa, Maggie]\n *   pool.getSiblings(\"4\")  // [Bart, Maggie]\n *   pool.getSiblings(\"5\")  // [Bart, Lisa]\n *\n * A bit weird maybe, but Homer and Marge are siblings in this example:\n *   pool.getSiblings(\"1\")  // [Marge]\n *   pool.getSiblings(\"2\")  // [Homer]\n *\n * Changing data is no problem, as long as the primary key and parent key don't change:\n *   pool.upsert({ id: \"1\", name: \"Homer Simpson\" });\n *   pool.upsert({ id: \"3\", name: \"Bart, son of Marge\", parent: \"2\" });\n *\n * But... this will throw an error:\n *   pool.upsert({ id: \"3\", name: \"Bart, son of Homer\", parent: \"1\" });\n *   //                                                         ^^^\n *   //                                Cannot change parent ID. If you want to ever\n *   //                                do this, remove the entry, and recreate it!\n *\n * XXXX Idea for the API to iterate nodes in this tree in arbitrary ways:\n * Traversal can be done in all directions:\n *   pool.walk(\"4\", \"up\", { includeSelf: true })   // Iterates: Lisa, Marge\n *   pool.walk(\"4\", \"up\", { includeSelf: false })  // Iterates: Marge\n *   pool.walk(\"4\", \"left\")                        // Iterates: Bart    // Prev\n *   pool.walk(\"4\", \"right\")                       // Iterates: Maggie  // Next\n *   pool.walk(\"4\", \"depth-first\")\n *   pool.walk(\"4\", \"breadth-first\")\n *   pool.walk(\"4\", \"depth-first-reversed\")\n *   pool.walk(\"4\", \"breadth-first-reversed\")\n *\n */\nexport class TreePool<T> {\n  #_items: Map<PK, T>;\n  #_childrenOf: DefaultMap</* parent */ PK | null, /* children */ Set<PK>>;\n  #_sorted: SortedList<T>;\n\n  #_primaryKey: (item: T) => PK;\n  #_parentKeyFn: (item: T) => PK | null;\n  #_lt: (a: T, b: T) => boolean;\n\n  constructor(\n    primaryKey: (item: T) => PK,\n    parentKey: (item: T) => PK | null,\n    lt: (a: T, b: T) => boolean\n  ) {\n    this.#_primaryKey = primaryKey;\n    this.#_parentKeyFn = parentKey;\n    this.#_lt = lt;\n\n    this.#_items = new Map();\n    this.#_childrenOf = new DefaultMap(() => new Set());\n    this.#_sorted = SortedList.with(lt);\n  }\n\n  public get(id: PK): T | undefined {\n    return this.#_items.get(id);\n  }\n\n  public getOrThrow(id: PK): T {\n    return this.get(id) ?? raise(`Item with id ${id} not found`);\n  }\n\n  public get sorted(): SortedList<T> {\n    // XXXX While it's fine to expose this SortedList for efficiency, really we\n    // should be exposing it as a readonly value.\n    return this.#_sorted;\n  }\n\n  public getParentId(id: PK): PK | null {\n    const item = this.getOrThrow(id);\n    return this.#_parentKeyFn(item);\n  }\n\n  public getParent(id: PK): T | null {\n    const parentId = this.getParentId(id);\n    return parentId ? this.getOrThrow(parentId) : null;\n  }\n\n  public getChildren(id: PK | null): T[] {\n    const childIds = this.#_childrenOf.get(id);\n    if (!childIds) return [];\n\n    // XXXX Should we return a sorted list here? From previous note: Think about *storing* it as a sorted list here!\n    return Array.from(childIds).map(\n      (id) => this.#_items.get(id)! // eslint-disable-line no-restricted-syntax\n    );\n  }\n\n  public *walkUp(\n    id: PK,\n    predicate?: (item: T) => boolean\n    // options?: { includeSelf?: boolean },\n  ): IterableIterator<T> {\n    // const includeSelf = options?.includeSelf ?? true;\n    const includeSelf = true; // XXXX Generalize\n    let nodeId: PK | null = id;\n    do {\n      const item = this.getOrThrow(nodeId);\n      if (includeSelf || nodeId !== id) {\n        if (!predicate || predicate(item)) {\n          yield item;\n        }\n      }\n      nodeId = this.#_parentKeyFn(item);\n    } while (nodeId !== null);\n  }\n\n  // XXXX Generalize\n  public *walkLeft(\n    id: PK,\n    predicate?: (item: T) => boolean\n  ): IterableIterator<T> {\n    // XXXX Calling getSiblings is too inefficient, optimize later!\n    // XXXX But first make it work\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings.iterReversed()) {\n      // Skip over all the \"right\" siblings\n      if (this.#_lt(self, sibling)) continue;\n\n      // If we get here, it's a \"left\" sibling\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n\n  // XXXX Generalize\n  public *walkRight(\n    id: PK,\n    predicate?: (item: T) => boolean\n  ): IterableIterator<T> {\n    // XXXX Calling getSiblings is too inefficient, optimize later!\n    // XXXX But first make it work\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings) {\n      // Skip over all the \"left\" siblings\n      if (this.#_lt(sibling, self)) continue;\n\n      // If we get here, it's a \"right\" sibling\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n\n  // XXXX Generalize\n  public *walkDown(\n    id: PK,\n    predicate?: (item: T) => boolean\n    // _direction?: \"depth-first\",\n    // _reversed?: true\n    // | \"depth-first\"\n    // | \"breadth-first\"\n    // | \"breadth-first-rev\"\n    // options?: {\n    //   _direction: \"depth-first\";\n    //   _reversed: true;\n    //   // _includeSelf?: boolean;\n    // }\n  ): IterableIterator<T> {\n    const children = SortedList.from(this.getChildren(id), this.#_lt).rawArray;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      yield* this.walkDown(\n        this.#_primaryKey(child),\n        predicate\n        // \"depth-first\",\n        // true\n      );\n      if (!predicate || predicate(child)) {\n        yield child;\n      }\n    }\n\n    // if (options?.includeSelf) {\n    //   yield this.getOrThrow(id);\n    // }\n  }\n\n  /** Returns all siblings, not including the item itself. */\n  public getSiblings(id: PK): readonly T[] {\n    const self = this.getOrThrow(id);\n    const parentId = this.getParentId(id);\n    return this.getChildren(parentId).filter((item) => item !== self);\n  }\n\n  public [Symbol.iterator](): IterableIterator<T> {\n    return this.#_sorted[Symbol.iterator]();\n  }\n\n  public upsert(item: T): void {\n    const pk = this.#_primaryKey(item);\n    const existing = this.#_items.get(pk);\n    if (existing) {\n      // Allow upserts if the parent ID hasn't changed, otherwise, remove the\n      // entry and replace it with the new item\n      if (this.#_parentKeyFn(existing) !== this.#_parentKeyFn(item)) {\n        throw new Error(\n          \"Cannot upsert parent ID changes that change the tree structure. Remove the entry first, and recreate it\"\n        );\n      }\n\n      this.#_sorted.remove(existing);\n    }\n\n    this.#_items.set(pk, item);\n    this.#_sorted.add(item);\n\n    const parentId = this.#_parentKeyFn(item);\n    this.#_childrenOf.getOrCreate(parentId).add(pk);\n  }\n\n  public remove(pk: PK): boolean {\n    const item = this.#_items.get(pk);\n    if (!item) return false;\n\n    const childIds = this.#_childrenOf.get(pk);\n    if (childIds) {\n      throw new Error(\n        `Cannot remove item '${pk}' while it still has children. Remove children first.`\n      );\n    }\n\n    const parentId = this.#_parentKeyFn(item);\n    const siblings = this.#_childrenOf.get(parentId);\n    if (siblings) {\n      siblings.delete(pk);\n      if (siblings.size === 0) {\n        this.#_childrenOf.delete(parentId);\n      }\n    }\n\n    this.#_sorted.remove(item);\n    this.#_childrenOf.delete(pk);\n    this.#_items.delete(pk);\n    return true;\n  }\n\n  public clear(): boolean {\n    if (this.#_items.size === 0) return false;\n\n    this.#_childrenOf.clear();\n    this.#_items.clear();\n    this.#_sorted.clear();\n    return true;\n  }\n}\n", "import { isPlainObject } from \"../lib/guards\";\nimport type { Json } from \"../lib/Json\";\nimport { b64decode, tryParseJson } from \"../lib/utils\";\nimport type { IUserInfo } from \"./BaseUserMeta\";\n\nexport enum Permission {\n  Read = \"room:read\",\n  Write = \"room:write\",\n  PresenceWrite = \"room:presence:write\",\n  CommentsWrite = \"comments:write\",\n  CommentsRead = \"comments:read\",\n}\n\nexport type LiveblocksPermissions = Record<string, Permission[]>;\n\nexport enum TokenKind {\n  SECRET_LEGACY = \"sec-legacy\",\n  ACCESS_TOKEN = \"acc\",\n  ID_TOKEN = \"id\",\n}\n\n/**\n * Infers from the given scopes whether the user can write the document (e.g.\n * Storage and/or YDoc).\n */\nexport function canWriteStorage(scopes: readonly string[]): boolean {\n  return scopes.includes(Permission.Write);\n}\n\nexport function canComment(scopes: readonly string[]): boolean {\n  return (\n    scopes.includes(Permission.CommentsWrite) ||\n    scopes.includes(Permission.Write)\n  );\n}\n\ntype JwtMeta = {\n  iat: number;\n  exp: number;\n};\n\n/**\n * Legacy Secret Token.\n */\nexport type LegacySecretToken = {\n  k: TokenKind.SECRET_LEGACY;\n  roomId: string;\n  scopes: string[];\n\n  // Extra payload as defined by the customer's own authorization\n  id?: string;\n  info?: IUserInfo;\n\n  // IMPORTANT: All other fields on the JWT token are deliberately treated as\n  // opaque, and not relied on by the client.\n  [other: string]: Json | undefined;\n} & JwtMeta;\n\n/**\n * New authorization Access Token.\n */\nexport type AccessToken = {\n  k: TokenKind.ACCESS_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  perms: LiveblocksPermissions; // permissions\n  ui?: IUserInfo; // user info\n  ai?: boolean; // is AI Copilots enabled for this user?\n} & JwtMeta;\n\n/**\n * New authorization ID Token.\n */\nexport type IDToken = {\n  k: TokenKind.ID_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  gids?: string[]; // group ids\n  ui?: IUserInfo; // user info\n  ai?: boolean; // is AI Copilots enabled for this user?\n} & JwtMeta;\n\nexport type AuthToken = AccessToken | IDToken | LegacySecretToken;\n\n// The \"rich\" token is data we obtain by parsing the JWT token and making all\n// metadata on it accessible. It's done right after hitting the backend, but\n// before the promise will get returned, so it's an inherent part of the\n// authentication step.\nexport type ParsedAuthToken = {\n  readonly raw: string; // The raw JWT value, unchanged\n  readonly parsed: AuthToken; // Rich data on the JWT value\n};\n\nfunction isValidAuthTokenPayload(\n  data: Json\n): data is AccessToken | IDToken | LegacySecretToken {\n  return (\n    isPlainObject(data) &&\n    (data.k === TokenKind.ACCESS_TOKEN ||\n      data.k === TokenKind.ID_TOKEN ||\n      data.k === TokenKind.SECRET_LEGACY)\n  );\n}\n\n/**\n * Parses a raw JWT token string, which allows reading the metadata/payload of\n * the token.\n *\n * NOTE: Doesn't do any validation, so always treat the metadata as other user\n * input: never trust these values for anything important.\n */\nexport function parseAuthToken(rawTokenString: string): ParsedAuthToken {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n\n  return {\n    raw: rawTokenString,\n    parsed: payload,\n  };\n}\n", "import type { JsonObject } from \"./Json\";\nimport { tryParseJson } from \"./utils\";\n\nconst EMPTY_OBJECT = Object.freeze({}) as JsonObject;\n\n// Characters that can end partial keywords: n, u, l, t, r, e, f, a, s\nconst NULL_KEYWORD_CHARS = Array.from(new Set(\"null\"));\nconst TRUE_KEYWORD_CHARS = Array.from(new Set(\"true\"));\nconst FALSE_KEYWORD_CHARS = Array.from(new Set(\"false\"));\nconst ALL_KEYWORD_CHARS = Array.from(new Set(\"nulltruefalse\"));\n\n/**\n * Strips the last character from `str` if it is one of the chars in the given\n * `chars` string.\n */\nfunction stripChar(str: string, chars: string): string {\n  const lastChar = str[str.length - 1];\n  if (chars.includes(lastChar)) {\n    return str.slice(0, -1);\n  }\n  return str;\n}\n\nexport class IncrementalJsonParser {\n  // Input\n  #sourceText: string = \"\";\n\n  // Output\n  #cachedJson?: JsonObject;\n\n  /** How much we've already parsed */\n  #scanIndex: number = 0;\n  /** Whether the last char processed was a backslash */\n  #escaped: boolean = false;\n  /**\n   * Start position of the last unterminated string, -1 if we're not inside\n   * a string currently.\n   *\n   * Example: '{\"a\": \"foo'\n   *                 ^\n   */\n  #lastUnterminatedString: number = -1;\n  /**\n   * Start position of the last fully terminated string we've seen.\n   *\n   * Example: '{\"a\": \"foo'\n   *            ^\n   */\n  #lastTerminatedString: number = -1;\n  /** The bracket stack of expected closing chars. For input '{\"a\": [\"foo', the stack would be ['}', ']']. */\n  #stack: string[] = [];\n\n  constructor(text: string = \"\") {\n    this.append(text);\n  }\n\n  get source(): string {\n    return this.#sourceText;\n  }\n\n  get json(): JsonObject {\n    if (this.#cachedJson === undefined) {\n      this.#cachedJson = this.#parse();\n    }\n    return this.#cachedJson;\n  }\n\n  /** Whether we're currently inside an unterminated string, e.g. '{\"hello' */\n  get #inString(): boolean {\n    return this.#lastUnterminatedString >= 0;\n  }\n\n  append(delta: string): void {\n    if (delta) {\n      // Trim leading whitespace only on the first delta\n      if (this.#sourceText === \"\") {\n        delta = delta.trimStart();\n      }\n      this.#sourceText += delta;\n      this.#cachedJson = undefined; // Invalidate the cache\n    }\n  }\n\n  #autocompleteTail(output: string): string {\n    // Complete unambiguous partial JSON keywords,\n    // e.g. '{\"a\": -' → '{\"a\": -0'\n    //      '{\"a\": n' → '{\"a\": null'\n    //      '{\"a\": t' → '{\"a\": true'\n    //      '{\"a\": f' → '{\"a\": false'\n\n    if (this.#inString) {\n      return \"\"; // Don't complete anything if we're in an unterminated string\n    }\n\n    const lastChar = output.charAt(output.length - 1);\n    if (lastChar === \"\") return \"\";\n\n    // Handle incomplete negative numbers\n    if (lastChar === \"-\") {\n      return \"0\"; // Complete to -0\n    }\n\n    // Skip keyword completion for most characters that can't be part of keywords\n    if (!ALL_KEYWORD_CHARS.includes(lastChar)) return \"\";\n\n    // Check the last few characters directly\n    if (NULL_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"nul\")) return \"l\";\n      if (output.endsWith(\"nu\")) return \"ll\";\n      if (output.endsWith(\"n\")) return \"ull\";\n    }\n\n    if (TRUE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"tru\")) return \"e\";\n      if (output.endsWith(\"tr\")) return \"ue\";\n      if (output.endsWith(\"t\")) return \"rue\";\n    }\n\n    if (FALSE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"fals\")) return \"e\";\n      if (output.endsWith(\"fal\")) return \"se\";\n      if (output.endsWith(\"fa\")) return \"lse\";\n      if (output.endsWith(\"f\")) return \"alse\";\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Updates the internal parsing state by processing any new content\n   * that has been appended since the last parse. This updates the state with\n   * facts only. Any interpretation is left to the #parse() method.\n   */\n  #catchup(): void {\n    const newContent = this.#sourceText.slice(this.#scanIndex);\n\n    // Update internal parsing state by processing only the new content character by character\n    for (let i = 0; i < newContent.length; i++) {\n      const ch = newContent[i];\n      const absolutePos = this.#scanIndex + i;\n\n      if (this.#inString) {\n        if (this.#escaped) {\n          this.#escaped = false;\n        } else if (ch === \"\\\\\") {\n          this.#escaped = true;\n        } else if (ch === '\"') {\n          this.#lastTerminatedString = this.#lastUnterminatedString; // Save the terminated string's start\n          this.#lastUnterminatedString = -1; // Exit string\n        }\n      } else {\n        if (ch === '\"') {\n          this.#lastUnterminatedString = absolutePos; // Enter string\n        } else if (ch === \"{\") {\n          this.#stack.push(\"}\");\n        } else if (ch === \"[\") {\n          this.#stack.push(\"]\");\n        } else if (\n          ch === \"}\" &&\n          this.#stack.length > 0 &&\n          this.#stack[this.#stack.length - 1] === \"}\"\n        ) {\n          this.#stack.pop();\n        } else if (\n          ch === \"]\" &&\n          this.#stack.length > 0 &&\n          this.#stack[this.#stack.length - 1] === \"]\"\n        ) {\n          this.#stack.pop();\n        }\n      }\n    }\n\n    this.#scanIndex = this.#sourceText.length;\n  }\n\n  #parse(): JsonObject {\n    this.#catchup();\n\n    let result = this.#sourceText; // Already trimmed on first append\n\n    if (result.charAt(0) !== \"{\") {\n      // Not an object, don't even try to parse it\n      return EMPTY_OBJECT;\n    }\n\n    // If it's already valid JSON, return as-is\n    if (result.endsWith(\"}\")) {\n      const quickCheck = tryParseJson(result);\n      if (quickCheck) {\n        // Due to the '{' check above, we can safely assume it's an object\n        return quickCheck as JsonObject;\n      }\n    }\n\n    // Fix unterminated strings by appending a '\"' if needed\n    // Use our tracked state instead of recalculating\n    if (this.#inString) {\n      // If we're in an escaped state (last char was \\), remove that incomplete escape\n      if (this.#escaped) {\n        result = result.slice(0, -1); // Remove the trailing backslash\n      }\n      result += '\"';\n    }\n\n    // If the last char is a ',' or '.', we can strip it, because it won't\n    // change the value. Trim whitespace first, then check for comma/period.\n    result = result.trimEnd();\n    result = stripChar(result, \",.\");\n\n    // Complete partial keywords at the end (if umambiguous)\n    result = result + this.#autocompleteTail(result);\n\n    // Use the bracket stack to compute the suffix\n    const suffix = this.#stack.reduceRight((acc, ch) => acc + ch, \"\");\n\n    // Attempt to \"just\" add the missing ] and }'s.\n    {\n      const attempt = tryParseJson(result + suffix);\n      if (attempt) {\n        // If it parses, return the result\n        return attempt as JsonObject;\n      }\n    }\n\n    // If there is a parse failure above, it's likely because we're missing\n    // a \"value\" for a key in an object.\n\n    if (this.#inString) {\n      // We're in an unterminated string, just remove it - e.g. '{\"abc'\n      result = result.slice(0, this.#lastUnterminatedString);\n    } else {\n      // If the last char is a \":\", just remove it - e.g. '{\"abc\"' or '{\"abc\":'\n      result = stripChar(result, \":\");\n\n      // If the last char is a '\"', remove that last string\n      if (result.endsWith('\"')) {\n        result = result.slice(0, this.#lastTerminatedString);\n      }\n    }\n\n    // If the last char now is a trailing comma, strip it\n    result = stripChar(result, \",\");\n\n    // Re-add the missing brackets/braces\n    result += suffix;\n\n    // Run JSON.parse on the result again. it should now work!\n    return (tryParseJson(result) as JsonObject | undefined) ?? EMPTY_OBJECT; // Still invalid JSON\n  }\n}\n", "///\n/// This module is shared with the back-end.\n/// All types in this file represent _public_ types, observable in the client\n/// or in our protocol.\n///\n\nimport type { JSONSchema7 } from \"json-schema\";\n\nimport { assertNever } from \"../lib/assert\";\nimport { IncrementalJsonParser } from \"../lib/IncrementalJsonParser\";\nimport type { Json, JsonObject } from \"../lib/Json\";\nimport type { Relax } from \"../lib/Relax\";\nimport type { Resolve } from \"../lib/Resolve\";\nimport type { Brand, ISODateString } from \"../lib/utils\";\nimport { findLastIndex } from \"../lib/utils\";\n\nexport type Cursor = Brand<string, \"Cursor\">;\n\ntype ChatId = string;\n\n// --------------------------------------------------------------\n\nexport type MessageId = Brand<`ms_${string}`, \"MessageId\">;\nexport type CmdId = Brand<string, \"CmdId\">;\nexport type CopilotId = Brand<`co_${string}`, \"CopilotId\">;\n\n// A client WebSocket message is always a command to the server\nexport type ClientAiMsg = ClientCmd;\n\n// A server WebSocket message can be either a command response from the server,\n// or a server-initiated event\nexport type ServerAiMsg = ServerCmdResponse | ServerEvent;\n\n// Helper to create a pair of matching commands and responses\ntype DefineCmd<CmdName extends string, TRequest, TResponse> = [\n  Resolve<{ cmd: CmdName; cmdId: CmdId } & TRequest>,\n  Resolve<{ cmd: CmdName; cmdId: CmdId } & TResponse>,\n];\n\n// -------------------------------------------------------------------------------------------------\n// Commands are request/response pairs that are client-initiated\n// -------------------------------------------------------------------------------------------------\n\ntype CommandPair =\n  | GetChatsPair\n  | GetOrCreateChatPair\n  | DeleteChatPair\n  | GetMessageTreePair\n  | DeleteMessagePair\n  | ClearChatPair\n  | AskInChatPair\n  | AbortAiPair\n  | SetToolResultPair;\n\nexport type ClientCmd<T extends CommandPair = CommandPair> = T[0];\nexport type ServerCmdResponse<T extends CommandPair = CommandPair> = T[1];\n\nexport type GetChatsCmd = ClientCmd<GetChatsPair>;\nexport type GetOrCreateChatCmd = ClientCmd<GetOrCreateChatPair>;\nexport type DeleteChatCmd = ClientCmd<DeleteChatPair>;\nexport type GetMessageTreeCmd = ClientCmd<GetMessageTreePair>;\nexport type DeleteMessageCmd = ClientCmd<DeleteMessagePair>;\nexport type ClearChatCmd = ClientCmd<ClearChatPair>;\nexport type AskInChatCmd = ClientCmd<AskInChatPair>;\nexport type AbortAiCmd = ClientCmd<AbortAiPair>;\nexport type SetToolResultCmd = ClientCmd<SetToolResultPair>;\n\nexport type GetChatsResponse = ServerCmdResponse<GetChatsPair>;\nexport type GetOrCreateChatResponse = ServerCmdResponse<GetOrCreateChatPair>;\nexport type DeleteChatResponse = ServerCmdResponse<DeleteChatPair>;\nexport type GetMessageTreeResponse = ServerCmdResponse<GetMessageTreePair>;\nexport type DeleteMessageResponse = ServerCmdResponse<DeleteMessagePair>;\nexport type ClearChatResponse = ServerCmdResponse<ClearChatPair>;\nexport type AskInChatResponse = ServerCmdResponse<AskInChatPair>;\nexport type AbortAiResponse = ServerCmdResponse<AbortAiPair>;\nexport type SetToolResultResponse = ServerCmdResponse<SetToolResultPair>;\n\ntype GetChatsPair = DefineCmd<\n  \"get-chats\",\n  {\n    cursor?: Cursor;\n    pageSize?: number;\n    query?: { metadata?: Record<string, string | string[] | null> };\n  },\n  { chats: AiChat[]; nextCursor: Cursor | null }\n>;\n\nexport type CreateChatOptions = {\n  /** A human-friendly title for the chat. If not set, it will get auto-generated after the first response. */\n  title?: string;\n  /** Arbitrary metadata to record for this chat. This can be later used to filter the list of chats by metadata. */\n  metadata?: Record<string, string | string[]>;\n};\n\nexport type AiChatsQuery = {\n  metadata?: Record<string, string | string[] | null>;\n};\n\nexport type GetChatsOptions = {\n  /**\n   * The cursor to use for pagination.\n   */\n  cursor?: Cursor;\n  /**\n   * The query (including metadata) to filter chats by. If provided, only chats\n   * that match the query will be returned. If not provided, all chats will be returned.\n   * @example\n   * ```\n   * // Filter by presence of metadata values\n   * { metadata: { tag: [\"urgent\"] } }\n   *\n   * // Filter by absence of metadata key (key must not exist)\n   * { metadata: { archived: null } }\n   * ```\n   */\n  query?: AiChatsQuery;\n};\n\ntype GetOrCreateChatPair = DefineCmd<\n  \"get-or-create-chat\",\n  {\n    id: ChatId;\n    options?: CreateChatOptions;\n  },\n  { chat: AiChat }\n>;\n\ntype DeleteChatPair = DefineCmd<\n  \"delete-chat\",\n  { chatId: ChatId },\n  { chatId: ChatId }\n>;\n\ntype GetMessageTreePair = DefineCmd<\n  \"get-message-tree\",\n  { chatId: ChatId },\n  { chat: AiChat; messages: AiChatMessage[] }\n>;\n\ntype DeleteMessagePair = DefineCmd<\n  \"delete-message\",\n  { chatId: ChatId; messageId: MessageId },\n  { chatId: ChatId; messageId: MessageId }\n>;\n\ntype ClearChatPair = DefineCmd<\n  \"clear-chat\",\n  { chatId: ChatId },\n  { chatId: ChatId }\n>;\n\nexport type AiGenerationOptions = {\n  /**\n   * The copilot ID to use for this request. If not provided, a built-in\n   * default Copilot will be used instead of one that you configured via the\n   * dashboard.\n   */\n  copilotId?: CopilotId;\n  stream?: boolean; // default = true\n  tools?: AiToolDescription[];\n  knowledge?: AiKnowledgeSource[];\n  timeout?: number; // in millis\n};\n\ntype AskInChatPair = DefineCmd<\n  \"ask-in-chat\",\n  {\n    chatId: ChatId;\n\n    /** The chat message to use as the source to create the assistant response. */\n    sourceMessage:\n      | // An existing message ID to reply to\n      MessageId\n      // Or a new (!) message ID to create (optimistically created on the client)\n      | {\n          id: MessageId;\n          parentMessageId: MessageId | null; // The existing message to use as parent\n          content: AiUserContentPart[];\n        };\n\n    /**\n     * The new (!) message ID to output the assistant response into. This ID\n     * should be a non-existing message ID, optimistically assigned by the\n     * client. The output message will be created as a child to the source\n     * message ID.\n     */\n    targetMessageId: MessageId;\n\n    generationOptions: AiGenerationOptions;\n  },\n  {\n    sourceMessage?: AiChatMessage; // If optimistically created\n    targetMessage: AiChatMessage;\n  }\n>;\n\ntype AbortAiPair = DefineCmd<\n  \"abort-ai\",\n  { messageId: MessageId },\n  { ok: true }\n>;\n\n// This is the type that users are supposed to return from the `execute()` method (or call respond() or confirm() with)\n// prettier-ignore\nexport type ToolResultResponse<R extends JsonObject = JsonObject> =\n  Relax<\n    (\n      | { data: R; description?: string; }\n      | { error: string }\n      | { cancel: true | /* reason */ string }\n    )\n  >;\n\nexport type NonEmptyString<T extends string> = T & { __nonEmpty: true };\n\n// This is the type that will get passed back into the `render()` method for further inspection\nexport type RenderableToolResultResponse<R extends JsonObject = JsonObject> =\n  Relax<\n    | { type: \"success\"; data: R }\n    | { type: \"error\"; error: NonEmptyString<string> }\n    | { type: \"cancelled\"; cancelled: true; reason?: string }\n  >;\n\ntype SetToolResultPair = DefineCmd<\n  \"set-tool-result\",\n  {\n    chatId: ChatId;\n    messageId: MessageId;\n    invocationId: string;\n    result: ToolResultResponse;\n    generationOptions: AiGenerationOptions;\n  },\n  { ok: true; message: AiChatMessage } | { ok: false }\n>;\n\n// -------------------------------------------------------------------------------------------------\n// Server-initiated events\n// -------------------------------------------------------------------------------------------------\n\nexport type ServerEvent =\n  | RebootedEvent\n  | CmdFailedEvent\n  | WarningServerEvent\n  | ErrorServerEvent\n  | SyncServerEvent\n  | DeltaServerEvent\n  | SettleServerEvent;\n\n// Sent from the server any time it woke up from hibernation. If this happens,\n// it means that any pending messages a client is still tracking are lost track\n// of. We emit this event to connected clients, so they can mark all of their\n// pending messages as failed.\nexport type RebootedEvent = {\n  event: \"rebooted\";\n};\n\nexport type CmdFailedEvent = {\n  event: \"cmd-failed\";\n  failedCmd: CommandPair[0][\"cmd\"];\n  failedCmdId: CmdId;\n  error: string;\n};\n\nexport type WarningServerEvent = { event: \"warning\"; message: string };\nexport type ErrorServerEvent = { event: \"error\"; error: string };\n\nexport type SyncServerEvent = {\n  event: \"sync\";\n\n  // Stuff to upsert\n  chats?: AiChat[];\n  messages?: AiChatMessage[];\n\n  // Stuff to delete\n  clear?: ChatId[]; // Chats to clear\n  \"-chats\"?: ChatId[]; // Chats to delete\n  \"-messages\"?: Pick<AiChatMessage, \"id\" | \"chatId\">[]; // Messages to delete\n};\n\n/**\n * A \"delta\" event is sent to append an incoming delta chunk to an assistant\n * message.\n */\nexport type DeltaServerEvent = {\n  event: \"delta\";\n  id: MessageId;\n  delta: AiAssistantDeltaUpdate;\n};\n\n/**\n * A \"settle\" event happens after 0 or more \"delta\" messages, and signifies the\n * end of a stream of updates to a pending assistant message. This event turns\n * a pending message into either a completed or failed assistant message.\n */\nexport type SettleServerEvent = {\n  event: \"settle\";\n  message:\n    | AiAwaitingToolAssistantMessage\n    | AiCompletedAssistantMessage\n    | AiFailedAssistantMessage;\n};\n\n// -------------------------------------------------------------------------------------------------\n// Shared data types\n// -------------------------------------------------------------------------------------------------\n\nexport type AiChat = {\n  id: ChatId;\n  title: string;\n  metadata: Record<string, string | string[]>;\n  createdAt: ISODateString;\n  lastMessageAt?: ISODateString; // Optional since some chats might have no messages\n  deletedAt?: ISODateString; // Optional for soft-deleted chats\n};\n\nexport type AiToolDescription = {\n  name: string;\n  description?: string;\n  parameters: JSONSchema7;\n};\n\nexport type AiToolInvocationPart<\n  A extends JsonObject = JsonObject,\n  R extends JsonObject = JsonObject,\n> = Relax<\n  | AiReceivingToolInvocationPart\n  | AiExecutingToolInvocationPart<A>\n  | AiExecutedToolInvocationPart<A, R>\n>;\n\nexport type AiReceivingToolInvocationPart = {\n  type: \"tool-invocation\";\n  stage: \"receiving\";\n  invocationId: string;\n  name: string;\n  /** @internal */\n  partialArgsText: string; // The raw, partial JSON text value\n  partialArgs: JsonObject; // The interpreted, partial JSON value\n  /** @internal */\n  __appendDelta?: (delta: string) => void; // Internal method for delta updates\n};\n\nexport type AiExecutingToolInvocationPart<A extends JsonObject = JsonObject> = {\n  type: \"tool-invocation\";\n  stage: \"executing\";\n  invocationId: string;\n  name: string;\n  args: A;\n};\n\nexport type AiExecutedToolInvocationPart<\n  A extends JsonObject = JsonObject,\n  R extends JsonObject = JsonObject,\n> = {\n  type: \"tool-invocation\";\n  stage: \"executed\";\n  invocationId: string;\n  name: string;\n  args: A;\n  result: RenderableToolResultResponse<R>;\n};\n\nexport type AiTextPart = {\n  type: \"text\";\n  text: string;\n};\n\nexport type AiTextDelta = {\n  type: \"text-delta\";\n  textDelta: string;\n};\n\nexport type AiReasoningDelta = {\n  type: \"reasoning-delta\";\n  textDelta: string;\n};\n\n// Available since protocol V5, this is the start of a tool invocation stream\nexport type AiToolInvocationStreamStart = {\n  type: \"tool-stream\";\n  invocationId: string;\n  name: string;\n};\n\n// Available since protocol V5, this is a partial tool invocation that is being\n// constructed by the server and sent to the client as a delta. The client will\n// append this delta to the last tool invocation stream's partial JSON buffer\n// that will eventually become the full `args` value when JSON.parse()'ed.\nexport type AiToolInvocationDelta = {\n  type: \"tool-delta\";\n  /**\n   * The textual delta to be appended to the last tool invocation stream's\n   * partial JSON buffer that will eventually become the full `args` value when\n   * JSON.parse()'ed.\n   */\n  delta: string;\n};\n\nexport type AiReasoningPart = {\n  type: \"reasoning\";\n  text: string;\n  startedAt: ISODateString;\n  endedAt?: ISODateString;\n};\n\nexport type AiUploadedImagePart = {\n  type: \"image\";\n  id: string;\n  name: string;\n  size: number;\n  mimeType: string;\n};\n\n/**\n * Represents a pending or completed knowledge retrieval operation.\n * Since protocol V6.\n */\nexport type AiRetrievalPart = {\n  type: \"retrieval\";\n  kind: \"knowledge\";\n  id: string;\n  query: string;\n  startedAt: ISODateString;\n  endedAt?: ISODateString;\n};\n\n// \"Parts\" are what make up the \"content\" of a message.\n// \"Content\" is always an \"array of parts\".\nexport type AiUserContentPart = AiTextPart | AiUploadedImagePart;\nexport type AiAssistantContentPart =\n  | AiReasoningPart\n  | AiTextPart\n  | AiToolInvocationPart\n  | AiRetrievalPart;\n\nexport type AiAssistantDeltaUpdate =\n  | AiTextDelta // a delta appended to the last part (if text)\n  | AiReasoningDelta // a delta appended to the last part (if reasoning)\n  | AiExecutingToolInvocationPart // a tool invocation ready to be executed by the client\n\n  // Since protocol V5, if tool-call-streaming is enabled\n  | AiToolInvocationStreamStart // the start of a new tool-call stream\n  | AiToolInvocationDelta // a partial/under-construction tool invocation (since protocol V5)\n\n  // Since protocol V6, clients can receive retrieval parts\n  | AiRetrievalPart; // Emitted when created, and when later updated with endedAt\n\nexport type AiUserMessage = {\n  id: MessageId;\n  chatId: ChatId;\n  parentId: MessageId | null;\n  role: \"user\";\n  content: AiUserContentPart[];\n  createdAt: ISODateString;\n  deletedAt?: ISODateString;\n  /** @internal */\n  _optimistic?: true; // Only set by clients, never by server\n};\n\nexport type AiAssistantMessage = Relax<\n  | AiGeneratingAssistantMessage\n  | AiAwaitingToolAssistantMessage\n  | AiCompletedAssistantMessage\n  | AiFailedAssistantMessage\n>;\n\nexport type AiGeneratingAssistantMessage = {\n  id: MessageId;\n  chatId: ChatId;\n  parentId: MessageId | null;\n  role: \"assistant\";\n  createdAt: ISODateString;\n  deletedAt?: ISODateString;\n  copilotId?: CopilotId;\n\n  status: \"generating\";\n  contentSoFar: AiAssistantContentPart[];\n  /** @internal */\n  _optimistic?: true; // Only set by clients, never by server\n};\n\nexport type AiAwaitingToolAssistantMessage = {\n  id: MessageId;\n  chatId: ChatId;\n  parentId: MessageId | null;\n  role: \"assistant\";\n  createdAt: ISODateString;\n  deletedAt?: ISODateString;\n  copilotId?: CopilotId;\n\n  status: \"awaiting-tool\";\n  contentSoFar: AiAssistantContentPart[];\n  /** @internal */\n  _optimistic?: true; // Only set by clients, never by server\n};\n\nexport type AiCompletedAssistantMessage = {\n  id: MessageId;\n  chatId: ChatId;\n  parentId: MessageId | null;\n  role: \"assistant\";\n  content: AiAssistantContentPart[];\n  createdAt: ISODateString;\n  deletedAt?: ISODateString;\n  copilotId?: CopilotId;\n\n  status: \"completed\";\n  /** @internal */\n  _optimistic?: true; // Only set by clients, never by server\n};\n\nexport type AiFailedAssistantMessage = {\n  id: MessageId;\n  chatId: ChatId;\n  parentId: MessageId | null;\n  role: \"assistant\";\n  createdAt: ISODateString;\n  deletedAt?: ISODateString;\n  copilotId?: CopilotId;\n\n  status: \"failed\";\n  contentSoFar: AiAssistantContentPart[];\n  errorReason: string;\n  /** @internal */\n  _optimistic?: true; // Only set by clients, never by server\n};\n\nexport type AiChatMessage = Relax<AiUserMessage | AiAssistantMessage>;\n\nexport type AiKnowledgeSource = {\n  description: string;\n  value: Json;\n};\n\n// --------------------------------------------------------------------------------------------------\n\n/**\n * Finds the last item in the content array that matches the type and the given\n * keyFn. If found, replaces that item with newItem in the content array. If\n * not found, appends newItem to the content array.\n * Mutates the content array in-place.\n */\nfunction replaceOrAppend<const T extends AiAssistantContentPart>(\n  content: AiAssistantContentPart[],\n  newItem: T,\n  keyFn: (item: T) => string,\n  now: ISODateString\n): void {\n  const existingIndex = findLastIndex(\n    content,\n    (item) => item.type === newItem.type && keyFn(item as T) === keyFn(newItem)\n  );\n\n  if (existingIndex > -1) {\n    // Replace the existing one\n    content[existingIndex] = newItem;\n  } else {\n    // No existing one found, just append\n    closePart(content[content.length - 1], now);\n    content.push(newItem);\n  }\n}\n\n/**\n * Given a part, mutates it in-place by setting its endedAt timestamp.\n */\nfunction closePart(\n  prevPart: AiAssistantContentPart | undefined,\n  endedAt: ISODateString\n) {\n  // Currently, only reasoning parts have an endedAt timestamp\n  if (prevPart?.type === \"reasoning\") {\n    prevPart.endedAt ??= endedAt;\n  }\n}\n\nexport function patchContentWithDelta(\n  content: AiAssistantContentPart[],\n  delta: AiAssistantDeltaUpdate | null\n): void {\n  if (delta === null)\n    // Nothing to do\n    return;\n\n  const now = new Date().toISOString() as ISODateString;\n  const lastPart = content[content.length - 1] as\n    | AiAssistantContentPart\n    | undefined;\n\n  // Otherwise, append a new part type to the array, which we can start\n  // writing into\n  switch (delta.type) {\n    case \"text-delta\":\n      if (lastPart?.type === \"text\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now);\n        content.push({ type: \"text\", text: delta.textDelta });\n      }\n      break;\n\n    case \"reasoning-delta\":\n      if (lastPart?.type === \"reasoning\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now);\n        content.push({\n          type: \"reasoning\",\n          text: delta.textDelta,\n          startedAt: now,\n        });\n      }\n      break;\n\n    case \"tool-stream\": {\n      const toolInvocation = createReceivingToolInvocation(\n        delta.invocationId,\n        delta.name\n      );\n      content.push(toolInvocation);\n      break;\n    }\n\n    case \"tool-delta\": {\n      // Take the last part, expect it to be a tool invocation in receiving\n      // stage. If not, ignore this delta. If it is, append the delta to the\n      // parser\n      if (\n        lastPart?.type === \"tool-invocation\" &&\n        lastPart.stage === \"receiving\"\n      ) {\n        lastPart.__appendDelta?.(delta.delta);\n      }\n      // Otherwise ignore the delta - it's out of order or unexpected\n      break;\n    }\n\n    case \"tool-invocation\":\n      replaceOrAppend(content, delta, (x) => x.invocationId, now);\n      break;\n\n    case \"retrieval\":\n      replaceOrAppend(content, delta, (x) => x.id, now);\n      break;\n\n    default:\n      return assertNever(delta, \"Unhandled case\");\n  }\n}\n\n/**\n * Creates a receiving tool invocation part for testing purposes.\n * This helper eliminates the need to manually create fake tool invocation objects\n * and provides a clean API for tests.\n */\nexport function createReceivingToolInvocation(\n  invocationId: string,\n  name: string,\n  partialArgsText: string = \"\"\n): AiReceivingToolInvocationPart {\n  const parser = new IncrementalJsonParser(partialArgsText); // FRONTEND only\n  return {\n    type: \"tool-invocation\",\n    stage: \"receiving\",\n    invocationId,\n    name,\n    // --- Alternative implementation for FRONTEND only ------------------------\n    get partialArgsText(): string { return parser.source; }, // prettier-ignore\n    get partialArgs(): JsonObject { return parser.json; }, // prettier-ignore\n    __appendDelta(delta: string) { parser.append(delta); }, // prettier-ignore\n    // ------------------------------------------------------------------------\n  } satisfies AiReceivingToolInvocationPart;\n}\n", "import { AiChatDB } from \"./AiChatDB\";\nimport { getBearerTokenFromAuthValue } from \"./api-client\";\nimport type { AuthValue } from \"./auth-manager\";\nimport type { Delegates, Status } from \"./connection\";\nimport { ManagedSocket, StopRetrying } from \"./connection\";\nimport { kInternal } from \"./internal\";\nimport { assertNever } from \"./lib/assert\";\nimport { Promise_withResolvers } from \"./lib/controlledPromise\";\nimport { DefaultMap } from \"./lib/DefaultMap\";\nimport * as console from \"./lib/fancy-console\";\nimport { isDefined } from \"./lib/guards\";\nimport type { JsonObject } from \"./lib/Json\";\nimport { nanoid } from \"./lib/nanoid\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport { shallow, shallow2 } from \"./lib/shallow\";\nimport { batch, DerivedSignal, MutableSignal, Signal } from \"./lib/signals\";\nimport { TreePool } from \"./lib/TreePool\";\nimport type { Brand, DistributiveOmit, ISODateString } from \"./lib/utils\";\nimport { raise, tryParseJson } from \"./lib/utils\";\nimport { TokenKind } from \"./protocol/AuthToken\";\nimport type {\n  DynamicSessionInfo,\n  OptionalTupleUnless,\n  Polyfills,\n  StaticSessionInfo,\n  TimeoutID,\n} from \"./room\";\nimport type {\n  AbortAiResponse,\n  AiAssistantDeltaUpdate,\n  AiAssistantMessage,\n  AiChat,\n  AiChatMessage,\n  AiChatsQuery,\n  AiFailedAssistantMessage,\n  AiGeneratingAssistantMessage,\n  AiGenerationOptions,\n  AiKnowledgeSource,\n  AiToolDescription,\n  AiToolInvocationPart,\n  AiUserContentPart,\n  AiUserMessage,\n  AskInChatResponse,\n  ClearChatResponse,\n  ClientAiMsg,\n  CmdId,\n  CopilotId,\n  CreateChatOptions,\n  DeleteChatResponse,\n  DeleteMessageResponse,\n  GetChatsOptions,\n  GetChatsResponse,\n  GetMessageTreeResponse,\n  GetOrCreateChatResponse,\n  MessageId,\n  ServerAiMsg,\n  SetToolResultResponse,\n  ToolResultResponse,\n} from \"./types/ai\";\nimport { patchContentWithDelta } from \"./types/ai\";\nimport type { Awaitable } from \"./types/Awaitable\";\nimport type {\n  InferFromSchema,\n  JSONObjectSchema7,\n} from \"./types/InferFromSchema\";\nimport type {\n  IWebSocket,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport { PKG_VERSION } from \"./version\";\n\n// Server must respond to any command within 4 seconds. Note that this timeout\n// isn't related to the timeout for long-running AI tasks. If a long-running AI\n// task is started, the initial command response from the server is \"okay, I'll\n// keep you posted about this long-running task\". That okay is the response\n// which must happen within 4 seconds. In practice it should only take a few\n// milliseconds at most.\nconst DEFAULT_REQUEST_TIMEOUT = 4_000;\n\nexport type AiToolTypePack<\n  A extends JsonObject = JsonObject,\n  R extends JsonObject = JsonObject,\n> = {\n  A: A;\n  R: R;\n};\n\nexport type AskUserMessageInChatOptions = Omit<AiGenerationOptions, \"tools\">;\n\nexport type SetToolResultOptions = Omit<\n  AiGenerationOptions,\n  \"tools\" | \"knowledge\"\n>;\n\nexport type AiToolInvocationProps<\n  A extends JsonObject,\n  R extends JsonObject,\n> = Resolve<\n  DistributiveOmit<AiToolInvocationPart<A, R>, \"type\"> & {\n    respond: (\n      ...args: OptionalTupleUnless<R, [result: ToolResultResponse<R>]>\n    ) => void;\n\n    /**\n     * These are the inferred types for your tool call which you can pass down\n     * to UI components, like so:\n     *\n     *     <AiTool.Confirmation\n     *       types={types}\n     *       confirm={\n     *         // Now fully type-safe!\n     *         (args) => result\n     *       } />\n     *\n     * This will make your AiTool.Confirmation component aware of the types for\n     * `args` and `result`.\n     */\n    types: AiToolTypePack<A, R>;\n\n    // Private APIs\n    [kInternal]: {\n      execute: AiToolExecuteCallback<A, R> | undefined;\n      messageStatus: AiAssistantMessage[\"status\"];\n    };\n  }\n>;\n\nexport type AiOpaqueToolInvocationProps = AiToolInvocationProps<\n  JsonObject,\n  JsonObject\n>;\n\nexport type AiToolExecuteContext = {\n  name: string;\n  invocationId: string;\n};\n\nexport type AiToolExecuteCallback<\n  A extends JsonObject,\n  R extends JsonObject,\n> = (\n  args: A,\n  context: AiToolExecuteContext\n) => Record<string, never> extends R\n  ? Awaitable<ToolResultResponse<R> | undefined | void>\n  : Awaitable<ToolResultResponse<R>>;\n\nexport type AiToolDefinition<\n  S extends JSONObjectSchema7,\n  A extends JsonObject,\n  R extends JsonObject,\n> = {\n  description?: string;\n  parameters: S;\n  execute?: AiToolExecuteCallback<A, R>;\n  render?: (props: AiToolInvocationProps<A, R>) => unknown;\n  enabled?: boolean;\n};\n\nexport type AiOpaqueToolDefinition = AiToolDefinition<\n  JSONObjectSchema7,\n  JsonObject,\n  JsonObject\n>;\n\n/**\n * Helper function to help infer the types of `args`, `render`, and `result`.\n * This function has no runtime implementation and is only needed to make it\n * possible for TypeScript to infer types.\n */\nexport function defineAiTool<R extends JsonObject>() {\n  return <const S extends JSONObjectSchema7>(\n    def: AiToolDefinition<\n      S,\n      InferFromSchema<S> extends JsonObject ? InferFromSchema<S> : JsonObject,\n      R\n    >\n  ): AiOpaqueToolDefinition => {\n    return def as AiOpaqueToolDefinition;\n  };\n}\n\ntype NavigationInfo = {\n  /**\n   * The message ID of the parent message, or null if there is no parent.\n   */\n  parent: MessageId | null;\n  /**\n   * The message ID of the left sibling message, or null if there is no left sibling.\n   */\n  prev: MessageId | null;\n  /**\n   * The message ID of the right sibling message, or null if there is no right sibling.\n   */\n  next: MessageId | null;\n};\n\nexport type WithNavigation<T> = T & { navigation: NavigationInfo };\n\ntype UiChatMessage = WithNavigation<AiChatMessage>;\n\ntype AiContext = {\n  staticSessionInfoSig: Signal<StaticSessionInfo | null>;\n  dynamicSessionInfoSig: Signal<DynamicSessionInfo | null>;\n  pendingCmds: Map<\n    CmdId,\n    {\n      resolve: (value: ServerAiMsg) => void;\n      reject: (reason: unknown) => void;\n    }\n  >;\n  chatsStore: ReturnType<typeof createStore_forUserAiChats>;\n  toolsStore: ReturnType<typeof createStore_forTools>;\n  messagesStore: ReturnType<typeof createStore_forChatMessages>;\n  knowledge: KnowledgeStack;\n};\n\ntype LayerKey = Brand<string, \"LayerKey\">;\n\nexport class KnowledgeStack {\n  #_layers: Set<LayerKey>;\n\n  #stack: DefaultMap<string, Map<LayerKey, AiKnowledgeSource | null>>;\n  //                 /                \\\n  //      knowledge key               \"layer\" key\n  //      (random, or optionally      (one entry per mounted component)\n  //       set by user)\n  #_cache: AiKnowledgeSource[] | undefined;\n\n  constructor() {\n    this.#_layers = new Set<LayerKey>();\n    this.#stack = new DefaultMap(\n      () => new Map<LayerKey, AiKnowledgeSource | null>()\n    );\n    this.#_cache = undefined;\n  }\n\n  // Typically a useId()\n  registerLayer(uniqueLayerId: string): LayerKey {\n    const layerKey = uniqueLayerId as LayerKey;\n    if (this.#_layers.has(layerKey))\n      raise(`Layer '${layerKey}' already exists, provide a unique layer id`);\n    this.#_layers.add(layerKey);\n    return layerKey;\n  }\n\n  deregisterLayer(layerKey: LayerKey): void {\n    this.#_layers.delete(layerKey);\n    let deleted = false;\n    for (const [key, knowledge] of this.#stack) {\n      if (knowledge.delete(layerKey)) {\n        deleted = true;\n      }\n      if (knowledge.size === 0)\n        // Just memory cleanup\n        this.#stack.delete(key);\n    }\n    if (deleted) {\n      this.invalidate();\n    }\n  }\n\n  get(): AiKnowledgeSource[] {\n    return (this.#_cache ??= this.#recompute());\n  }\n\n  invalidate(): void {\n    this.#_cache = undefined;\n  }\n\n  #recompute(): AiKnowledgeSource[] {\n    return Array.from(this.#stack.values()).flatMap((layer) =>\n      // Return only the last item (returns [] when empty)\n      Array.from(layer.values()).slice(-1).filter(isDefined)\n    );\n  }\n\n  updateKnowledge(\n    layerKey: LayerKey,\n    key: string,\n    data: AiKnowledgeSource | null\n  ): void {\n    if (!this.#_layers.has(layerKey)) raise(`Unknown layer key: ${layerKey}`);\n    this.#stack.getOrCreate(key).set(layerKey, data);\n    this.invalidate();\n  }\n}\n\nexport type GetOrCreateChatOptions = {\n  name: string;\n  metadata?: AiChat[\"metadata\"];\n};\n\nfunction now(): ISODateString {\n  return new Date().toISOString() as ISODateString;\n}\n\n// Symbol used to register tools globally. These tools are not scoped to\n// a particular chatId and made available to any AiChat instance.\nconst kWILDCARD = Symbol(\"*\");\n\nfunction createStore_forTools() {\n  const toolsByChatIdΣ = new DefaultMap(\n    (_chatId: string | typeof kWILDCARD) => {\n      return new DefaultMap((_name: string) => {\n        return new Signal<AiOpaqueToolDefinition | undefined>(undefined);\n      });\n    }\n  );\n\n  //\n  // TODO This administration is pretty ugly at the moment.\n  // Would be nice to have some kind of helper for constructing these\n  // structures. Maintaining them in all these different DefaultMaps is pretty\n  // getting pretty tricky. Ideas are very welcomed!\n  //\n  // Key here is: '[\"my-tool\",\"my-chat\"]' or just '[\"my-tool\"]' (for global tools)\n  //\n  const globalOrScopedToolΣ = new DefaultMap((nameAndChat: string) => {\n    const [name, chatId] = tryParseJson(nameAndChat) as [\n      string,\n      string | undefined,\n    ];\n    return DerivedSignal.from(() => {\n      return (\n        // A tool that's registered and scoped to a specific chat ID...\n        (chatId !== undefined\n          ? toolsByChatIdΣ.getOrCreate(chatId).getOrCreate(name)\n          : undefined\n        )?.get() ??\n        // ...or a globally registered tool\n        toolsByChatIdΣ.getOrCreate(kWILDCARD).getOrCreate(name).get()\n      );\n    });\n  });\n\n  function getToolΣ(name: string, chatId?: string) {\n    const key = JSON.stringify(chatId !== undefined ? [name, chatId] : [name]);\n    return globalOrScopedToolΣ.getOrCreate(key);\n  }\n\n  function registerTool(\n    name: string,\n    tool: AiOpaqueToolDefinition,\n    chatId?: string\n  ) {\n    if (!tool.execute && !tool.render) {\n      throw new Error(\n        \"A tool definition must have an execute() function, a render() function, or both.\"\n      );\n    }\n\n    const key = chatId ?? kWILDCARD;\n    toolsByChatIdΣ.getOrCreate(key).getOrCreate(name).set(tool);\n\n    return () => unregisterTool(key, name);\n  }\n\n  function unregisterTool(chatId: string | typeof kWILDCARD, name: string) {\n    const tools = toolsByChatIdΣ.get(chatId);\n    if (tools === undefined) return;\n    const tool = tools.get(name);\n    if (tool === undefined) return;\n    tool.set(undefined);\n  }\n\n  function getToolDescriptions(chatId: string): AiToolDescription[] {\n    const globalToolsΣ = toolsByChatIdΣ.get(kWILDCARD);\n    const scopedToolsΣ = toolsByChatIdΣ.get(chatId);\n    return Array.from([\n      ...(globalToolsΣ?.entries() ?? []),\n      ...(scopedToolsΣ?.entries() ?? []),\n    ]).flatMap(([name, toolΣ]) => {\n      const tool = toolΣ.get();\n      return tool && (tool.enabled ?? true)\n        ? [{ name, description: tool.description, parameters: tool.parameters }]\n        : [];\n    });\n  }\n\n  return {\n    getToolDescriptions,\n\n    getToolΣ,\n    registerTool,\n  };\n}\n\nfunction createStore_forChatMessages(\n  toolsStore: ReturnType<typeof createStore_forTools>,\n  setToolResultFn: (\n    chatId: string,\n    messageId: MessageId,\n    invocationId: string,\n    result: ToolResultResponse,\n    options?: SetToolResultOptions\n  ) => Promise<void>\n) {\n  // Keeps track of all message IDs that are originated from this client. We\n  // use this concept of \"ownership\" to determine which client instance is\n  // allowed to auto-execute tool invocations for this message.\n  const myMessages = new Set<MessageId>();\n\n  // Keeps track of any tool invocations that have been auto-executed by this\n  // client. Note that this can also record invocations that don't have an\n  // execute() function. In that case, we also handled it (by kicking off nothing).\n  const handledInvocations = new Set<string>();\n\n  // We maintain a Map with mutable signals. Each such signal contains\n  // a mutable automatically-sorted list of chat messages by chat ID.\n  const messagePoolByChatIdΣ = new DefaultMap(\n    (_chatId: string) =>\n      new MutableSignal(\n        new TreePool<AiChatMessage>(\n          (x) => x.id,\n          (x) => x.parentId,\n          (x, y) => x.createdAt < y.createdAt\n        )\n      )\n  );\n\n  // Separately from that, we track all _generating_ signals in a separate\n  // administration. Because generating messages are likely to receive\n  // many/frequent updates, updating them in a separate administration makes\n  // rendering streaming contents much more efficient than if we had to\n  // re-create and re-render the entire chat list on every such update.\n  const generatingMessagesΣ = new MutableSignal(\n    new Map<MessageId, AiGeneratingAssistantMessage>()\n  );\n\n  function createOptimistically(\n    chatId: string,\n    role: \"user\",\n    parentId: MessageId | null,\n    content: AiUserContentPart[]\n  ): MessageId;\n  function createOptimistically(\n    chatId: string,\n    role: \"assistant\",\n    parentId: MessageId | null,\n    copilotId?: CopilotId\n  ): MessageId;\n  function createOptimistically(\n    chatId: string,\n    role: \"user\" | \"assistant\",\n    parentId: MessageId | null,\n    third?: AiUserContentPart[] | CopilotId\n  ) {\n    const id = `ms_${nanoid()}` as MessageId;\n    const createdAt = now();\n    if (role === \"user\") {\n      const content = third as AiUserContentPart[];\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        content,\n        _optimistic: true,\n      } satisfies AiUserMessage);\n    } else {\n      const copilotId = third as CopilotId | undefined;\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        status: \"generating\",\n        contentSoFar: [],\n        copilotId,\n        _optimistic: true,\n      } satisfies AiGeneratingAssistantMessage);\n    }\n    return id;\n  }\n\n  function upsertMany(messages: AiChatMessage[]): void {\n    batch(() => {\n      for (const message of messages) {\n        upsert(message);\n      }\n    });\n  }\n\n  function remove(chatId: string, messageId: MessageId): void {\n    const chatMsgsΣ = messagePoolByChatIdΣ.get(chatId);\n    if (!chatMsgsΣ) return;\n\n    const existing = chatMsgsΣ.get().get(messageId);\n    if (!existing || existing.deletedAt) return;\n\n    if (existing.role === \"assistant\" && existing.status !== \"completed\") {\n      upsert({ ...existing, deletedAt: now(), contentSoFar: [] });\n    } else {\n      upsert({ ...existing, deletedAt: now(), content: [] });\n    }\n  }\n\n  function removeByChatId(chatId: string): void {\n    const chatMsgsΣ = messagePoolByChatIdΣ.get(chatId);\n    if (chatMsgsΣ === undefined) return;\n    chatMsgsΣ.mutate((pool) => pool.clear());\n  }\n\n  function upsert(message: AiChatMessage): void {\n    batch(() => {\n      const chatMsgsΣ = messagePoolByChatIdΣ.getOrCreate(message.chatId);\n      chatMsgsΣ.mutate((pool) => pool.upsert(message));\n\n      // If the message is a pending update, write it to the generating\n      // messages LUT. If not, remove it from there.\n      if (message.role === \"assistant\" && message.status === \"generating\") {\n        generatingMessagesΣ.mutate((lut) => {\n          lut.set(message.id, structuredClone(message));\n        });\n      } else {\n        generatingMessagesΣ.mutate((lut) => {\n          lut.delete(message.id);\n        });\n      }\n\n      //\n      // If this message has \"awaiting-tool\" status, it may be the client's\n      // move to trigger an action / call an execute function.\n      //\n      // We will automatically invoke execute()...\n      // - only if such function is provided by the user\n      // - at most once (which is why we track it in seenToolCallIds)\n      // - and only if the current client ID is the designated client ID\n      //\n      if (message.role === \"assistant\" && message.status === \"awaiting-tool\") {\n        if (myMessages.has(message.id)) {\n          for (const toolInvocation of message.contentSoFar.filter(\n            (part) =>\n              part.type === \"tool-invocation\" && part.stage === \"executing\"\n          )) {\n            if (!handledInvocations.has(toolInvocation.invocationId)) {\n              handledInvocations.add(toolInvocation.invocationId);\n            } else {\n              // Do nothing, we already kicked this one off\n              continue;\n            }\n\n            const executeFn = toolsStore\n              .getToolΣ(toolInvocation.name, message.chatId)\n              .get()?.execute;\n            if (executeFn) {\n              (async () => {\n                const result = await executeFn(toolInvocation.args, {\n                  name: toolInvocation.name,\n                  invocationId: toolInvocation.invocationId,\n                });\n                return await setToolResultFn(\n                  message.chatId,\n                  message.id,\n                  toolInvocation.invocationId,\n                  result ?? { data: {} },\n                  { copilotId: message.copilotId } // TODO: Should we pass the other generation options (tools, knowledge) as well?\n                );\n              })().catch((err) => {\n                console.error(\n                  `Error trying to respond to tool-call: ${String(err)} (in execute())`\n                );\n              });\n            }\n          }\n        }\n      } else {\n        // Clean up the ownership administration\n        if (message.role === \"assistant\" && message.status === \"generating\") {\n          // ...unless it's still generating\n        } else {\n          myMessages.delete(message.id);\n        }\n      }\n    });\n  }\n\n  function addDelta(messageId: MessageId, delta: AiAssistantDeltaUpdate): void {\n    generatingMessagesΣ.mutate((lut) => {\n      const message = lut.get(messageId);\n      if (message === undefined) return false;\n\n      patchContentWithDelta(message.contentSoFar, delta);\n      lut.set(messageId, message);\n      return true;\n    });\n  }\n\n  function* iterGeneratingMessages() {\n    for (const chatMsgsΣ of messagePoolByChatIdΣ.values()) {\n      for (const m of chatMsgsΣ.get()) {\n        if (\n          m.role === \"assistant\" &&\n          m.status === \"generating\" &&\n          !m._optimistic\n        ) {\n          yield m;\n        }\n      }\n    }\n  }\n\n  function failAllPending(): void {\n    batch(() => {\n      generatingMessagesΣ.mutate((lut) => {\n        let deleted = false;\n        for (const [k, v] of lut) {\n          if (!v._optimistic) {\n            lut.delete(k);\n            deleted = true;\n          }\n        }\n        return deleted;\n      });\n\n      upsertMany(\n        Array.from(iterGeneratingMessages()).map(\n          (message) =>\n            ({\n              ...message,\n              status: \"failed\",\n              errorReason: \"Lost connection\",\n            }) as AiFailedAssistantMessage\n        )\n      );\n    });\n  }\n\n  function getMessageById(messageId: MessageId): AiChatMessage | undefined {\n    for (const messagesΣ of messagePoolByChatIdΣ.values()) {\n      const message = messagesΣ.get().get(messageId);\n      if (message) {\n        return message;\n      }\n    }\n    return undefined;\n  }\n\n  function first<T>(iterable: IterableIterator<T>): T | undefined {\n    const result = iterable.next();\n    return result.done ? undefined : result.value;\n  }\n\n  function selectBranch(\n    pool: TreePool<AiChatMessage>,\n    preferredBranch: MessageId | null\n  ): UiChatMessage[] {\n    function isAlive(message: AiChatMessage): boolean {\n      // This could be generalized by doing a walk(\n      //   { direction: 'down',\n      //     type: 'breadth-first',\n      //     includeSelf: true,\n      //     predicate: m => !m.deletedAt,\n      //   })\n\n      // If it's a non-deleted message, it's alive\n      if (!message.deletedAt) {\n        return true;\n      }\n      for (const _ of pool.walkDown(message.id, (m) => !m.deletedAt)) {\n        return true;\n      }\n      return false;\n    }\n\n    function selectSpine(leaf: AiChatMessage): UiChatMessage[] {\n      const spine = [];\n\n      let lastVisitedMessage: UiChatMessage | null = null;\n      for (const message of pool.walkUp(leaf.id)) {\n        const prev = first(pool.walkLeft(message.id, isAlive))?.id ?? null;\n        const next = first(pool.walkRight(message.id, isAlive))?.id ?? null;\n\n        // Remove deleted messages only if they don't have any non-deleted\n        // children, and also don't have a next/prev link, requiring the\n        // deleted node to have an on-screen presence.\n        if (!message.deletedAt || prev || next) {\n          const node: UiChatMessage = {\n            ...message,\n            navigation: { parent: null, prev, next },\n          };\n          // Set the parent of the last visited to the id of the current node.\n          if (lastVisitedMessage !== null) {\n            lastVisitedMessage.navigation.parent = node.id;\n          }\n          lastVisitedMessage = node;\n          spine.push(node);\n        }\n      }\n      return spine.reverse();\n    }\n\n    function fallback(): UiChatMessage[] {\n      const latest = pool.sorted.findRight((m) => !m.deletedAt);\n      return latest ? selectSpine(latest) : [];\n    }\n\n    if (preferredBranch === null) {\n      return fallback();\n    }\n\n    const message = pool.get(preferredBranch);\n    if (!message) {\n      return fallback();\n    }\n\n    // Find the first non-deleted grand child. If one doesn't exist, keep\n    // walking up the tree and repeat, until we find one.\n    for (const current of pool.walkUp(message.id)) {\n      // If a non-deleted grandchild exists, select it.\n      for (const desc of pool.walkDown(current.id, (m) => !m.deletedAt)) {\n        return selectSpine(desc);\n      }\n\n      // If the current node is not deleted, select it.\n      if (!current.deletedAt) {\n        return selectSpine(current);\n      }\n\n      // Otherwise, continue looping by walking up one level and repeating.\n    }\n\n    return fallback();\n  }\n\n  const immutableMessagesByBranch = new DefaultMap((chatId: string) => {\n    return new DefaultMap((branchId: MessageId | null) => {\n      const messagesΣ = DerivedSignal.from(() => {\n        const pool = messagePoolByChatIdΣ.getOrCreate(chatId).get();\n        return selectBranch(pool, branchId);\n      }, shallow2);\n\n      return DerivedSignal.from((): UiChatMessage[] => {\n        const generatingMessages = generatingMessagesΣ.get();\n        return messagesΣ.get().map((message) => {\n          if (message.role !== \"assistant\" || message.status !== \"generating\") {\n            return message;\n          }\n          const generatingMessage = generatingMessages.get(message.id);\n          if (generatingMessage === undefined) return message;\n          return {\n            ...message,\n            contentSoFar: generatingMessage.contentSoFar,\n          } satisfies AiGeneratingAssistantMessage;\n        });\n      }, shallow);\n    });\n  });\n\n  function getChatMessagesForBranchΣ(chatId: string, branch?: MessageId) {\n    return immutableMessagesByBranch\n      .getOrCreate(chatId)\n      .getOrCreate(branch || null);\n  }\n\n  function getLastUsedCopilotId(chatId: string): CopilotId | undefined {\n    const pool = messagePoolByChatIdΣ.getOrCreate(chatId).get();\n    // Find the most recent non-deleted assistant message\n    const latest = pool.sorted.findRight(\n      (m) => m.role === \"assistant\" && !m.deletedAt\n    );\n    return latest?.copilotId;\n  }\n\n  return {\n    // Readers\n    getMessageById,\n    getChatMessagesForBranchΣ,\n    getLastUsedCopilotId,\n\n    // Mutations\n    createOptimistically,\n    upsert,\n    upsertMany,\n    remove,\n    removeByChatId,\n    addDelta,\n    failAllPending,\n\n    markMine(messageId: MessageId) {\n      myMessages.add(messageId);\n    },\n\n    /**\n     * Iterates over all my auto-executing messages.\n     *\n     * These are messages that match all these conditions:\n     * - The message is an assistant message\n     * - The message is owned by this client (\"mine\")\n     * - The message is currently in \"awaiting-tool\" status\n     * - The message has at least one tool invocation in \"executing\" stage\n     * - The tool invocation has an execute() function defined\n     */\n    *getAutoExecutingMessageIds(): Iterable<MessageId> {\n      for (const messageId of myMessages) {\n        const message = getMessageById(messageId);\n        if (\n          message?.role === \"assistant\" &&\n          message.status === \"awaiting-tool\"\n        ) {\n          const isAutoExecuting = message.contentSoFar.some((part) => {\n            if (part.type === \"tool-invocation\" && part.stage === \"executing\") {\n              const tool = toolsStore.getToolΣ(part.name, message.chatId).get();\n              return typeof tool?.execute === \"function\";\n            }\n            return false;\n          });\n\n          if (isAutoExecuting) {\n            yield message.id;\n          }\n        }\n      }\n    },\n  };\n}\n\nfunction createStore_forUserAiChats() {\n  const chatsDB = new AiChatDB();\n\n  function upsertMany(chats: AiChat[]) {\n    batch(() => {\n      for (const chat of chats) {\n        chatsDB.upsert(chat);\n      }\n    });\n  }\n\n  function upsert(chat: AiChat) {\n    chatsDB.upsert(chat);\n  }\n\n  /**\n   * \"Just\" deleting a chat we already know about might break assumptions in\n   * clients that are currently displaying the chat on-screen. So instead,\n   * we'll re-render those so they can display the chat is deleted.\n   */\n  function markDeleted(chatId: string) {\n    chatsDB.markDeleted(chatId);\n  }\n\n  function getChatById(chatId: string) {\n    return chatsDB.getEvenIfDeleted(chatId);\n  }\n\n  function findMany(query: AiChatsQuery): AiChat[] {\n    return chatsDB.signal.get().findMany(query);\n  }\n\n  return {\n    getChatById,\n\n    findMany,\n\n    // Mutations\n    upsert,\n    upsertMany,\n    markDeleted,\n  };\n}\n\n/** @private This API will change, and is not considered stable. DO NOT RELY on it. */\nexport type Ai = {\n  [kInternal]: {\n    context: AiContext;\n  };\n  connectInitially: () => void;\n  // connect: () => void;\n  // reconnect: () => void;\n  disconnect: () => void;\n  getStatus: () => Status;\n\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getChats: (options?: GetChatsOptions) => Promise<GetChatsResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getOrCreateChat: (\n    /** A unique identifier for the chat. */\n    chatId: string,\n    options?: CreateChatOptions\n  ) => Promise<GetOrCreateChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  deleteChat: (chatId: string) => Promise<DeleteChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getMessageTree: (chatId: string) => Promise<GetMessageTreeResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  deleteMessage: (\n    chatId: string,\n    messageId: MessageId\n  ) => Promise<DeleteMessageResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  clearChat: (chatId: string) => Promise<ClearChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  askUserMessageInChat: (\n    chatId: string,\n    userMessage:\n      | MessageId\n      | {\n          id: MessageId;\n          parentMessageId: MessageId | null;\n          content: AiUserContentPart[];\n        },\n    targetMessageId: MessageId,\n    options?: AskUserMessageInChatOptions\n  ) => Promise<AskInChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  abort: (messageId: MessageId) => Promise<AbortAiResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  setToolResult: (\n    chatId: string,\n    messageId: MessageId,\n    invocationId: string,\n    result: ToolResultResponse,\n    options?: SetToolResultOptions\n  ) => Promise<void>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  signals: {\n    getChatMessagesForBranchΣ(\n      chatId: string,\n      branch?: MessageId\n    ): DerivedSignal<UiChatMessage[]>;\n    getToolΣ(\n      name: string,\n      chatId?: string\n    ): DerivedSignal<AiOpaqueToolDefinition | undefined>;\n  };\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getChatById: (chatId: string) => AiChat | undefined;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  queryChats: (query: AiChatsQuery) => AiChat[];\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getLastUsedCopilotId: (chatId: string) => CopilotId | undefined;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  registerKnowledgeLayer: (uniqueLayerId: string) => LayerKey;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  deregisterKnowledgeLayer: (layerKey: LayerKey) => void;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  updateKnowledge: (\n    layerKey: LayerKey,\n    data: AiKnowledgeSource,\n    key?: string\n  ) => void;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  registerTool: (\n    name: string,\n    tool: AiOpaqueToolDefinition,\n    chatId?: string\n  ) => () => void;\n};\n\n/** @internal */\nexport type AiConfig = {\n  delegates: Delegates<AuthValue>;\n\n  userId?: string;\n  lostConnectionTimeout: number;\n  backgroundKeepAliveTimeout?: number;\n  polyfills?: Polyfills;\n\n  enableDebugLogging?: boolean;\n};\n\nexport function createAi(config: AiConfig): Ai {\n  const managedSocket: ManagedSocket<AuthValue> = new ManagedSocket(\n    config.delegates,\n    config.enableDebugLogging,\n    false // AI doesn't have actors (yet, but it will)\n  );\n\n  const chatsStore = createStore_forUserAiChats();\n  const toolsStore = createStore_forTools();\n  const messagesStore = createStore_forChatMessages(toolsStore, setToolResult);\n  const context: AiContext = {\n    staticSessionInfoSig: new Signal<StaticSessionInfo | null>(null),\n    dynamicSessionInfoSig: new Signal<DynamicSessionInfo | null>(null),\n    pendingCmds: new Map(),\n    chatsStore,\n    messagesStore,\n    toolsStore,\n    knowledge: new KnowledgeStack(),\n  };\n\n  // Delta batch processing system to throttle incoming delta updates. Incoming\n  // deltas are buffered and only let through every every 25ms. This creates\n  // a ceiling of max 40 rerenders/second during streaming.\n  const DELTA_THROTTLE = 25;\n  let pendingDeltas: { id: MessageId; delta: AiAssistantDeltaUpdate }[] = [];\n  let deltaBatchTimer: ReturnType<typeof setTimeout> | null = null;\n\n  function flushPendingDeltas() {\n    const currentQueue = pendingDeltas;\n\n    pendingDeltas = [];\n    if (deltaBatchTimer !== null) {\n      clearTimeout(deltaBatchTimer);\n      deltaBatchTimer = null;\n    }\n\n    // Process all pending deltas in a single batch\n    batch(() => {\n      for (const { id, delta } of currentQueue) {\n        context.messagesStore.addDelta(id, delta);\n      }\n    });\n  }\n\n  function enqueueDelta(id: MessageId, delta: AiAssistantDeltaUpdate) {\n    pendingDeltas.push({ id, delta });\n\n    // If no timer is running, start one to process the batch\n    if (deltaBatchTimer === null) {\n      deltaBatchTimer = setTimeout(flushPendingDeltas, DELTA_THROTTLE);\n    }\n  }\n\n  let lastTokenKey: string | undefined;\n  function onStatusDidChange(_newStatus: Status) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === TokenKind.SECRET_LEGACY ? token.id : token.uid,\n            userInfo:\n              token.k === TokenKind.SECRET_LEGACY ? token.info : token.ui,\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: undefined,\n            userInfo: undefined,\n          });\n        }\n      }\n    }\n  }\n  let _connectionLossTimerId: TimeoutID | undefined;\n  let _hasLostConnection = false;\n\n  function handleConnectionLossEvent(newStatus: Status) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        _hasLostConnection = true;\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n\n      if (_hasLostConnection) {\n        _hasLostConnection = false;\n      }\n    }\n  }\n\n  function onDidConnect() {\n    // NoOp for now, but we should maybe fetch messages or something?\n  }\n\n  function onDidDisconnect() {\n    // Flush any pending deltas before disconnect to prevent data loss\n    flushPendingDeltas();\n  }\n\n  function handleServerMessage(event: IWebSocketMessageEvent) {\n    if (typeof event.data !== \"string\")\n      // Ignore binary (non-string) WebSocket messages\n      return;\n\n    const msg = tryParseJson(event.data) as ServerAiMsg | undefined;\n    if (!msg)\n      // Ignore non-JSON messages\n      return;\n\n    // If the current msg carries a cmdId, check to see if it's a known one,\n    // and if it's still exists in our pendingRequest administration. If not,\n    // it may have timed out already, or it wasn't intended for us.\n    const cmdId =\n      \"cmdId\" in msg\n        ? msg.cmdId\n        : msg.event === \"cmd-failed\"\n          ? msg.failedCmdId\n          : undefined;\n    const pendingCmd = context.pendingCmds.get(cmdId!); // eslint-disable-line no-restricted-syntax\n\n    if (cmdId && !pendingCmd) {\n      console.warn(\"Ignoring unexpected command response. Already timed out, or not for us?\", msg); // prettier-ignore\n      return;\n    }\n\n    if (\"event\" in msg) {\n      // Delta's are handled separately\n      if (msg.event === \"delta\") {\n        const { id, delta } = msg;\n        enqueueDelta(id, delta);\n      } else {\n        batch(() => {\n          flushPendingDeltas();\n\n          switch (msg.event) {\n            case \"cmd-failed\":\n              pendingCmd?.reject(new Error(msg.error));\n              break;\n\n            case \"settle\": {\n              context.messagesStore.upsert(msg.message);\n              break;\n            }\n\n            case \"warning\":\n              console.warn(msg.message);\n              break;\n\n            case \"error\":\n              console.error(msg.error);\n              break;\n\n            case \"rebooted\":\n              context.messagesStore.failAllPending();\n              break;\n\n            case \"sync\":\n              // Delete any resources?\n              for (const m of msg[\"-messages\"] ?? []) {\n                context.messagesStore.remove(m.chatId, m.id);\n              }\n              for (const chatId of msg[\"-chats\"] ?? []) {\n                context.chatsStore.markDeleted(chatId);\n                context.messagesStore.removeByChatId(chatId);\n              }\n              for (const chatId of msg.clear ?? []) {\n                context.messagesStore.removeByChatId(chatId);\n              }\n\n              // Add any new resources?\n              if (msg.chats) {\n                context.chatsStore.upsertMany(msg.chats);\n              }\n              if (msg.messages) {\n                context.messagesStore.upsertMany(msg.messages);\n              }\n              break;\n\n            default:\n              return assertNever(msg, \"Unhandled case\");\n          }\n        });\n      }\n    } else {\n      switch (msg.cmd) {\n        case \"get-chats\":\n          context.chatsStore.upsertMany(msg.chats);\n          break;\n\n        case \"get-or-create-chat\":\n          context.chatsStore.upsert(msg.chat);\n          break;\n\n        case \"delete-chat\":\n          context.chatsStore.markDeleted(msg.chatId);\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n\n        case \"get-message-tree\":\n          context.chatsStore.upsert(msg.chat);\n          context.messagesStore.upsertMany(msg.messages);\n          break;\n\n        case \"delete-message\":\n          context.messagesStore.remove(msg.chatId, msg.messageId);\n          break;\n\n        case \"clear-chat\":\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n\n        case \"ask-in-chat\":\n          if (msg.sourceMessage) {\n            // This field will only be returned if the ask-in-chat command\n            // created a new source message\n            context.messagesStore.upsert(msg.sourceMessage);\n          }\n          context.messagesStore.upsert(msg.targetMessage);\n          break;\n\n        case \"abort-ai\":\n          // TODO Not handled yet\n          break;\n\n        case \"set-tool-result\":\n          if (msg.ok) {\n            context.messagesStore.upsert(msg.message);\n          }\n          break;\n\n        default:\n          return assertNever(msg, \"Unhandled case\");\n      }\n    }\n\n    // After handling the side-effects above, we can resolve the promise\n    pendingCmd?.resolve(msg);\n  }\n\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    //const type = \"AI_CONNECTION_ERROR\";\n    // const err = new LiveblocksError(message, { type, code });\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\n        `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n      );\n    }\n  });\n\n  function connectInitially() {\n    if (managedSocket.getStatus() === \"initial\") {\n      managedSocket.connect();\n    }\n  }\n\n  async function sendClientMsgWithResponse<T extends ServerAiMsg>(\n    msg: DistributiveOmit<ClientAiMsg, \"cmdId\">\n  ): Promise<T> {\n    connectInitially();\n    if (managedSocket.getStatus() !== \"connected\") {\n      await managedSocket.events.didConnect.waitUntil();\n    }\n\n    const { promise, resolve, reject } = Promise_withResolvers<ServerAiMsg>();\n\n    // Automatically calls reject() when signal is aborted\n    const abortSignal = AbortSignal.timeout(DEFAULT_REQUEST_TIMEOUT);\n    abortSignal.addEventListener(\"abort\", () => reject(abortSignal.reason), {\n      once: true,\n    });\n\n    const cmdId = nanoid(7) as CmdId;\n    context.pendingCmds.set(cmdId, { resolve, reject });\n\n    sendClientMsg({ ...msg, cmdId });\n    return (\n      (promise as Promise<T>)\n        .finally(() => {\n          // Always cleanup\n          context.pendingCmds.delete(cmdId);\n        })\n        // Make sure these promises don't go uncaught (in contrast to the\n        // promise instance we return to the caller)\n        .catch((err: Error) => {\n          console.error(err.message);\n          throw err;\n        })\n    );\n  }\n\n  function sendClientMsg(msg: ClientAiMsg) {\n    managedSocket.send(\n      JSON.stringify({\n        ...msg,\n      })\n    );\n  }\n\n  function getChats(options: GetChatsOptions = {}) {\n    return sendClientMsgWithResponse<GetChatsResponse>({\n      cmd: \"get-chats\",\n      cursor: options.cursor,\n      query: options.query,\n    });\n  }\n\n  function getOrCreateChat(id: string, options?: CreateChatOptions) {\n    return sendClientMsgWithResponse<GetOrCreateChatResponse>({\n      cmd: \"get-or-create-chat\",\n      id,\n      options,\n    });\n  }\n\n  function getMessageTree(chatId: string) {\n    return sendClientMsgWithResponse<GetMessageTreeResponse>({\n      cmd: \"get-message-tree\",\n      chatId,\n    });\n  }\n\n  function registerKnowledgeLayer(uniqueLayerId: string): LayerKey {\n    return context.knowledge.registerLayer(uniqueLayerId);\n  }\n\n  function deregisterKnowledgeLayer(layerKey: LayerKey): void {\n    context.knowledge.deregisterLayer(layerKey);\n  }\n\n  function updateKnowledge(\n    layerKey: LayerKey,\n    data: AiKnowledgeSource,\n    key: string = nanoid()\n  ) {\n    context.knowledge.updateKnowledge(layerKey, key, data);\n  }\n\n  async function setToolResult(\n    chatId: string,\n    messageId: MessageId,\n    invocationId: string,\n    result: ToolResultResponse,\n    options?: SetToolResultOptions\n  ): Promise<void> {\n    const knowledge = context.knowledge.get();\n    const tools = context.toolsStore.getToolDescriptions(chatId);\n\n    const resp: SetToolResultResponse = await sendClientMsgWithResponse({\n      cmd: \"set-tool-result\",\n      chatId,\n      messageId,\n      invocationId,\n      result,\n      generationOptions: {\n        copilotId: options?.copilotId,\n        stream: options?.stream,\n        timeout: options?.timeout,\n\n        // Knowledge and tools aren't coming from the options, but retrieved\n        // from the global context\n        knowledge: knowledge.length > 0 ? knowledge : undefined,\n        tools: tools.length > 0 ? tools : undefined,\n      },\n    });\n    if (resp.ok) {\n      messagesStore.markMine(resp.message.id);\n    }\n  }\n\n  // Abort all my auto-executing messages when the page is unloaded\n  function handleBeforeUnload() {\n    for (const messageId of context.messagesStore.getAutoExecutingMessageIds()) {\n      sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }).catch(() => {\n        // Ignore errors during page unload\n      });\n    }\n  }\n\n  const win = typeof window !== \"undefined\" ? window : undefined;\n  win?.addEventListener(\"beforeunload\", handleBeforeUnload, { once: true });\n\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        context,\n      },\n\n      connectInitially,\n      // reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n\n      getChats,\n      getOrCreateChat,\n\n      deleteChat: (chatId: string) => {\n        return sendClientMsgWithResponse({ cmd: \"delete-chat\", chatId });\n      },\n\n      getMessageTree,\n\n      deleteMessage: (chatId: string, messageId: MessageId) =>\n        sendClientMsgWithResponse({ cmd: \"delete-message\", chatId, messageId }),\n      clearChat: (chatId: string) =>\n        sendClientMsgWithResponse({ cmd: \"clear-chat\", chatId }),\n\n      askUserMessageInChat: async (\n        chatId: string,\n        userMessage:\n          | MessageId\n          | {\n              id: MessageId;\n              parentMessageId: MessageId | null;\n              content: AiUserContentPart[];\n            },\n        targetMessageId: MessageId,\n        options?: AskUserMessageInChatOptions\n      ): Promise<AskInChatResponse> => {\n        const globalKnowledge = context.knowledge.get();\n        const requestKnowledge = options?.knowledge || [];\n        const combinedKnowledge = [...globalKnowledge, ...requestKnowledge];\n        const tools = context.toolsStore.getToolDescriptions(chatId);\n\n        messagesStore.markMine(targetMessageId);\n        const resp: AskInChatResponse = await sendClientMsgWithResponse({\n          cmd: \"ask-in-chat\",\n          chatId,\n          sourceMessage: userMessage,\n          targetMessageId,\n          generationOptions: {\n            copilotId: options?.copilotId,\n            stream: options?.stream,\n            timeout: options?.timeout,\n\n            // Combine global knowledge with request-specific knowledge\n            knowledge:\n              combinedKnowledge.length > 0 ? combinedKnowledge : undefined,\n            tools: tools.length > 0 ? tools : undefined,\n          },\n        });\n        return resp;\n      },\n\n      abort: (messageId: MessageId) =>\n        sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }),\n\n      setToolResult,\n\n      getStatus: () => managedSocket.getStatus(),\n\n      signals: {\n        getChatMessagesForBranchΣ:\n          context.messagesStore.getChatMessagesForBranchΣ,\n        getToolΣ: context.toolsStore.getToolΣ,\n      },\n\n      getChatById: context.chatsStore.getChatById,\n      queryChats: context.chatsStore.findMany,\n      getLastUsedCopilotId: context.messagesStore.getLastUsedCopilotId,\n      registerKnowledgeLayer,\n      deregisterKnowledgeLayer,\n      updateKnowledge,\n\n      registerTool: context.toolsStore.registerTool,\n    } satisfies Ai,\n    kInternal,\n    { enumerable: false }\n  );\n}\n\nexport function makeCreateSocketDelegateForAi(\n  baseUrl: string,\n  WebSocketPolyfill?: IWebSocket\n) {\n  return (authValue: AuthValue): IWebSocketInstance => {\n    const ws: IWebSocket | undefined =\n      WebSocketPolyfill ??\n      (typeof WebSocket === \"undefined\" ? undefined : WebSocket);\n\n    if (ws === undefined) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/ai/v6\";\n    // TODO: don't allow public key to do this\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      throw new Error(\"Public key not supported with AI Copilots\");\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n", "import { StopRetrying } from \"./connection\";\nimport { isPlainObject } from \"./lib/guards\";\nimport type { Json } from \"./lib/Json\";\nimport type { Relax } from \"./lib/Relax\";\nimport { stringifyOrLog as stringify } from \"./lib/stringify\";\nimport type {\n  Authentication,\n  CustomAuthenticationResult,\n} from \"./protocol/Authentication\";\nimport type { AuthToken, ParsedAuthToken } from \"./protocol/AuthToken\";\nimport { parseAuthToken, Permission, TokenKind } from \"./protocol/AuthToken\";\nimport type { Polyfills } from \"./room\";\n\nexport type AuthValue =\n  | { type: \"secret\"; token: ParsedAuthToken }\n  | { type: \"public\"; publicApiKey: string };\n\nexport type RequestedScope = \"room:read\" | \"comments:read\";\n\nexport type AuthManager = {\n  reset(): void;\n  getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue>;\n};\n\ntype AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\nexport type AuthenticationOptions = {\n  polyfills?: Polyfills;\n} & Relax<{ publicApiKey: string } | { authEndpoint: AuthEndpoint }>;\n\nexport function createAuthManager(\n  authOptions: AuthenticationOptions,\n  onAuthenticate?: (token: AuthToken) => void\n): AuthManager {\n  const authentication = prepareAuthentication(authOptions);\n\n  const seenTokens: Set<string> = new Set();\n\n  const tokens: ParsedAuthToken[] = [];\n  const expiryTimes: number[] = []; // Supposed to always contain the same number of elements as `tokens`\n\n  const requestPromises = new Map<string, Promise<ParsedAuthToken>>();\n\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n\n  function hasCorrespondingScopes(\n    requestedScope: RequestedScope,\n    scopes: Permission[]\n  ) {\n    if (requestedScope === \"comments:read\") {\n      return (\n        scopes.includes(Permission.CommentsRead) ||\n        scopes.includes(Permission.CommentsWrite) ||\n        scopes.includes(Permission.Read) ||\n        scopes.includes(Permission.Write)\n      );\n    } else if (requestedScope === \"room:read\") {\n      return (\n        scopes.includes(Permission.Read) || scopes.includes(Permission.Write)\n      );\n    }\n\n    return false;\n  }\n\n  function getCachedToken(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): ParsedAuthToken | undefined {\n    const now = Math.ceil(Date.now() / 1000);\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n\n      // If this token is expired, remove it from cache, as if it never existed\n      // in the first place\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n\n      if (token.parsed.k === TokenKind.ID_TOKEN) {\n        // When ID token method is used, only one token per user should be used and cached at the same time.\n        return token;\n      } else if (token.parsed.k === TokenKind.ACCESS_TOKEN) {\n        // In this version, we accept access tokens with zero permission when issuing token for resources outside a room.\n        if (\n          !requestOptions.roomId &&\n          Object.entries(token.parsed.perms).length === 0\n        ) {\n          return token;\n        }\n\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          // If the requester didn't pass a roomId,\n          // it means they need the token to access the user's resources (inbox notifications for example).\n          // We return any access token that contains a wildcard for the requested scope.\n          if (!requestOptions.roomId) {\n            if (\n              resource.includes(\"*\") &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes)\n            ) {\n              return token;\n            }\n          } else if (\n            (resource.includes(\"*\") &&\n              requestOptions.roomId.startsWith(resource.replace(\"*\", \"\"))) ||\n            (requestOptions.roomId === resource &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes))\n          ) {\n            return token;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  async function makeAuthRequest(options: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<ParsedAuthToken> {\n    const fetcher =\n      authOptions.polyfills?.fetch ??\n      (typeof window === \"undefined\" ? undefined : window.fetch);\n\n    if (authentication.type === \"private\") {\n      if (fetcher === undefined) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId,\n      });\n      const parsed = parseAuthToken(response.token);\n\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\n            \"reason\" in response && typeof response.reason === \"string\"\n              ? response.reason\n              : \"Forbidden\"\n          }`;\n\n          // istanbul ignore else\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n\n    // istanbul ignore next\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n\n  async function getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue> {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== undefined) {\n      return { type: \"secret\", token: cachedToken };\n    }\n\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n\n    try {\n      const token = await currentPromise;\n      // Translate \"server timestamps\" to \"local timestamps\" in case clocks aren't in sync\n      const BUFFER = 30; // Expire tokens 30 seconds sooner than they have to\n      const expiresAt =\n        Math.floor(Date.now() / 1000) +\n        (token.parsed.exp - token.parsed.iat) -\n        BUFFER;\n\n      seenTokens.add(token.raw);\n\n      // Legacy tokens should not get cached\n      if (token.parsed.k !== TokenKind.SECRET_LEGACY) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n\n  return {\n    reset,\n    getAuthValue,\n  };\n}\n\nfunction prepareAuthentication(\n  authOptions: AuthenticationOptions\n): Authentication {\n  const { publicApiKey, authEndpoint } = authOptions;\n\n  if (authEndpoint !== undefined && publicApiKey !== undefined) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey,\n    };\n  }\n\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint,\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint,\n    };\n  } else if (authEndpoint !== undefined) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\n\nasync function fetchAuthEndpoint(\n  fetch: typeof window.fetch,\n  endpoint: string,\n  body: {\n    room?: string;\n  }\n): Promise<{ token: string }> {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(body),\n  });\n  if (!res.ok) {\n    const reason = `${\n      (await res.text()).trim() || \"reason not provided in auth response\"\n    } (${res.status} returned by POST ${endpoint})`;\n\n    if (res.status === 401 || res.status === 403) {\n      // Throw a special error instance, which the connection manager will\n      // recognize and understand that retrying will have no effect\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n\n  let data: Json;\n  try {\n    data = await (res.json() as Promise<Json>);\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n", "export const DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\nexport const MENTION_CHARACTER = \"@\";\n", "import { makeEventSource } from \"../lib/EventSource\";\nimport type * as DevTools from \"./protocol\";\n\ntype SendToPanelOptions = {\n  /**\n   * We'll only want to send messages from the client to the panel if the panel\n   * has shown interest in this. To allow message passing to the dev panel,\n   * call allowMessagePassing().\n   */\n  force: boolean;\n};\n\nlet _bridgeActive = false;\nexport function activateBridge(allowed: boolean): void {\n  _bridgeActive = allowed;\n}\n\nexport function sendToPanel(\n  message: DevTools.ClientToPanelMessage,\n  options?: SendToPanelOptions\n): void {\n  // DevTools communication only happens on the client side\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\",\n  };\n\n  if (!(options?.force || _bridgeActive)) {\n    /*\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.log(\n      \"%c[client → panel] %c%s\",\n      \"color: green\",\n      \"color: gray; font-weight: bold\",\n      fullMsg.msg,\n      \"[🚫 NOT sent!]\"\n    );\n    */\n    return;\n  }\n  /*\n  // eslint-disable-next-line rulesdir/console-must-be-fancy\n  console.log(\n    \"%c[client → panel] %c%s\",\n    \"color: green\",\n    \"color: green; font-weight: bold\",\n    fullMsg.msg,\n    fullMsg\n  );*/\n  window.postMessage(fullMsg, \"*\");\n}\n\nconst eventSource = makeEventSource<DevTools.FullPanelToClientMessage>();\n\n// Define it as a no-op in production environments or when run outside of a browser context\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event: MessageEvent<unknown>) => {\n    if (\n      event.source === window &&\n      (event.data as Record<string, unknown>)?.source ===\n        \"liveblocks-devtools-panel\"\n    ) {\n      // console.log(\n      //   \"%c[client ← panel] %c%s\",\n      //   \"color: purple\",\n      //   \"color: purple; font-weight: bold\",\n      //   (event.data as Record<string, unknown>).msg,\n      //   event.data\n      // );\n      eventSource.notify(event.data as DevTools.FullPanelToClientMessage);\n    } else {\n      // Message not for us\n    }\n  });\n}\n\nexport const onMessageFromPanel = eventSource.observable;\n", "import { kInternal } from \"../internal\";\nimport type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { UpdateYDocClientMsg } from \"../protocol/ClientMsg\";\nimport type { YDocUpdateServerMsg } from \"../protocol/ServerMsg\";\nimport type { OpaqueRoom, RoomEventMessage } from \"../room\";\nimport { PKG_VERSION } from \"../version\";\nimport { activateBridge, onMessageFromPanel, sendToPanel } from \"./bridge\";\n\nconst VERSION = PKG_VERSION || \"dev\";\nlet _devtoolsSetupHasRun = false;\n\n/**\n * Sends a wake up message to the devtools panel, if any such panel exists, and\n * listens for the initial connect message, which would be the trigger to start\n * emitting updates.\n *\n * Must be called before linkDevTools() can be used.\n *\n * Will only run once, even when called multiple times.\n */\nexport function setupDevTools(getAllRooms: () => string[]): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  if (_devtoolsSetupHasRun) {\n    // This setup code should only happen the first time\n    return;\n  }\n\n  _devtoolsSetupHasRun = true;\n\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        // Allows future sendToPanel() messages to go through\n        activateBridge(true);\n\n        // Emit an explicit \"room::available\" message for every known room at\n        // this point. These can be used by the devpanel to subscribe to such\n        // room's updates.\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION,\n          });\n        }\n\n        break;\n      }\n\n      // TODO: Later on, we can support explicit disconnects, too\n      // case \"disconnect\": {\n      //   // Make sendToPanel() no-ops again\n      //   activateBridge(false);\n      //   break;\n      // }\n    }\n  });\n\n  // Send initial wake up message, in case the devtool panel is already open!\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\n\nconst unsubsByRoomId = new Map<string, (() => void)[]>();\n\nfunction stopSyncStream(roomId: string): void {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId); // Pop it off\n\n  for (const unsub of unsubs) {\n    // Cancel all of the subscriptions to room updates that are synchronizing\n    // partial state to the devtools panel\n    unsub();\n  }\n}\n\n/**\n * Starts, or restarts, the stream of sync messages for the given room. A sync\n * stream consists of an initial \"full sync\" message, followed by many\n * \"partial\" messages that happen whenever part of the room changes.\n */\nfunction startSyncStream(room: OpaqueRoom): void {\n  stopSyncStream(room.id);\n\n  // Sync the room ID instantly, as soon as we know it\n  fullSync(room);\n\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe((eventData) =>\n      forwardEvent(room, eventData)\n    ),\n  ]);\n}\n\nfunction syncYdocUpdate(\n  room: OpaqueRoom,\n  update: YDocUpdateServerMsg | UpdateYDocClientMsg\n) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update,\n  });\n}\n\nconst loadedAt = Date.now();\nlet eventCounter = 0;\n\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\n\nfunction forwardEvent(\n  room: OpaqueRoom,\n  eventData: RoomEventMessage<JsonObject, BaseUserMeta, Json>\n) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event,\n    },\n  });\n}\n\nfunction partialSyncConnection(room: OpaqueRoom) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus(),\n  });\n}\n\nfunction partialSyncStorage(room: OpaqueRoom) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload,\n    });\n  }\n}\n\nfunction partialSyncMe(room: OpaqueRoom) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me,\n    });\n  }\n}\n\nfunction partialSyncOthers(room: OpaqueRoom) {\n  // Any time others updates, send the new storage root to the dev panel\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others,\n    });\n  }\n}\n\nfunction fullSync(room: OpaqueRoom) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  // Because the room doesn't have access to the YJS doc, we must tell it to go get the full doc\n  // sending an empty vector will return the whole document and then devtools will be up to date\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others,\n  });\n}\n\n// Currently registered \"channel\" listeners, waiting for \"room::subscribe\" or\n// \"room::unsubscribe\" messages coming from the devtools panel\nconst roomChannelListeners = new Map<string, () => void>();\n\nfunction stopRoomChannelListener(roomId: string) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\n\n/**\n * Publicly announce to the devtool panel that a new room is available.\n */\nexport function linkDevTools(roomId: string, room: OpaqueRoom): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n\n  // Before adding a new listener, stop all active listeners, so there is only\n  // ever going to be one listener per room \"channel\"\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n\n        case \"room::unsubscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\n\nexport function unlinkDevTools(roomId: string): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  // Immediately stop the sync stream of room updates to the dev panel\n  stopSyncStream(roomId);\n\n  stopRoomChannelListener(roomId);\n\n  // Inform dev panel that this room is no longer available\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId,\n  });\n}\n", "import * as console from \"./fancy-console\";\n\n// Keeps a set of messages in memory that it has warned about\n// already. There will be only one message in the console, no\n// matter how often it gets called.\nconst _emittedWarnings: Set<string> = new Set();\n\n/**\n * Emit a warning only once.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function warnOnce(message: string, key = message): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedWarnings.has(key)) {\n      _emittedWarnings.add(key);\n      console.warn(message);\n    }\n  }\n}\n\n/**\n * Emit a warning only once if a condition is met.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function warnOnceIf(\n  condition: boolean | (() => boolean),\n  message: string,\n  key = message\n): void {\n  if (typeof condition === \"function\" ? condition() : condition) {\n    warnOnce(message, key);\n  }\n}\n", "import type { DAD } from \"../globals/augmentation\";\nimport * as console from \"../lib/fancy-console\";\nimport { create, entries, keys, values } from \"../lib/utils\";\n\n/**\n * Pre-defined notification channels support list.\n */\nexport type NotificationChannel = \"email\" | \"slack\" | \"teams\" | \"webPush\";\n\n/**\n * `K` represents custom notification kinds\n * defined in the augmentation `ActivitiesData` (e.g `liveblocks.config.ts`).\n * It means the type `NotificationKind` will be shaped like:\n * thread | textMention | $customKind1 | $customKind2 | ...\n */\nexport type NotificationKind<K extends keyof DAD = keyof DAD> =\n  | \"thread\"\n  | \"textMention\"\n  | K;\n\n/**\n * A notification channel settings is a set of notification kinds.\n * One setting can have multiple kinds (+ augmentation)\n */\nexport type NotificationChannelSettings = {\n  [K in NotificationKind]: boolean;\n};\n\n/**\n * @private\n *\n * Base definition of notification settings.\n * Plain means it's a simple object coming from the remote backend.\n *\n * It's the raw settings object where somme channels cannot exists\n * because there are no notification kinds enabled on the dashboard.\n * And this object isn't yet proxied by the creator factory `createNotificationSettings`.\n */\nexport type NotificationSettingsPlain = {\n  [C in NotificationChannel]?: NotificationChannelSettings;\n};\n\n/**\n * @internal\n *\n * Symbol to branch plain value of notification settings\n * inside the NotificationSettings object.\n */\nconst kPlain = Symbol(\"notification-settings-plain\");\n\n/**\n * @internal\n * Proxied `NotificationSettingsPlain` object.\n */\ntype ProxiedNotificationSettings = NotificationSettingsPlain;\n\n/**\n * Notification settings.\n * One channel for one set of settings.\n */\nexport type NotificationSettings = {\n  [C in NotificationChannel]: NotificationChannelSettings | null;\n};\n\n/**\n * It creates a deep partial specific for `NotificationSettings`\n * to offer a nice DX when updating the settings (e.g not being forced to define every keys)\n * and at the same the some preserver the augmentation for custom kinds (e.g `liveblocks.config.ts`).\n */\ntype DeepPartialWithAugmentation<T> = T extends object\n  ? {\n      [P in keyof T]?: T[P] extends { [K in NotificationKind]: boolean }\n        ? Partial<T[P]> & { [K in keyof DAD]?: boolean }\n        : DeepPartialWithAugmentation<T[P]>;\n    }\n  : T;\n\n/**\n * Partial notification settings with augmentation preserved gracefully.\n * It means you can update the settings without being forced to define every keys.\n * Useful when implementing update functions.\n */\nexport type PartialNotificationSettings =\n  DeepPartialWithAugmentation<NotificationSettingsPlain>;\n\n/**\n * @private\n *\n * Creates a `NotificationSettings` object with the given initial plain settings.\n * It defines a getter for each channel to access the settings and returns `null` with an error log\n * in case the required channel isn't enabled in the dashboard.\n *\n * You can see this function as `Proxy` like around `NotificationSettingsPlain` type.\n * We can't predict what will be enabled on the dashboard or not, so it's important\n * provide a good DX to developers by returning `null` completed by an error log\n * when they try to access a channel that isn't enabled in the dashboard.\n */\nexport function createNotificationSettings(\n  plain: NotificationSettingsPlain\n): NotificationSettings {\n  const channels: NotificationChannel[] = [\n    \"email\",\n    \"slack\",\n    \"teams\",\n    \"webPush\",\n  ];\n  const descriptors: PropertyDescriptorMap &\n    ThisType<NotificationSettings & { [kPlain]: ProxiedNotificationSettings }> =\n    {\n      [kPlain]: {\n        value: plain,\n        enumerable: false,\n      },\n    };\n\n  for (const channel of channels) {\n    descriptors[channel] = {\n      enumerable: true,\n      /**\n       * In the TypeScript standard library definitions, the built-in interface for a property descriptor\n       * does not include a specialized type for the “this” context in the getter or setter functions.\n       * As a result, both the ⁠get and ⁠set methods implicitly have ⁠this: any.\n       * The reason is that property descriptors in JavaScript are used across various objects with\n       * no enforced shape for ⁠this. And so the standard library definitions have to remain as broad as possible\n       * to support any valid JavaScript usage (e.g `Object.defineProperty`).\n       *\n       * So we can safely tells that this getter is typed as `this: NotificationSettings` because we're\n       * creating a well known shaped object → `NotificationSettings`.\n       */\n      get(\n        this: NotificationSettings & {\n          [kPlain]: ProxiedNotificationSettings;\n        }\n      ): NotificationChannelSettings | null {\n        const value = this[kPlain][channel];\n        if (typeof value === \"undefined\") {\n          console.error(\n            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`\n          );\n          return null;\n        }\n        return value;\n      },\n    };\n  }\n\n  return create<NotificationSettings>(null, descriptors);\n}\n\n/**\n * @private\n *\n * Patch a `NotificationSettings` object by applying notification kind updates\n * coming from a `PartialNotificationSettings` object.\n */\nexport function patchNotificationSettings(\n  existing: NotificationSettings,\n  patch: PartialNotificationSettings\n): NotificationSettings {\n  // Create a copy of the settings object to mutate\n  const outcoming = createNotificationSettings({\n    ...(\n      existing as NotificationSettings & {\n        [kPlain]: ProxiedNotificationSettings;\n      }\n    )[kPlain],\n  });\n\n  for (const channel of keys(patch)) {\n    const updates = patch[channel];\n    if (updates !== undefined) {\n      const kindUpdates = Object.fromEntries(\n        entries(updates).filter(([, value]) => value !== undefined)\n      ) as NotificationChannelSettings; // Fine to type cast here because we've filtered out undefined values\n\n      (\n        outcoming as NotificationSettings & {\n          [kPlain]: ProxiedNotificationSettings;\n        }\n      )[kPlain][channel] = {\n        ...(\n          outcoming as NotificationSettings & {\n            [kPlain]: ProxiedNotificationSettings;\n          }\n        )[kPlain][channel],\n        ...kindUpdates,\n      };\n    }\n  }\n\n  return outcoming;\n}\n\n/**\n *\n * Utility to check if a notification channel settings\n * is enabled for every notification kinds.\n *\n * Usage:\n * ```ts\n * const isEmailChannelEnabled = isNotificationChannelEnabled(settings.email);\n * ```\n */\nexport function isNotificationChannelEnabled(\n  settings: NotificationChannelSettings | null\n): boolean {\n  return settings !== null\n    ? values(settings).every((enabled) => enabled === true)\n    : false;\n}\n", "/**\n * Positions, aka the Pos type, are efficient encodings of \"positions\" in\n * a list, using the following printable subset of the ASCII alphabet:\n *\n *    !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n *   ^                                                                                             ^\n *   Lowest digit                                                                      Highest digit\n *\n * Each Pos is a sequence of characters from the above alphabet, conceptually\n * codifying a floating point number 0 < n < 1. For example, the string \"31007\"\n * would be used to represent the number 0.31007, except that this\n * representation uses base 96.\n *\n *   0 ≃ ' '  (lowest digit)\n *   1 ≃ '!'\n *   2 ≃ '\"'\n *   ...\n *   9 ≃ '~'  (highest digit)\n *\n * So think:\n *   '!'    ≃ 0.1\n *   '\"'    ≃ 0.2\n *   '!\"~'  ≃ 0.129\n *\n * Three rules:\n * - All \"characters\" in the string should be valid digits (from the above\n *   alphabet)\n * - The value 0.0 is not a valid Pos value\n * - A Pos cannot have trailing \"zeroes\"\n *\n * This representation has the following benefits:\n *\n * 1. It's always possible to get a number that lies before, after, or between\n *    two arbitrary Pos values.\n * 2. Pos values can be compared using normal string comparison.\n *\n * Some examples:\n * - '!'  < '\"'   (like how .1  < .2)\n * - '!'  < '~'   (like how .1  < .9)\n * - '!!' < '!~'  (like how .11 < .19)\n * - '~!' < '~~'  (like how .91 < .99)\n * - '~'  < '~!'  (like how .9  < .91)\n * - '!!' < '!O'  (like how .1  < .5)\n * - '!O' < '!~'  (like how .5  < .9)\n *\n */\nimport type { Brand } from \"./utils\";\n\n/**\n * A valid/verified \"position\" string. These values are used as \"parentKey\"s by\n * LiveList children, and define their relative ordering.\n */\nexport type Pos = Brand<string, \"Pos\">;\n\nconst MIN_CODE = 32; // ASCII code of the lowest alphabet char (e.g. ' ')\nconst MAX_CODE = 126; // ASCII code of the highest alphabet char (e.g. '~')\n\nconst NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\n\nconst ZERO: string = nthDigit(0); // \" \"\n\n/**\n * The \"first\" canonical position.\n * In an equivalent decimal number system, think of this as the value .1.\n */\nconst ONE: Pos = nthDigit(1); // \"!\"\n\nconst ZERO_NINE = (ZERO + nthDigit(-1)) as Pos;\n\n/**\n * Returns the Pos value for the nth digit in the alphabet.\n * Value must be between 0 and 94.\n *\n * Just used to generate some static data, and for usage in test cases.\n */\nfunction nthDigit(n: 0): string; // \"0\" is a legal _digit_, but not a legal Pos value\nfunction nthDigit(n: number): Pos;\nfunction nthDigit(n: number): Pos {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code) as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n * When given only a high bound, computes the canonical position \"before\" it.\n * When given only a low bound, computes the canonical position \"after\" it.\n * When given no bounds at all, returns the \"first\" canonical position.\n */\nfunction makePosition(x?: Pos, y?: Pos): Pos {\n  if (x !== undefined && y !== undefined) {\n    return between(x, y);\n  } else if (x !== undefined) {\n    return after(x);\n  } else if (y !== undefined) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\n\n/**\n * Given any position value, computes the canonical position \"before\" it.\n *\n * The equivalent in a decimal number system would be:\n *   before(.1)     // .09\n *   before(.11)    // .1\n *   before(.111)   // .1\n *   before(.2)     // .1\n *   before(.23101) // .2\n *   before(.3)     // .2\n *   ...\n *   before(.8)     // .7\n *   before(.9)     // .8\n *   before(.91)    // .9\n *   before(.92)    // .9\n *   before(.93)    // .9\n *   ...\n *   before(.98)    // .9\n *   before(.99)    // .9\n *\n * Note:\n *   before(.01)    // .009\n *   before(.001)   // .0009\n *   before(.002)   // .001\n *   before(.00283) // .002\n *\n */\nfunction before(pos: Pos): Pos {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n\n    // Scan away all leading zeros, if there are any\n    if (code <= MIN_CODE) {\n      continue;\n    }\n\n    //\n    // Now, i points to the first non-zero digit\n    //\n    // Two options:\n    // 1. It's the last digit.\n    //    a. If it's a 1, it's on the edge. Replace with \"09\".\n    //    b. Otherwise, just lower it.\n    // 2. It's not the last digit, so we can just chop off the remainder.\n    //\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return (pos.substring(0, i) + ZERO_NINE) as Pos;\n      } else {\n        return (pos.substring(0, i) + String.fromCharCode(code - 1)) as Pos;\n      }\n    } else {\n      return pos.substring(0, i + 1) as Pos;\n    }\n  }\n\n  // If we end up here, it means the input consisted of only zeroes, which is\n  // invalid, so return the canonical first value as a best effort\n  return ONE;\n}\n\n/**\n * Given any position value, computes the canonical position \"after\" it.\n *\n * The equivalent in a decimal number system would be:\n *   after(.001)  // .1\n *   after(.1)    // .2\n *   after(.101)  // .2\n *   after(.2)    // .3\n *   after(.3)    // .4\n *   ...\n *   after(.8)    // .9\n *   after(.9)    // .91\n *   after(.91)   // .92\n *   after(.9123) // .92\n *   ...\n *   after(.98)   // .99\n *   after(.99)   // .991\n *   after(.9999) // .99991\n *\n */\nfunction after(pos: Pos): Pos {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n\n    // Scan away all leading \"nines\", if there are any\n    if (code >= MAX_CODE) {\n      continue;\n    }\n\n    // Now, i points to the first non-\"nine\" digit\n    return (pos.substring(0, i) + String.fromCharCode(code + 1)) as Pos;\n  }\n\n  // If we end up here, it means the input consisted of only \"nines\", means we\n  // can just append a ONE digit.\n  return (pos + ONE) as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n *\n * Think:\n *   between('!', '%')  // '#'    (like how between(.1, .5) would be .3)\n *   between('!', '\"')  // '!O'   (like how between(.1, .2) would be .15)\n *\n *   between(.1, .3)      // .2\n *   between(.1, .4)      // also .2\n *   between(.1, .5)      // .3\n *   between(.11, .21)    // .15\n *   between(.1,  .1003)  // .1001\n *   between(.11, .12)    // .115\n *   between(.09, .1)     // .095\n *   between(.19, .21)    // .195\n *\n */\nfunction between(lo: Pos, hi: Pos): Pos {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\n\n/**\n * Like between(), but guaranteed that lo < hi.\n */\nfunction _between(lo: Pos, hi: Pos | \"\"): Pos {\n  let index = 0;\n\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n\n    // Difference of only 1 means we'll have to settle this in the next digit\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size) as Pos;\n      const nines = \"\"; // Will get interpreted like .999999…\n      return (prefix + _between(suffix, nines)) as Pos;\n    } else {\n      // Difference of more than 1 means we take the \"middle\" between these digits\n      return (takeN(lo, index) +\n        String.fromCharCode((hiCode + loCode) >> 1)) as Pos;\n    }\n  }\n}\n\nfunction takeN(pos: string, n: number): string {\n  return n < pos.length\n    ? pos.substring(0, n)\n    : pos + ZERO.repeat(n - pos.length);\n}\n\nconst MIN_NON_ZERO_CODE = MIN_CODE + 1;\n\n/**\n * Checks whether a given string is a valid Pos value. There are three rules:\n *\n *   - The string must not be the empty string\n *   - The string must not have any trailing \"zeroes\" (trailing \" \")\n *   - All characters in the string must be from our alphabet\n *\n */\nfunction isPos(str: string): str is Pos {\n  // May not be empty string\n  if (str === \"\") {\n    return false;\n  }\n\n  // Last digit may not be a \"0\" (no trailing zeroes)\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction convertToPos(str: string): Pos {\n  const codes: number[] = [];\n\n  // All chars in the string must be in the min-max range\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    // Clamp to min-max range\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n\n  // Strip all trailing zeros\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n\n  return codes.length > 0\n    ? (String.fromCharCode(...codes) as Pos)\n    : // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n      ONE;\n}\n\n/**\n * Checks that a str is a valid Pos, and converts it to the nearest valid one\n * if not.\n */\nfunction asPos(str: string): Pos {\n  // Calling convertToPos(str) would suffice here, but since this is a hot code\n  // path, we prefer to just check, which is a lot faster.\n  return isPos(str) ? str : convertToPos(str);\n}\n\nexport { asPos, makePosition };\n\n// For use in unit tests only\nexport {\n  after as __after,\n  before as __before,\n  between as __between,\n  isPos as __isPos,\n  nthDigit as __nthDigit,\n  NUM_DIGITS as __NUM_DIGITS,\n};\n", "import type { Json, JsonObject } from \"../lib/Json\";\n\nexport enum OpCode {\n  INIT = 0,\n  SET_PARENT_KEY = 1,\n  CREATE_LIST = 2,\n  UPDATE_OBJECT = 3,\n  CREATE_OBJECT = 4,\n  DELETE_CRDT = 5,\n  DELETE_OBJECT_KEY = 6,\n  CREATE_MAP = 7,\n  CREATE_REGISTER = 8,\n}\n\n/**\n * These operations are the payload for {@link UpdateStorageServerMsg} messages\n * only.\n */\nexport type Op =\n  | AckOp\n  | CreateOp\n  | UpdateObjectOp\n  | DeleteCrdtOp\n  | SetParentKeyOp // Only for lists!\n  | DeleteObjectKeyOp;\n\nexport type CreateOp =\n  | CreateObjectOp\n  | CreateRegisterOp\n  | CreateMapOp\n  | CreateListOp;\n\nexport type UpdateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.UPDATE_OBJECT;\n  readonly data: Partial<JsonObject>;\n};\n\nexport type CreateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type CreateListOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateMapOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateRegisterOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport type DeleteCrdtOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_CRDT;\n};\n\n//\n// HACK:\n// Disguised as a \"DeleteCrdtOp\" for a nonexisting node \"ACK\", this Op that the\n// server may return to senders is effectively sent as a backward-compatible\n// way to trigger an acknowledgement for Ops that were seen by the server, but\n// deliberately ignored.\n//\nexport type AckOp = {\n  readonly type: OpCode.DELETE_CRDT; // Not a typo!\n  readonly id: \"ACK\";\n  readonly opId: string;\n};\n\n/**\n * Create an Op that can be used as an acknowledgement for the given opId, to\n * send back to the originating client in cases where the server decided to\n * ignore the Op and not forward it.\n *\n * Why?\n * It's important for the client to receive an acknowledgement for this, so\n * that it can correctly update its own unacknowledged Ops administration.\n * Otherwise it could get in \"synchronizing\" state indefinitely.\n *\n * CLEVER HACK\n * Introducing a new Op type for this would not be backward-compatible as\n * receiving such Op would crash old clients :(\n * So the clever backward-compatible hack pulled here is that we codify the\n * acknowledgement as a \"deletion Op\" for the non-existing node id \"ACK\". In\n * old clients such Op is accepted, but will effectively be a no-op as that\n * node does not exist, but as a side-effect the Op will get acknowledged.\n */\nexport function ackOp(opId: string): AckOp {\n  return {\n    type: OpCode.DELETE_CRDT,\n    id: \"ACK\", // (H)ACK\n    opId,\n  };\n}\n\nexport function isAckOp(op: Op): op is AckOp {\n  return op.type === OpCode.DELETE_CRDT && op.id === \"ACK\";\n}\n\nexport type SetParentKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.SET_PARENT_KEY;\n  readonly parentKey: string;\n};\n\nexport type DeleteObjectKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_OBJECT_KEY;\n  readonly key: string;\n};\n", "import { assertNever } from \"../lib/assert\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos } from \"../lib/position\";\nimport type { CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { SerializedCrdt } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport type ApplyResult =\n  | { reverse: Op[]; modified: StorageUpdate }\n  | { modified: false };\n\n/**\n * The managed pool is a namespace registry (i.e. a context) that \"owns\" all\n * the individual live nodes, ensuring each one has a unique ID, and holding on\n * to live nodes before and after they are inter-connected.\n */\nexport interface ManagedPool {\n  readonly roomId: string;\n  readonly nodes: ReadonlyMap<string, LiveNode>;\n  readonly generateId: () => string;\n  readonly generateOpId: () => string;\n\n  readonly getNode: (id: string) => LiveNode | undefined;\n  readonly addNode: (id: string, node: LiveNode) => void;\n  readonly deleteNode: (id: string) => void;\n\n  /**\n   * Dispatching has three responsibilities:\n   * - Sends serialized ops to the WebSocket servers\n   * - Add reverse operations to the undo/redo stack\n   * - Notify room subscribers with updates (in-client, no networking)\n   */\n  dispatch: (\n    ops: Op[],\n    reverseOps: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ) => void;\n\n  /**\n   * Ensures storage can be written to else throws an error.\n   * This is used to prevent writing to storage when the user does not have\n   * permission to do so.\n   * @throws {Error} if storage is not writable\n   * @returns {void}\n   */\n  assertStorageIsWritable: () => void;\n}\n\nexport type CreateManagedPoolOptions = {\n  /**\n   * Returns the current connection ID. This is used to generate unique\n   * prefixes for nodes created by this client. This number is allowed to\n   * change over time (for example, when the client reconnects).\n   */\n  getCurrentConnectionId(): number;\n\n  /**\n   * Will get invoked when any Live structure calls .dispatch() on the pool.\n   */\n  onDispatch?: (\n    ops: Op[],\n    reverse: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ) => void;\n\n  /**\n   * Will get invoked when any Live structure calls .assertStorageIsWritable()\n   * on the pool. Defaults to true when not provided. Return false if you want\n   * to prevent writes to the pool locally early, because you know they won't\n   * have an effect upstream.\n   */\n  isStorageWritable?: () => boolean;\n};\n\n/**\n * @private Private API, never use this API directly.\n */\nexport function createManagedPool(\n  roomId: string,\n  options: CreateManagedPoolOptions\n): ManagedPool {\n  const {\n    getCurrentConnectionId,\n    onDispatch,\n    isStorageWritable = () => true,\n  } = options;\n\n  let clock = 0;\n  let opClock = 0;\n  const nodes = new Map<string, LiveNode>();\n\n  return {\n    roomId,\n    nodes,\n\n    getNode: (id: string) => nodes.get(id),\n    addNode: (id: string, node: LiveNode) => void nodes.set(id, node),\n    deleteNode: (id: string) => void nodes.delete(id),\n\n    generateId: () => `${getCurrentConnectionId()}:${clock++}`,\n    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,\n\n    dispatch(\n      ops: Op[],\n      reverse: Op[],\n      storageUpdates: Map<string, StorageUpdate>\n    ) {\n      onDispatch?.(ops, reverse, storageUpdates);\n    },\n\n    assertStorageIsWritable: () => {\n      if (!isStorageWritable()) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    },\n  };\n}\n\nexport enum OpSource {\n  UNDOREDO_RECONNECT,\n  REMOTE,\n  ACK,\n}\n\n// TODO Temporary helper to help convert from AbstractCrdt -> LiveNode, only\n// needed for within this module. The reason is that AbstractCrdt is an\n// _abstract_ type, and in our LiveNode union we exhaustively include all\n// concrete types.\n// TODO Remove me later, if we inline the abstract base methods in the concrete\n// classes.\nfunction crdtAsLiveNode(\n  value: AbstractCrdt // eslint-disable-line no-restricted-syntax\n): LiveNode {\n  return value as LiveNode;\n}\n\ntype HasParent = {\n  readonly type: \"HasParent\";\n  readonly node: LiveNode;\n  readonly key: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly pos: Pos;\n};\n\ntype NoParent = {\n  readonly type: \"NoParent\";\n};\n\ntype Orphaned = {\n  readonly type: \"Orphaned\";\n  readonly oldKey: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly oldPos: Pos;\n};\n\nfunction HasParent(\n  node: LiveNode,\n  key: string,\n  pos: Pos = asPos(key)\n): HasParent {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\n\nconst NoParent: NoParent = Object.freeze({ type: \"NoParent\" });\n\nfunction Orphaned(oldKey: string, oldPos: Pos = asPos(oldKey)): Orphaned {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\n\n/**\n * Represents the possible states of the parent field pointers.\n */\ntype ParentInfo =\n  // Both the parent node and the parent key are set. This is a normal child.\n  | HasParent\n\n  // Neither are set. This is either the root node (if attached to a document),\n  // or it's a dangling node that hasn't been attached yet.\n  | NoParent\n\n  // -------------------------------------------------------------------------\n  // TODO Refactor this state away!\n  // -------------------------------------------------------------------------\n  // Tricky case! This state is used after the node is detached from its\n  // parent, but we still need to retain the parent key that it was originally\n  // attached under. For example we rely on this to derive the reverse Op to\n  // add. We should be able to get rid of this case by structuring the code\n  // differently!\n  | Orphaned;\n\nexport abstract class AbstractCrdt {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool?: ManagedPool;\n  #id?: string;\n\n  #parent: ParentInfo = NoParent;\n\n  /** @internal */\n  _getParentKeyOrThrow(): string {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  get _parentPos(): Pos {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldPos;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  protected get _pool(): ManagedPool | undefined {\n    return this.#pool;\n  }\n\n  get roomId(): string | null {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n\n  /** @internal */\n  get _id(): string | undefined {\n    return this.#id;\n  }\n\n  /** @internal */\n  get parent(): ParentInfo {\n    return this.#parent;\n  }\n\n  /** @internal */\n  get _parentKey(): string | null {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        return null;\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, _isLocal: boolean): ApplyResult {\n    switch (op.type) {\n      case OpCode.DELETE_CRDT: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n\n        return { modified: false };\n      }\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  _setParentLink(newParentNode: LiveNode, newParentKey: string): void {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          // Ignore\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n\n    pool.addNode(id, crdtAsLiveNode(this));\n\n    this.#id = id;\n    this.#pool = pool;\n  }\n\n  /** @internal */\n  abstract _attachChild(op: CreateOp, source: OpSource): ApplyResult;\n\n  /** @internal */\n  _detach(): void {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n\n      case \"Orphaned\": {\n        // No change needed\n        break;\n      }\n\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n\n    this.#pool = undefined;\n  }\n\n  /** @internal */\n  abstract _detachChild(crdt: LiveNode): ApplyResult;\n\n  /** @internal */\n  abstract _toOps(\n    parentId: string,\n    parentKey: string,\n    pool?: ManagedPool\n  ): CreateOp[];\n\n  /** @internal */\n  abstract _serialize(): SerializedCrdt;\n\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable?: Immutable;\n\n  #cachedTreeNodeKey?: string | number;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode?: DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate(): void {\n    if (\n      this.#cachedImmutable !== undefined ||\n      this.#cachedTreeNode !== undefined\n    ) {\n      this.#cachedImmutable = undefined;\n      this.#cachedTreeNode = undefined;\n\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n\n  /** @internal */\n  abstract _toTreeNode(key: string): DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key: string): DevTools.LsonTreeNode {\n    if (this.#cachedTreeNode === undefined || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n\n    // Return cached version\n    return this.#cachedTreeNode;\n  }\n\n  /** @internal */\n  abstract _toImmutable(): Immutable;\n\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable(): Immutable {\n    if (this.#cachedImmutable === undefined) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n\n    // Return cached version\n    return this.#cachedImmutable;\n  }\n\n  /**\n   * Returns a deep clone of the current LiveStructure, suitable for insertion\n   * in the tree elsewhere.\n   */\n  abstract clone(): Lson;\n}\n", "import type { Json, JsonObject } from \"../lib/Json\";\n\nexport type IdTuple<T> = [id: string, value: T];\n\nexport enum CrdtType {\n  OBJECT = 0,\n  LIST = 1,\n  MAP = 2,\n  REGISTER = 3,\n}\n\nexport type SerializedCrdt = SerializedRootObject | SerializedChild;\n\nexport type SerializedChild =\n  | SerializedObject\n  | SerializedList\n  | SerializedMap\n  | SerializedRegister;\n\nexport type SerializedRootObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly data: JsonObject;\n\n  // Root objects don't have a parent relationship\n  readonly parentId?: never;\n  readonly parentKey?: never;\n};\n\nexport type SerializedObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type SerializedList = {\n  readonly type: CrdtType.LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedMap = {\n  readonly type: CrdtType.MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedRegister = {\n  readonly type: CrdtType.REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport function isRootCrdt(crdt: SerializedCrdt): crdt is SerializedRootObject {\n  return crdt.type === CrdtType.OBJECT && !isChildCrdt(crdt);\n}\n\nexport function isChildCrdt(crdt: SerializedCrdt): crdt is SerializedChild {\n  return crdt.parentId !== undefined && crdt.parentKey !== undefined;\n}\n", "import type { LiveNode } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { Json } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport { deepClone } from \"../lib/utils\";\nimport type { CreateOp, CreateRegisterOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedRegister } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt } from \"./AbstractCrdt\";\n\n/**\n * INTERNAL\n */\nexport class LiveRegister<TValue extends Json> extends AbstractCrdt {\n  #data: TValue;\n\n  constructor(data: TValue) {\n    super();\n    this.#data = data;\n  }\n\n  get data(): TValue {\n    return this.#data;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: IdTuple<SerializedRegister>,\n    _parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveRegister<Json> {\n    const register = new LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n\n  /** @internal */\n  _toOps(\n    parentId: string,\n    parentKey: string,\n    pool?: ManagedPool\n  ): CreateRegisterOp[] {\n    if (this._id === undefined) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n\n    return [\n      {\n        type: OpCode.CREATE_REGISTER,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data,\n      },\n    ];\n  }\n\n  /** @internal */\n  _serialize(): SerializedRegister {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.REGISTER,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data,\n    };\n  }\n\n  /** @internal */\n  _attachChild(_op: CreateOp): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _detachChild(_crdt: LiveNode): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data,\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): Immutable {\n    return this.#data;\n  }\n\n  clone(): TValue {\n    return deepClone(this.data);\n  }\n}\n", "import { nn } from \"../lib/assert\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos, makePosition } from \"../lib/position\";\nimport type { CreateListOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedList } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveListUpdateDelta =\n  | { type: \"insert\"; index: number; item: Lson }\n  | { type: \"delete\"; index: number; deletedItem: Lson }\n  | { type: \"move\"; index: number; previousIndex: number; item: Lson }\n  | { type: \"set\"; index: number; item: Lson };\n\n/**\n * A LiveList notification that is sent in-client to any subscribers whenever\n * one or more of the items inside the LiveList instance have changed.\n */\nexport type LiveListUpdates<TItem extends Lson> = {\n  type: \"LiveList\";\n  node: LiveList<TItem>;\n  updates: LiveListUpdateDelta[];\n};\n\nfunction compareNodePosition(itemA: LiveNode, itemB: LiveNode) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\n\n/**\n * The LiveList class represents an ordered collection of items that is synchronized across clients.\n */\nexport class LiveList<TItem extends Lson> extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  #items: LiveNode[];\n  #implicitlyDeletedItems: WeakSet<LiveNode>;\n  #unacknowledgedSets: Map<string, string>;\n\n  constructor(items: TItem[]) {\n    super();\n    this.#items = [];\n    this.#implicitlyDeletedItems = new WeakSet();\n    this.#unacknowledgedSets = new Map();\n\n    let position = undefined;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this.#items.push(node);\n      position = newPosition;\n    }\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id]: IdTuple<SerializedList>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveList<Lson> {\n    const list = new LiveList([]);\n    list._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return list;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, pool);\n\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n\n    return list;\n  }\n\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateListOp = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: OpCode.CREATE_LIST,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const item of this.#items) {\n      const parentKey = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey, pool),\n        undefined\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== undefined) {\n        this.#unacknowledgedSets.set(parentKey, childOpId);\n      }\n      ops.push(...childOps);\n    }\n\n    return ops;\n  }\n\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item: LiveNode): void {\n    this.#items.push(item);\n    this._sortItems();\n  }\n\n  /** @internal */\n  _sortItems(): void {\n    this.#items.sort(compareNodePosition);\n    this.invalidate();\n  }\n\n  /** @internal */\n  _indexOfPosition(position: string): number {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n\n  #applySetRemote(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n\n    const deletedId = op.deletedId;\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n\n    // If there is already an item at this position\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];\n\n      // No conflict, the item that is being replaced is the same that was deleted on the sender\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n\n        // Replace the existing item with the newly created item without sorting the list\n        this.#items[indexOfItemWithSamePosition] = child;\n\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child),\n          ]),\n          reverse: [],\n        };\n      } else {\n        // item at position to be replaced is different from server, so we put in a cache\n        // This scenario can happen if an other item has been put at this position\n        // while getting the acknowledgement of the set (move, insert or set)\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n\n        // Replace the existing item with the newly created item without sorting the list\n        this.#items[indexOfItemWithSamePosition] = child;\n\n        const delta: LiveListUpdateDelta[] = [\n          setDelta(indexOfItemWithSamePosition, child),\n        ];\n\n        // Even if we implicitly delete the item at the set position\n        // We still need to delete the item that was orginaly deleted by the set\n        const deleteDelta = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n\n        if (deleteDelta) {\n          delta.push(deleteDelta);\n        }\n\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: [],\n        };\n      }\n    } else {\n      // Item at position to be replaced doesn't exist\n      const updates: LiveListUpdateDelta[] = [];\n      const deleteDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta) {\n        updates.push(deleteDelta);\n      }\n\n      this._insertAndSort(child);\n\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates),\n      };\n    }\n  }\n\n  #applySetAck(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const delta: LiveListUpdateDelta[] = [];\n\n    // Deleted item can be re-inserted by remote undo/redo\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n\n    if (unacknowledgedOpId !== undefined) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0\n          ? { modified: false }\n          : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n\n    const existingItem = this.#items.find((item) => item._id === op.id);\n\n    // If item already exists...\n    if (existingItem !== undefined) {\n      // ...and if it's at the right position\n      if (existingItem._parentKey === op.parentKey) {\n        // ... do nothing\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: [],\n        };\n      }\n\n      // Item exists but not at the right position (local move after set)\n      if (indexOfItemWithSamePosition !== -1) {\n        this.#implicitlyDeletedItems.add(\n          this.#items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n\n      const prevIndex = this.#items.indexOf(existingItem);\n\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n\n      const newIndex = this.#items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: [],\n      };\n    } else {\n      // Item associated to the set ack does not exist either deleted localy or via remote undo/redo\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        // Reattach orphan at the new position\n        orphan._setParentLink(this, op.parentKey);\n        // And delete it from the orphan cache\n        this.#implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const recreatedItemIndex = this.#items.indexOf(orphan);\n\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(recreatedItemIndex, orphan)\n              : setDelta(recreatedItemIndex, orphan),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this.#items.splice(indexOfItemWithSamePosition, 1);\n        }\n\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(newIndex, newItem)\n              : setDelta(newIndex, newItem),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(\n    deletedId?: string\n  ): LiveListUpdateDelta | null {\n    if (deletedId === undefined || this._pool === undefined) {\n      return null;\n    }\n\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === undefined) {\n      return null;\n    }\n\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n\n    return result.modified.updates[0];\n  }\n\n  #applyRemoteInsert(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const key = asPos(op.parentKey);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    if (existingItemIndex !== -1) {\n      // If change is remote => assign a temporary position to existing child until we get the fix from the backend\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n\n    // TODO: add move update?\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: [],\n    };\n  }\n\n  #applyInsertAck(op: CreateOp): ApplyResult {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n\n    const itemIndexAtPosition = this._indexOfPosition(key);\n\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        // Normal case, no modification\n        return {\n          modified: false,\n        };\n      } else {\n        const oldPositionIndex = this.#items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n\n        const newIndex = this._indexOfPosition(key);\n\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem),\n          ]),\n          reverse: [],\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        // Implicit delete after set\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const newIndex = this._indexOfPosition(key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: [],\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  #applyInsertUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    let newKey = key;\n\n    if (existingItemIndex !== -1) {\n      const before = this.#items[existingItemIndex]?._parentPos;\n      const after = this.#items[existingItemIndex + 1]?._parentPos;\n\n      newKey = makePosition(before, after);\n      child._setParentLink(this, newKey);\n    }\n\n    this._insertAndSort(child);\n\n    const newIndex = this._indexOfPosition(newKey);\n\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: OpCode.DELETE_CRDT, id }],\n    };\n  }\n\n  #applySetUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const newKey = key;\n\n    // If there is already an item at this position\n    if (indexOfItemWithSameKey !== -1) {\n      // TODO: Should we add this item to implictly deleted item?\n      const existingItem = this.#items[indexOfItemWithSameKey];\n      existingItem._detach();\n\n      this.#items[indexOfItemWithSameKey] = child;\n\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n\n      return {\n        modified: makeUpdate(this, delta),\n        reverse,\n      };\n    } else {\n      this._insertAndSort(child);\n\n      // TODO: Use delta\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n\n      const newIndex = this._indexOfPosition(newKey);\n\n      return {\n        reverse: [{ type: OpCode.DELETE_CRDT, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      };\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    let result: ApplyResult;\n\n    if (op.intent === \"set\") {\n      if (source === OpSource.REMOTE) {\n        result = this.#applySetRemote(op);\n      } else if (source === OpSource.ACK) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === OpSource.REMOTE) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === OpSource.ACK) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n\n    return result;\n  }\n\n  /** @internal */\n  _detachChild(\n    child: LiveNode\n  ): { reverse: Op[]; modified: LiveListUpdates<TItem> } | { modified: false } {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n\n      const indexToDelete = this.#items.indexOf(child);\n\n      if (indexToDelete === -1) {\n        return {\n          modified: false,\n        };\n      }\n\n      const [previousNode] = this.#items.splice(indexToDelete, 1);\n      this.invalidate();\n\n      child._detach();\n\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse,\n      };\n    }\n\n    return { modified: false };\n  }\n\n  #applySetChildKeyRemote(newKey: Pos, child: LiveNode): ApplyResult {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n\n      const newIndex = this.#items.indexOf(child);\n\n      // TODO: Shift existing item?\n\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: [],\n      };\n    }\n\n    const previousKey = child._parentKey;\n\n    if (newKey === previousKey) {\n      return {\n        modified: false,\n      };\n    }\n\n    // TODO: should we look at orphan\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // Normal case\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    } else {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    }\n  }\n\n  #applySetChildKeyAck(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      this.#implicitlyDeletedItems.delete(child);\n\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n\n      // TODO\n      return {\n        modified: false,\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false,\n        };\n      }\n\n      // At this point, it means that the item has been moved before receiving the ack\n      // so we replace it at the right position\n\n      const previousIndex = this.#items.indexOf(child);\n\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n\n      child._setParentLink(this, newKey);\n      this._sortItems();\n\n      const newIndex = this.#items.indexOf(child);\n\n      if (previousIndex === newIndex) {\n        // parentKey changed but final position in the list didn't\n        return {\n          modified: false,\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child),\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  #applySetChildKeyUndoRedo(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    const previousIndex = this.#items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // If position is occupied, find a free position for item being moved\n    let actualNewKey = newKey;\n    if (existingItemIndex !== -1) {\n      // Find a free position near the desired position\n      actualNewKey = makePosition(\n        newKey,\n        this.#items[existingItemIndex + 1]?._parentPos\n      );\n    }\n\n    child._setParentLink(this, actualNewKey);\n\n    this._sortItems();\n\n    const newIndex = this.#items.indexOf(child);\n\n    if (previousIndex === newIndex) {\n      return {\n        modified: false,\n      };\n    }\n\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: OpCode.SET_PARENT_KEY,\n          id: nn(child._id),\n          parentKey: previousKey,\n        },\n      ],\n    };\n  }\n\n  /** @internal */\n  _setChildKey(newKey: Pos, child: LiveNode, source: OpSource): ApplyResult {\n    if (source === OpSource.REMOTE) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === OpSource.ACK) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _serialize(): SerializedList {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.LIST,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns the number of elements.\n   */\n  get length(): number {\n    return this.#items.length;\n  }\n\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element: TItem, index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n\n    const before = this.#items[index - 1]\n      ? this.#items[index - 1]._parentPos\n      : undefined;\n    const after = this.#items[index]\n      ? this.#items[index]._parentPos\n      : undefined;\n\n    const position = makePosition(before, after);\n\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n\n    this._insertAndSort(value);\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: OpCode.DELETE_CRDT, id }],\n        new Map<string, LiveListUpdates<TItem>>([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])],\n        ])\n      );\n    }\n  }\n\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index: number, targetIndex: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n\n    let beforePosition = null;\n    let afterPosition = null;\n\n    if (index < targetIndex) {\n      afterPosition =\n        targetIndex === this.#items.length - 1\n          ? undefined\n          : this.#items[targetIndex + 1]._parentPos;\n      beforePosition = this.#items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this.#items[targetIndex]._parentPos;\n      beforePosition =\n        targetIndex === 0 ? undefined : this.#items[targetIndex - 1]._parentPos;\n    }\n\n    const position = makePosition(beforePosition, afterPosition);\n\n    const item = this.#items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n\n    if (this._pool && this._id) {\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])],\n      ]);\n\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position,\n          },\n        ],\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            parentKey: previousPosition,\n          },\n        ],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${\n          this.#items.length - 1\n        }`\n      );\n    }\n\n    const item = this.#items[index];\n    item._detach();\n    const [prev] = this.#items.splice(index, 1);\n    this.invalidate();\n\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: OpCode.DELETE_CRDT,\n            },\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n\n  clear(): void {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops: Op[] = [];\n      const reverseOps: Op[] = [];\n\n      const updateDelta: LiveListUpdateDelta[] = [];\n\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: OpCode.DELETE_CRDT,\n            id: childId,\n            opId: this._pool.generateOpId(),\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n\n          // Index is always 0 because updates are applied one after another\n          // when applied on an immutable state\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n\n      this.#items = [];\n      this.invalidate();\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items = [];\n      this.invalidate();\n    }\n  }\n\n  set(index: number, item: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${\n          this.#items.length - 1\n        }`\n      );\n    }\n\n    const existingItem = this.#items[index];\n    const position = existingItem._getParentKeyOrThrow();\n\n    const existingId = existingItem._id;\n    existingItem._detach();\n\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items[index] = value;\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, undefined),\n        id\n      );\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray(): TItem[] {\n    return this.#items.map(\n      (entry) => liveNodeToLson(entry) as TItem\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().every(predicate);\n  }\n\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate: (value: TItem, index: number) => unknown): TItem[] {\n    return this.toArray().filter(predicate);\n  }\n\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate: (value: TItem, index: number) => unknown): TItem | undefined {\n    return this.toArray().find(predicate);\n  }\n\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate: (value: TItem, index: number) => unknown): number {\n    return this.toArray().findIndex(predicate);\n  }\n\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn: (value: TItem, index: number) => void): void {\n    return this.toArray().forEach(callbackfn);\n  }\n\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index: number): TItem | undefined {\n    if (index < 0 || index >= this.#items.length) {\n      return undefined;\n    }\n\n    return liveNodeToLson(this.#items[index]) as TItem | undefined;\n    //                                           ^^^^^^^^^^^^^^^^^\n    //                                           FIXME! This isn't safe.\n  }\n\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map<U>(callback: (value: TItem, index: number) => U): U[] {\n    return this.#items.map((entry, i) =>\n      callback(\n        liveNodeToLson(entry) as TItem,\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().some(predicate);\n  }\n\n  [Symbol.iterator](): IterableIterator<TItem> {\n    return new LiveListIterator(this.#items);\n  }\n\n  #createAttachItemAndSort(\n    op: CreateOp,\n    key: string\n  ): {\n    newItem: LiveNode;\n    newIndex: number;\n  } {\n    const newItem = creationOpToLiveNode(op);\n\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n\n    this._insertAndSort(newItem);\n\n    const newIndex = this._indexOfPosition(key);\n\n    return { newItem, newIndex };\n  }\n\n  #shiftItemPosition(index: number, key: Pos) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1\n        ? this.#items[index + 1]?._parentPos\n        : undefined\n    );\n\n    this.#items[index]._setParentLink(this, shiftedPosition);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#items.map((item, index) =>\n        item.toTreeNode(index.toString())\n      ),\n    };\n  }\n\n  toImmutable(): readonly ToImmutable<TItem>[] {\n    // Don't implement actual toJson logic in here. Implement it in ._toImmutable()\n    // instead. This helper merely exists to help TypeScript infer better\n    // return types.\n    return super.toImmutable() as readonly ToImmutable<TItem>[];\n  }\n\n  /** @internal */\n  _toImmutable(): readonly ToImmutable<TItem>[] {\n    const result = this.#items.map((node) => node.toImmutable());\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as readonly ToImmutable<TItem>[];\n  }\n\n  clone(): LiveList<TItem> {\n    return new LiveList(this.#items.map((item) => item.clone() as TItem));\n  }\n}\n\nclass LiveListIterator<T extends Lson> implements IterableIterator<T> {\n  #innerIterator: IterableIterator<LiveNode>;\n\n  constructor(items: Array<LiveNode>) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.#innerIterator.next();\n\n    if (result.done) {\n      return {\n        done: true,\n        value: undefined,\n      };\n    }\n\n    const value = liveNodeToLson(result.value) as T;\n    //                                         ^^^^\n    //                                         FIXME! This isn't safe.\n    return { value };\n  }\n}\n\nfunction makeUpdate<TItem extends Lson>(\n  liveList: LiveList<TItem>,\n  deltaUpdates: LiveListUpdateDelta[]\n): LiveListUpdates<TItem> {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates,\n  };\n}\n\nfunction setDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction deleteDelta(\n  index: number,\n  deletedNode: LiveNode\n): LiveListUpdateDelta {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem:\n      deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode,\n  };\n}\n\nfunction insertDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction moveDelta(\n  previousIndex: number,\n  index: number,\n  item: LiveNode\n): LiveListUpdateDelta {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex,\n  };\n}\n\n/**\n * This function is only temporary.\n * As soon as we refactor the operations structure,\n * serializing a LiveStructure should not know anything about intent\n */\nfunction HACK_addIntentAndDeletedIdToOperation(\n  ops: CreateOp[],\n  deletedId: string | undefined\n): CreateOp[] {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      // NOTE: Only patch the first Op here\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId,\n      };\n    } else {\n      return op;\n    }\n  });\n}\n", "import { nn } from \"../lib/assert\";\nimport { freeze } from \"../lib/freeze\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { CreateMapOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedMap } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  isLiveNode,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\n/**\n * A LiveMap notification that is sent in-client to any subscribers whenever\n * one or more of the values inside the LiveMap instance have changed.\n */\nexport type LiveMapUpdates<TKey extends string, TValue extends Lson> = {\n  type: \"LiveMap\";\n  node: LiveMap<TKey, TValue>;\n  updates: { [key: string]: UpdateDelta };\n  //               ^^^^^^\n  //               FIXME: `string` is not specific enough here. See if we can\n  //               improve this type to match TKey!\n};\n\n/**\n * The LiveMap class is similar to a JavaScript Map that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveMap<\n  TKey extends string,\n  TValue extends Lson,\n> extends AbstractCrdt {\n  #map: Map<TKey, LiveNode>;\n  #unacknowledgedSet: Map<TKey, string>;\n\n  constructor(entries?: readonly (readonly [TKey, TValue])[] | undefined) {\n    super();\n    this.#unacknowledgedSet = new Map<TKey, string>();\n\n    if (entries) {\n      const mappedEntries: [TKey, LiveNode][] = [];\n      for (const [key, value] of entries) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = new Map();\n    }\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateMapOp = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: OpCode.CREATE_MAP,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this.#map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n\n    return ops;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, _item]: IdTuple<SerializedMap>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveMap<string, Lson> {\n    const map = new LiveMap();\n    map._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return map;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n\n    return map;\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey, opId } = op;\n\n    const key = parentKey as TKey;\n    //                    ^^^^^^^ TODO: Fix me!\n\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    if (source === OpSource.ACK) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        // Acknowlegment from local operation\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== undefined) {\n        // Another local set has overriden the value, so we do nothing\n        return { modified: false };\n      }\n    } else if (source === OpSource.REMOTE) {\n      // If a remote operation set an item,\n      // delete the unacknowledgedSet associated to the key\n      // to make sure any future ack can override it\n      this.#unacknowledgedSet.delete(key);\n    }\n\n    const previousValue = this.#map.get(key);\n    let reverse: Op[];\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: OpCode.DELETE_CRDT, id }];\n    }\n\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      },\n      reverse,\n    };\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n\n  /** @internal */\n  _detachChild(child: LiveNode): ApplyResult {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n\n    child._detach();\n\n    const storageUpdate: LiveMapUpdates<TKey, TValue> = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } },\n    };\n\n    return { modified: storageUpdate, reverse };\n  }\n\n  /** @internal */\n  _serialize(): SerializedMap {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.MAP,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key: TKey): TValue | undefined {\n    const value = this.#map.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n    return liveNodeToLson(value) as TValue | undefined;\n    //                           ^^^^^^^^^^^^^^^^^^^^^\n    //                           FIXME! This isn't safe.\n  }\n\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key: TKey, value: TValue): void {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n\n    if (oldValue) {\n      oldValue._detach();\n    }\n\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n\n    this.#map.set(key, item);\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      });\n\n      const ops = item._toOps(this._id, key, this._pool);\n\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue\n          ? oldValue._toOps(this._id, key)\n          : [{ type: OpCode.DELETE_CRDT, id }],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size(): number {\n    return this.#map.size;\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key: TKey): boolean {\n    return this.#map.has(key);\n  }\n\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key: TKey): boolean {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n\n    if (item === undefined) {\n      return false;\n    }\n\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } },\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.DELETE_CRDT,\n            id: item._id,\n            opId: this._pool.generateOpId(),\n          },\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries(): IterableIterator<[TKey, TValue]> {\n    const innerIterator = this.#map.entries();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const entry = iteratorValue.value;\n\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]) as TValue;\n        //                                                   ^^^^^^^^^\n        //                                                   FIXME! This isn't safe.\n        return {\n          value: [key, value],\n        };\n      },\n    };\n  }\n\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator](): IterableIterator<[TKey, TValue]> {\n    return this.entries();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys(): IterableIterator<TKey> {\n    return this.#map.keys();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values(): IterableIterator<TValue> {\n    const innerIterator = this.#map.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const value = liveNodeToLson(iteratorValue.value) as TValue;\n        //                                                ^^^^^^^^^\n        //                                                FIXME! This isn't safe.\n\n        return { value };\n      },\n    };\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(\n    callback: (value: TValue, key: TKey, map: LiveMap<TKey, TValue>) => void\n  ): void {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(([key, val]) =>\n        val.toTreeNode(key)\n      ),\n    };\n  }\n\n  toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ReadonlyMap<TKey, ToImmutable<TValue>>;\n  }\n\n  /** @internal */\n  _toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    const result: Map<TKey, ToImmutable<TValue>> = new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable() as ToImmutable<TValue>);\n    }\n    return freeze(result);\n  }\n\n  clone(): LiveMap<TKey, TValue> {\n    return new LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone() as TValue])\n    );\n  }\n}\n", "import type { LiveNode, Lson, LsonObject } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { Json, JsonObject } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { RemoveUndefinedValues } from \"../lib/utils\";\nimport { compactObject, deepClone } from \"../lib/utils\";\nimport type {\n  CreateObjectOp,\n  CreateOp,\n  DeleteObjectKeyOp,\n  Op,\n  UpdateObjectOp,\n} from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type {\n  IdTuple,\n  SerializedChild,\n  SerializedCrdt,\n  SerializedObject,\n  SerializedRootObject,\n} from \"../protocol/SerializedCrdt\";\nimport { CrdtType, isRootCrdt } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLson,\n  deserializeToLson,\n  isLiveNode,\n  isLiveStructure,\n} from \"./liveblocks-helpers\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveObjectUpdateDelta<O extends { [key: string]: unknown }> = {\n  [K in keyof O]?: UpdateDelta | undefined;\n};\n\n// One key platform limit is that a LiveObject cannot exceed 128 kB when\n// totalling the size of the keys and values.\n// See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits\nconst MAX_LIVE_OBJECT_SIZE = 128 * 1024;\n\n/**\n * A LiveObject notification that is sent in-client to any subscribers whenever\n * one or more of the entries inside the LiveObject instance have changed.\n */\nexport type LiveObjectUpdates<TData extends LsonObject> = {\n  type: \"LiveObject\";\n  node: LiveObject<TData>;\n  updates: LiveObjectUpdateDelta<TData>;\n};\n\n/**\n * The LiveObject class is similar to a JavaScript object that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveObject<O extends LsonObject> extends AbstractCrdt {\n  #map: Map<string, Lson>;\n  #propToLastUpdate: Map<string, string>;\n\n  /**\n   * Enable or disable detection of too large LiveObjects.\n   * When enabled, throws an error if LiveObject static data exceeds 128KB, which\n   * is the maximum value the server will be able to accept.\n   * By default, this behavior is disabled to avoid the runtime performance\n   * overhead on every LiveObject.set() or LiveObject.update() call.\n   *\n   * @experimental\n   */\n  public static detectLargeObjects = false;\n\n  static #buildRootAndParentToChildren(\n    items: IdTuple<SerializedCrdt>[]\n  ): [IdTuple<SerializedRootObject>, ParentToChildNodeMap] {\n    const parentToChildren: ParentToChildNodeMap = new Map();\n    let root: IdTuple<SerializedRootObject> | null = null;\n\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple: IdTuple<SerializedChild> = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== undefined) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n\n    return [root, parentToChildren];\n  }\n\n  /** @private Do not use this API directly */\n  static _fromItems<O extends LsonObject>(\n    items: IdTuple<SerializedCrdt>[],\n    pool: ManagedPool\n  ): LiveObject<O> {\n    const [root, parentToChildren] =\n      LiveObject.#buildRootAndParentToChildren(items);\n    return LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    ) as LiveObject<O>;\n  }\n\n  constructor(obj: O = {} as O) {\n    super();\n\n    this.#propToLastUpdate = new Map<string, string>();\n\n    const o: RemoveUndefinedValues<LsonObject> = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n\n    this.#map = new Map(Object.entries(o));\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const opId = pool?.generateOpId();\n\n    const ops: CreateOp[] = [];\n    const op: CreateObjectOp = {\n      type: OpCode.CREATE_OBJECT,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {},\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n\n    return ops;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: IdTuple<SerializedObject | SerializedRootObject>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const liveObj = new LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n\n  /** @internal */\n  static _deserializeChildren(\n    liveObj: LiveObject<JsonObject>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === undefined) {\n      return liveObj;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n\n    return liveObj;\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      if (this.#propToLastUpdate.get(key) === opId) {\n        // Acknowlegment from local operation\n        this.#propToLastUpdate.delete(key);\n      }\n\n      return { modified: false };\n    }\n\n    if (source === OpSource.UNDOREDO_RECONNECT) {\n      this.#propToLastUpdate.set(key, nn(opId));\n    } else if (this.#propToLastUpdate.get(key) === undefined) {\n      // Remote operation with no local change => apply operation\n    } else if (this.#propToLastUpdate.get(key) === opId) {\n      // Acknowlegment from local operation\n      this.#propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      // Conflict, ignore remote operation\n      return { modified: false };\n    }\n\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse: Op[];\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === undefined) {\n      reverse = [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id: thisId,\n          data: { [key]: previousValue },\n        },\n      ];\n    }\n\n    this.#map.set(key, child);\n    this.invalidate();\n\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } },\n      },\n    };\n  }\n\n  /** @internal */\n  _detachChild(child: LiveNode): ApplyResult {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n\n      child._detach();\n\n      const storageUpdate: LiveObjectUpdates<O> = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" },\n        } as { [K in keyof O]: UpdateDelta },\n      };\n\n      return { modified: storageUpdate, reverse };\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    if (op.type === OpCode.UPDATE_OBJECT) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === OpCode.DELETE_OBJECT_KEY) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _serialize(): SerializedObject | SerializedRootObject {\n    const data: JsonObject = {};\n\n    // Add only the static Json data fields into the objects\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: CrdtType.OBJECT,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data,\n      };\n    } else {\n      // Root object has no parent ID/key\n      return {\n        type: CrdtType.OBJECT,\n        data,\n      };\n    }\n  }\n\n  #applyUpdate(op: UpdateObjectOp, isLocal: boolean): ApplyResult {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse: Op[] = [];\n    const reverseUpdate: UpdateObjectOp = {\n      type: OpCode.UPDATE_OBJECT,\n      id,\n      data: {},\n    };\n\n    for (const key in op.data as Partial<O>) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== undefined) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === undefined) {\n        reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id, key });\n      }\n    }\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n    for (const key in op.data as Partial<O>) {\n      const value = op.data[key];\n      if (value === undefined) {\n        continue;\n      }\n\n      if (isLocal) {\n        this.#propToLastUpdate.set(key, nn(op.opId));\n      } else if (this.#propToLastUpdate.get(key) === undefined) {\n        // Not modified localy so we apply update\n        isModified = true;\n      } else if (this.#propToLastUpdate.get(key) === op.opId) {\n        // Acknowlegment from local operation\n        this.#propToLastUpdate.delete(key);\n        continue;\n      } else {\n        // Conflict, ignore remote operation\n        continue;\n      }\n\n      const oldValue = this.#map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n\n    return isModified\n      ? {\n          modified: {\n            node: this,\n            type: \"LiveObject\",\n            updates: updateDelta,\n          },\n          reverse,\n        }\n      : { modified: false };\n  }\n\n  #applyDeleteObjectKey(op: DeleteObjectKeyOp, isLocal: boolean): ApplyResult {\n    const key = op.key;\n\n    // If property does not exist, exit without notifying\n    if (this.#map.has(key) === false) {\n      return { modified: false };\n    }\n\n    // If a local operation exists on the same key and we receive a remote\n    // one prevent flickering by not applying delete op.\n    if (!isLocal && this.#propToLastUpdate.get(key) !== undefined) {\n      return { modified: false };\n    }\n\n    const oldValue = this.#map.get(key);\n\n    const id = nn(this._id);\n    let reverse: Op[] = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== undefined) {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id,\n          data: { [key]: oldValue },\n        },\n      ];\n    }\n\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } },\n      },\n      reverse,\n    };\n  }\n\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject(): O {\n    return Object.fromEntries(this.#map) as O;\n  }\n\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set<TKey extends keyof O>(key: TKey, value: O[TKey]): void {\n    // TODO: Find out why typescript complains\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value } as unknown as Partial<O>);\n  }\n\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get<TKey extends keyof O>(key: TKey): O[TKey] {\n    return this.#map.get(key as string) as O[TKey];\n  }\n\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key: keyof O): void {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key as string;\n    const oldValue = this.#map.get(keyAsString);\n\n    if (oldValue === undefined) {\n      return;\n    }\n\n    if (this._pool === undefined || this._id === undefined) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n\n    let reverse: Op[];\n\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          data: { [keyAsString]: oldValue },\n          id: this._id,\n        },\n      ];\n    }\n\n    this.#map.delete(keyAsString);\n    this.invalidate();\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } } as {\n        [K in keyof O]: UpdateDelta;\n      },\n    });\n\n    this._pool.dispatch(\n      [\n        {\n          type: OpCode.DELETE_OBJECT_KEY,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId(),\n        },\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch: Partial<O>): void {\n    this._pool?.assertStorageIsWritable();\n\n    // If detectLargeObjects is enabled, perform a runtime size check now so we\n    // can immediately throw as soon as the max object size is exceeded.\n    if (LiveObject.detectLargeObjects) {\n      const data: Record<string, Json> = {};\n      for (const [key, value] of this.#map) {\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n      for (const key of Object.keys(patch)) {\n        const value = patch[key];\n        if (value === undefined) continue;\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n\n      // Fast upper-bound check: multiply JSON string length by 4 (worst-case UTF-8)\n      // This is much faster than TextEncoder and gives us an upper bound\n      const jsonString = JSON.stringify(data);\n      const upperBoundSize = jsonString.length * 4;\n\n      // Only do the precise calculation if the fast check suggests we might be close\n      if (upperBoundSize > MAX_LIVE_OBJECT_SIZE) {\n        const preciseSize = new TextEncoder().encode(jsonString).length;\n        if (preciseSize > MAX_LIVE_OBJECT_SIZE) {\n          throw new Error(\n            `LiveObject size exceeded limit: ${preciseSize} bytes > ${MAX_LIVE_OBJECT_SIZE} bytes. See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits`\n          );\n        }\n      }\n    }\n\n    if (this._pool === undefined || this._id === undefined) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === undefined) {\n          continue;\n        }\n\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n\n      return;\n    }\n\n    const ops: Op[] = [];\n    const reverseOps: Op[] = [];\n\n    const opId = this._pool.generateOpId();\n    const updatedProps: JsonObject = {};\n\n    const reverseUpdateOp: UpdateObjectOp = {\n      id: this._id,\n      type: OpCode.UPDATE_OBJECT,\n      data: {},\n    };\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n\n    for (const key in patch) {\n      const newValue: Lson | undefined = patch[key];\n      if (newValue === undefined) {\n        continue;\n      }\n\n      const oldValue = this.#map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === undefined) {\n        reverseOps.push({ type: OpCode.DELETE_OBJECT_KEY, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n\n        const createCrdtOp = newAttachChildOps.find(\n          (op: Op & { parentId?: string }) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this.#propToLastUpdate.set(key, opId);\n      }\n\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: OpCode.UPDATE_OBJECT,\n        data: updatedProps,\n      });\n    }\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta,\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n\n  toImmutable(): ToImmutable<O> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ToImmutable<O>;\n  }\n\n  /** @internal */\n  toTreeNode(key: string): DevTools.LiveTreeNode<\"LiveObject\"> {\n    // Don't implement actual toTreeNode logic in here. Implement it in\n    // ._toTreeNode() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toTreeNode(key) as DevTools.LiveTreeNode<\"LiveObject\">;\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(([key, value]) =>\n        isLiveNode(value)\n          ? value.toTreeNode(key)\n          : { type: \"Json\", id: `${nodeId}:${key}`, key, payload: value }\n      ),\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): ToImmutable<O> {\n    const result: { [key: string]: unknown } = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as ToImmutable<O>;\n  }\n\n  clone(): LiveObject<O> {\n    return new LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value),\n        ])\n      ) as O\n    );\n  }\n}\n", "import { assertNever, nn } from \"../lib/assert\";\nimport { isPlainObject } from \"../lib/guards\";\nimport type { Json } from \"../lib/Json\";\nimport { stringifyOrLog as stringify } from \"../lib/stringify\";\nimport { deepClone, entries } from \"../lib/utils\";\nimport type { CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedCrdt } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type { NodeMap, ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ManagedPool } from \"./AbstractCrdt\";\nimport { LiveList, type LiveListUpdates } from \"./LiveList\";\nimport { LiveMap, type LiveMapUpdates } from \"./LiveMap\";\nimport { LiveObject, type LiveObjectUpdates } from \"./LiveObject\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, LiveStructure, Lson, LsonObject } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport function creationOpToLiveNode(op: CreateOp): LiveNode {\n  return lsonToLiveNode(creationOpToLson(op));\n}\n\nexport function creationOpToLson(op: CreateOp): Lson {\n  switch (op.type) {\n    case OpCode.CREATE_REGISTER:\n      return op.data;\n    case OpCode.CREATE_OBJECT:\n      return new LiveObject(op.data);\n    case OpCode.CREATE_MAP:\n      return new LiveMap();\n    case OpCode.CREATE_LIST:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\n\nexport function isSameNodeOrChildOf(node: LiveNode, parent: LiveNode): boolean {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\n\nexport function deserialize(\n  [id, crdt]: IdTuple<SerializedCrdt>,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): LiveNode {\n  switch (crdt.type) {\n    case CrdtType.OBJECT: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.LIST: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.MAP: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.REGISTER: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\n\nexport function deserializeToLson(\n  [id, crdt]: IdTuple<SerializedCrdt>,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): Lson {\n  switch (crdt.type) {\n    case CrdtType.OBJECT: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.LIST: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.MAP: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.REGISTER: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\n\nexport function isLiveStructure(value: unknown): value is LiveStructure {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\n\nexport function isLiveNode(value: unknown): value is LiveNode {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\n\nexport function isLiveList(value: unknown): value is LiveList<Lson> {\n  return value instanceof LiveList;\n}\n\nexport function isLiveMap(value: unknown): value is LiveMap<string, Lson> {\n  return value instanceof LiveMap;\n}\n\nexport function isLiveObject(value: unknown): value is LiveObject<LsonObject> {\n  return value instanceof LiveObject;\n}\n\nexport function isLiveRegister(value: unknown): value is LiveRegister<Json> {\n  return value instanceof LiveRegister;\n}\n\nexport function cloneLson<L extends Lson | undefined>(value: L): L {\n  return value === undefined\n    ? (undefined as L)\n    : isLiveStructure(value)\n      ? (value.clone() as L)\n      : (deepClone(value) as L);\n}\n\nexport function liveNodeToLson(obj: LiveNode): Lson {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (\n    obj instanceof LiveList ||\n    obj instanceof LiveMap ||\n    obj instanceof LiveObject\n  ) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\n\nexport function lsonToLiveNode(value: Lson): LiveNode {\n  if (\n    value instanceof LiveObject ||\n    value instanceof LiveMap ||\n    value instanceof LiveList\n  ) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\n\nexport function getTreesDiffOperations(\n  currentItems: NodeMap,\n  newItems: NodeMap\n): Op[] {\n  const ops: Op[] = [];\n\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      // Delete crdt\n      ops.push({\n        type: OpCode.DELETE_CRDT,\n        id,\n      });\n    }\n  });\n\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === CrdtType.OBJECT) {\n        if (\n          currentCrdt.type !== CrdtType.OBJECT ||\n          stringify(crdt.data) !== stringify(currentCrdt.data)\n        ) {\n          ops.push({\n            type: OpCode.UPDATE_OBJECT,\n            id,\n            data: crdt.data,\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: OpCode.SET_PARENT_KEY,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\"),\n        });\n      }\n    } else {\n      // new Crdt\n      switch (crdt.type) {\n        case CrdtType.REGISTER:\n          ops.push({\n            type: OpCode.CREATE_REGISTER,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.LIST:\n          ops.push({\n            type: OpCode.CREATE_LIST,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n        case CrdtType.OBJECT:\n          if (crdt.parentId === undefined || crdt.parentKey === undefined) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: OpCode.CREATE_OBJECT,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.MAP:\n          ops.push({\n            type: OpCode.CREATE_MAP,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n      }\n    }\n  });\n\n  return ops;\n}\n\nfunction mergeObjectStorageUpdates<A extends LsonObject, B extends LsonObject>(\n  first: LiveObjectUpdates<A>,\n  second: LiveObjectUpdates<B>\n): LiveObjectUpdates<B> {\n  const updates = first.updates as (typeof second)[\"updates\"];\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeMapStorageUpdates<K2 extends string, V2 extends Lson>(\n  first: LiveMapUpdates<string, Lson>,\n  second: LiveMapUpdates<K2, V2>\n): LiveMapUpdates<K2, V2> {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeListStorageUpdates<T extends Lson>(\n  first: LiveListUpdates<Lson>,\n  second: LiveListUpdates<T>\n): LiveListUpdates<T> {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates),\n  };\n}\n\nexport function mergeStorageUpdates(\n  first: StorageUpdate | undefined,\n  second: StorageUpdate\n): StorageUpdate {\n  if (first === undefined) {\n    return second;\n  }\n\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n    /* Mismatching merge types. Throw an error here? */\n  }\n\n  return second;\n}\n\nfunction isPlain(\n  value: unknown\n): value is\n  | undefined\n  | null\n  | string\n  | boolean\n  | number\n  | unknown[]\n  | { [key: string]: unknown } {\n  const type = typeof value;\n  return (\n    value === undefined ||\n    value === null ||\n    type === \"string\" ||\n    type === \"boolean\" ||\n    type === \"number\" ||\n    Array.isArray(value) ||\n    isPlainObject(value)\n  );\n}\n\nexport function findNonSerializableValue(\n  value: unknown,\n  path: string = \"\"\n): { path: string; value: unknown } | false {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value,\n    };\n  }\n\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue,\n      };\n    }\n\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n\n  return false;\n}\n", "export function captureStackTrace(\n  msg: string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  traceRoot?: Function\n): string | undefined {\n  // Hack: Normally browsers will add the name of the error before the stack trace (default Error).\n  // To customize this, we set the name of the error to the message we want to display.\n  const errorLike: { name: string; stack?: string } = { name: msg };\n\n  // Error.captureStackTrace is non-standard and only available in certain browsers/runtimes.\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return undefined;\n  }\n\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n", "import { raise } from \"./utils\";\n\n/**\n * A Deque (= Double Ended Queue) is like a stack, but where elements can be\n * efficiently pushed or popped from either side.\n *\n * The following calls are equivalent with arrays (but insertions are O(n)\n * instead of O(n^2)):\n *\n * - deque.push(1)              ⇔  array.push(1)\n * - deque.push([1, 2, 3])      ⇔  array.push(1, 2, 3)\n * - deque.push(many)           ⇔  array.push(...many)\n * - deque.pop()                ⇔  array.pop()\n *\n * - deque.pushLeft(1)          ⇔  array.unshift(1)\n * - deque.pushLeft([1, 2, 3])  ⇔  array.unshift(1, 2, 3)\n * - deque.pushLeft(many)       ⇔  array.unshift(...many)\n * - deque.popLeft()            ⇔  array.shift()\n *\n */\nexport class Deque<T> {\n  readonly #data: Record<number, T>;\n  #front: number;\n  #back: number;\n  #size: number;\n\n  constructor() {\n    this.#data = {};\n    this.#front = 0; // Inclusive\n    this.#back = 1; // Exclusive\n    this.#size = 0;\n  }\n\n  get length(): number {\n    return this.#size;\n  }\n\n  *[Symbol.iterator](): IterableIterator<T> {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n\n  push(value: T | readonly T[]): void {\n    const values: readonly T[] = Array.isArray(value)\n      ? value\n      : ([value] as readonly T[]);\n    if (this.#back > Number.MAX_SAFE_INTEGER - values.length - 1)\n      raise(\"Deque full\");\n    for (const value of values) {\n      this.#data[this.#back++ - 1] = value;\n    }\n    this.#size += values.length;\n  }\n\n  pop(): T | undefined {\n    if (this.#size < 1) return undefined;\n\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n\n  pushLeft(value: T | readonly T[]): void {\n    const values: readonly T[] = Array.isArray(value)\n      ? value\n      : ([value] as readonly T[]);\n    if (this.#front < Number.MIN_SAFE_INTEGER + values.length)\n      raise(\"Deque full\");\n    for (let i = values.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values[i];\n    }\n    this.#size += values.length;\n  }\n\n  popLeft(): T | undefined {\n    if (this.#size < 1) return undefined;\n\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n}\n", "/**\n * Represents an indefinitely deep arbitrary JSON data structure. There are\n * four types that make up the Json family:\n *\n * - Json         any legal JSON value\n * - JsonScalar   any legal JSON leaf value (no lists or objects)\n * - JsonArray    a JSON value whose outer type is an array\n * - JsonObject   a JSON value whose outer type is an object\n *\n */\nexport type Json = JsonScalar | JsonArray | JsonObject;\nexport type JsonScalar = string | number | boolean | null;\nexport type JsonArray = Json[];\n/**\n * Any valid JSON object.\n */\nexport type JsonObject = { [key: string]: Json | undefined };\n\nexport function isJsonScalar(data: Json): data is JsonScalar {\n  return (\n    data === null ||\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\"\n  );\n}\n\nexport function isJsonArray(data: Json): data is JsonArray {\n  return Array.isArray(data);\n}\n\nexport function isJsonObject(data: Json): data is JsonObject {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n", "import type { Json, JsonObject } from \"../lib/Json\";\nimport type { Op } from \"./Op\";\n\nexport enum ClientMsgCode {\n  // For Presence\n  UPDATE_PRESENCE = 100,\n  BROADCAST_EVENT = 103,\n\n  // For Storage\n  FETCH_STORAGE = 200,\n  UPDATE_STORAGE = 201,\n\n  // For Yjs support\n  FETCH_YDOC = 300,\n  UPDATE_YDOC = 301,\n}\n\n/**\n * Messages that can be sent from the client to the server.\n */\nexport type ClientMsg<P extends JsonObject, E extends Json> =\n  // For Presence\n  | BroadcastEventClientMsg<E>\n  | UpdatePresenceClientMsg<P>\n\n  // For Storage\n  | UpdateStorageClientMsg\n  | FetchStorageClientMsg\n\n  // For Yjs support\n  | FetchYDocClientMsg\n  | UpdateYDocClientMsg;\n\nexport type BroadcastEventClientMsg<E extends Json> = {\n  type: ClientMsgCode.BROADCAST_EVENT;\n  event: E;\n};\n\nexport type UpdatePresenceClientMsg<P extends JsonObject> =\n  //\n  // Full Presence™ message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Set this to any number to signify that this is a Full Presence™\n       * update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      readonly data: P;\n    }\n\n  //\n  // Partial Presence™ message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Absence of the `targetActor` field signifies that this is a Partial\n       * Presence™ \"patch\".\n       */\n      readonly targetActor?: undefined;\n      readonly data: Partial<P>;\n    };\n\nexport type UpdateStorageClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_STORAGE;\n  readonly ops: Op[];\n};\n\nexport type FetchStorageClientMsg = {\n  readonly type: ClientMsgCode.FETCH_STORAGE;\n};\n\nexport type FetchYDocClientMsg = {\n  readonly type: ClientMsgCode.FETCH_YDOC;\n  readonly vector: string; // base64 encoded stateVector a from yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n  readonly v2?: boolean; // if it's a v2 update\n};\n\nexport type UpdateYDocClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_YDOC;\n  readonly update: string; // base64 encoded update from a yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n  readonly v2?: boolean; // if it's a v2 update\n};\n", "import { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { DerivedSignal, merge, MutableSignal } from \"../lib/signals\";\nimport { compact, compactObject } from \"../lib/utils\";\nimport { canComment, canWriteStorage } from \"../protocol/AuthToken\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { User } from \"../types/User\";\n\ntype Connection<U extends BaseUserMeta> = {\n  readonly connectionId: number;\n  readonly scopes: string[];\n  readonly id: U[\"id\"];\n  readonly info: U[\"info\"];\n};\n\nfunction makeUser<P extends JsonObject, U extends BaseUserMeta>(\n  conn: Connection<U>,\n  presence: P\n): User<P, U> {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite, // Deprecated, kept for backward-compatibility\n      presence,\n    })\n  );\n}\n\nexport class ManagedOthers<P extends JsonObject, U extends BaseUserMeta> {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  readonly #internal: MutableSignal<{\n    connections: Map</* connectionId */ number, Connection<U>>;\n    presences: Map</* connectionId */ number, P>;\n  }>;\n  readonly #userCache: Map</* connectionId */ number, User<P, U>>;\n\n  // The \"clean\" signal that is exposed to the outside world\n  public readonly signal: DerivedSignal<readonly User<P, U>[]>;\n\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: new Map</* connectionId */ number, Connection<U>>(),\n      presences: new Map</* connectionId */ number, P>(),\n    });\n\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore): readonly User<P, U>[] =>\n        compact(\n          Array.from(this.#internal.get().presences.keys()).map(\n            (connectionId) => this.getUser(Number(connectionId))\n          )\n        )\n    );\n\n    // Others\n    this.#userCache = new Map();\n  }\n\n  // Shorthand for .signal.get()\n  get(): readonly User<P, U>[] {\n    return this.signal.get();\n  }\n\n  public connectionIds(): IterableIterator<number> {\n    return this.#internal.get().connections.keys();\n  }\n\n  clearOthers(): void {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n\n  #_getUser(connectionId: number): User<P, U> | undefined {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== undefined && presence !== undefined) {\n      return makeUser(conn, presence);\n    }\n    return undefined;\n  }\n\n  getUser(connectionId: number): User<P, U> | undefined {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n\n    return undefined;\n  }\n\n  #invalidateUser(connectionId: number): void {\n    this.#userCache.delete(connectionId);\n  }\n\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(\n    connectionId: number,\n    metaUserId: U[\"id\"],\n    metaUserInfo: U[\"info\"],\n    scopes: string[]\n  ): void {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes,\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId: number): void {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId: number, presence: P): void {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId: number, patch: Partial<P>): void {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === undefined) {\n        return false;\n      }\n\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n}\n", "import { assertNever } from \"../lib/assert\";\nimport type { Relax } from \"../lib/Relax\";\nimport type { BaseMetadata, CommentBody } from \"../protocol/Comments\";\nimport type { Patchable } from \"./Patchable\";\n\n// All possible error originating from using Presence, Storage, or Yjs\n\ntype AiConnectionErrorContext = {\n  type: \"AI_CONNECTION_ERROR\";\n  code: -1 | 4001 | (number & {}); // eslint-disable-line @typescript-eslint/ban-types\n};\n\ntype RoomConnectionErrorContext = {\n  type: \"ROOM_CONNECTION_ERROR\";\n  code: -1 | 4001 | 4005 | 4006 | (number & {}); // eslint-disable-line @typescript-eslint/ban-types\n  roomId: string;\n};\n\ntype LargeMessageErrorContext = {\n  type: \"LARGE_MESSAGE_ERROR\";\n};\n\n// All possible errors originating from using Comments or Notifications\ntype CommentsOrNotificationsErrorContext =\n  | {\n      type: \"CREATE_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n      metadata: BaseMetadata;\n    }\n  | {\n      type: \"DELETE_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n    }\n  | {\n      type: \"EDIT_THREAD_METADATA_ERROR\";\n      roomId: string;\n      threadId: string;\n      metadata: Patchable<BaseMetadata>;\n    }\n  | {\n      type:\n        | \"MARK_THREAD_AS_RESOLVED_ERROR\"\n        | \"MARK_THREAD_AS_UNRESOLVED_ERROR\"\n        | \"SUBSCRIBE_TO_THREAD_ERROR\"\n        | \"UNSUBSCRIBE_FROM_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n    }\n  | {\n      type: \"CREATE_COMMENT_ERROR\" | \"EDIT_COMMENT_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  | {\n      type: \"DELETE_COMMENT_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n    }\n  | {\n      type: \"ADD_REACTION_ERROR\" | \"REMOVE_REACTION_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  | {\n      type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\";\n      inboxNotificationId: string;\n      roomId?: string;\n    }\n  | {\n      type: \"DELETE_INBOX_NOTIFICATION_ERROR\";\n      inboxNotificationId: string;\n    }\n  | {\n      type:\n        | \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\"\n        | \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\";\n    }\n  | {\n      type: \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\";\n      roomId: string;\n    }\n  | {\n      type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\";\n    };\n\nexport type LiveblocksErrorContext = Relax<\n  | RoomConnectionErrorContext // from Presence, Storage, or Yjs\n  | CommentsOrNotificationsErrorContext // from Comments or Notifications or UserNotificationSettings\n  | AiConnectionErrorContext // from AI\n  | LargeMessageErrorContext // whena  message is too large\n>;\n\nexport class LiveblocksError extends Error {\n  public readonly context: LiveblocksErrorContext;\n\n  constructor(message: string, context: LiveblocksErrorContext, cause?: Error) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId(): LiveblocksErrorContext[\"roomId\"] {\n    return this.context.roomId;\n  }\n\n  /** @internal Use `context.code` instead, to enable type narrowing */\n  get code(): LiveblocksErrorContext[\"code\"] {\n    return this.context.code;\n  }\n\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context: LiveblocksErrorContext, cause?: Error): LiveblocksError {\n    return new LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n}\n\n/**\n * Return a default, human-friendly error message for each possible error.\n */\nfunction defaultMessageFromContext(context: LiveblocksErrorContext): string {\n  // prettier-ignore\n  switch (context.type) {\n      case \"ROOM_CONNECTION_ERROR\": {\n        switch (context.code) {\n          case 4001: return \"Not allowed to connect to the room\";\n          case 4005: return \"Room is already full\";\n          case 4006: return \"Kicked out of the room, because the room ID changed\";\n          default:   return \"Could not connect to the room\";\n        }\n      }\n\n    case \"AI_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001: return \"Not allowed to connect to ai\";\n        default:   return \"Could not connect to the room\";\n      }\n    }\n\n    case \"CREATE_THREAD_ERROR\": return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\": return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\": return \"Could not edit thread metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\": return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\": return \"Could not mark thread as unresolved\";\n    case \"SUBSCRIBE_TO_THREAD_ERROR\": return \"Could not subscribe to thread\";\n    case \"UNSUBSCRIBE_FROM_THREAD_ERROR\": return \"Could not unsubscribe from thread\";\n    case \"CREATE_COMMENT_ERROR\": return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\": return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\": return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\": return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\": return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\": return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\": return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\": return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\": return \"Could not delete all inbox notifications\";\n    case \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\": return \"Could not update room subscription settings\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\": return \"Could not update notification settings\";\n    case \"LARGE_MESSAGE_ERROR\": return \"Could not send large message\";\n\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n", "import { getBearerTokenFromAuthValue, type RoomHttpApi } from \"./api-client\";\nimport type { AuthManager, AuthValue } from \"./auth-manager\";\nimport type { InternalSyncStatus } from \"./client\";\nimport type { Delegates, LostConnectionEvent, Status } from \"./connection\";\nimport { ManagedSocket, StopRetrying } from \"./connection\";\nimport type { ApplyResult, ManagedPool } from \"./crdts/AbstractCrdt\";\nimport { createManagedPool, OpSource } from \"./crdts/AbstractCrdt\";\nimport {\n  cloneLson,\n  getTreesDiffOperations,\n  isLiveList,\n  isLiveNode,\n  isSameNodeOrChildOf,\n  mergeStorageUpdates,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport type { LiveStructure, LsonObject } from \"./crdts/Lson\";\nimport type { StorageCallback, StorageUpdate } from \"./crdts/StorageUpdates\";\nimport type { DE, DM, DP, DS, DU } from \"./globals/augmentation\";\nimport { kInternal } from \"./internal\";\nimport { assertNever, nn } from \"./lib/assert\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Promise_withResolvers } from \"./lib/controlledPromise\";\nimport { createCommentAttachmentId } from \"./lib/createIds\";\nimport { captureStackTrace } from \"./lib/debug\";\nimport { Deque } from \"./lib/Deque\";\nimport type { Callback, EventSource, Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonArray, isJsonObject } from \"./lib/Json\";\nimport { asPos } from \"./lib/position\";\nimport { DerivedSignal, PatchableSignal, Signal } from \"./lib/signals\";\nimport { stringifyOrLog as stringify } from \"./lib/stringify\";\nimport {\n  compact,\n  deepClone,\n  memoizeOnSuccess,\n  raise,\n  tryParseJson,\n} from \"./lib/utils\";\nimport type {\n  ContextualPromptContext,\n  ContextualPromptResponse,\n} from \"./protocol/Ai\";\nimport type { Permission } from \"./protocol/AuthToken\";\nimport { canComment, canWriteStorage, TokenKind } from \"./protocol/AuthToken\";\nimport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nimport type {\n  ClientMsg,\n  UpdateStorageClientMsg,\n  UpdateYDocClientMsg,\n} from \"./protocol/ClientMsg\";\nimport { ClientMsgCode } from \"./protocol/ClientMsg\";\nimport type {\n  BaseMetadata,\n  CommentAttachment,\n  CommentBody,\n  CommentData,\n  CommentLocalAttachment,\n  CommentUserReaction,\n  QueryMetadata,\n  ThreadData,\n  ThreadDeleteInfo,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n} from \"./protocol/InboxNotifications\";\nimport type { MentionData } from \"./protocol/MentionData\";\nimport type { Op } from \"./protocol/Op\";\nimport { isAckOp, OpCode } from \"./protocol/Op\";\nimport type { RoomSubscriptionSettings } from \"./protocol/RoomSubscriptionSettings\";\nimport type { IdTuple, SerializedCrdt } from \"./protocol/SerializedCrdt\";\nimport type {\n  CommentsEventServerMsg,\n  InitialDocumentStateServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  UpdatePresenceServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type {\n  SubscriptionData,\n  SubscriptionDeleteInfo,\n} from \"./protocol/Subscriptions\";\nimport type { HistoryVersion } from \"./protocol/VersionHistory\";\nimport { ManagedOthers } from \"./refs/ManagedOthers\";\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nimport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport { LiveblocksError } from \"./types/LiveblocksError\";\nimport type { NodeMap } from \"./types/NodeMap\";\nimport type {\n  InternalOthersEvent,\n  OthersEvent,\n  TextEditorType,\n} from \"./types/Others\";\nimport type { Patchable } from \"./types/Patchable\";\nimport type { User } from \"./types/User\";\nimport { PKG_VERSION } from \"./version\";\n\nexport type TimeoutID = ReturnType<typeof setTimeout>;\n\n//\n// NOTE:\n// This type looks an awful lot like InternalOthersEvent, but don't change this\n// type definition or DRY this up!\n// The type LegacyOthersEvent is used in the signature of some public APIs, and\n// as such should remain backward compatible.\n//\ntype LegacyOthersEvent<P extends JsonObject, U extends BaseUserMeta> =\n  | { type: \"leave\"; user: User<P, U> }\n  | { type: \"enter\"; user: User<P, U> }\n  | {\n      type: \"update\";\n      user: User<P, U>;\n      updates: Partial<P>;\n    }\n  | { type: \"reset\" };\n\ntype LegacyOthersEventCallback<P extends JsonObject, U extends BaseUserMeta> = (\n  others: readonly User<P, U>[],\n  event: LegacyOthersEvent<P, U>\n) => void;\n\nexport type RoomEventMessage<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * The connection ID of the client that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be -1.\n   */\n  connectionId: number;\n  /**\n   * The User (from the others list) that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be null.\n   */\n  user: User<P, U> | null;\n  event: E;\n};\n\nexport type SyncStatus =\n  /* Liveblocks is in the process of writing changes */\n  | \"synchronizing\"\n  /* Liveblocks has persisted all pending changes */\n  | \"synchronized\";\n\nexport type StorageStatus =\n  /* The storage is not loaded and has not been requested. */\n  | \"not-loaded\"\n  /* The storage is loading from Liveblocks servers */\n  | \"loading\"\n  /* Some storage modifications has not been acknowledged yet by the server */\n  | \"synchronizing\"\n  /* The storage is sync with Liveblocks servers */\n  | \"synchronized\";\n\ntype RoomEventCallbackMap<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  status: Callback<Status>; // New/recommended API\n  \"lost-connection\": Callback<LostConnectionEvent>;\n  event: Callback<RoomEventMessage<P, U, E>>;\n  \"my-presence\": Callback<P>;\n  //\n  // NOTE: LegacyOthersEventCallback is the only one not taking a Callback<T>\n  // shape, since this API historically has taken _two_ callback arguments\n  // instead of just one.\n  others: LegacyOthersEventCallback<P, U>;\n  error: Callback<Error>;\n  history: Callback<HistoryEvent>;\n  \"storage-status\": Callback<StorageStatus>;\n  comments: Callback<CommentsEventServerMsg>;\n};\n\nexport interface History {\n  /**\n   * Undoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   */\n  undo: () => void;\n\n  /**\n   * Redoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   * room.history.redo();\n   * // room.getPresence() equals { selectedId: \"yy\" }\n   */\n  redo: () => void;\n\n  /**\n   * Returns whether there are any operations to undo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * // room.history.canUndo() is true\n   * room.history.undo();\n   * // room.history.canUndo() is false\n   */\n  canUndo: () => boolean;\n\n  /**\n   * Returns whether there are any operations to redo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.history.canRedo() is true\n   * room.history.redo();\n   * // room.history.canRedo() is false\n   */\n  canRedo: () => boolean;\n\n  /**\n   * Clears the undo and redo stacks. This operation cannot be undone ;)\n   */\n  clear: () => void;\n\n  /**\n   * All future modifications made on the Room will be merged together to create a single history item until resume is called.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  pause: () => void;\n\n  /**\n   * Resumes history. Modifications made on the Room are not merged into a single history item anymore.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  resume: () => void;\n}\n\nexport type HistoryEvent = {\n  canUndo: boolean;\n  canRedo: boolean;\n};\n\nexport type RoomEventName = Extract<\n  keyof RoomEventCallbackMap<never, never, never>,\n  string\n>;\n\nexport type RoomEventCallbackFor<\n  K extends RoomEventName,\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = RoomEventCallbackMap<P, U, E>[K];\n\nexport type RoomEventCallback = RoomEventCallbackFor<\n  RoomEventName,\n  JsonObject,\n  BaseUserMeta,\n  Json\n>;\n\nexport type BroadcastOptions = {\n  /**\n   * Whether or not event is queued if the connection is currently closed.\n   *\n   * ❗ We are not sure if we want to support this option in the future so it might be deprecated to be replaced by something else\n   */\n  shouldQueueEventIfNotReady: boolean;\n};\n\ntype SubscribeFn<\n  P extends JsonObject,\n  _TStorage extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * Subscribes to changes made on any Live structure. Returns an unsubscribe function.\n   *\n   * @internal This legacy API works, but was never documented publicly.\n   */\n  (callback: StorageCallback): () => void;\n\n  /**\n   * Subscribe to the current user presence updates.\n   *\n   * @param listener the callback that is called every time the current user presence is updated with {@link Room.updatePresence}.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"my-presence\", (presence) => {\n   *   // Do something\n   * });\n   */\n  (type: \"my-presence\", listener: Callback<P>): () => void;\n\n  /**\n   * Subscribe to the other users updates.\n   *\n   * @param listener the callback that is called when a user enters or leaves the room or when a user update its presence.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"others\", (others) => {\n   *   // Do something\n   * });\n   *\n   */\n  (type: \"others\", listener: LegacyOthersEventCallback<P, U>): () => void;\n\n  /**\n   * Subscribe to events broadcasted by {@link Room.broadcastEvent}\n   *\n   * @param listener the callback that is called when a user calls {@link Room.broadcastEvent}\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"event\", ({ event, connectionId }) => {\n   *   // Do something\n   * });\n   *\n   */\n  (type: \"event\", listener: Callback<RoomEventMessage<P, U, E>>): () => void;\n\n  /**\n   * Subscribe to errors thrown in the room.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"error\", listener: Callback<LiveblocksError>): () => void;\n\n  /**\n   * Subscribe to connection status updates. The callback will be called any\n   * time the status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"status\", listener: Callback<Status>): () => void;\n\n  /**\n   * Subscribe to the exceptional event where reconnecting to the Liveblocks\n   * servers is taking longer than usual. This typically is a sign of a client\n   * that has lost internet connectivity.\n   *\n   * This isn't problematic (because the Liveblocks client is still trying to\n   * reconnect), but it's typically a good idea to inform users about it if\n   * the connection takes too long to recover.\n   */\n  (\n    type: \"lost-connection\",\n    listener: Callback<LostConnectionEvent>\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure. Returns an unsubscribe function.\n   *\n   * @param callback The callback this called when the Live structure changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (liveMap) => { });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: (node: L) => void\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure and all the nested data\n   * structures. Returns an unsubscribe function. In a future version, we\n   * will also expose what exactly changed in the Live structure.\n   *\n   * @param callback The callback this called when the Live structure, or any\n   * of its nested values, changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (updates) => { }, { isDeep: true });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: StorageCallback,\n    options: { isDeep: true }\n  ): () => void;\n\n  /**\n   * Subscribe to the current user's history changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"history\", ({ canUndo, canRedo }) => {\n   *   // Do something\n   * });\n   */\n  (type: \"history\", listener: Callback<HistoryEvent>): () => void;\n\n  /**\n   * Subscribe to storage status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"storage-status\", (status) => {\n   *   switch(status) {\n   *      case \"not-loaded\":\n   *        break;\n   *      case \"loading\":\n   *        break;\n   *      case \"synchronizing\":\n   *        break;\n   *      case \"synchronized\":\n   *        break;\n   *      default:\n   *        break;\n   *   }\n   * });\n   */\n  (type: \"storage-status\", listener: Callback<StorageStatus>): () => void;\n\n  (type: \"comments\", listener: Callback<CommentsEventServerMsg>): () => void;\n};\n\nexport type GetThreadsOptions<M extends BaseMetadata> = {\n  cursor?: string;\n  query?: {\n    resolved?: boolean;\n    metadata?: Partial<QueryMetadata<M>>;\n  };\n};\n\nexport type GetThreadsSinceOptions = {\n  since: Date;\n  signal?: AbortSignal;\n};\n\nexport type UploadAttachmentOptions = {\n  signal?: AbortSignal;\n};\n\ntype ListTextVersionsSinceOptions = {\n  since: Date;\n  signal?: AbortSignal;\n};\n\ntype GetSubscriptionSettingsOptions = {\n  signal?: AbortSignal;\n};\n\n/**\n * @private Widest-possible Room type, matching _any_ Room instance. Note that\n * this type is different from `Room`-without-type-arguments. That represents\n * a Room instance using globally augmented types only, which is narrower.\n */\nexport type OpaqueRoom = Room<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  Json,\n  BaseMetadata\n>;\n\nexport type Room<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n> = {\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  readonly [kInternal]: PrivateRoomApi;\n\n  /**\n   * The id of the room.\n   */\n  readonly id: string;\n\n  /**\n   * Return the current connection status for this room. Can be used to display\n   * a status badge for your Liveblocks connection.\n   */\n  getStatus(): Status;\n  readonly subscribe: SubscribeFn<P, S, U, E>;\n\n  /**\n   * Room's history contains functions that let you undo and redo operation made on by the current client on the presence and storage.\n   */\n  readonly history: History;\n\n  /**\n   * Gets the current user.\n   * Returns null if not it is not yet connected to the room.\n   *\n   * @example\n   * const user = room.getSelf();\n   */\n  getSelf(): User<P, U> | null;\n\n  /**\n   * Gets the presence of the current user.\n   *\n   * @example\n   * const presence = room.getPresence();\n   */\n  getPresence(): P;\n\n  /**\n   * Gets all the other users in the room.\n   *\n   * @example\n   * const others = room.getOthers();\n   */\n  getOthers(): readonly User<P, U>[];\n\n  /**\n   * Updates the presence of the current user. Only pass the properties you want to update. No need to send the full presence.\n   * @param patch A partial object that contains the properties you want to update.\n   * @param options Optional object to configure the behavior of updatePresence.\n   *\n   * @example\n   * room.updatePresence({ x: 0 });\n   * room.updatePresence({ y: 0 });\n   *\n   * const presence = room.getPresence();\n   * // presence is equivalent to { x: 0, y: 0 }\n   */\n  updatePresence(\n    patch: Partial<P>,\n    options?: {\n      /**\n       * Whether or not the presence should have an impact on the undo/redo history.\n       */\n      addToHistory: boolean;\n    }\n  ): void;\n\n  /**\n   * Sends Yjs document updates to Liveblocks server.\n   *\n   * @param {string} data the doc update to send to the server, base64 encoded uint8array\n   */\n  updateYDoc(data: string, guid?: string, isV2?: boolean): void;\n\n  /**\n   * Sends a request for the current document from liveblocks server\n   */\n  fetchYDoc(stateVector: string, guid?: string, isV2?: boolean): void;\n\n  /**\n   * Broadcasts an event to other users in the room. Event broadcasted to the room can be listened with {@link Room.subscribe}(\"event\").\n   * @param {any} event the event to broadcast. Should be serializable to JSON\n   *\n   * @example\n   * // On client A\n   * room.broadcastEvent({ type: \"EMOJI\", emoji: \"🔥\" });\n   *\n   * // On client B\n   * room.subscribe(\"event\", ({ event }) => {\n   *   if(event.type === \"EMOJI\") {\n   *     // Do something\n   *   }\n   * });\n   */\n  broadcastEvent(event: E, options?: BroadcastOptions): void;\n\n  /**\n   * Get the room's storage asynchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   */\n  getStorage(): Promise<{\n    root: LiveObject<S>;\n  }>;\n\n  /**\n   * Get the room's storage synchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const root = room.getStorageSnapshot();\n   */\n  getStorageSnapshot(): LiveObject<S> | null;\n\n  /**\n   * All possible room events, subscribable from a single place.\n   *\n   * @private These event sources are private for now, but will become public\n   * once they're stable.\n   */\n  readonly events: {\n    readonly status: Observable<Status>;\n    readonly lostConnection: Observable<LostConnectionEvent>;\n\n    readonly customEvent: Observable<RoomEventMessage<P, U, E>>; // prettier-ignore\n    readonly self: Observable<User<P, U>>;\n    readonly myPresence: Observable<P>;\n    readonly others: Observable<OthersEvent<P, U>>;\n    readonly storageBatch: Observable<StorageUpdate[]>;\n    readonly history: Observable<HistoryEvent>;\n\n    /**\n     * Subscribe to the storage loaded event. Will fire any time a full Storage\n     * copy is downloaded. (This happens after the initial connect, and on\n     * every reconnect.)\n     */\n    readonly storageDidLoad: Observable<void>;\n\n    readonly storageStatus: Observable<StorageStatus>;\n    readonly ydoc: Observable<YDocUpdateServerMsg | UpdateYDocClientMsg>;\n    readonly comments: Observable<CommentsEventServerMsg>;\n\n    /**\n     * Called right before the room is destroyed. The event cannot be used to\n     * prevent the room from being destroyed, only to be informed that this is\n     * imminent.\n     */\n    readonly roomWillDestroy: Observable<void>;\n  };\n\n  /**\n   * Batches modifications made during the given function.\n   * All the modifications are sent to other clients in a single message.\n   * All the subscribers are called only after the batch is over.\n   * All the modifications are merged in a single history item (undo/redo).\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   * room.batch(() => {\n   *   root.set(\"x\", 0);\n   *   room.updatePresence({ cursor: { x: 100, y: 100 }});\n   * });\n   */\n  batch<T>(fn: () => T): T;\n\n  /**\n   * Get the storage status.\n   *\n   * - `not-loaded`: Initial state when entering the room.\n   * - `loading`: Once the storage has been requested via room.getStorage().\n   * - `synchronizing`: When some local updates have not been acknowledged by Liveblocks servers.\n   * - `synchronized`: Storage is in sync with Liveblocks servers.\n   */\n  getStorageStatus(): StorageStatus;\n\n  isPresenceReady(): boolean;\n  isStorageReady(): boolean;\n\n  /**\n   * Returns a Promise that resolves as soon as Presence is available, which\n   * happens shortly after the WebSocket connection has been established. Once\n   * this happens, `self` and `others` are known and available to use. After\n   * awaiting this promise, `.isPresenceReady()` will be guaranteed to be true.\n   * Even when calling this function multiple times, it's guaranteed to return\n   * the same Promise instance.\n   */\n  waitUntilPresenceReady(): Promise<void>;\n\n  /**\n   * Returns a Promise that resolves as soon as Storage has been loaded and\n   * available. After awaiting this promise, `.isStorageReady()` will be\n   * guaranteed to be true. Even when calling this function multiple times,\n   * it's guaranteed to return the same Promise instance.\n   */\n  waitUntilStorageReady(): Promise<void>;\n\n  /**\n   * Start an attempt to connect the room (aka \"enter\" it). Calling\n   * `.connect()` only has an effect if the room is still in its idle initial\n   * state, or the room was explicitly disconnected, or reconnection attempts\n   * were stopped (for example, because the user isn't authorized to enter the\n   * room). Will be a no-op otherwise.\n   */\n  connect(): void;\n\n  /**\n   * Disconnect the room's connection to the Liveblocks server, if any. Puts\n   * the room back into an idle state. It will not do anything until either\n   * `.connect()` or `.reconnect()` is called.\n   *\n   * Only use this API if you wish to connect the room again at a later time.\n   * If you want to disconnect the room because you no longer need it, call\n   * `.destroy()` instead.\n   */\n  disconnect(): void;\n\n  /**\n   * @internal (for now)\n   *\n   * Disconnect the room's connection to the Liveblocks server, if any. Runs\n   * cleanup functions. The room instance can no longer be used to (re)connect.\n   */\n  destroy(): void;\n\n  /**\n   * Reconnect the room to the Liveblocks server by re-establishing a fresh\n   * connection. If the room is not connected yet, initiate it.\n   */\n  reconnect(): void;\n\n  /**\n   * Returns the threads within the current room and their associated inbox notifications.\n   * It also returns the request date that can be used for subsequent polling.\n   *\n   * @example\n   * const {\n   *   threads,\n   *   inboxNotifications,\n   *   subscriptions,\n   *   requestedAt\n   * } = await room.getThreads({ query: { resolved: false }});\n   */\n  getThreads(options?: GetThreadsOptions<M>): Promise<{\n    threads: ThreadData<M>[];\n    inboxNotifications: InboxNotificationData[];\n    subscriptions: SubscriptionData[];\n    requestedAt: Date;\n    nextCursor: string | null;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  /**\n   * Returns the updated and deleted threads and their associated inbox notifications and subscriptions since the requested date.\n   *\n   * @example\n   * const result = await room.getThreads();\n   * // ... //\n   * await room.getThreadsSince({ since: result.requestedAt });\n   */\n  getThreadsSince(options: GetThreadsSinceOptions): Promise<{\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  /**\n   * Returns a thread and the associated inbox notification and subscription if it exists.\n   *\n   * @example\n   * const { thread, inboxNotification, subscription } = await room.getThread(\"th_xxx\");\n   */\n  getThread(threadId: string): Promise<{\n    thread?: ThreadData<M>;\n    inboxNotification?: InboxNotificationData;\n    subscription?: SubscriptionData;\n  }>;\n\n  /**\n   * Creates a thread.\n   *\n   * @example\n   * const thread = await room.createThread({\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * })\n   */\n  createThread(options: {\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<ThreadData<M>>;\n\n  /**\n   * Deletes a thread.\n   *\n   * @example\n   * await room.deleteThread(\"th_xxx\");\n   */\n  deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Edits a thread's metadata.\n   * To delete an existing metadata property, set its value to `null`.\n   *\n   * @example\n   * await room.editThreadMetadata({ threadId: \"th_xxx\", metadata: { x: 100, y: 100 } })\n   */\n  editThreadMetadata(options: {\n    metadata: Patchable<M>;\n    threadId: string;\n  }): Promise<M>;\n\n  /**\n   * Marks a thread as resolved.\n   *\n   * @example\n   * await room.markThreadAsResolved(\"th_xxx\");\n   */\n  markThreadAsResolved(threadId: string): Promise<void>;\n\n  /**\n   * Marks a thread as unresolved.\n   *\n   * @example\n   * await room.markThreadAsUnresolved(\"th_xxx\");\n   */\n  markThreadAsUnresolved(threadId: string): Promise<void>;\n\n  /**\n   * Subscribes the user to a thread.\n   *\n   * @example\n   * await room.subscribeToThread(\"th_xxx\");\n   */\n  subscribeToThread(threadId: string): Promise<SubscriptionData>;\n\n  /**\n   * Unsubscribes the user from a thread.\n   *\n   * @example\n   * await room.unsubscribeFromThread(\"th_xxx\");\n   */\n  unsubscribeFromThread(threadId: string): Promise<void>;\n\n  /**\n   * Creates a comment.\n   *\n   * @example\n   * await room.createComment({\n   *   threadId: \"th_xxx\",\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * });\n   */\n  createComment(options: {\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  /**\n   * Edits a comment.\n   *\n   * @example\n   * await room.editComment({\n   *   threadId: \"th_xxx\",\n   *   commentId: \"cm_xxx\"\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * });\n   */\n  editComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<CommentData>;\n\n  /**\n   * Deletes a comment.\n   * If it is the last non-deleted comment, the thread also gets deleted.\n   *\n   * @example\n   * await room.deleteComment({\n   *   threadId: \"th_xxx\",\n   *   commentId: \"cm_xxx\"\n   * });\n   */\n  deleteComment(options: {\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  /**\n   * Adds a reaction from a comment for the current user.\n   *\n   * @example\n   * await room.addReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n   */\n  addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<CommentUserReaction>;\n\n  /**\n   * Removes a reaction from a comment.\n   *\n   * @example\n   * await room.removeReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n   */\n  removeReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  /**\n   * Creates a local attachment from a file.\n   *\n   * @example\n   * room.prepareAttachment(file);\n   */\n  prepareAttachment(file: File): CommentLocalAttachment;\n\n  /**\n   * Uploads a local attachment.\n   *\n   * @example\n   * const attachment = room.prepareAttachment(file);\n   * await room.uploadAttachment(attachment);\n   */\n  uploadAttachment(\n    attachment: CommentLocalAttachment,\n    options?: UploadAttachmentOptions\n  ): Promise<CommentAttachment>;\n\n  /**\n   * Returns a presigned URL for an attachment by its ID.\n   *\n   * @example\n   * await room.getAttachmentUrl(\"at_xxx\");\n   */\n  getAttachmentUrl(attachmentId: string): Promise<string>;\n\n  /**\n   * Gets the user's subscription settings for the current room.\n   *\n   * @example\n   * const settings = await room.getSubscriptionSettings();\n   */\n  getSubscriptionSettings(\n    options?: GetSubscriptionSettingsOptions\n  ): Promise<RoomSubscriptionSettings>;\n\n  /**\n   * Updates the user's subscription settings for the current room.\n   *\n   * @example\n   * await room.updateSubscriptionSettings({ threads: \"replies_and_mentions\" });\n   */\n  updateSubscriptionSettings(\n    settings: Partial<RoomSubscriptionSettings>\n  ): Promise<RoomSubscriptionSettings>;\n\n  /**\n   * @private\n   *\n   * Internal use only. Signature might change in the future.\n   */\n  markInboxNotificationAsRead(notificationId: string): Promise<void>;\n};\n\nexport type YjsSyncStatus = \"loading\" | \"synchronizing\" | \"synchronized\";\n\n/**\n * Interface that @liveblocks/yjs must respect.\n * This interface type is declare in @liveblocks/core, so we don't have to\n * depend on `yjs`. It's only used to determine the API contract between\n * @liveblocks/core and @liveblocks/yjs.\n */\nexport interface IYjsProvider {\n  synced: boolean;\n  getStatus: () => YjsSyncStatus;\n  on(event: \"sync\", listener: (synced: boolean) => void): void;\n  on(event: \"status\", listener: (status: YjsSyncStatus) => void): void;\n  off(event: \"sync\", listener: (synced: boolean) => void): void;\n  off(event: \"status\", listener: (status: YjsSyncStatus) => void): void;\n}\n\n/**\n * A \"Sync Source\" can be a Storage document, a Yjs document, Comments,\n * Notifications, etc.\n * The Client keeps a registry of all active sync sources, and will use it to\n * determine the global \"sync status\" for Liveblocks.\n */\nexport interface SyncSource {\n  setSyncStatus(status: InternalSyncStatus): void;\n  destroy(): void;\n}\n\n/**\n * @private\n *\n * Private methods to directly control the underlying state machine for this\n * room. Used in the core internals and for unit testing, but as a user of\n * Liveblocks, NEVER USE ANY OF THESE METHODS DIRECTLY, because bad things\n * will probably happen if you do.\n */\nexport type PrivateRoomApi = {\n  // For introspection in unit tests only\n  presenceBuffer: Json | undefined;\n  undoStack: readonly (readonly Readonly<HistoryOp<JsonObject>>[])[];\n  nodeCount: number;\n\n  // Get/set the associated Yjs provider on this room\n  getYjsProvider(): IYjsProvider | undefined;\n  setYjsProvider(provider: IYjsProvider | undefined): void;\n  yjsProviderDidChange: Observable<void>;\n\n  // For DevTools support (Liveblocks browser extension)\n  getSelf_forDevTools(): DevTools.UserTreeNode | null;\n  getOthers_forDevTools(): readonly DevTools.UserTreeNode[];\n\n  // For reporting editor metadata\n  reportTextEditor(editor: TextEditorType, rootKey: string): Promise<void>;\n\n  createTextMention(mentionId: string, mention: MentionData): Promise<void>;\n  deleteTextMention(mentionId: string): Promise<void>;\n  listTextVersions(): Promise<{\n    versions: HistoryVersion[];\n    requestedAt: Date;\n  }>;\n  listTextVersionsSince(options: ListTextVersionsSinceOptions): Promise<{\n    versions: HistoryVersion[];\n    requestedAt: Date;\n  }>;\n\n  getTextVersion(versionId: string): Promise<Response>;\n  createTextVersion(): Promise<void>;\n\n  executeContextualPrompt(options: {\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }): Promise<string>;\n\n  // NOTE: These are only used in our e2e test app!\n  simulate: {\n    explicitClose(event: IWebSocketCloseEvent): void;\n    rawSend(data: string): void;\n  };\n\n  attachmentUrlsStore: BatchStore<string, string>;\n};\n\n//\n// The maximum message size on websockets is 1MB. If a message larger than this\n// threshold is attempted to be sent, the strategy picked via the\n// `largeMessageStrategy` option will be used.\n//\n// In practice, we'll set threshold to slightly less than 1 MB.\nconst MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;\n\nfunction makeIdFactory(connectionId: number): IdFactory {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\n\ntype HistoryOp<P extends JsonObject> =\n  | Op\n  | {\n      readonly type: \"presence\";\n      readonly data: P;\n    };\n\ntype IdFactory = () => string;\n\nexport type StaticSessionInfo = {\n  readonly userId?: string;\n  readonly userInfo?: IUserInfo;\n};\n\nexport type DynamicSessionInfo = {\n  readonly actor: number;\n  readonly nonce: string;\n  readonly scopes: string[];\n};\n\ntype RoomState<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * All pending changes that yet need to be synced.\n   */\n  buffer: {\n    flushTimerID: TimeoutID | undefined;\n\n    // When the last flush happened. Together with config.throttleDelay, this\n    // will control whether the next flush will be sent out immediately, or if\n    // a flush will get scheduled for a few milliseconds into the future.\n    readonly lastFlushedAt: number;\n\n    // Queued-up \"my presence\" updates to be flushed at the earliest convenience\n    presenceUpdates:\n      | { type: \"partial\"; data: Partial<P> }\n      | { type: \"full\"; data: P }\n      | null;\n    messages: ClientMsg<P, E>[];\n    storageOperations: Op[];\n  };\n\n  //\n  // The \"self\" User takes assembly of three sources-of-truth:\n  // - The JWT token provides the userId and userInfo metadata (static)\n  // - The server, in its initial ROOM_STATE message, will provide the actor ID\n  //   and the scopes (dynamic)\n  // - The presence is provided by the client's initialPresence configuration (presence)\n  //\n  readonly staticSessionInfoSig: Signal<StaticSessionInfo | null>;\n  readonly dynamicSessionInfoSig: Signal<DynamicSessionInfo | null>;\n  readonly myPresence: PatchableSignal<P>;\n  readonly others: ManagedOthers<P, U>;\n\n  idFactory: IdFactory | null;\n  initialStorage: S;\n\n  yjsProvider: IYjsProvider | undefined;\n  readonly yjsProviderDidChange: EventSource<void>;\n\n  pool: ManagedPool;\n  root: LiveObject<S> | undefined;\n\n  readonly undoStack: HistoryOp<P>[][];\n  readonly redoStack: HistoryOp<P>[][];\n\n  /**\n   * When history is paused, all operations will get queued up here. When\n   * history is resumed, these operations get \"committed\" to the undo stack.\n   */\n  pausedHistory: null | Deque<HistoryOp<P>>;\n\n  /**\n   * Place to collect all mutations during a batch. Ops will be sent over the\n   * wire after the batch is ended.\n   */\n  activeBatch: {\n    ops: Op[];\n    reverseOps: Deque<HistoryOp<P>>;\n    updates: {\n      others: [];\n      presence: boolean;\n      storageUpdates: Map<string, StorageUpdate>;\n    };\n  } | null;\n\n  // A registry of yet-unacknowledged Ops. These Ops have already been\n  // submitted to the server, but have not yet been acknowledged.\n  readonly unacknowledgedOps: Map<string, Op>;\n\n  // Stack traces of all pending Ops. Used for debugging in non-production builds\n  readonly opStackTraces?: Map<string, string>;\n};\n\nexport type Polyfills = {\n  atob?: (data: string) => string;\n  fetch?: typeof fetch;\n  WebSocket?: IWebSocket;\n};\n\n/**\n * Makes all tuple positions optional.\n * Example, turns:\n *   [foo: string; bar: number]\n * into:\n *   [foo?: string; bar?: number]\n */\ntype OptionalTuple<T extends any[]> = { [K in keyof T]?: T[K] };\n\n/**\n * Returns Partial<T> if all fields on C are optional, T otherwise.\n */\nexport type PartialUnless<C, T> =\n  Record<string, never> extends C\n    ? Partial<T>\n    : // Extra test. We'll want to treat \"never\" as if the empty object is\n      // assignable to it, because otherwise it will not\n      [C] extends [never]\n      ? Partial<T>\n      : T;\n\n/**\n * Returns OptionalTupleUnless<T> if all fields on C are optional, T otherwise.\n */\nexport type OptionalTupleUnless<C, T extends any[]> =\n  Record<string, never> extends C\n    ? OptionalTuple<T>\n    : // Extra test. We'll want to treat \"never\" as if the empty object is\n      // assignable to it, because otherwise it will not\n      [C] extends [never]\n      ? OptionalTuple<T>\n      : T;\n\nexport type RoomDelegates = Omit<Delegates<AuthValue>, \"canZombie\">;\n\nexport type LargeMessageStrategy =\n  | \"default\"\n  | \"split\"\n  | \"experimental-fallback-to-http\";\n\n/** @internal */\nexport type RoomConfig<M extends BaseMetadata> = {\n  delegates: RoomDelegates;\n\n  roomId: string;\n  throttleDelay: number;\n  lostConnectionTimeout: number;\n  backgroundKeepAliveTimeout?: number;\n  largeMessageStrategy?: LargeMessageStrategy;\n\n  unstable_streamData?: boolean;\n\n  polyfills?: Polyfills;\n\n  roomHttpClient: RoomHttpApi<M>;\n\n  baseUrl: string;\n  enableDebugLogging?: boolean;\n\n  // We would not have to pass this complicated factory/callback functions to\n  // the createRoom() function if we would simply pass the Client instance to\n  // the Room instance, so it can directly call this back on the Client.\n  createSyncSource: () => SyncSource;\n  errorEventSource: EventSource<LiveblocksError>;\n};\n\nfunction userToTreeNode(\n  key: string,\n  user: User<JsonObject, BaseUserMeta>\n): DevTools.UserTreeNode {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite,\n    },\n  };\n}\n\n/**\n * Returns a ref to access if, and if so, how long the current tab is in the\n * background and an unsubscribe function.\n *\n * The `inBackgroundSince` value will either be a JS timestamp indicating the\n * moment the tab was put into the background, or `null` in case the tab isn't\n * currently in the background. In non-DOM environments, this will always\n * return `null`.\n */\nfunction installBackgroundTabSpy(): [\n  inBackgroundSince: { readonly current: number | null },\n  unsub: () => void,\n] {\n  const doc = typeof document !== \"undefined\" ? document : undefined;\n  const inBackgroundSince: { current: number | null } = { current: null };\n\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n\n  return [inBackgroundSince, unsub];\n}\n\n/**\n * @internal\n * Initializes a new Room, and returns its public API.\n */\nexport function createRoom<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(\n  options: { initialPresence: P; initialStorage: S },\n  config: RoomConfig<M>\n): Room<P, S, U, E, M> {\n  const roomId = config.roomId;\n  const initialPresence = options.initialPresence; // ?? {};\n  const initialStorage = options.initialStorage; // ?? {};\n\n  const httpClient = config.roomHttpClient;\n\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n\n  // Create a delegate pair for (a specific) Live Room socket connection(s)\n  const delegates = {\n    ...config.delegates,\n\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return (\n        config.backgroundKeepAliveTimeout !== undefined &&\n        inBackgroundSince.current !== null &&\n        Date.now() >\n          inBackgroundSince.current + config.backgroundKeepAliveTimeout &&\n        getStorageStatus() !== \"synchronizing\"\n      );\n    },\n  };\n\n  const managedSocket: ManagedSocket<AuthValue> = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n\n  // The room's internal stateful context\n  const context: RoomState<P, S, U, E> = {\n    buffer: {\n      flushTimerID: undefined,\n      lastFlushedAt: 0,\n      presenceUpdates:\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence,\n        },\n      messages: [],\n      storageOperations: [],\n    },\n\n    staticSessionInfoSig: new Signal<StaticSessionInfo | null>(null),\n    dynamicSessionInfoSig: new Signal<DynamicSessionInfo | null>(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers<P, U>(),\n\n    initialStorage,\n    idFactory: null,\n\n    // The Yjs provider associated to this room\n    yjsProvider: undefined,\n    yjsProviderDidChange: makeEventSource(),\n\n    // Storage\n    pool: createManagedPool(roomId, {\n      getCurrentConnectionId,\n      onDispatch,\n      isStorageWritable,\n    }),\n    root: undefined,\n\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n\n    activeBatch: null,\n    unacknowledgedOps: new Map<string, Op>(),\n\n    // Debug\n    opStackTraces:\n      process.env.NODE_ENV !== \"production\"\n        ? new Map<string, string>()\n        : undefined,\n  };\n\n  let lastTokenKey: string | undefined;\n  function onStatusDidChange(newStatus: Status) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === TokenKind.SECRET_LEGACY ? token.id : token.uid,\n            userInfo:\n              token.k === TokenKind.SECRET_LEGACY ? token.info : token.ui,\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: undefined,\n            userInfo: undefined,\n          });\n        }\n      }\n    }\n\n    // Forward to the outside world\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n\n  let _connectionLossTimerId: TimeoutID | undefined;\n  let _hasLostConnection = false;\n\n  function handleConnectionLossEvent(newStatus: Status) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n\n        // Clear the others\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          // Typically the case when going back to \"connected\", but really take\n          // *any* other state change as a recovery sign\n          eventHub.lostConnection.notify(\"restored\");\n        }\n\n        _hasLostConnection = false;\n      }\n    }\n  }\n\n  function onDidConnect() {\n    // Re-broadcast the full user presence as soon as we (re)connect\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data:\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() },\n    };\n\n    // NOTE: There was a flush here before, but I don't think it's really\n    // needed anymore. We're now combining this flush with the one below, to\n    // combine them in a single batch.\n    // tryFlushing();\n\n    // If a storage fetch has ever been initiated, we assume the client is\n    // interested in storage, so we will refresh it after a reconnection.\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n\n  // Register events handlers for events coming from the socket\n  // We never have to unsubscribe, because the Room and the Connection Manager\n  // will have the same life-time.\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n\n  function onDispatch(\n    ops: Op[],\n    reverse: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ): void {\n    if (process.env.NODE_ENV !== \"production\") {\n      const stackTrace = captureStackTrace(\"Storage mutation\", onDispatch);\n      if (stackTrace) {\n        for (const op of ops) {\n          if (op.opId) {\n            nn(context.opStackTraces).set(op.opId, stackTrace);\n          }\n        }\n      }\n    }\n\n    if (context.activeBatch) {\n      for (const op of ops) {\n        context.activeBatch.ops.push(op);\n      }\n      for (const [key, value] of storageUpdates) {\n        context.activeBatch.updates.storageUpdates.set(\n          key,\n          mergeStorageUpdates(\n            context.activeBatch.updates.storageUpdates.get(key),\n            value\n          )\n        );\n      }\n      context.activeBatch.reverseOps.pushLeft(reverse);\n    } else {\n      addToUndoStack(reverse);\n      context.redoStack.length = 0;\n      dispatchOps(ops);\n      notify({ storageUpdates });\n    }\n  }\n\n  function isStorageWritable(): boolean {\n    const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n    // If we aren't connected yet, assume we can write\n    return scopes !== undefined ? canWriteStorage(scopes) : true;\n  }\n\n  const eventHub = {\n    status: makeEventSource<Status>(), // New/recommended API\n    lostConnection: makeEventSource<LostConnectionEvent>(),\n\n    customEvent: makeEventSource<RoomEventMessage<P, U, E>>(),\n    self: makeEventSource<User<P, U>>(),\n    myPresence: makeEventSource<P>(),\n    others: makeEventSource<OthersEvent<P, U>>(),\n    storageBatch: makeEventSource<StorageUpdate[]>(),\n    history: makeEventSource<HistoryEvent>(),\n    storageDidLoad: makeEventSource<void>(),\n    storageStatus: makeEventSource<StorageStatus>(),\n    ydoc: makeEventSource<YDocUpdateServerMsg | UpdateYDocClientMsg>(),\n\n    comments: makeEventSource<CommentsEventServerMsg>(),\n    roomWillDestroy: makeEventSource<void>(),\n  };\n\n  async function createTextMention(mentionId: string, mention: MentionData) {\n    return httpClient.createTextMention({ roomId, mentionId, mention });\n  }\n\n  async function deleteTextMention(mentionId: string) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n\n  async function reportTextEditor(type: TextEditorType, rootKey: string) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n\n  async function listTextVersionsSince(options: ListTextVersionsSinceOptions) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options.since,\n      signal: options.signal,\n    });\n  }\n\n  async function getTextVersion(versionId: string) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n\n  async function executeContextualPrompt(options: {\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options,\n    });\n  }\n\n  /**\n   * Split a single large UPDATE_STORAGE message into smaller chunks, by\n   * splitting the ops list recursively in half.\n   */\n  function* chunkOps(msg: UpdateStorageClientMsg): IterableIterator<string> {\n    const { ops, ...rest } = msg;\n    if (ops.length < 2) {\n      throw new Error(\"Cannot split ops into smaller chunks\");\n    }\n\n    const mid = Math.floor(ops.length / 2);\n    const firstHalf = ops.slice(0, mid);\n    const secondHalf = ops.slice(mid);\n\n    for (const halfOps of [firstHalf, secondHalf]) {\n      const half: UpdateStorageClientMsg = { ops: halfOps, ...rest };\n      const text = stringify([half]);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkOps(half);\n      }\n    }\n  }\n\n  /**\n   * Split the message array in half (two chunks), and try to send each chunk\n   * separately. If the chunk is still too big, repeat the process. If a chunk\n   * can no longer be split up (i.e. is 1 message), then error.\n   */\n  function* chunkMessages(\n    messages: ClientMsg<P, E>[]\n  ): IterableIterator<string> {\n    if (messages.length < 2) {\n      if (messages[0].type === ClientMsgCode.UPDATE_STORAGE) {\n        yield* chunkOps(messages[0]);\n        return;\n      } else {\n        throw new Error(\n          \"Cannot split into chunks smaller than the allowed message size\"\n        );\n      }\n    }\n\n    const mid = Math.floor(messages.length / 2);\n    const firstHalf = messages.slice(0, mid);\n    const secondHalf = messages.slice(mid);\n\n    for (const half of [firstHalf, secondHalf]) {\n      const text = stringify(half);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkMessages(half);\n      }\n    }\n  }\n\n  function isTooBigForWebSocket(text: string): boolean {\n    // The theoretical worst case is that each character in the string is\n    // a 4-byte UTF-8 character. String.prototype.length is an O(1) operation,\n    // so we can spare ourselves the TextEncoder() measurement overhead with\n    // this heuristic.\n    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {\n      return false;\n    }\n\n    // Otherwise we need to measure to be sure\n    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;\n  }\n\n  function sendMessages(messages: ClientMsg<P, E>[]) {\n    const strategy = config.largeMessageStrategy ?? \"default\";\n\n    const text = stringify(messages);\n    if (!isTooBigForWebSocket(text)) {\n      return managedSocket.send(text); // Happy path\n    }\n\n    // If message is too big for WebSockets, we need to follow a strategy\n    switch (strategy) {\n      case \"default\": {\n        const type = \"LARGE_MESSAGE_ERROR\";\n        const err = new LiveblocksError(\"Message is too large for websockets\", {\n          type,\n        });\n        const didNotify = config.errorEventSource.notify(err);\n        if (!didNotify) {\n          console.error(\n            \"Message is too large for websockets.  Configure largeMessageStrategy option or useErrorListener to handle this.\"\n          );\n        }\n        return;\n      }\n\n      case \"split\": {\n        console.warn(\"Message is too large for websockets, splitting into smaller chunks\"); // prettier-ignore\n        for (const chunk of chunkMessages(messages)) {\n          managedSocket.send(chunk);\n        }\n        return;\n      }\n\n      case \"experimental-fallback-to-http\": {\n        console.warn(\"Message is too large for websockets, so sending over HTTP instead\"); // prettier-ignore\n        const nonce =\n          context.dynamicSessionInfoSig.get()?.nonce ??\n          raise(\"Session is not authorized to send message over HTTP\");\n\n        void httpClient\n          .sendMessages<P, E>({ roomId, nonce, messages })\n          .then((resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          });\n        return;\n      }\n    }\n  }\n\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence): User<P, U> | null => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n        };\n      }\n    }\n  );\n\n  let _lastSelf: Readonly<User<P, U>> | undefined;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n\n  // For use in DevTools\n  const selfAsTreeNode = DerivedSignal.from(self, (me) =>\n    me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n\n  function createOrUpdateRootFromMessage(\n    message: InitialDocumentStateServerMsg\n  ) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n\n    if (context.root !== undefined) {\n      updateRoot(message.items);\n    } else {\n      context.root = LiveObject._fromItems<S>(message.items, context.pool);\n    }\n\n    const canWrite = self.get()?.canWrite ?? true;\n\n    // Populate missing top-level keys using `initialStorage`\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === undefined) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          console.warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n\n    // Initial storage is populated using normal \"set\" operations in the loop\n    // above, those updates can end up in the undo stack, so let's prune it.\n    context.undoStack.length = stackSizeBefore;\n  }\n\n  function updateRoot(items: IdTuple<SerializedCrdt>[]) {\n    if (context.root === undefined) {\n      return;\n    }\n\n    const currentItems: NodeMap = new Map();\n    for (const [id, node] of context.pool.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n\n    // Get operations that represent the diff between 2 states.\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n\n    const result = applyOps(ops, false);\n\n    notify(result.updates);\n  }\n\n  function _addToRealUndoStack(historyOps: HistoryOp<P>[]) {\n    // If undo stack is too large, we remove the older item\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n\n    context.undoStack.push(historyOps);\n    onHistoryChange();\n  }\n\n  function addToUndoStack(historyOps: HistoryOp<P>[]) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(historyOps);\n    } else {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n\n  type NotifyUpdates = {\n    storageUpdates?: Map<string, StorageUpdate>;\n    presence?: boolean;\n    others?: InternalOthersEvent<P, U>[];\n  };\n\n  function notify(updates: NotifyUpdates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n\n    if (othersUpdates !== undefined && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n\n    if (storageUpdates !== undefined && storageUpdates.size > 0) {\n      const updates = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates);\n    }\n    notifyStorageStatus();\n  }\n\n  function getCurrentConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n\n  function applyOps<O extends HistoryOp<P>>(\n    rawOps: readonly O[],\n    isLocal: boolean\n  ): {\n    // Input Ops can get opIds assigned during application.\n    ops: O[];\n    reverse: O[];\n    updates: {\n      storageUpdates: Map<string, StorageUpdate>;\n      presence: boolean;\n    };\n  } {\n    const output = {\n      reverse: new Deque<O>(),\n      storageUpdates: new Map<string, StorageUpdate>(),\n      presence: false,\n    };\n\n    const createdNodeIds = new Set<string>();\n\n    // Ops applied after undo/redo won't have opIds assigned, yet. Let's do\n    // that right now first.\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: context.pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\" as const,\n          data: {} as P,\n        };\n\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.get()[key];\n        }\n\n        context.myPresence.patch(op.data);\n\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          // Merge the new fields with whatever is already queued up (doesn't\n          // matter whether its a partial or full update)\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n\n        output.reverse.pushLeft(reverse as O);\n        output.presence = true;\n      } else {\n        let source: OpSource;\n\n        if (isLocal) {\n          source = OpSource.UNDOREDO_RECONNECT;\n        } else {\n          const opId = nn(op.opId);\n          if (process.env.NODE_ENV !== \"production\") {\n            nn(context.opStackTraces).delete(opId);\n          }\n\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? OpSource.ACK : OpSource.REMOTE;\n        }\n\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n\n          // If the modified node is not the root (undefined) and was created in the same batch, we don't want to notify\n          // storage updates for the children.\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.pushLeft(applyOpResult.reverse as O[]);\n          }\n\n          if (\n            op.type === OpCode.CREATE_LIST ||\n            op.type === OpCode.CREATE_MAP ||\n            op.type === OpCode.CREATE_OBJECT\n          ) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n\n    return {\n      ops,\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence,\n      },\n    };\n  }\n\n  function applyOp(op: Op, source: OpSource): ApplyResult {\n    // Explicit case to handle incoming \"AckOp\"s, which are supposed to be\n    // no-ops.\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n\n    switch (op.type) {\n      case OpCode.DELETE_OBJECT_KEY:\n      case OpCode.UPDATE_OBJECT:\n      case OpCode.DELETE_CRDT: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        return node._apply(op, source === OpSource.UNDOREDO_RECONNECT);\n      }\n\n      case OpCode.SET_PARENT_KEY: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case OpCode.CREATE_OBJECT:\n      case OpCode.CREATE_LIST:\n      case OpCode.CREATE_MAP:\n      case OpCode.CREATE_REGISTER: {\n        if (op.parentId === undefined) {\n          return { modified: false };\n        }\n\n        const parentNode = context.pool.nodes.get(op.parentId);\n        if (parentNode === undefined) {\n          return { modified: false };\n        }\n\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n\n  function updatePresence(\n    patch: Partial<P>,\n    options?: { addToHistory: boolean }\n  ) {\n    const oldValues = {} as P;\n\n    if (context.buffer.presenceUpdates === null) {\n      // try {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {},\n      };\n      // } catch (err) {\n      //   window.console.log({ context, patch, err });\n      //   throw err;\n      // }\n    }\n\n    for (const key in patch) {\n      type K = typeof key;\n      const overrideValue: P[K] | undefined = patch[key];\n      if (overrideValue === undefined) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n\n    context.myPresence.patch(patch);\n\n    if (context.activeBatch) {\n      if (options?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues,\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n\n  function onUpdatePresenceMessage(\n    message: UpdatePresenceServerMsg<P>\n  ): InternalOthersEvent<P, U> | undefined {\n    if (message.targetActor !== undefined) {\n      // The incoming message is a full presence update. We are obliged to\n      // handle it if `targetActor` matches our own connection ID, but we can\n      // use the opportunity to effectively reset the known presence as\n      // a \"keyframe\" update, while we have free access to it.\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === undefined && newUser !== undefined) {\n        // The user just became \"visible\" due to this update, so fire the\n        // \"enter\" event\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      // The incoming message is a partial presence update\n      context.others.patchOther(message.actor, message.data), message;\n    }\n\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  function onUserLeftMessage(\n    message: UserLeftServerMsg\n  ): InternalOthersEvent<P, U> | null {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n\n  function onRoomStateMessage(\n    message: RoomStateServerMsg<U>\n  ): InternalOthersEvent<P, U> {\n    // The server will inform the client about its assigned actor ID and scopes\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes,\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === undefined) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n\n    // NOTE: We could be notifying the \"others\" event here, but the reality is\n    // that ROOM_STATE is often the first message to be received from the\n    // server, and it won't contain all the information needed to update the\n    // other views yet. Instead, we'll let the others' presences trickle in,\n    // and notify each time that happens.\n    return { type: \"reset\" };\n  }\n\n  function canUndo() { return context.undoStack.length > 0; } // prettier-ignore\n  function canRedo() { return context.redoStack.length > 0; } // prettier-ignore\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n\n  function onUserJoinedMessage(\n    message: UserJoinServerMsg<U>\n  ): InternalOthersEvent<P, U> | undefined {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    // Send current presence to new user\n    // TODO: Consider storing it on the backend\n    context.buffer.messages.push({\n      type: ClientMsgCode.UPDATE_PRESENCE,\n      data: context.myPresence.get(),\n      targetActor: message.actor,\n    });\n    flushNowOrSoon();\n\n    // We recorded the connection, but we won't make the new user visible\n    // unless we also know their initial presence data at this point.\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : undefined;\n  }\n\n  function parseServerMessage(data: Json): ServerMsg<P, U, E> | null {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n\n    return data as ServerMsg<P, U, E>;\n    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ FIXME: Properly validate incoming external data instead!\n  }\n\n  function parseServerMessages(text: string): ServerMsg<P, U, E>[] | null {\n    const data: Json | undefined = tryParseJson(text);\n    if (data === undefined) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n\n  function applyAndSendOps(offlineOps: Map<string, Op>) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n\n    const messages: ClientMsg<P, E>[] = [];\n\n    const inOps = Array.from(offlineOps.values());\n\n    const result = applyOps(inOps, true);\n\n    messages.push({\n      type: ClientMsgCode.UPDATE_STORAGE,\n      ops: result.ops,\n    });\n\n    notify(result.updates);\n\n    sendMessages(messages);\n  }\n\n  /**\n   * Handles a message received on the WebSocket. Will never be a \"pong\". The\n   * \"pong\" is handled at the connection manager level.\n   */\n  function handleServerMessage(event: IWebSocketMessageEvent) {\n    if (typeof event.data !== \"string\") {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const updates = {\n      storageUpdates: new Map<string, StorageUpdate>(),\n      others: [] as InternalOthersEvent<P, U>[],\n    };\n\n    for (const message of messages) {\n      switch (message.type) {\n        case ServerMsgCode.USER_JOINED: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n\n        case ServerMsgCode.UPDATE_PRESENCE: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n\n        case ServerMsgCode.BROADCASTED_EVENT: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user:\n              message.actor < 0\n                ? null\n                : (others.find((u) => u.connectionId === message.actor) ??\n                  null),\n            event: message.event,\n          });\n          break;\n        }\n\n        case ServerMsgCode.USER_LEFT: {\n          const event = onUserLeftMessage(message);\n          if (event) {\n            updates.others.push(event);\n          }\n          break;\n        }\n\n        case ServerMsgCode.UPDATE_YDOC: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n\n        case ServerMsgCode.ROOM_STATE: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n\n        case ServerMsgCode.INITIAL_STORAGE_STATE: {\n          // createOrUpdateRootFromMessage function could add ops to offlineOperations.\n          // Client shouldn't resend these ops as part of the offline ops sending after reconnect.\n          processInitialStorage(message);\n          break;\n        }\n        // Write event\n        case ServerMsgCode.UPDATE_STORAGE: {\n          const applyResult = applyOps(message.ops, false);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error. We look at this kind of bug\n        // as a developer-owned bug. In production, these errors are not expected to happen.\n        case ServerMsgCode.REJECT_STORAGE_OP: {\n          console.errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n\n          if (process.env.NODE_ENV !== \"production\") {\n            const traces: Set<string> = new Set();\n            for (const opId of message.opIds) {\n              const trace = context.opStackTraces?.get(opId);\n              if (trace) {\n                traces.add(trace);\n              }\n            }\n\n            if (traces.size > 0) {\n              console.warnWithTitle(\n                \"The following function calls caused the rejected storage mutations:\",\n                `\\n\\n${Array.from(traces).join(\"\\n\\n\")}`\n              );\n            }\n\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n\n          break;\n        }\n\n        case ServerMsgCode.THREAD_CREATED:\n        case ServerMsgCode.THREAD_DELETED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.THREAD_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_CREATED:\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.COMMENT_DELETED: {\n          eventHub.comments.notify(message);\n          break;\n        }\n      }\n    }\n\n    notify(updates);\n  }\n\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n\n    if (elapsedMillis >= config.throttleDelay) {\n      // Flush the buffer right now\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: undefined,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null,\n      };\n    } else {\n      // Or schedule the flush a few millis into the future\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n\n  /**\n   * Returns a list of ClientMsgs to flush to the network, computed from all\n   * pending changes in the buffer. Has no side effects.\n   */\n  function serializeBuffer() {\n    const messages: ClientMsg<P, E>[] = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\"\n          ? {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              // Populating the `targetActor` field turns this message into\n              // a Full Presence™ update message (not a patch), which will get\n              // interpreted by other clients as such.\n              targetActor: -1,\n              data: context.buffer.presenceUpdates.data,\n            }\n          : {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              data: context.buffer.presenceUpdates.data,\n            }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: ClientMsgCode.UPDATE_STORAGE,\n        ops: context.buffer.storageOperations,\n      });\n    }\n    return messages;\n  }\n\n  function updateYDoc(update: string, guid?: string, isV2?: boolean) {\n    const clientMsg: UpdateYDocClientMsg = {\n      type: ClientMsgCode.UPDATE_YDOC,\n      update,\n      guid,\n      v2: isV2,\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n\n  function broadcastEvent(\n    event: E,\n    options: BroadcastOptions = {\n      shouldQueueEventIfNotReady: false,\n    }\n  ) {\n    if (\n      managedSocket.getStatus() !== \"connected\" &&\n      !options.shouldQueueEventIfNotReady\n    ) {\n      return;\n    }\n\n    context.buffer.messages.push({\n      type: ClientMsgCode.BROADCAST_EVENT,\n      event,\n    });\n    flushNowOrSoon();\n  }\n\n  function dispatchOps(ops: Op[]) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n\n  let _getStorage$: Promise<void> | null = null;\n  let _resolveStoragePromise: (() => void) | null = null;\n\n  function processInitialStorage(message: InitialDocumentStateServerMsg) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message);\n    applyAndSendOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n\n  async function streamStorage() {\n    // TODO: Handle potential race conditions where the room get disconnected while the request is pending\n    if (!managedSocket.authValue) return;\n    const items = await httpClient.streamStorage({ roomId });\n    processInitialStorage({ type: ServerMsgCode.INITIAL_STORAGE_STATE, items });\n  }\n\n  function refreshStorage(options: { flush: boolean }) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      // instead of sending a fetch message over WS, stream over HTTP\n      void streamStorage();\n    } else if (\n      !messages.some((msg) => msg.type === ClientMsgCode.FETCH_STORAGE)\n    ) {\n      // Only add the fetch message to the outgoing message queue if it isn't\n      // already there\n      messages.push({ type: ClientMsgCode.FETCH_STORAGE });\n    }\n\n    if (options.flush) {\n      flushNowOrSoon();\n    }\n  }\n\n  function startLoadingStorage(): Promise<void> {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n\n  /**\n   * Closely related to .getStorage(), but synchronously. Will be `null`\n   * initially. When requested for the first time, will kick off the loading of\n   * Storage if it hasn't happened yet.\n   *\n   * Once Storage is loaded, will return a stable reference to the storage\n   * root.\n   */\n  function getStorageSnapshot(): LiveObject<S> | null {\n    const root = context.root;\n    if (root !== undefined) {\n      // Done loading\n      return root;\n    } else {\n      // Not done loading, kick off the loading (will not do anything if already kicked off)\n      void startLoadingStorage();\n      return null;\n    }\n  }\n\n  async function getStorage(): Promise<{\n    root: LiveObject<S>;\n  }> {\n    if (context.root !== undefined) {\n      // Store has already loaded, so we can resolve it directly\n      return Promise.resolve({\n        root: context.root,\n      });\n    }\n\n    await startLoadingStorage();\n    return {\n      root: nn(context.root) as LiveObject<S>,\n    };\n  }\n\n  function fetchYDoc(vector: string, guid?: string, isV2?: boolean): void {\n    // don't allow multiple fetches in the same buffer with the same vector\n    // dev tools may also call with a different vector (if its opened later), and that's okay\n    // because the updates will be ignored by the provider\n    if (\n      !context.buffer.messages.find((m) => {\n        return (\n          m.type === ClientMsgCode.FETCH_YDOC &&\n          m.vector === vector &&\n          m.guid === guid &&\n          m.v2 === isV2\n        );\n      })\n    ) {\n      context.buffer.messages.push({\n        type: ClientMsgCode.FETCH_YDOC,\n        vector,\n        guid,\n        v2: isV2,\n      });\n    }\n\n    flushNowOrSoon();\n  }\n\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n\n    const historyOps = context.redoStack.pop();\n    if (historyOps === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n\n  function batch<T>(callback: () => T): T {\n    if (context.activeBatch) {\n      // If there already is an active batch, we don't have to handle this in\n      // any special way. That outer active batch will handle the batch. This\n      // nested call can be a no-op.\n      return callback();\n    }\n\n    let returnValue: T = undefined as unknown as T;\n\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: new Map(),\n        presence: false,\n        others: [],\n      },\n      reverseOps: new Deque(),\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      // \"Pop\" the current batch of the state, closing the active batch, but\n      // handling it separately here\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n\n      if (currentBatch.ops.length > 0) {\n        // Only clear the redo stack if something has changed during a batch\n        // Clear the redo stack because batch is always called from a local operation\n        context.redoStack.length = 0;\n      }\n\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n\n    return returnValue;\n  }\n\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(Array.from(historyOps));\n    }\n  }\n\n  // Register a global source of pending changes for Storage™, so that the\n  // useSyncStatus() hook will be able to report this to end users\n  const syncSourceForStorage = config.createSyncSource();\n\n  function getStorageStatus(): StorageStatus {\n    if (context.root === undefined) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0\n        ? \"synchronized\"\n        : \"synchronizing\";\n    }\n  }\n\n  /**\n   * Storage status is a computed value based other internal states so we need to keep a reference to the previous computed value to avoid triggering events when it does not change\n   * This is far from ideal because we need to call this function whenever we update our internal states.\n   *\n   * TODO: Encapsulate our internal state differently to make sure this event is triggered whenever necessary.\n   * Currently okay because we only have 4 callers and shielded by tests.\n   */\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n\n  async function waitUntilPresenceReady(): Promise<void> {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      // Return whenever one of these returns, whichever is first\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n\n  async function waitUntilStorageReady(): Promise<void> {\n    while (!isStorageReady()) {\n      // Trigger a load of Storage and wait until it finished\n      await getStorage();\n    }\n  }\n\n  // Derived cached state for use in DevTools\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) =>\n      others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable,\n  };\n\n  async function getThreadsSince(options: GetThreadsSinceOptions) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options.since,\n      signal: options.signal,\n    });\n  }\n\n  async function getThreads(options?: GetThreadsOptions<M>) {\n    return httpClient.getThreads({\n      roomId,\n      query: options?.query,\n      cursor: options?.cursor,\n    });\n  }\n\n  async function getThread(threadId: string) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n\n  async function createThread(options: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: M | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      metadata: options.metadata,\n      body: options.body,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function deleteThread(threadId: string) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n\n  async function editThreadMetadata({\n    metadata,\n    threadId,\n  }: {\n    roomId: string;\n    metadata: Patchable<M>;\n    threadId: string;\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n\n  async function markThreadAsResolved(threadId: string) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n\n  async function markThreadAsUnresolved(threadId: string) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId,\n    });\n  }\n\n  async function subscribeToThread(threadId: string) {\n    return httpClient.subscribeToThread({ roomId, threadId });\n  }\n\n  async function unsubscribeFromThread(threadId: string) {\n    return httpClient.unsubscribeFromThread({ roomId, threadId });\n  }\n\n  async function createComment(options: {\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      body: options.body,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function editComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      body: options.body,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function deleteComment({\n    threadId,\n    commentId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji,\n    });\n  }\n\n  function prepareAttachment(file: File): CommentLocalAttachment {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file,\n    };\n  }\n\n  async function uploadAttachment(\n    attachment: CommentLocalAttachment,\n    options: UploadAttachmentOptions = {}\n  ): Promise<CommentAttachment> {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options.signal,\n    });\n  }\n\n  function getAttachmentUrl(attachmentId: string) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n\n  function getSubscriptionSettings(\n    options?: GetSubscriptionSettingsOptions\n  ): Promise<RoomSubscriptionSettings> {\n    return httpClient.getSubscriptionSettings({\n      roomId,\n      signal: options?.signal,\n    });\n  }\n\n  function updateSubscriptionSettings(\n    settings: Partial<RoomSubscriptionSettings>\n  ): Promise<RoomSubscriptionSettings> {\n    return httpClient.updateSubscriptionSettings({ roomId, settings });\n  }\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId,\n    });\n  }\n\n  // Register a global source of pending changes for Storage™, so that the\n  // useSyncStatus() hook will be able to report this to end users\n  const syncSourceForYjs = config.createSyncSource();\n\n  function yjsStatusDidChange(status: YjsSyncStatus) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" || status === \"loading\"\n        ? \"synchronizing\"\n        : \"synchronized\"\n    );\n  }\n\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() { return deepClone(context.buffer.presenceUpdates?.data ?? null) }, // prettier-ignore\n        get undoStack() { return deepClone(context.undoStack) }, // prettier-ignore\n        get nodeCount() { return context.pool.nodes.size }, // prettier-ignore\n\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n\n        setYjsProvider(newProvider: IYjsProvider | undefined) {\n          // Deregister status change listener for the old Yjs provider\n          // Register status change listener for the new Yjs provider\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: (): readonly DevTools.UserTreeNode[] =>\n          others_forDevTools.get(),\n\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data),\n        },\n\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId),\n      },\n\n      id: roomId,\n      subscribe: makeClassicSubscribeFn(\n        roomId,\n        events,\n        config.errorEventSource\n      ),\n\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        // remove the roomWillDestroy event from the event hub\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        // Unregister all registered callbacks\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source.dispose();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n\n        // cleanup will destroy listener\n        roomWillDestroy.dispose();\n      },\n\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory,\n      },\n\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n\n      events,\n\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      subscribeToThread,\n      unsubscribeFromThread,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n\n      // Notifications\n      getNotificationSettings: getSubscriptionSettings,\n      getSubscriptionSettings,\n      updateNotificationSettings: updateSubscriptionSettings,\n      updateSubscriptionSettings,\n      markInboxNotificationAsRead,\n    },\n\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\n\n/**\n * @internal\n * This recreates the classic single `.subscribe()` method for the Room API, as\n * documented here https://liveblocks.io/docs/api-reference/liveblocks-client#Room.subscribe(storageItem)\n */\nfunction makeClassicSubscribeFn<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n>(\n  roomId: string,\n  events: Room<P, S, U, E, M>[\"events\"],\n  errorEvents: EventSource<LiveblocksError>\n): SubscribeFn<P, S, U, E> {\n  // Set up the \"subscribe\" wrapper API\n  function subscribeToLiveStructureDeeply<L extends LiveStructure>(\n    node: L,\n    callback: (updates: StorageUpdate[]) => void\n  ): () => void {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter((update) =>\n        isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n\n  function subscribeToLiveStructureShallowly<L extends LiveStructure>(\n    node: L,\n    callback: (node: L) => void\n  ): () => void {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node as L);\n        }\n      }\n    });\n  }\n\n  // Generic storage callbacks\n  function subscribe(callback: StorageCallback): () => void; // prettier-ignore\n  // Storage callbacks filtered by Live structure\n  function subscribe<L extends LiveStructure>(liveStructure: L, callback: (node: L) => void): () => void; // prettier-ignore\n  function subscribe(node: LiveStructure, callback: StorageCallback, options: { isDeep: true }): () => void; // prettier-ignore\n  // Room event callbacks\n  function subscribe<K extends RoomEventName>(type: K, listener: RoomEventCallbackFor<K, P, U, E>): () => void; // prettier-ignore\n\n  function subscribe<L extends LiveStructure, K extends RoomEventName>(\n    first: StorageCallback | L | K,\n    second?: ((node: L) => void) | StorageCallback | RoomEventCallback,\n    options?: { isDeep: boolean }\n  ): () => void {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback as Callback<RoomEventMessage<P, U, E>>\n          );\n\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback as Callback<P>);\n\n        case \"others\": {\n          // NOTE: Others have a different callback structure, where the API\n          // exposed on the outside takes _two_ callback arguments!\n          const cb = callback as LegacyOthersEventCallback<P, U>;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return (callback as Callback<Error>)(err);\n            }\n          });\n        }\n\n        case \"status\":\n          return events.status.subscribe(callback as Callback<Status>);\n\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback as Callback<LostConnectionEvent>\n          );\n\n        case \"history\":\n          return events.history.subscribe(callback as Callback<HistoryEvent>);\n\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback as Callback<StorageStatus>\n          );\n\n        case \"comments\":\n          return events.comments.subscribe(\n            callback as Callback<CommentsEventServerMsg>\n          );\n\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n\n    if (second === undefined || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        // istanbul ignore next\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second as StorageCallback;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second as (node: L) => void;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n\n  return subscribe;\n}\n\nfunction isRoomEventName(value: string) {\n  return (\n    value === \"my-presence\" ||\n    value === \"others\" ||\n    value === \"event\" ||\n    value === \"error\" ||\n    value === \"history\" ||\n    value === \"status\" ||\n    value === \"storage-status\" ||\n    value === \"lost-connection\" ||\n    value === \"connection\" ||\n    value === \"comments\"\n  );\n}\n\nexport function makeAuthDelegateForRoom(\n  roomId: string,\n  authManager: AuthManager\n): () => Promise<AuthValue> {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\n\nexport function makeCreateSocketDelegateForRoom(\n  roomId: string,\n  baseUrl: string,\n  WebSocketPolyfill?: IWebSocket\n) {\n  return (authValue: AuthValue): IWebSocketInstance => {\n    const ws: IWebSocket | undefined =\n      WebSocketPolyfill ??\n      (typeof WebSocket === \"undefined\" ? undefined : WebSocket);\n\n    if (ws === undefined) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n", "import { type Ai, createAi, makeCreateSocketDelegateForAi } from \"./ai\";\nimport type { LiveblocksHttpApi } from \"./api-client\";\nimport { createApiClient } from \"./api-client\";\nimport { createAuthManager } from \"./auth-manager\";\nimport { isIdle, StopRetrying } from \"./connection\";\nimport { DEFAULT_BASE_URL } from \"./constants\";\nimport type { LsonObject } from \"./crdts/Lson\";\nimport { linkDevTools, setupDevTools, unlinkDevTools } from \"./devtools\";\nimport type { DE, DGI, DM, DP, DRI, DS, DU } from \"./globals/augmentation\";\nimport { kInternal } from \"./internal\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Batch, createBatchStore } from \"./lib/batch\";\nimport type { Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport type { NoInfr } from \"./lib/NoInfer\";\nimport type { Relax } from \"./lib/Relax\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport { Signal } from \"./lib/signals\";\nimport { warnOnceIf } from \"./lib/warnings\";\nimport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nimport { TokenKind } from \"./protocol/AuthToken\";\nimport type { BaseUserMeta } from \"./protocol/BaseUserMeta\";\nimport type {\n  BaseMetadata,\n  ThreadData,\n  ThreadDeleteInfo,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n} from \"./protocol/InboxNotifications\";\nimport type { MentionData } from \"./protocol/MentionData\";\nimport type {\n  NotificationSettings,\n  PartialNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nimport { createNotificationSettings } from \"./protocol/NotificationSettings\";\nimport type {\n  SubscriptionData,\n  SubscriptionDeleteInfo,\n} from \"./protocol/Subscriptions\";\nimport type {\n  LargeMessageStrategy,\n  OpaqueRoom,\n  OptionalTupleUnless,\n  PartialUnless,\n  Polyfills,\n  Room,\n  RoomDelegates,\n  SyncSource,\n} from \"./room\";\nimport {\n  createRoom,\n  makeAuthDelegateForRoom,\n  makeCreateSocketDelegateForRoom,\n} from \"./room\";\nimport type { Awaitable } from \"./types/Awaitable\";\nimport type { LiveblocksErrorContext } from \"./types/LiveblocksError\";\nimport { LiveblocksError } from \"./types/LiveblocksError\";\n\nconst MIN_THROTTLE = 16;\nconst MAX_THROTTLE = 1_000;\nconst DEFAULT_THROTTLE = 100;\n\nconst MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15_000;\nconst MIN_LOST_CONNECTION_TIMEOUT = 200;\nconst RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1_000;\nconst MAX_LOST_CONNECTION_TIMEOUT = 30_000;\nconst DEFAULT_LOST_CONNECTION_TIMEOUT = 5_000;\n\nconst RESOLVE_USERS_BATCH_DELAY = 50;\nconst RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nconst RESOLVE_GROUPS_INFO_BATCH_DELAY = 50;\n\nexport type ResolveMentionSuggestionsArgs = {\n  /**\n   * The ID of the current room.\n   */\n  roomId: string;\n\n  /**\n   * The text to search for.\n   */\n  text: string;\n};\n\nexport type ResolveUsersArgs = {\n  /**\n   * The IDs of the users to resolve.\n   */\n  userIds: string[];\n};\n\nexport type ResolveRoomsInfoArgs = {\n  /**\n   * The IDs of the rooms to resolve.\n   */\n  roomIds: string[];\n};\n\nexport type ResolveGroupsInfoArgs = {\n  /**\n   * The IDs of the groups to resolve.\n   */\n  groupIds: string[];\n};\n\nexport type EnterOptions<P extends JsonObject = DP, S extends LsonObject = DS> =\n  // prettier-ignore\n  Resolve<\n  {\n    /**\n     * Whether or not the room automatically connects to Liveblock servers.\n     * Default is true.\n     *\n     * Usually set to false when the client is used from the server to not call\n     * the authentication endpoint or connect via WebSocket.\n     */\n    autoConnect?: boolean;\n  }\n\n  // Initial presence is only mandatory if the custom type requires it to be\n  & PartialUnless<\n    P,\n    {\n      /**\n       * The initial Presence to use and announce when you enter the Room. The\n       * Presence is available on all users in the Room (me & others).\n       */\n      initialPresence: P | ((roomId: string) => P);\n    }\n  >\n  \n  // Initial storage is only mandatory if the custom type requires it to be\n  & PartialUnless<\n    S,\n    {\n      /**\n       * The initial Storage to use when entering a new Room.\n       */\n      initialStorage: S | ((roomId: string) => S);\n    }\n  >\n>;\n\nexport type SyncStatus =\n  /* Liveblocks is in the process of writing changes */\n  | \"synchronizing\"\n  /* Liveblocks has persisted all pending changes */\n  | \"synchronized\";\n\n/**\n * \"synchronizing\"     - Liveblocks is in the process of writing changes\n * \"synchronized\"      - Liveblocks has persisted all pending changes\n * \"has-local-changes\" - There is local pending state inputted by the user, but\n *                       we're not yet \"synchronizing\" it until a user\n *                       interaction, like the draft text in a comment box.\n */\nexport type InternalSyncStatus = SyncStatus | \"has-local-changes\";\n\n/**\n * @private\n *\n * Private methods and variables used in the core internals, but as a user\n * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n * will probably happen if you do.\n */\nexport type PrivateClientApi<U extends BaseUserMeta, M extends BaseMetadata> = {\n  readonly currentUserId: Signal<string | undefined>;\n  readonly mentionSuggestionsCache: Map<string, MentionData[]>;\n  readonly resolveMentionSuggestions: ClientOptions<U>[\"resolveMentionSuggestions\"];\n  readonly usersStore: BatchStore<U[\"info\"] | undefined, string>;\n  readonly roomsInfoStore: BatchStore<DRI | undefined, string>;\n  readonly groupsInfoStore: BatchStore<DGI | undefined, string>;\n  readonly getRoomIds: () => string[];\n  readonly httpClient: LiveblocksHttpApi<M>;\n  // Type-level helper\n  as<M2 extends BaseMetadata>(): Client<U, M2>;\n  // Tracking pending changes globally\n  createSyncSource(): SyncSource;\n  emitError(context: LiveblocksErrorContext, cause?: Error): void;\n  ai: Ai;\n};\n\nexport type NotificationsApi<M extends BaseMetadata> = {\n  /**\n   * Gets a page (or the initial page) for user inbox notifications and their\n   * associated threads and thread subscriptions.\n   *\n   * This function should NOT be used for delta updates, only for pagination\n   * (including the first page fetch). For delta updates (done during the\n   * periodic polling), use the `getInboxNotificationsSince` function.\n   *\n   * @example\n   * const {\n   *   inboxNotifications,\n   *   threads,\n   *   subscriptions,\n   *   nextCursor,\n   * } = await client.getInboxNotifications();\n   * const data = await client.getInboxNotifications();  // Fetch initial page (of 20 inbox notifications)\n   * const data = await client.getInboxNotifications({ cursor: nextCursor });  // Fetch next page (= next 20 inbox notifications)\n   */\n  getInboxNotifications(options?: {\n    cursor?: string;\n    query?: { roomId?: string; kind?: string };\n  }): Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<M>[];\n    subscriptions: SubscriptionData[];\n    nextCursor: string | null;\n    requestedAt: Date;\n  }>;\n\n  /**\n   * Fetches a \"delta update\" since the last time we updated.\n   *\n   * This function should NOT be used for pagination, for that, see the\n   * `getInboxNotifications` function.\n   *\n   * @example\n   * const {\n   *   inboxNotifications: {\n   *     updated,\n   *     deleted,\n   *   },\n   *   threads: {\n   *     updated,\n   *     deleted,\n   *   },\n   *   subscriptions: {\n   *     updated,\n   *     deleted,\n   *   },\n   *   requestedAt,\n   * } = await client.getInboxNotificationsSince({ since: result.requestedAt }});\n   */\n  getInboxNotificationsSince(options: {\n    since: Date;\n    query?: { roomId?: string; kind?: string };\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<M>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n  }>;\n\n  /**\n   * Gets the number of unread inbox notifications for the current user.\n   *\n   * @example\n   * const count = await client.getUnreadInboxNotificationsCount();\n   */\n  getUnreadInboxNotificationsCount(): Promise<number>;\n\n  /**\n   * Marks all inbox notifications as read.\n   *\n   * @example\n   * await client.markAllInboxNotificationsAsRead();\n   */\n  markAllInboxNotificationsAsRead(): Promise<void>;\n\n  /**\n   * Marks an inbox notification as read.\n   *\n   * @example\n   * await client.markInboxNotificationAsRead(\"in_xxx\");\n   */\n  markInboxNotificationAsRead(inboxNotificationId: string): Promise<void>;\n\n  /**\n   * Deletes all inbox notifications for the current user.\n   *\n   * @example\n   * await client.deleteAllInboxNotifications();\n   */\n  deleteAllInboxNotifications(): Promise<void>;\n\n  /**\n   * Deletes an inbox notification for the current user.\n   *\n   * @example\n   * await client.deleteInboxNotification(\"in_xxx\");\n   */\n  deleteInboxNotification(inboxNotificationId: string): Promise<void>;\n\n  /**\n   * Gets notifications settings for a user for a project.\n   *\n   * @example\n   * const notificationSettings = await client.getNotificationSettings();\n   */\n  getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettings>;\n\n  /**\n   * Update notifications settings for a user for a project.\n   *\n   * @example\n   * await client.updateNotificationSettings({\n   *  email: {\n   *    thread: true,\n   *    textMention: false,\n   *    $customKind1: true,\n   *  }\n   * })\n   */\n  updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettings>;\n};\n\n/**\n * @private Widest-possible Client type, matching _any_ Client instance. Note\n * that this type is different from `Client`-without-type-arguments. That\n * represents a Client instance using globally augmented types only, which is\n * narrower.\n */\nexport type OpaqueClient = Client<BaseUserMeta>;\n\nexport type Client<U extends BaseUserMeta = DU, M extends BaseMetadata = DM> = {\n  /**\n   * Gets a room. Returns null if {@link Client.enter} has not been called previously.\n   *\n   * @param roomId The id of the room\n   */\n  getRoom<\n    P extends JsonObject = DP,\n    S extends LsonObject = DS,\n    E extends Json = DE,\n    M2 extends BaseMetadata = M,\n  >(\n    roomId: string\n  ): Room<P, S, U, E, M2> | null;\n\n  /**\n   * Enter a room.\n   * @param roomId The id of the room\n   * @param options Optional. You can provide initializers for the Presence or Storage when entering the Room.\n   * @returns The room and a leave function. Call the returned leave() function when you no longer need the room.\n   */\n  enterRoom<\n    P extends JsonObject = DP,\n    S extends LsonObject = DS,\n    E extends Json = DE,\n    M2 extends BaseMetadata = M,\n  >(\n    roomId: string,\n    ...args: OptionalTupleUnless<\n      P & S,\n      [options: EnterOptions<NoInfr<P>, NoInfr<S>>]\n    >\n  ): {\n    room: Room<P, S, U, E, M2>;\n    leave: () => void;\n  };\n\n  /**\n   * Purges all cached auth tokens and reconnects all rooms that are still\n   * connected, if any.\n   *\n   * Call this whenever you log out a user in your application.\n   */\n  logout(): void;\n\n  /**\n   * Advanced APIs related to the resolvers.\n   */\n  resolvers: {\n    /**\n     * Invalidate some or all users that were previously cached by `resolveUsers`.\n     *\n     * @example\n     * // Invalidate all users\n     * client.resolvers.invalidateUsers();\n     *\n     * @example\n     * // Invalidate specific users\n     * client.resolvers.invalidateUsers([\"user-1\", \"user-2\"]);\n     */\n    invalidateUsers(userIds?: string[]): void;\n\n    /**\n     * Invalidate some or all rooms info that were previously cached by `resolveRoomsInfo`.\n     *\n     * @example\n     * // Invalidate all rooms\n     * client.resolvers.invalidateRoomsInfo();\n     *\n     * @example\n     * // Invalidate specific rooms\n     * client.resolvers.invalidateRoomsInfo([\"room-1\", \"room-2\"]);\n     */\n    invalidateRoomsInfo(roomIds?: string[]): void;\n\n    /**\n     * Invalidate some or all groups info that were previously cached by `resolveGroupsInfo`.\n     *\n     * @example\n     * // Invalidate all groups\n     * client.resolvers.invalidateGroupsInfo();\n     *\n     * @example\n     * // Invalidate specific groups\n     * client.resolvers.invalidateGroupsInfo([\"group-1\", \"group-2\"]);\n     */\n    invalidateGroupsInfo(groupIds?: string[]): void;\n\n    /**\n     * Invalidate all mention suggestions cached by `resolveMentionSuggestions`.\n     *\n     * @example\n     * // Invalidate all mention suggestions\n     * client.resolvers.invalidateMentionSuggestions();\n     */\n    invalidateMentionSuggestions(): void;\n  };\n\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  // TODO Make this a getter, so we can provide M\n  readonly [kInternal]: PrivateClientApi<U, M>;\n\n  /**\n   * Returns the current global sync status of the Liveblocks client. If any\n   * part of Liveblocks has any local pending changes that haven't been\n   * confirmed by or persisted by the server yet, this will be \"synchronizing\",\n   * otherwise \"synchronized\".\n   *\n   * This is a combined status for all of the below parts of Liveblocks:\n   * - Storage (realtime APIs)\n   * - Text Editors\n   * - Comments\n   * - Notifications\n   *\n   * @example\n   * const status = client.getSyncStatus();  // \"synchronizing\" | \"synchronized\"\n   */\n  getSyncStatus(): SyncStatus;\n\n  /**\n   * All possible client events, subscribable from a single place.\n   */\n  readonly events: {\n    readonly error: Observable<LiveblocksError>;\n    readonly syncStatus: Observable<void>;\n  };\n} & NotificationsApi<M>;\n\nexport type AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\n/**\n * The authentication endpoint that is called to ensure that the current user has access to a room.\n * Can be an url or a callback if you need to add additional headers.\n */\nexport type ClientOptions<U extends BaseUserMeta = DU> = {\n  throttle?: number; // in milliseconds\n  lostConnectionTimeout?: number; // in milliseconds\n  backgroundKeepAliveTimeout?: number; // in milliseconds\n  polyfills?: Polyfills;\n  largeMessageStrategy?: LargeMessageStrategy;\n  unstable_streamData?: boolean;\n  /**\n   * A function that returns a list of mention suggestions matching a string.\n   */\n  resolveMentionSuggestions?: (\n    args: ResolveMentionSuggestionsArgs\n  ) => Awaitable<string[] | MentionData[]>;\n\n  /**\n   * A function that returns user info from user IDs.\n   * You should return a list of user objects of the same size, in the same order.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => Awaitable<(U[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * A function that returns room info from room IDs.\n   * You should return a list of room info objects of the same size, in the same order.\n   */\n  resolveRoomsInfo?: (\n    args: ResolveRoomsInfoArgs\n  ) => Awaitable<(DRI | undefined)[] | undefined>;\n\n  /**\n   * A function that returns group info from group IDs.\n   * You should return a list of group info objects of the same size, in the same order.\n   */\n  resolveGroupsInfo?: (\n    args: ResolveGroupsInfoArgs\n  ) => Awaitable<(DGI | undefined)[] | undefined>;\n\n  /**\n   * Prevent the current browser tab from being closed if there are any locally\n   * pending Liveblocks changes that haven't been submitted to or confirmed by\n   * the server yet.\n   */\n  preventUnsavedChanges?: boolean;\n\n  /**\n   * @internal To point the client to a different Liveblocks server. Only\n   * useful for Liveblocks developers. Not for end users.\n   */\n  baseUrl?: string;\n\n  /** @internal */\n  mockedDelegates?: RoomDelegates;\n\n  /** @internal */\n  enableDebugLogging?: boolean;\n\n  /** @internal */\n  __DANGEROUSLY_disableThrottling?: true; // for unit testing purposes only, never use this in production\n} & Relax<{ publicApiKey: string } | { authEndpoint: AuthEndpoint }>;\n\nfunction getBaseUrl(baseUrl?: string | undefined): string {\n  if (\n    typeof baseUrl === \"string\" &&\n    baseUrl.startsWith(\"http\") // Must be http or https URL\n  ) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\n\n/**\n * Create a client that will be responsible to communicate with liveblocks servers.\n *\n * @example\n * const client = createClient({\n *   authEndpoint: \"/api/auth\"\n * });\n *\n * // It's also possible to use a function to call your authentication endpoint.\n * // Useful to add additional headers or use an API wrapper (like Firebase functions)\n * const client = createClient({\n *   authEndpoint: async (room?) => {\n *     const response = await fetch(\"/api/auth\", {\n *       method: \"POST\",\n *       headers: {\n *          Authentication: \"token\",\n *          \"Content-Type\": \"application/json\"\n *       },\n *       body: JSON.stringify({ room })\n *     });\n *\n *     return await response.json(); // should be: { token: \"...\" }\n *   }\n * });\n */\nexport function createClient<U extends BaseUserMeta = DU>(\n  options: ClientOptions<U>\n): Client<U> {\n  const clientOptions = options;\n  const throttleDelay =\n    process.env.NODE_ENV !== \"production\" &&\n    clientOptions.__DANGEROUSLY_disableThrottling\n      ? 0\n      : getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n\n  const currentUserId = new Signal<string | undefined>(undefined);\n\n  const authManager = createAuthManager(options, (token) => {\n    const userId = token.k === TokenKind.SECRET_LEGACY ? token.id : token.uid;\n    currentUserId.set(() => userId);\n  });\n\n  const fetchPolyfill =\n    clientOptions.polyfills?.fetch ||\n    /* istanbul ignore next */ globalThis.fetch?.bind(globalThis);\n\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    currentUserId,\n    authManager,\n  });\n\n  type RoomDetails = {\n    room: OpaqueRoom;\n    unsubs: Set<() => void>;\n  };\n\n  const roomsById = new Map<string, RoomDetails>();\n\n  const ai = createAi({\n    userId: currentUserId.get(),\n    lostConnectionTimeout,\n    backgroundKeepAliveTimeout: getBackgroundKeepAliveTimeout(\n      clientOptions.backgroundKeepAliveTimeout\n    ),\n    polyfills: clientOptions.polyfills,\n    delegates: {\n      createSocket: makeCreateSocketDelegateForAi(\n        baseUrl,\n        clientOptions.polyfills?.WebSocket\n      ),\n      authenticate: async () => {\n        const resp = await authManager.getAuthValue({\n          requestedScope: \"room:read\",\n        });\n        if (resp.type === \"public\") {\n          throw new StopRetrying(\n            \"Cannot use AI Copilots with a public API key\"\n          );\n        } else if (resp.token.parsed.k === TokenKind.SECRET_LEGACY) {\n          throw new StopRetrying(\"AI Copilots requires an ID or Access token\");\n        } else {\n          if (!resp.token.parsed.ai) {\n            throw new StopRetrying(\n              \"AI Copilots is not yet enabled for this account. To get started, see https://liveblocks.io/docs/get-started/ai-copilots#Quickstart\"\n            );\n          }\n        }\n        return resp;\n      },\n      canZombie: () => false,\n    },\n  });\n\n  function teardownRoom(room: OpaqueRoom) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n\n  function leaseRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    M extends BaseMetadata,\n  >(\n    details: RoomDetails\n  ): {\n    room: Room<P, S, U, E, M>;\n    leave: () => void;\n  } {\n    // Create a new self-destructing leave function\n    const leave = () => {\n      const self = leave; // A reference to the currently executing function itself\n\n      if (!details.unsubs.delete(self)) {\n        console.warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        // Was this the last room lease? If so, tear down the room\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n\n    details.unsubs.add(leave);\n    return {\n      room: details.room as Room<P, S, U, E, M>,\n      leave,\n    };\n  }\n\n  function enterRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    M extends BaseMetadata,\n  >(\n    roomId: string,\n    ...args: OptionalTupleUnless<\n      P & S,\n      [options: EnterOptions<NoInfr<P>, NoInfr<S>>]\n    >\n  ): {\n    room: Room<P, S, U, E, M>;\n    leave: () => void;\n  } {\n    const existing = roomsById.get(roomId);\n    if (existing !== undefined) {\n      return leaseRoom(existing);\n    }\n\n    const options = args[0] ?? ({} as EnterOptions<P, S>);\n    const initialPresence =\n      (typeof options.initialPresence === \"function\"\n        ? options.initialPresence(roomId)\n        : options.initialPresence) ?? ({} as P);\n\n    const initialStorage =\n      (typeof options.initialStorage === \"function\"\n        ? options.initialStorage(roomId)\n        : options.initialStorage) ?? ({} as S);\n\n    const newRoom = createRoom<P, S, U, E, M>(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager),\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        largeMessageStrategy: clientOptions.largeMessageStrategy,\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient as LiveblocksHttpApi<M>,\n        createSyncSource,\n      }\n    );\n\n    const newRoomDetails: RoomDetails = {\n      room: newRoom,\n      unsubs: new Set(),\n    };\n    roomsById.set(roomId, newRoomDetails);\n\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n\n    const shouldConnect = options.autoConnect ?? true;\n    if (shouldConnect) {\n      // we need to check here because nextjs would fail earlier with Node < 16\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === undefined) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        // At this point, atob does not exist so we are either on React Native or on Node < 16, hence global is available.\n        global.atob = clientOptions.polyfills.atob;\n      }\n\n      newRoom.connect();\n    }\n\n    return leaseRoom(newRoomDetails);\n  }\n\n  function getRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    M extends BaseMetadata,\n  >(roomId: string): Room<P, S, U, E, M> | null {\n    const room = roomsById.get(roomId)?.room;\n    return room ? (room as Room<P, S, U, E, M>) : null;\n  }\n\n  function logout() {\n    authManager.reset();\n\n    // Reset the current user id store when the client is logged out\n    currentUserId.set(() => undefined);\n\n    // Reconnect all rooms that aren't idle, if any. This ensures that those\n    // rooms will get reauthorized now that the auth cache is reset. If that\n    // fails, they might disconnect.\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n\n  const resolveUsers = clientOptions.resolveUsers;\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds: string[]) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n\n      warnOnceIf(\n        !resolveUsers,\n        \"Set the resolveUsers option in createClient to specify user info.\"\n      );\n\n      return users ?? userIds.map(() => undefined);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n\n  function invalidateResolvedUsers(userIds?: string[]) {\n    usersStore.invalidate(userIds);\n  }\n\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds: string[]) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n\n      warnOnceIf(\n        !resolveRoomsInfo,\n        \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n      );\n\n      return roomsInfo ?? roomIds.map(() => undefined);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n\n  function invalidateResolvedRoomsInfo(roomIds?: string[]) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n\n  const resolveGroupsInfo = clientOptions.resolveGroupsInfo;\n  const batchedResolveGroupsInfo = new Batch(\n    async (batchedGroupIds: string[]) => {\n      const groupIds = batchedGroupIds.flat();\n      const groupsInfo = await resolveGroupsInfo?.({ groupIds });\n\n      warnOnceIf(\n        !resolveGroupsInfo,\n        \"Set the resolveGroupsInfo option in createClient to specify group info.\"\n      );\n\n      return groupsInfo ?? groupIds.map(() => undefined);\n    },\n    { delay: RESOLVE_GROUPS_INFO_BATCH_DELAY }\n  );\n  const groupsInfoStore = createBatchStore(batchedResolveGroupsInfo);\n\n  function invalidateResolvedGroupsInfo(groupIds?: string[]) {\n    groupsInfoStore.invalidate(groupIds);\n  }\n\n  const mentionSuggestionsCache = new Map<string, MentionData[]>();\n\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n\n  // ----------------------------------------------------------------\n\n  const syncStatusSources: Signal<InternalSyncStatus>[] = [];\n  const syncStatusSignal = new Signal<InternalSyncStatus>(\"synchronized\");\n\n  const liveblocksErrorSource = makeEventSource<LiveblocksError>();\n\n  function getSyncStatus(): SyncStatus {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\")\n        ? \"synchronizing\"\n        : syncStatusSources.some((src) => src.get() === \"has-local-changes\")\n          ? \"has-local-changes\"\n          : \"synchronized\"\n    );\n  }\n\n  function createSyncSource(): SyncSource {\n    const source = new Signal<InternalSyncStatus>(\"synchronized\");\n    syncStatusSources.push(source);\n\n    const unsub = source.subscribe(() => recompute());\n\n    function setSyncStatus(status: InternalSyncStatus) {\n      source.set(status);\n    }\n\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          // We only have to recompute if it was still pending. Otherwise it\n          // could not have an effect on the global state anyway.\n          recompute();\n        }\n      }\n    }\n\n    return { setSyncStatus, destroy };\n  }\n\n  // ----------------------------------------------------------------\n\n  // Set up event handler that will prevent the browser tab from being closed\n  // if there are locally pending changes to any part of Liveblocks (Storage,\n  // text editors, Threads, Notifications, etc)\n  {\n    const maybePreventClose = (e: BeforeUnloadEvent) => {\n      if (\n        clientOptions.preventUnsavedChanges &&\n        syncStatusSignal.get() !== \"synchronized\"\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    // A Liveblocks client is currently never destroyed.\n    // TODO Call win.removeEventListener(\"beforeunload\", maybePreventClose)\n    // once we have a client.destroy() method\n    const win = typeof window !== \"undefined\" ? window : undefined;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n\n  async function getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettings> {\n    const plainSettings = await httpClient.getNotificationSettings(options);\n    const settings = createNotificationSettings(plainSettings);\n\n    return settings;\n  }\n\n  async function updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettings> {\n    const plainSettings = await httpClient.updateNotificationSettings(settings);\n    const settingsObject = createNotificationSettings(plainSettings);\n\n    return settingsObject;\n  }\n\n  const client: Client<U> = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n\n      logout,\n\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount:\n        httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead:\n        httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n\n      // Public notification settings API\n      getNotificationSettings,\n      updateNotificationSettings,\n\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateGroupsInfo: invalidateResolvedGroupsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions,\n      },\n\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal,\n      },\n\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        ai,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        groupsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: <M2 extends BaseMetadata>() => client as Client<U, M2>,\n        createSyncSource,\n        emitError: (context: LiveblocksErrorContext, cause?: Error) => {\n          const error = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error);\n          if (!didNotify) {\n            console.error(error.message);\n          }\n        },\n      },\n    },\n    kInternal,\n    {\n      enumerable: false,\n    }\n  );\n\n  return client;\n}\n\n/**\n * @private Private API, don't use this directly.\n */\nexport function checkBounds(\n  option: string,\n  value: unknown,\n  min: number,\n  max?: number,\n  recommendedMin?: number\n): number {\n  if (\n    typeof value !== \"number\" ||\n    value < min ||\n    (max !== undefined && value > max)\n  ) {\n    throw new Error(\n      max !== undefined\n        ? `${option} should be between ${recommendedMin ?? min} and ${max}.`\n        : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\n\nfunction getBackgroundKeepAliveTimeout(\n  value: number | undefined\n): number | undefined {\n  if (value === undefined) return undefined;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\n\nfunction getThrottle(value: number): number {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\n\nfunction getLostConnectionTimeout(value: number): number {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\n", "import type { ResolveGroupsInfoArgs, ResolveUsersArgs } from \"../client\";\nimport type { DGI, DU } from \"../globals/augmentation\";\nimport { nn } from \"../lib/assert\";\nimport { sanitizeUrl } from \"../lib/url\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"../protocol/Comments\";\nimport type { Awaitable } from \"../types/Awaitable\";\n\ntype CommentBodyBlockElementName = Exclude<\n  CommentBodyBlockElement,\n  CommentBodyText\n>[\"type\"];\n\ntype CommentBodyInlineElementName =\n  | Exclude<CommentBodyInlineElement, CommentBodyText>[\"type\"]\n  | \"text\";\n\ntype CommentBodyElementName =\n  | CommentBodyBlockElementName\n  | CommentBodyInlineElementName;\n\ntype CommentBodyBlockElements = {\n  paragraph: CommentBodyParagraph;\n};\n\ntype CommentBodyInlineElements = {\n  text: CommentBodyText;\n  link: CommentBodyLink;\n  mention: CommentBodyMention;\n};\n\ntype CommentBodyElements = CommentBodyBlockElements & CommentBodyInlineElements;\n\ntype CommentBodyVisitor<T extends CommentBodyElement = CommentBodyElement> = (\n  element: T\n) => void;\n\nexport type CommentBodyParagraphElementArgs = {\n  /**\n   * The paragraph element.\n   */\n  element: CommentBodyParagraph;\n\n  /**\n   * The text content of the paragraph.\n   */\n  children: string;\n};\n\nexport type CommentBodyTextElementArgs = {\n  /**\n   * The text element.\n   */\n  element: CommentBodyText;\n};\n\nexport type CommentBodyLinkElementArgs = {\n  /**\n   * The link element.\n   */\n  element: CommentBodyLink;\n\n  /**\n   * The absolute URL of the link.\n   */\n  href: string;\n};\n\nexport type CommentBodyMentionElementArgs<U extends BaseUserMeta = DU> = {\n  /**\n   * The mention element.\n   */\n  element: CommentBodyMention;\n\n  /**\n   * The mention's user info, if the mention is a user mention and the `resolveUsers` option was provided.\n   */\n  user?: U[\"info\"];\n\n  /**\n   * The mention's group info, if the mention is a group mention and the `resolveGroupsInfo` option was provided.\n   */\n  group?: DGI;\n};\n\nexport type StringifyCommentBodyElements<U extends BaseUserMeta = DU> = {\n  /**\n   * The element used to display paragraphs.\n   */\n  paragraph: (args: CommentBodyParagraphElementArgs, index: number) => string;\n\n  /**\n   * The element used to display text elements.\n   */\n  text: (args: CommentBodyTextElementArgs, index: number) => string;\n\n  /**\n   * The element used to display links.\n   */\n  link: (args: CommentBodyLinkElementArgs, index: number) => string;\n\n  /**\n   * The element used to display mentions.\n   */\n  mention: (args: CommentBodyMentionElementArgs<U>, index: number) => string;\n};\n\nexport type StringifyCommentBodyOptions<U extends BaseUserMeta = DU> = {\n  /**\n   * Which format to convert the comment to.\n   */\n  format?: \"plain\" | \"html\" | \"markdown\";\n\n  /**\n   * The elements used to customize the resulting string. Each element has\n   * priority over the defaults inherited from the `format` option.\n   */\n  elements?: Partial<StringifyCommentBodyElements<U>>;\n\n  /**\n   * The separator used between paragraphs.\n   */\n  separator?: string;\n\n  /**\n   * A function that returns user info from user IDs.\n   * You should return a list of user objects of the same size, in the same order.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => Awaitable<(U[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * A function that returns group info from group IDs.\n   * You should return a list of group info objects of the same size, in the same order.\n   */\n  resolveGroupsInfo?: (\n    args: ResolveGroupsInfoArgs\n  ) => Awaitable<(DGI | undefined)[] | undefined>;\n};\n\nexport function isCommentBodyParagraph(\n  element: CommentBodyElement\n): element is CommentBodyParagraph {\n  return \"type\" in element && element.type === \"paragraph\";\n}\n\nexport function isCommentBodyText(\n  element: CommentBodyElement\n): element is CommentBodyText {\n  return (\n    !(\"type\" in element) &&\n    \"text\" in element &&\n    typeof element.text === \"string\"\n  );\n}\n\nexport function isCommentBodyMention(\n  element: CommentBodyElement\n): element is CommentBodyMention {\n  return \"type\" in element && element.type === \"mention\";\n}\n\nexport function isCommentBodyLink(\n  element: CommentBodyElement\n): element is CommentBodyLink {\n  return \"type\" in element && element.type === \"link\";\n}\n\nconst commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention,\n};\n\nconst commentBodyElementsTypes: Record<\n  CommentBodyElementName,\n  \"block\" | \"inline\"\n> = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\",\n};\n\nfunction traverseCommentBody(\n  body: CommentBody,\n  visitor: CommentBodyVisitor\n): void;\nfunction traverseCommentBody<T extends CommentBodyElementName>(\n  body: CommentBody,\n  element: T,\n  visitor: CommentBodyVisitor<CommentBodyElements[T]>\n): void;\nfunction traverseCommentBody(\n  body: CommentBody,\n  elementOrVisitor: CommentBodyElementName | CommentBodyVisitor,\n  possiblyVisitor?: CommentBodyVisitor\n): void {\n  if (!body || !body?.content) {\n    return;\n  }\n\n  const element =\n    typeof elementOrVisitor === \"string\" ? elementOrVisitor : undefined;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor =\n    typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get an array of all mentions in a `CommentBody`.\n *\n * Narrow results with an optional predicate, e.g.\n * `(mention) => mention.kind === \"user\"` to only get user mentions.\n */\nexport function getMentionsFromCommentBody(\n  body: CommentBody,\n  predicate?: (mention: CommentBodyMention) => boolean\n): CommentBodyMention[] {\n  const mentionIds = new Set<string>();\n  const mentions: CommentBodyMention[] = [];\n\n  traverseCommentBody(body, \"mention\", (mention) => {\n    if (\n      // If this mention isn't already in the list\n      !mentionIds.has(mention.id) &&\n      // And the provided predicate is true\n      (predicate ? predicate(mention) : true)\n    ) {\n      mentionIds.add(mention.id);\n      mentions.push(mention);\n    }\n  });\n\n  return mentions;\n}\n\nexport async function resolveMentionsInCommentBody<U extends BaseUserMeta>(\n  body: CommentBody,\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => Awaitable<(U[\"info\"] | undefined)[] | undefined>,\n  resolveGroupsInfo?: (\n    args: ResolveGroupsInfoArgs\n  ) => Awaitable<(DGI | undefined)[] | undefined>\n): Promise<{\n  users: Map<string, U[\"info\"]>;\n  groups: Map<string, DGI>;\n}> {\n  const resolvedUsers = new Map<string, U[\"info\"]>();\n  const resolvedGroupsInfo = new Map<string, DGI>();\n\n  if (!resolveUsers && !resolveGroupsInfo) {\n    return {\n      users: resolvedUsers,\n      groups: resolvedGroupsInfo,\n    };\n  }\n\n  const mentions = getMentionsFromCommentBody(body);\n  const userIds = mentions\n    .filter((mention) => mention.kind === \"user\")\n    .map((mention) => mention.id);\n  const groupIds = mentions\n    .filter((mention) => mention.kind === \"group\")\n    .map((mention) => mention.id);\n\n  const [users, groups] = await Promise.all([\n    resolveUsers && userIds.length > 0 ? resolveUsers({ userIds }) : undefined,\n    resolveGroupsInfo && groupIds.length > 0\n      ? resolveGroupsInfo({ groupIds })\n      : undefined,\n  ]);\n\n  if (users) {\n    for (const [index, userId] of userIds.entries()) {\n      const user = users[index];\n      if (user) {\n        resolvedUsers.set(userId, user);\n      }\n    }\n  }\n\n  if (groups) {\n    for (const [index, groupId] of groupIds.entries()) {\n      const group = groups[index];\n      if (group) {\n        resolvedGroupsInfo.set(groupId, group);\n      }\n    }\n  }\n\n  return {\n    users: resolvedUsers,\n    groups: resolvedGroupsInfo,\n  };\n}\n\nconst htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nconst htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nexport function htmlSafe(value: string): HtmlSafeString {\n  return new HtmlSafeString([String(value)], []);\n}\n\nfunction joinHtml(strings: (string | HtmlSafeString)[]) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n\n  return new HtmlSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeHtml(\n  value: string | string[] | HtmlSafeString | HtmlSafeString[]\n) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character as keyof typeof htmlEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class HtmlSafeString {\n  #strings: readonly string[];\n  #values: readonly (string | string[] | HtmlSafeString | HtmlSafeString[])[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n  ) {\n    this.#strings = strings;\n    this.#values = values;\n  }\n\n  toString(): string {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build an HTML string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nexport function html(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n): string {\n  return new HtmlSafeString(strings, values) as unknown as string;\n}\n\nconst markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\",\n};\n\nconst markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nfunction joinMarkdown(strings: (string | MarkdownSafeString)[]) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n\n  return new MarkdownSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeMarkdown(\n  value: string | string[] | MarkdownSafeString | MarkdownSafeString[]\n) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) =>\n      markdownEscapables[character as keyof typeof markdownEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class MarkdownSafeString {\n  #strings: readonly string[];\n  #values: readonly (\n    | string\n    | string[]\n    | MarkdownSafeString\n    | MarkdownSafeString[]\n  )[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (\n      | string\n      | string[]\n      | MarkdownSafeString\n      | MarkdownSafeString[]\n    )[]\n  ) {\n    this.#strings = strings;\n    this.#values = values;\n  }\n\n  toString(): string {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build a Markdown string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nfunction markdown(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | MarkdownSafeString | MarkdownSafeString[])[]\n) {\n  return new MarkdownSafeString(strings, values) as unknown as string;\n}\n\nconst stringifyCommentBodyPlainElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => children,\n    text: ({ element }) => element.text,\n    link: ({ element }) => element.text ?? element.url,\n    mention: ({ element, user, group }) => {\n      return `@${user?.name ?? group?.name ?? element.id}`;\n    },\n  };\n\nconst stringifyCommentBodyHtmlElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => {\n      // prettier-ignore\n      return children ? html`<p>${htmlSafe(children)}</p>` : children;\n    },\n    text: ({ element }) => {\n      // <code><s><em><strong>text</strong></s></em></code>\n      let children = element.text;\n\n      if (!children) {\n        return html`${children}`;\n      }\n\n      if (element.bold) {\n        // prettier-ignore\n        children = html`<strong>${children}</strong>`;\n      }\n\n      if (element.italic) {\n        // prettier-ignore\n        children = html`<em>${children}</em>`;\n      }\n\n      if (element.strikethrough) {\n        // prettier-ignore\n        children = html`<s>${children}</s>`;\n      }\n\n      if (element.code) {\n        // prettier-ignore\n        children = html`<code>${children}</code>`;\n      }\n\n      return html`${children}`;\n    },\n    link: ({ element, href }) => {\n      // prettier-ignore\n      return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n    },\n    mention: ({ element, user, group }) => {\n      // prettier-ignore\n      return html`<span data-mention>@${user?.name ? html`${user?.name}` : group?.name ? html`${group?.name}` : element.id}</span>`;\n    },\n  };\n\nconst stringifyCommentBodyMarkdownElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => {\n      return children;\n    },\n    text: ({ element }) => {\n      // <code><s><em><strong>text</strong></s></em></code>\n      let children = element.text;\n\n      if (!children) {\n        return children;\n      }\n\n      if (element.bold) {\n        // prettier-ignore\n        children = markdown`**${children}**`;\n      }\n\n      if (element.italic) {\n        // prettier-ignore\n        children = markdown`_${children}_`;\n      }\n\n      if (element.strikethrough) {\n        // prettier-ignore\n        children = markdown`~~${children}~~`;\n      }\n\n      if (element.code) {\n        // prettier-ignore\n        children = markdown`\\`${children}\\``;\n      }\n\n      return children;\n    },\n    link: ({ element, href }) => {\n      // prettier-ignore\n      return markdown`[${element.text ?? element.url}](${href})`;\n    },\n    mention: ({ element, user, group }) => {\n      // prettier-ignore\n      return markdown`@${user?.name ?? group?.name ?? element.id}`;\n    },\n  };\n\n/**\n * Convert a `CommentBody` into either a plain string,\n * Markdown, HTML, or a custom format.\n */\nexport async function stringifyCommentBody(\n  body: CommentBody,\n  options?: StringifyCommentBodyOptions<BaseUserMeta>\n): Promise<string> {\n  const format = options?.format ?? \"plain\";\n  const separator =\n    options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...(format === \"html\"\n      ? stringifyCommentBodyHtmlElements\n      : format === \"markdown\"\n        ? stringifyCommentBodyMarkdownElements\n        : stringifyCommentBodyPlainElements),\n    ...options?.elements,\n  };\n  const { users: resolvedUsers, groups: resolvedGroupsInfo } =\n    await resolveMentionsInCommentBody(\n      body,\n      options?.resolveUsers,\n      options?.resolveGroupsInfo\n    );\n\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id\n              ? [\n                  elements.mention(\n                    {\n                      element: inline,\n                      user:\n                        inline.kind === \"user\"\n                          ? resolvedUsers.get(inline.id)\n                          : undefined,\n                      group:\n                        inline.kind === \"group\"\n                          ? resolvedGroupsInfo.get(inline.id)\n                          : undefined,\n                    },\n                    inlineIndex\n                  ),\n                ]\n              : [];\n          }\n\n          if (isCommentBodyLink(inline)) {\n            const href = sanitizeUrl(inline.url);\n\n            // If the URL is invalid, its text/URL are used as plain text.\n            if (href === null) {\n              return [\n                elements.text(\n                  {\n                    element: { text: inline.text ?? inline.url },\n                  },\n                  inlineIndex\n                ),\n              ];\n            }\n\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href,\n                },\n                inlineIndex\n              ),\n            ];\n          }\n\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n\n          return [];\n        });\n\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          ),\n        ];\n      }\n\n      default:\n        return [];\n    }\n  });\n\n  return blocks.join(separator);\n}\n", "import type { Json } from \"../lib/Json\";\nimport type { PlainLson } from \"../types/PlainLson\";\nimport { LiveList } from \"./LiveList\";\nimport { LiveMap } from \"./LiveMap\";\nimport { LiveObject } from \"./LiveObject\";\nimport type { Lson, LsonObject } from \"./Lson\";\n\n/**\n * Helper type to convert any valid Lson type to the equivalent Json type.\n *\n * Examples:\n *\n *   ToImmutable<42>                         // 42\n *   ToImmutable<'hi'>                       // 'hi'\n *   ToImmutable<number>                     // number\n *   ToImmutable<string>                     // string\n *   ToImmutable<string | LiveList<number>>  // string | readonly number[]\n *   ToImmutable<LiveMap<string, LiveList<number>>>\n *                                           // ReadonlyMap<string, readonly number[]>\n *   ToImmutable<LiveObject<{ a: number, b: LiveList<string>, c?: number }>>\n *                                           // { readonly a: null, readonly b: readonly string[], readonly c?: number }\n *\n */\n// prettier-ignore\nexport type ToImmutable<L extends Lson | LsonObject> =\n  // A LiveList serializes to an equivalent JSON array\n  L extends LiveList<infer I> ? readonly ToImmutable<I>[] :\n\n  // A LiveObject serializes to an equivalent JSON object\n  L extends LiveObject<infer O> ? ToImmutable<O> :\n\n  // A LiveMap serializes to a JSON object with string-V pairs\n  L extends LiveMap<infer K, infer V> ? ReadonlyMap<K, ToImmutable<V>> :\n\n  // Any LsonObject recursively becomes a JsonObject\n  L extends LsonObject ?\n    { readonly [K in keyof L]: ToImmutable<Exclude<L[K], undefined>>\n                                 | (undefined extends L[K] ? undefined : never) } :\n\n  // Any Json value already is a legal Json value\n  L extends Json ? L :\n\n  // Otherwise, this is not possible\n  never;\n\n/**\n * Returns PlainLson for a given Json or LiveStructure, suitable for calling the storage init api\n */\nexport function toPlainLson(lson: Lson): PlainLson {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(([key, value]) =>\n          value !== undefined ? [[key, toPlainLson(value)]] : []\n        )\n      ),\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      ),\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item)),\n    };\n  } else {\n    return lson;\n  }\n}\n", "import {\n  findNonSerializableValue,\n  isLiveList,\n  isLiveObject,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveList } from \"./crdts/LiveList\";\nimport { LiveMap } from \"./crdts/LiveMap\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport { LiveRegister } from \"./crdts/LiveRegister\";\nimport type { LiveNode, Lson, LsonObject, ToJson } from \"./crdts/Lson\";\nimport type { StorageUpdate } from \"./crdts/StorageUpdates\";\nimport * as console from \"./lib/fancy-console\";\nimport { isPlainObject } from \"./lib/guards\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonObject } from \"./lib/Json\";\n\nfunction lsonObjectToJson<O extends LsonObject>(\n  obj: O\n): { [K in keyof O]: Json } {\n  const result = {} as { [K in keyof O]: Json };\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== undefined) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\n\nexport function liveObjectToJson<O extends LsonObject>(\n  liveObject: LiveObject<O>\n): { [K in keyof O]: Json } {\n  return lsonObjectToJson(liveObject.toObject());\n}\n\nfunction liveMapToJson<TKey extends string>(\n  map: LiveMap<TKey, Lson>\n): { [K in TKey]: Json } {\n  const result = {} as { [K in TKey]: Json };\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\n\nfunction lsonListToJson(value: Lson[]): Json[] {\n  return value.map(lsonToJson);\n}\n\nfunction liveListToJson(value: LiveList<Lson>): Json[] {\n  return lsonListToJson(value.toArray());\n}\n\nexport function lsonToJson(value: Lson): Json {\n  // Check for LiveStructure datastructures first\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    // NOTE: This branch should never be taken, because LiveRegister isn't a valid Lson value\n    return value.data as Json;\n  }\n\n  // Then for composite Lson values\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n\n  // Finally, if value is an LsonScalar, then it's also a valid JsonScalar\n  return value;\n}\n\n/**\n * Deeply converts all nested lists to LiveLists, and all nested objects to\n * LiveObjects.\n *\n * As such, the returned result will not contain any Json arrays or Json\n * objects anymore.\n */\nfunction deepLiveify(value: Lson | LsonObject): Lson {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init: LsonObject = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === undefined) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\n\nexport function patchLiveList<T extends Lson>(\n  liveList: LiveList<T>,\n  prev: Array<T>,\n  next: Array<T>\n): void {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n\n  let prevNode = prev[0];\n  let nextNode = next[0];\n\n  /**\n   * For A,B,C => A,B,C,D\n   * i = 3, prevEnd = 2, nextEnd = 3\n   *\n   * For A,B,C => B,C\n   * i = 2, prevEnd = 2, nextEnd = 1\n   *\n   * For B,C => A,B,C\n   * i = 0, pre\n   */\n\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]) as T, i);\n        //                                   ^^^^ FIXME Not entirely true\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n\n      if (\n        isLiveObject(liveListNode) &&\n        isPlainObject(prevNode) &&\n        isPlainObject(nextNode)\n      ) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode) as T);\n        //                                    ^^^^ FIXME Not entirely true\n      }\n\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]) as T, i);\n      //                                   ^^^^ FIXME Not entirely true\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\n\nexport function patchLiveObjectKey<\n  O extends LsonObject,\n  K extends keyof O,\n  V extends Json,\n>(liveObject: LiveObject<O>, key: K, prev?: V, next?: V): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      console.error(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n\n  const value = liveObject.get(key);\n\n  if (next === undefined) {\n    liveObject.delete(key);\n  } else if (value === undefined) {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (\n    isLiveObject(value) &&\n    isPlainObject(prev) &&\n    isPlainObject(next)\n  ) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  }\n}\n\nexport function patchLiveObject<O extends LsonObject>(\n  root: LiveObject<O>,\n  prev: ToJson<O>,\n  next: ToJson<O>\n): void {\n  const updates: Partial<O> = {};\n\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key] as Json, next[key] as Json);\n  }\n\n  for (const key in prev) {\n    if (next[key] === undefined) {\n      root.delete(key);\n    }\n  }\n\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\n\nfunction getParentsPath(node: LiveNode): Array<string | number> {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\n\n//\n// TODO: Remove `patchImmutableObject`!\n//\n// This helper is now only used internally, to support our Zustand and\n// Redux packages. We should be able to reimplement those using the new\n// `.toImmutable()` APIs.\n//\nexport function legacy_patchImmutableObject<TState extends JsonObject>(\n  state: TState,\n  updates: StorageUpdate[]\n): TState {\n  return updates.reduce(\n    (state, update) => legacy_patchImmutableObjectWithUpdate(state, update),\n    state\n  );\n}\n\nfunction legacy_patchImmutableObjectWithUpdate<TState extends JsonObject>(\n  state: TState,\n  update: StorageUpdate\n): TState {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\n\nfunction legacy_patchImmutableNode<S extends Json>(\n  state: S,\n  path: Array<string | number>,\n  update: StorageUpdate\n): S {\n  // FIXME: Split this function up into a few smaller ones! In each of them,\n  // the types can be define much more narrowly and correctly, and there will\n  // be less type shoehorning necessary.\n\n  const pathItem = path.pop();\n  if (pathItem === undefined) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== undefined) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n\n        let newState: Json[] = state.map((x: Json) => x);\n\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map((item, index) =>\n              index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index),\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1),\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1),\n              ];\n            }\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== undefined) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n    }\n  }\n\n  if (Array.isArray(state)) {\n    const newArray: Json[] = [...state];\n    newArray[pathItem as number] = legacy_patchImmutableNode(\n      state[pathItem as number],\n      path,\n      update\n    );\n    return newArray as S;\n    //              ^^^^\n    //              FIXME Not completely true, because we could have been\n    //              updating indexes from StorageUpdate here that aren't in S,\n    //              technically.\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === undefined) {\n      return state;\n    } else {\n      const stateAsObj: JsonObject = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update),\n      } as S;\n      //   ^\n      //   FIXME Not completely true, because we could have been updating\n      //   indexes from StorageUpdate here that aren't in S, technically.\n    }\n  } else {\n    return state;\n  }\n}\n", "/**\n * Like `new AbortController()`, but where the result can be unpacked\n * safely, i.e. `const { signal, abort } = makeAbortController()`.\n *\n * This unpacking is unsafe to do with a regular `AbortController` because\n * the `abort` method is not bound to the controller instance.\n *\n * In addition to this, you can also pass an optional (external)\n * AbortSignal to \"wrap\", in which case the returned signal will be in\n * aborted state when either the signal is aborted externally or\n * internally.\n */\nexport function makeAbortController(externalSignal?: AbortSignal): {\n  signal: AbortSignal;\n  abort: (reason?: unknown) => void;\n} {\n  const ctl = new AbortController();\n  return {\n    signal: externalSignal\n      ? AbortSignal.any([ctl.signal, externalSignal])\n      : ctl.signal,\n    abort: ctl.abort.bind(ctl),\n  };\n}\n", "import * as console from \"./fancy-console\";\n\n/**\n * Tools to help with the controlled deprecation of public APIs.\n *\n * First warn, then error, then remove eventually.\n */\n\n// Keeps a set of deprecation messages in memory that it has warned about\n// already. There will be only one deprecation message in the console, no\n// matter how often it gets called.\nconst _emittedDeprecationWarnings: Set<string> = new Set();\n\n/**\n * Displays a deprecation warning in the dev console. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecate(message: string, key = message): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      console.errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\n\n/**\n * Conditionally displays a deprecation warning in the dev\n * console if the first argument is truthy. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecateIf(\n  condition: unknown,\n  message: string,\n  key = message\n): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\n\n/**\n * Throws a deprecation error in the dev console.\n *\n * Only triggers in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function throwUsageError(message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    console.errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\n\n/**\n * Conditionally throws a usage error in the dev console if the first argument\n * is truthy. Use this to \"escalate\" usage patterns that in previous versions\n * we already warned about with deprecation warnings.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function errorIf(condition: unknown, message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n", "import { FSM } from \"./fsm\";\n\nexport type Poller = {\n  /**\n   * Increments the subscriber count for this poller. If it becomes > 0, the\n   * poller will be enabled.\n   */\n  inc(): void;\n  /**\n   * Decrements the subscriber count for this poller. If it becomes = 0, the\n   * poller will be disabled.\n   */\n  dec(): void;\n\n  /**\n   * Polls immediately only if it has been more than `maxStaleTimeMs` milliseconds since\n   * the last poll and no poll is currently in progress. After polling, schedules\n   * the next poll at the regular interval.\n   */\n  pollNowIfStale(): void;\n\n  /**\n   * Marks the poller as stale. This can be used to force the next call\n   * to `.pollNowIfStale()` to poll immediately.\n   */\n  markAsStale(): void;\n\n  /**\n   * Used in unit tests only.\n   * @internal\n   */\n  setInForeground(condition: boolean): void;\n};\n\ntype Context = {\n  inForeground: boolean; // Whether the visibility state is visible\n  lastSuccessfulPollAt: number; // The timestamp of the last successful poll (or when the poller was initialized)\n  count: number; // Subscriber count\n  backoff: number; // Backoff delay in ms\n};\n\ntype State =\n  | \"@idle\" //\n  | \"@enabled\" //\n  | \"@polling\";\n\ntype Event =\n  | { type: \"START\" } //\n  | { type: \"STOP\" } //\n  | { type: \"POLL\" };\n\nconst BACKOFF_DELAYS = [1_000, 2_000, 4_000, 8_000, 10_000] as const;\n\n/**\n * Makes a poller that will call `await callback()` at the desired interval (in\n * millis).\n *\n * The poller has only three public APIs, all side effects:\n * - .inc(): void\n * - .dec(): void\n * - .pollNowIfStale(): void\n *\n * It has the following behaviors/guarantees:\n * - Performing a \"poll\" literally means calling the provided callback (and\n *   awaiting it)\n * - It will only ever start polling if .inc() was called (more often than .dec())\n * - It will not _immediately_ poll if .inc() is called. The first poll\n *   can be expected no earlier than the specified interval.\n * - If .dec() is called as many times as .inc(), it stops the poller. This\n *   means that any next poll will get unscheduled. If .dev() is called while\n *   a poll is ongoing, it will still finish that poll, but after that stop\n *   further polling.\n * - If the document's visibility state changes to hidden (tab is moved to the\n *   background), polling will be paused until the document's made visible again\n * - If the document becomes visible again, the poller will:\n *   - Still do nothing if the poller isn't enabled\n *   - Still do nothing if the poller is enabled, but the last time a poll\n *     happened recently enough (= less than the maxStaleTimeMs, which defaults\n *     to infinity)\n *   - Trigger a poll right away otherwise. If an existing poll was already\n *     scheduled, think of it as if this future poll is \"earlied\" and just\n *     happening right now instead\n */\nexport function makePoller(\n  callback: (signal: AbortSignal) => Promise<void> | void,\n  intervalMs: number,\n  options?: {\n    maxStaleTimeMs?: number;\n  }\n): Poller {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : undefined;\n  const win = typeof window !== \"undefined\" ? window : undefined;\n\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context: Context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0,\n  };\n\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n\n  /**\n   *                                    +----------+\n   *        +-------------------------> |  @idle   |\n   *        |   else                    +----------+\n   *        |                             |      ^\n   *        |                     on STOP |      | on START\n   *        |                             v      |\n   *   +--------+   if mayPoll()        +----------+      on POLL             +----------+\n   *   | decide |---------------------> | @enabled | -----------------------> | @polling |\n   *   +--------+                       +----------+   after POLL_INTERVAL    +----------+\n   *        ^                                                                      |\n   *        |                                                                      |\n   *        +----------------------------------------------------------------------+\n   */\n  const fsm = new FSM<object, Event, State>({})\n    .addState(\"@idle\")\n    .addState(\"@enabled\")\n    .addState(\"@polling\");\n\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          // Reset backoff delay to 0 if the callback was successful\n          context.backoff = 0;\n        },\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          // Increase the backoff delay if an error occured\n          context.backoff =\n            BACKOFF_DELAYS.find((delay) => delay > context.backoff) ??\n            BACKOFF_DELAYS[BACKOFF_DELAYS.length - 1];\n        },\n      };\n    },\n    30_000 // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n\n  function markAsStale() {\n    // Set the last successful poll timestamp to a stale time\n    context.lastSuccessfulPollAt = performance.now() - maxStaleTimeMs - 1;\n  }\n\n  function setInForeground(inForeground: boolean) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale(); // Won't do anything if in @idle\n  }\n\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n\n  // NOTE: Currently, poller instances are only ever created and never\n  // destroyed. If we add a destroy() method in the future, then we should also\n  // unregister these event handlers.\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    markAsStale,\n\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground,\n  };\n}\n", "import type { DAD } from \"../globals/augmentation\";\nimport type { DateToString } from \"../lib/DateToString\";\nimport type { NotificationKind } from \"./NotificationSettings\";\n\nexport type SubscriptionData<K extends keyof DAD = keyof DAD> = {\n  kind: NotificationKind<K>;\n  subjectId: string;\n  createdAt: Date;\n};\n\nexport type SubscriptionDataPlain = DateToString<SubscriptionData>;\n\nexport type UserSubscriptionData<K extends keyof DAD = keyof DAD> =\n  SubscriptionData<K> & {\n    userId: string;\n  };\n\nexport type UserSubscriptionDataPlain = DateToString<UserSubscriptionData>;\n\nexport type SubscriptionDeleteInfo = {\n  type: \"deletedSubscription\";\n  kind: NotificationKind;\n  subjectId: string;\n  deletedAt: Date;\n};\n\nexport type SubscriptionDeleteInfoPlain = DateToString<SubscriptionDeleteInfo>;\n\nexport type SubscriptionKey = `${NotificationKind}:${string}`;\n\nexport function getSubscriptionKey(\n  subscription: SubscriptionData | SubscriptionDeleteInfo\n): SubscriptionKey;\nexport function getSubscriptionKey(\n  kind: NotificationKind,\n  subjectId: string\n): SubscriptionKey;\nexport function getSubscriptionKey(\n  subscription: SubscriptionData | SubscriptionDeleteInfo | NotificationKind,\n  subjectId?: string\n): SubscriptionKey {\n  if (typeof subscription === \"string\") {\n    return `${subscription}:${subjectId}`;\n  }\n\n  return `${subscription.kind}:${subscription.subjectId}`;\n}\n", "import type { DP, DU } from \"../globals/augmentation\";\nimport type { JsonObject } from \"../lib/Json\";\nimport type { Relax } from \"../lib/Relax\";\nimport type { Resolve } from \"../lib/Resolve\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { User } from \"./User\";\n\nexport type InternalOthersEvent<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n> = Relax<\n  | { type: \"leave\"; user: User<P, U> }\n  | { type: \"enter\"; user: User<P, U> }\n  | {\n      type: \"update\";\n      user: User<P, U>;\n      updates: Partial<P>;\n    }\n  | { type: \"reset\" }\n>;\n\nexport type OthersEvent<\n  P extends JsonObject = DP,\n  U extends BaseUserMeta = DU,\n> = Resolve<\n  InternalOthersEvent<P, U> & {\n    others: readonly User<P, U>[];\n  }\n>;\n\nexport enum TextEditorType {\n  Lexical = \"lexical\",\n  TipTap = \"tiptap\",\n  BlockNote = \"blocknote\",\n}\n", "import { detectDupes } from \"./dupe-detection\";\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n/**\n * PRIVATE / INTERNAL APIS\n * -----------------------\n *\n * This module is intended for internal use only, PLEASE DO NOT RELY ON ANY OF\n * THE EXPORTS IN HERE. These are implementation details that can change at any\n * time and without announcement. This module purely exists to share code\n * between the several Liveblocks packages.\n *\n * But since you're so deep inside Liveblocks code... we're hiring!\n * https://join.team/liveblocks ;)\n */\n\nexport type {\n  AiOpaqueToolDefinition,\n  AiOpaqueToolInvocationProps,\n  AiToolDefinition,\n  AiToolExecuteCallback,\n  AiToolExecuteContext,\n  AiToolInvocationProps,\n  AiToolTypePack,\n  WithNavigation,\n} from \"./ai\";\nexport { defineAiTool } from \"./ai\";\nexport type {\n  Client,\n  ClientOptions,\n  EnterOptions,\n  OpaqueClient,\n  PrivateClientApi,\n  ResolveGroupsInfoArgs,\n  ResolveMentionSuggestionsArgs,\n  ResolveRoomsInfoArgs,\n  ResolveUsersArgs,\n  SyncStatus,\n} from \"./client\";\nexport { checkBounds, createClient } from \"./client\";\nexport type {\n  CommentBodyLinkElementArgs,\n  CommentBodyMentionElementArgs,\n  CommentBodyParagraphElementArgs,\n  CommentBodyTextElementArgs,\n  StringifyCommentBodyElements,\n  StringifyCommentBodyOptions,\n} from \"./comments/comment-body\";\nexport {\n  getMentionsFromCommentBody,\n  html,\n  htmlSafe,\n  isCommentBodyLink,\n  isCommentBodyMention,\n  isCommentBodyText,\n  resolveMentionsInCommentBody,\n  stringifyCommentBody,\n} from \"./comments/comment-body\";\nexport type { BaseAuthResult, Delegates } from \"./connection\";\nexport type { LostConnectionEvent, Status } from \"./connection\";\nexport { MENTION_CHARACTER } from \"./constants\";\nexport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToGroupData,\n  convertToInboxNotificationData,\n  convertToSubscriptionData,\n  convertToThreadData,\n  convertToUserSubscriptionData,\n} from \"./convert-plain-data\";\nexport type {\n  CreateManagedPoolOptions,\n  ManagedPool,\n} from \"./crdts/AbstractCrdt\";\nexport { createManagedPool } from \"./crdts/AbstractCrdt\";\nexport { cloneLson, isLiveNode } from \"./crdts/liveblocks-helpers\";\nexport { LiveList } from \"./crdts/LiveList\";\nexport { LiveMap } from \"./crdts/LiveMap\";\nexport { LiveObject } from \"./crdts/LiveObject\";\nexport type {\n  LiveNode,\n  LiveStructure,\n  Lson,\n  LsonObject,\n  ToJson,\n} from \"./crdts/Lson\";\nexport type {\n  LiveListUpdate,\n  LiveMapUpdate,\n  LiveObjectUpdate,\n  StorageUpdate,\n} from \"./crdts/StorageUpdates\";\nexport type { ToImmutable } from \"./crdts/utils\";\nexport { toPlainLson } from \"./crdts/utils\";\nexport type {\n  DAD,\n  DE,\n  DGI,\n  DM,\n  DP,\n  DRI,\n  DS,\n  DU,\n  KDAD,\n} from \"./globals/augmentation\";\nexport {\n  legacy_patchImmutableObject,\n  lsonToJson,\n  patchLiveObjectKey,\n} from \"./immutable\";\nexport { kInternal } from \"./internal\";\nexport { makeAbortController } from \"./lib/abortController\";\nexport { assert, assertNever, nn } from \"./lib/assert\";\nexport type {\n  AsyncError,\n  AsyncLoading,\n  AsyncResult,\n  AsyncSuccess,\n} from \"./lib/AsyncResult\";\nexport { autoRetry, HttpError } from \"./lib/autoRetry\";\nexport { chunk } from \"./lib/chunk\";\nexport { Promise_withResolvers } from \"./lib/controlledPromise\";\nexport {\n  createCommentAttachmentId,\n  createCommentId,\n  createInboxNotificationId,\n  createThreadId,\n} from \"./lib/createIds\";\nexport { DefaultMap } from \"./lib/DefaultMap\";\nexport {\n  deprecate,\n  deprecateIf,\n  errorIf,\n  throwUsageError,\n} from \"./lib/deprecation\";\nexport { Deque } from \"./lib/Deque\";\nexport type {\n  EventSource,\n  Observable,\n  UnsubscribeCallback,\n} from \"./lib/EventSource\";\nexport { makeEventSource } from \"./lib/EventSource\";\nexport * as console from \"./lib/fancy-console\";\nexport { freeze } from \"./lib/freeze\";\nexport { isPlainObject, isStartsWithOperator } from \"./lib/guards\";\nexport type { Json, JsonArray, JsonObject, JsonScalar } from \"./lib/Json\";\nexport { isJsonArray, isJsonObject, isJsonScalar } from \"./lib/Json\";\nexport { nanoid } from \"./lib/nanoid\";\nexport type { NoInfr } from \"./lib/NoInfer\";\nexport { objectToQuery } from \"./lib/objectToQuery\";\nexport type { Poller } from \"./lib/Poller\";\nexport { makePoller } from \"./lib/Poller\";\nexport { asPos, makePosition } from \"./lib/position\";\nexport type { Relax } from \"./lib/Relax\";\nexport type { Resolve } from \"./lib/Resolve\";\nexport { shallow, shallow2 } from \"./lib/shallow\";\nexport type { ISignal, SignalType } from \"./lib/signals\";\nexport { batch, DerivedSignal, MutableSignal, Signal } from \"./lib/signals\";\nexport { SortedList } from \"./lib/SortedList\";\nexport { stableStringify } from \"./lib/stringify\";\nexport type { QueryParams, URLSafeString } from \"./lib/url\";\nexport { generateUrl, isUrl, sanitizeUrl, url, urljoin } from \"./lib/url\";\nexport type {\n  Brand,\n  DistributiveOmit,\n  WithOptional,\n  WithRequired,\n} from \"./lib/utils\";\nexport {\n  b64decode,\n  compactObject,\n  entries,\n  findLastIndex,\n  keys,\n  mapValues,\n  memoizeOnSuccess,\n  raise,\n  tryParseJson,\n  wait,\n  withTimeout,\n} from \"./lib/utils\";\nexport { warnOnce, warnOnceIf } from \"./lib/warnings\";\nexport type {\n  ContextualPromptContext,\n  ContextualPromptResponse,\n} from \"./protocol/Ai\";\nexport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nexport { Permission } from \"./protocol/AuthToken\";\nexport type { BaseActivitiesData } from \"./protocol/BaseActivitiesData\";\nexport type { BaseGroupInfo } from \"./protocol/BaseGroupInfo\";\nexport type { BaseRoomInfo } from \"./protocol/BaseRoomInfo\";\nexport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nexport type {\n  BroadcastEventClientMsg,\n  ClientMsg,\n  FetchStorageClientMsg,\n  FetchYDocClientMsg,\n  UpdatePresenceClientMsg,\n  UpdateStorageClientMsg,\n  UpdateYDocClientMsg,\n} from \"./protocol/ClientMsg\";\nexport { ClientMsgCode } from \"./protocol/ClientMsg\";\nexport type { BaseMetadata } from \"./protocol/Comments\";\nexport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"./protocol/Comments\";\nexport type {\n  CommentAttachment,\n  CommentData,\n  CommentDataPlain,\n  CommentLocalAttachment,\n  CommentMixedAttachment,\n  CommentReaction,\n} from \"./protocol/Comments\";\nexport type {\n  CommentUserReaction,\n  CommentUserReactionPlain,\n} from \"./protocol/Comments\";\nexport type { QueryMetadata } from \"./protocol/Comments\";\nexport type {\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDataWithDeleteInfo,\n} from \"./protocol/Comments\";\nexport type { ThreadDeleteInfo } from \"./protocol/Comments\";\nexport type {\n  GroupData,\n  GroupDataPlain,\n  GroupMemberData,\n  GroupScopes,\n} from \"./protocol/Groups\";\nexport type {\n  ActivityData,\n  InboxNotificationCustomData,\n  InboxNotificationCustomDataPlain,\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationTextMentionData,\n  InboxNotificationTextMentionDataPlain,\n  InboxNotificationThreadData,\n  InboxNotificationThreadDataPlain,\n} from \"./protocol/InboxNotifications\";\nexport type { InboxNotificationDeleteInfo } from \"./protocol/InboxNotifications\";\nexport type {\n  NotificationChannel,\n  NotificationChannelSettings,\n  NotificationKind,\n  NotificationSettings,\n  NotificationSettingsPlain,\n  PartialNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nexport {\n  createNotificationSettings,\n  isNotificationChannelEnabled,\n  patchNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nexport type {\n  AckOp,\n  CreateListOp,\n  CreateMapOp,\n  CreateObjectOp,\n  CreateOp,\n  CreateRegisterOp,\n  DeleteCrdtOp,\n  DeleteObjectKeyOp,\n  Op,\n  SetParentKeyOp,\n  UpdateObjectOp,\n} from \"./protocol/Op\";\nexport { ackOp, OpCode } from \"./protocol/Op\";\nexport type {\n  RoomSubscriptionSettings,\n  UserRoomSubscriptionSettings,\n} from \"./protocol/RoomSubscriptionSettings\";\nexport type {\n  IdTuple,\n  SerializedChild,\n  SerializedCrdt,\n  SerializedList,\n  SerializedMap,\n  SerializedObject,\n  SerializedRegister,\n  SerializedRootObject,\n} from \"./protocol/SerializedCrdt\";\nexport { CrdtType } from \"./protocol/SerializedCrdt\";\nexport { isChildCrdt, isRootCrdt } from \"./protocol/SerializedCrdt\";\nexport type {\n  BroadcastedEventServerMsg,\n  CommentsEventServerMsg,\n  InitialDocumentStateServerMsg,\n  RejectedStorageOpServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  UpdatePresenceServerMsg,\n  UpdateStorageServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nexport { ServerMsgCode } from \"./protocol/ServerMsg\";\nexport type {\n  SubscriptionData,\n  SubscriptionDataPlain,\n  SubscriptionDeleteInfo,\n  SubscriptionDeleteInfoPlain,\n  SubscriptionKey,\n  UserSubscriptionData,\n  UserSubscriptionDataPlain,\n} from \"./protocol/Subscriptions\";\nexport { getSubscriptionKey } from \"./protocol/Subscriptions\";\nexport type { HistoryVersion } from \"./protocol/VersionHistory\";\nexport type {\n  IYjsProvider,\n  LargeMessageStrategy,\n  PrivateRoomApi,\n  YjsSyncStatus,\n} from \"./room\";\nexport type {\n  BroadcastOptions,\n  History,\n  OpaqueRoom,\n  OptionalTupleUnless,\n  PartialUnless,\n  Room,\n  RoomEventMessage,\n  StorageStatus,\n  SyncSource,\n} from \"./room\";\nexport type { GetThreadsOptions, UploadAttachmentOptions } from \"./room\";\nexport type {\n  AiAssistantContentPart,\n  AiAssistantMessage,\n  AiChat,\n  AiChatMessage,\n  AiChatsQuery,\n  AiKnowledgeSource,\n  AiReasoningPart,\n  AiRetrievalPart,\n  AiTextPart,\n  AiToolInvocationPart,\n  AiUserMessage,\n  CopilotId,\n  Cursor,\n  MessageId,\n  RenderableToolResultResponse,\n  ToolResultResponse,\n} from \"./types/ai\";\nexport type { Awaitable } from \"./types/Awaitable\";\nexport type { Immutable } from \"./types/Immutable\";\nexport type { InferFromSchema } from \"./types/InferFromSchema\";\nexport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nexport { WebsocketCloseCodes } from \"./types/IWebSocket\";\nexport type { LiveblocksErrorContext } from \"./types/LiveblocksError\";\nexport { LiveblocksError } from \"./types/LiveblocksError\";\nexport type { NodeMap, ParentToChildNodeMap } from \"./types/NodeMap\";\nexport type { OthersEvent } from \"./types/Others\";\nexport { TextEditorType } from \"./types/Others\";\nexport type { Patchable } from \"./types/Patchable\";\nexport type {\n  PlainLson,\n  PlainLsonFields,\n  PlainLsonList,\n  PlainLsonMap,\n  PlainLsonObject,\n} from \"./types/PlainLson\";\nexport type { User } from \"./types/User\";\nexport { detectDupes };\nexport type {\n  GroupMentionData,\n  MentionData,\n  UserMentionData,\n} from \"./protocol/MentionData\";\n\n/**\n * Helper type to help users adopt to Lson types from interface definitions.\n * You should only use this to wrap interfaces you don't control. For more\n * information, see\n * https://liveblocks.io/docs/guides/limits#lson-constraint-and-interfaces\n */\n// prettier-ignore\nexport type EnsureJson<T> =\n  // Retain all valid `JSON` fields\n  T extends Json ? T :\n  // Retain all valid arrays\n  T extends Array<infer I> ? (EnsureJson<I>)[] :\n  // Retain `unknown` fields, but just treat them as if they're Json | undefined\n  [unknown] extends [T] ? Json | undefined :\n  // Dates become strings when serialized to JSON\n  T extends Date ? string :\n  // Remove functions\n  T extends (...args: any[]) => any ? never :\n  // Resolve all other values explicitly\n  { [K in keyof T as EnsureJson<T[K]> extends never ? never : K]: EnsureJson<T[K]> };\n\n// Support for DevTools\nimport type * as DevToolsMsg from \"./devtools/protocol\";\nexport type { DevToolsMsg };\nimport type { Json } from \"./lib/Json\";\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nexport type { DevTools };\n", "import { detectDupes } from \"@liveblocks/core\";\n\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\nexport type {\n  Awaitable,\n  BaseActivitiesData,\n  BaseMetadata,\n  BaseUserMeta,\n  BroadcastOptions,\n  Client,\n  ClientOptions,\n  CommentAttachment,\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyLinkElementArgs,\n  CommentBodyMention,\n  CommentBodyMentionElementArgs,\n  CommentBodyParagraph,\n  CommentBodyParagraphElementArgs,\n  CommentBodyText,\n  CommentBodyTextElementArgs,\n  CommentData,\n  CommentLocalAttachment,\n  CommentMixedAttachment,\n  CommentReaction,\n  EnsureJson,\n  History,\n  HistoryVersion,\n  Immutable,\n  InboxNotificationData,\n  IUserInfo,\n  Json,\n  JsonArray,\n  JsonObject,\n  JsonScalar,\n  LargeMessageStrategy,\n  LiveblocksErrorContext,\n  LiveListUpdate,\n  LiveMapUpdate,\n  LiveObjectUpdate,\n  LiveStructure,\n  LostConnectionEvent,\n  Lson,\n  LsonObject,\n  MentionData,\n  NotificationChannel,\n  NotificationChannelSettings,\n  NotificationKind,\n  NotificationSettings,\n  OthersEvent,\n  PlainLsonObject,\n  ResolveGroupsInfoArgs,\n  ResolveMentionSuggestionsArgs,\n  ResolveRoomsInfoArgs,\n  ResolveUsersArgs,\n  Room,\n  RoomSubscriptionSettings,\n  Status,\n  StorageStatus,\n  StorageUpdate,\n  StringifyCommentBodyElements,\n  StringifyCommentBodyOptions,\n  ThreadData,\n  ToImmutable,\n  UploadAttachmentOptions,\n  User,\n} from \"@liveblocks/core\";\nexport {\n  createClient,\n  defineAiTool,\n  getMentionsFromCommentBody,\n  isNotificationChannelEnabled,\n  LiveblocksError,\n  LiveList,\n  LiveMap,\n  LiveObject,\n  shallow,\n  stringifyCommentBody,\n  toPlainLson,\n} from \"@liveblocks/core\";\n", "declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/client\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n"],
  "mappings": "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",
  "names": ["eventSource", "_a", "_value", "error", "_a", "call", "batch", "entries", "t", "url", "values", "parts", "err", "after", "ServerMsgCode", "WebsocketCloseCodes", "log", "ctx", "id", "Permission", "now", "_stack", "recompute_fn", "message", "_b", "OpCode", "_a", "CrdtType", "_data", "id", "parentKey", "before", "after", "deleteDelta", "_b", "entries", "key", "_map", "_a", "_data", "_size", "values", "value", "ClientMsgCode", "error", "options", "chunk", "updates", "event", "now", "batch", "url", "_b", "_strings", "_values", "BACKOFF_DELAYS", "TextEditorType", "PKG_NAME", "PKG_VERSION", "PKG_FORMAT"]
}
