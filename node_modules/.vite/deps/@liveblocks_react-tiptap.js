import {
  EditorContent,
  NodeViewWrapper,
  ReactNodeViewRenderer,
  ReactRenderer,
  useEditor,
  useEditorState
} from "./chunk-X7MEKHWO.js";
import {
  CollaborationCursor,
  Doc,
  Observable,
  PermanentUserData,
  applyUpdate,
  applyUpdateV2,
  create,
  create2,
  createDocFromSnapshot,
  emptySnapshot,
  encodeSnapshot,
  encodeSnapshotV2,
  encodeStateAsUpdate,
  encodeStateAsUpdateV2,
  encodeStateVector,
  equalSnapshots,
  redo,
  snapshot,
  transact,
  undo,
  ySyncPlugin,
  ySyncPluginKey,
  yUndoPlugin,
  yUndoPluginKey,
  yXmlFragmentToProseMirrorFragment,
  yXmlFragmentToProseMirrorRootNode,
  yXmlFragmentToProsemirrorJSON
} from "./chunk-BI53JRIC.js";
import {
  Decoration,
  DecorationSet,
  Extension,
  Fragment,
  Mark,
  Node as Node2,
  Plugin,
  PluginKey,
  Slice,
  TextSelection,
  combineTransactionSteps,
  escapeForRegEx,
  getChangedRanges,
  getMarkType,
  isTextSelection,
  mergeAttributes
} from "./chunk-CWLPEUGS.js";
import {
  require_react_dom
} from "./chunk-7WYZBWXT.js";
import {
  PKG_FORMAT,
  PKG_NAME,
  PKG_VERSION,
  RegisterAiTool,
  _useAiChatMessages,
  _useCreateThread,
  _useInboxNotificationThread,
  _useRoom,
  _useUser,
  getUmbrellaStoreForClient,
  useAddRoomCommentReaction,
  useClient,
  useClientOrNull,
  useCreateRoomComment,
  useCreateRoomThread,
  useCreateTextMention,
  useDeleteInboxNotification,
  useDeleteRoomComment,
  useDeleteTextMention,
  useEditRoomComment,
  useGroupInfo,
  useHistoryVersionData,
  useLatest,
  useMarkInboxNotificationAsRead,
  useMarkRoomThreadAsRead,
  useMarkRoomThreadAsResolved,
  useMarkRoomThreadAsUnresolved,
  useMentionSuggestionsCache,
  useRemoveRoomCommentReaction,
  useReportTextEditor,
  useResolveMentionSuggestions,
  useRoomAttachmentUrl,
  useRoomInfo,
  useRoomPermissions,
  useRoomThreadSubscription,
  useSendAiMessage,
  useSignal,
  useSyncExternalStoreWithSelector,
  useYjsProvider
} from "./chunk-6EBPODIK.js";
import {
  ClientMsgCode,
  DerivedSignal,
  HttpError,
  MENTION_CHARACTER,
  MutableSignal,
  Permission,
  Signal,
  TextEditorType,
  assertNever,
  autoRetry,
  createCommentAttachmentId,
  createInboxNotificationId,
  detectDupes,
  fancy_console_exports,
  findLastIndex,
  generateUrl,
  getMentionsFromCommentBody,
  isCommentBodyLink,
  isCommentBodyMention,
  isCommentBodyText,
  isUrl,
  kInternal,
  makeEventSource,
  nn,
  sanitizeUrl,
  shallow,
  stableStringify,
  warnOnce
} from "./chunk-NT76HTXR.js";
import {
  require_jsx_runtime
} from "./chunk-CRNJR6QK.js";
import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/direction/index.js
var require_direction = __commonJS({
  "node_modules/direction/index.js"(exports, module) {
    "use strict";
    module.exports = direction;
    var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
    var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
    var rtl = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var ltr = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    function direction(value) {
      value = String(value || "");
      if (rtl.test(value)) {
        return "rtl";
      }
      if (ltr.test(value)) {
        return "ltr";
      }
      return "neutral";
    }
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string3) {
      var index2 = string3.length;
      while (index2-- && reWhitespace.test(string3.charAt(index2))) {
      }
      return index2;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string3) {
      return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e3) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject2 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other2 = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other2) ? other2 + "" : other2;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module) {
    var isObject2 = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce2(func, wait, options2) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject2(options2)) {
        leading = !!options2.leading;
        maxing = "maxWait" in options2;
        maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options2 ? !!options2.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module.exports = debounce2;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module) {
    var debounce2 = require_debounce();
    var isObject2 = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options2) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options2)) {
        leading = "leading" in options2 ? !!options2.leading : leading;
        trailing = "trailing" in options2 ? !!options2.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module.exports = throttle2;
  }
});

// node_modules/is-hotkey/lib/index.js
var require_lib = __commonJS({
  "node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS2 = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f = 1; f < 20; f++) {
      CODES["f" + f] = 111 + f;
    }
    var f;
    function isHotkey2(hotkey, options2, event) {
      if (options2 && !("byKey" in options2)) {
        event = options2;
        options2 = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string3) {
        return parseHotkey(string3, options2);
      });
      var check = function check2(e3) {
        return array.some(function(object) {
          return compareHotkey(object, e3);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options2) {
      var byKey = options2 && options2.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values = hotkey.split("+");
      var length = values.length;
      for (var k3 in MODIFIERS2) {
        ret[MODIFIERS2[k3]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var optional = value.endsWith("?") && value.length > 1;
          if (optional) {
            value = value.slice(0, -1);
          }
          var name = toKeyName(value);
          var modifier = MODIFIERS2[name];
          if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name]) {
            throw new TypeError('Unknown modifier: "' + value + '"');
          }
          if (length === 1 || !modifier) {
            if (byKey) {
              ret.key = name;
            } else {
              ret.which = toKeyCode(value);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object, event) {
      for (var key in object) {
        var expected = object[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name) {
      name = toKeyName(name);
      var code = CODES[name] || name.toUpperCase().charCodeAt(0);
      return code;
    }
    function toKeyName(name) {
      name = name.toLowerCase();
      name = ALIASES[name] || name;
      return name;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/@liveblocks/react-tiptap/dist/version.js
var PKG_NAME2 = "@liveblocks/react-tiptap";
var PKG_VERSION2 = "3.7.1";
var PKG_FORMAT2 = "esm";

// node_modules/@liveblocks/react-tiptap/dist/ai/AiToolbar.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value, end2) {
  return max(start2, min(value, end2));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart2, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart2 ? rlPlacement : lrPlacement;
      return isStart2 ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart2 ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
    }
  }
  return list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x2,
    right: x2 + width,
    bottom: y + height,
    x: x2,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(state) {
    const {
      x: x2,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options2, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options2, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "hide",
    options: options2,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options2, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left));
  const minY = min(...rects.map((rect) => rect.top));
  const maxX = max(...rects.map((rect) => rect.right));
  const maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
var inline = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "inline",
    options: options2,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state;
      const {
        padding = 2,
        x: x2,
        y
      } = evaluate(options2, state);
      const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y != null) {
          return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options2) {
  if (options2 === void 0) {
    options2 = 0;
  }
  return {
    name: "offset",
    options: options2,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options2);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(state) {
      const {
        x: x2,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y2
            } = _ref;
            return {
              x: x3,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const coords = {
        x: x2,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    options: options2,
    fn(state) {
      const {
        x: x2,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options2, state);
      const coords = {
        x: x2,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node3) {
  if (isNode(node3)) {
    return (node3.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node3) {
  var _node$ownerDocument;
  return (node3 == null || (_node$ownerDocument = node3.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node3) {
  var _ref;
  return (_ref = (isNode(node3) ? node3.ownerDocument : node3.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e3) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node3) {
  return lastTraversableNodeNames.has(getNodeName(node3));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node3) {
  if (getNodeName(node3) === "html") {
    return node3;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node3.assignedSlot || // DOM Element detected.
    node3.parentNode || // ShadowRoot detected.
    isShadowRoot(node3) && node3.host || // Fallback.
    getDocumentElement(node3)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node3) {
  const parentNode = getParentNode(node3);
  if (isLastTraversableNode(parentNode)) {
    return node3.ownerDocument ? node3.ownerDocument.body : node3.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node3, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node3);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node3.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x2 = ($3 ? round(rect.width) : rect.width) / width;
  let y = ($3 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x: x2,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x2 = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html2);
  if (windowScrollbarX <= 0) {
    const doc = html2.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html2.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e3) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var inline2 = inline;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options2) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options2
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react.useLayoutEffect : noop;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options2;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node3) => {
    if (node3 !== referenceRef.current) {
      referenceRef.current = node3;
      _setReference(node3);
    }
  }, []);
  const setFloating = React.useCallback((node3) => {
    if (node3 !== floatingRef.current) {
      floatingRef.current = node3;
      _setFloating(node3);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options2) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options: options2,
    fn(state) {
      const {
        element,
        padding
      } = typeof options2 === "function" ? options2(state) : options2;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options2, deps) => ({
  ...offset2(options2),
  options: [options2, deps]
});
var shift3 = (options2, deps) => ({
  ...shift2(options2),
  options: [options2, deps]
});
var limitShift3 = (options2, deps) => ({
  ...limitShift2(options2),
  options: [options2, deps]
});
var flip3 = (options2, deps) => ({
  ...flip2(options2),
  options: [options2, deps]
});
var size3 = (options2, deps) => ({
  ...size2(options2),
  options: [options2, deps]
});
var hide3 = (options2, deps) => ({
  ...hide2(options2),
  options: [options2, deps]
});
var inline3 = (options2, deps) => ({
  ...inline2(options2),
  options: [options2, deps]
});
var arrow3 = (options2, deps) => ({
  ...arrow$1(options2),
  options: [options2, deps]
});

// node_modules/@liveblocks/react/dist/_private.js
var import_react2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var useLayoutEffect2 = typeof window !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function selectorFor_useGroup(state) {
  if (state === void 0 || (state == null ? void 0 : state.isLoading)) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  return {
    isLoading: false,
    group: state.data
  };
}
function useGroup(groupId) {
  const client = useClient();
  const store = client[kInternal].httpClient.groupsStore;
  const getGroupState = (0, import_react3.useCallback)(
    () => store.getItemState(groupId),
    [store, groupId]
  );
  (0, import_react3.useEffect)(() => {
    void store.enqueue(groupId);
  }, [store, groupId]);
  return useSyncExternalStoreWithSelector(
    store.subscribe,
    getGroupState,
    getGroupState,
    selectorFor_useGroup,
    shallow
  );
}
var MENTION_SUGGESTIONS_DEBOUNCE = 500;
function normalizeMentionSuggestions(suggestions) {
  return suggestions.map(
    (suggestion) => typeof suggestion === "string" ? { kind: "user", id: suggestion } : suggestion
  );
}
function useMentionSuggestions(roomId, search) {
  const [mentionSuggestions, setMentionSuggestions] = (0, import_react4.useState)();
  const lastInvokedAt = (0, import_react4.useRef)();
  const resolveMentionSuggestions = useResolveMentionSuggestions();
  const mentionSuggestionsCache = useMentionSuggestionsCache();
  (0, import_react4.useEffect)(() => {
    if (search === void 0 || !resolveMentionSuggestions) {
      return;
    }
    const resolveMentionSuggestionsArgs = { text: search, roomId };
    const mentionSuggestionsCacheKey = stableStringify(
      resolveMentionSuggestionsArgs
    );
    let debounceTimeout;
    let isCanceled = false;
    const getMentionSuggestions = async () => {
      try {
        lastInvokedAt.current = performance.now();
        const rawMentionSuggestions = await resolveMentionSuggestions(
          resolveMentionSuggestionsArgs
        );
        if (!isCanceled) {
          const normalizedSuggestions = normalizeMentionSuggestions(
            rawMentionSuggestions
          );
          setMentionSuggestions(normalizedSuggestions);
          mentionSuggestionsCache.set(
            mentionSuggestionsCacheKey,
            normalizedSuggestions
          );
        }
      } catch (error) {
        console.error(error == null ? void 0 : error.message);
      }
    };
    if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {
      const cachedSuggestions = mentionSuggestionsCache.get(
        mentionSuggestionsCacheKey
      );
      setMentionSuggestions(cachedSuggestions);
    } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {
      void getMentionSuggestions();
    } else {
      debounceTimeout = window.setTimeout(() => {
        void getMentionSuggestions();
      }, MENTION_SUGGESTIONS_DEBOUNCE);
    }
    return () => {
      isCanceled = true;
      window.clearTimeout(debounceTimeout);
    };
  }, [search, roomId, resolveMentionSuggestions, mentionSuggestionsCache]);
  return mentionSuggestions;
}
function useSyncSource() {
  const client = useClient();
  const createSyncSource = client[kInternal].createSyncSource;
  const [syncSource, setSyncSource] = (0, import_react5.useState)();
  (0, import_react5.useEffect)(() => {
    const newSyncSource = createSyncSource();
    setSyncSource(newSyncSource);
    return () => newSyncSource.destroy();
  }, [createSyncSource]);
  return syncSource;
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/cn.js
function cn(...args) {
  return args.filter((arg) => typeof arg === "string" || typeof arg === "number").join(" ");
}

// node_modules/@liveblocks/react-ui/dist/utils/get-initials.js
function getInitials(name) {
  return name.trim().split(" ").reduce((initials, name2, index2, array) => {
    if (index2 === 0 || index2 === array.length - 1) {
      initials += name2.charAt(0).toLocaleUpperCase();
    }
    return initials;
  }, "");
}

// node_modules/@liveblocks/react/dist/suspense.js
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);

// node_modules/@liveblocks/react-ui/dist/utils/use-initial.js
var import_react6 = __toESM(require_react(), 1);
function useInitial(value) {
  const [initialValue] = (0, import_react6.useState)(value);
  return initialValue;
}

// node_modules/@liveblocks/react-ui/dist/utils/use-user-or-group-info.js
function useUserOrGroupInfo(kind, id) {
  const frozenKind = useInitial(kind);
  if (frozenKind === "user") {
    const { user, isLoading, error } = _useUser(id);
    return {
      info: user,
      isLoading,
      error
    };
  } else if (frozenKind === "group") {
    const { info, isLoading, error } = useGroupInfo(id);
    return {
      info,
      isLoading,
      error
    };
  }
  return assertNever(frozenKind, "Invalid kind");
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Avatar.js
function AvatarLayout({
  src,
  name,
  fallback,
  isLoading,
  className,
  ...props
}) {
  const nameInitials = (0, import_react8.useMemo)(
    () => name ? getInitials(name) : void 0,
    [name]
  );
  const fallbackInitials = (0, import_react8.useMemo)(
    () => !isLoading && fallback && !name ? getInitials(fallback) : void 0,
    [isLoading, fallback, name]
  );
  return (0, import_jsx_runtime.jsxs)("div", {
    className: cn("lb-avatar", className),
    "data-loading": isLoading ? "" : void 0,
    ...props,
    children: [
      src && (0, import_jsx_runtime.jsx)("img", {
        className: "lb-avatar-image",
        src,
        alt: name
      }),
      nameInitials ? (0, import_jsx_runtime.jsx)("span", {
        className: "lb-avatar-fallback",
        "aria-hidden": true,
        children: nameInitials
      }) : fallbackInitials ? (0, import_jsx_runtime.jsx)("span", {
        className: "lb-avatar-fallback",
        "aria-label": fallback,
        title: fallback,
        children: fallbackInitials
      }) : null
    ]
  });
}
function Avatar({ userId, groupId, icon, ...props }) {
  const { info, isLoading } = useUserOrGroupInfo(
    userId ? "user" : "group",
    userId ?? groupId
  );
  return icon && (isLoading || !(info == null ? void 0 : info.avatar)) ? (0, import_jsx_runtime.jsx)("div", {
    ...props,
    children: icon
  }) : (0, import_jsx_runtime.jsx)(AvatarLayout, {
    src: info == null ? void 0 : info.avatar,
    name: info == null ? void 0 : info.name,
    fallback: userId ?? groupId,
    isLoading,
    ...props
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Button.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/ChevronDown.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var ICON_WIDTH = 20;
var ICON_HEIGHT = 20;
function Icon({ children, className, ...props }) {
  return (0, import_jsx_runtime2.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: ICON_WIDTH,
    height: ICON_HEIGHT,
    viewBox: `0 0 ${ICON_WIDTH} ${ICON_HEIGHT}`,
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    role: "presentation",
    className: cn("lb-icon", className),
    ...props,
    children
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/ChevronDown.js
function ChevronDownIcon(props) {
  return (0, import_jsx_runtime3.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime3.jsx)("path", {
      d: "M14.5 8.5 10 13 5.5 8.5"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Button.js
var CustomButton = (0, import_react9.forwardRef)(
  ({
    variant = "default",
    size: size5 = "default",
    disableable = true,
    className,
    children,
    ...props
  }, forwardedRef) => {
    return (0, import_jsx_runtime4.jsx)("button", {
      type: "button",
      className: cn(
        "lb-button",
        !disableable && "lb-button:non-disableable",
        className
      ),
      "data-variant": variant,
      "data-size": size5,
      ...props,
      ref: forwardedRef,
      children
    });
  }
);
var Button = (0, import_react9.forwardRef)(
  ({ icon, children, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime4.jsxs)(CustomButton, {
      ...props,
      ref: forwardedRef,
      children: [
        icon ? (0, import_jsx_runtime4.jsx)("span", {
          className: "lb-icon-container",
          children: icon
        }) : null,
        children ? (0, import_jsx_runtime4.jsx)("span", {
          className: "lb-button-label",
          children
        }) : null
      ]
    });
  }
);
var SelectButton = (0, import_react9.forwardRef)(
  ({ icon, children, className, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime4.jsxs)(CustomButton, {
      ...props,
      type: "button",
      className: cn("lb-select-button", className),
      ref: forwardedRef,
      children: [
        icon ? (0, import_jsx_runtime4.jsx)("span", {
          className: "lb-icon-container",
          children: icon
        }) : null,
        children ? (0, import_jsx_runtime4.jsx)("span", {
          className: "lb-button-label",
          children
        }) : null,
        (0, import_jsx_runtime4.jsx)("span", {
          className: "lb-select-button-chevron",
          children: (0, import_jsx_runtime4.jsx)(ChevronDownIcon, {})
        })
      ]
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/internal/Group.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function Group({ groupId, className, children, ...props }) {
  const { info, isLoading } = useGroupInfo(groupId);
  return (0, import_jsx_runtime5.jsxs)("span", {
    className: cn("lb-name lb-group", className),
    "data-loading": isLoading ? "" : void 0,
    ...props,
    children: [
      isLoading ? null : (info == null ? void 0 : info.name) ?? groupId,
      children
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/GroupDescription.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
function GroupDescription({
  groupId,
  className,
  ...props
}) {
  const { info } = useGroupInfo(groupId);
  return (info == null ? void 0 : info.description) ? (0, import_jsx_runtime6.jsx)("span", {
    className: cn("lb-group-description", className),
    ...props,
    children: info.description
  }) : null;
}

// node_modules/@liveblocks/react-ui/dist/components/internal/List.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React3 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React2 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node3) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node3);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React2.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot22 = React3.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React3.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React3.Children.count(newElement) > 1) return React3.Children.only(null);
          return React3.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime7.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React3.isValidElement(newElement) ? React3.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime7.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React3.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React3.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React3.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React3.cloneElement(children, props2);
    }
    return React3.Children.count(children) > 1 ? React3.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable22;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React3.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a3, _b;
  let getter = (_a3 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a3.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@liveblocks/react-ui/dist/components/internal/List.js
var import_react17 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/overrides.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/constants.js
var FLOATING_ELEMENT_SIDE_OFFSET = 6;
var FLOATING_ELEMENT_COLLISION_PADDING = 10;
var EMOJI_FONT_FAMILY = "'Apple Color Emoji', 'Noto Color Emoji', 'Twemoji Mozilla', 'Android Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', EmojiSymbols, sans-serif";

// node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.js
var Emoji = (0, import_react12.forwardRef)(
  ({ emoji, className, style, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime8.jsx)("span", {
      role: "img",
      "aria-label": emoji,
      "data-emoji": emoji,
      className: cn("lb-emoji", className),
      style: {
        ...style,
        fontFamily: EMOJI_FONT_FAMILY
      },
      ...props,
      ref: forwardedRef,
      children: emoji
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/primitives/Duration.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/memoize.js
function memoize(fn) {
  const cache2 = /* @__PURE__ */ new Map();
  return (...args) => {
    const key = JSON.stringify(args.map((arg) => stableStringify(arg)));
    const cached = cache2.get(key);
    if (cached !== void 0) {
      return cached;
    }
    const result = fn(...args);
    cache2.set(key, result);
    return result;
  };
}

// node_modules/@liveblocks/react-ui/dist/utils/intl.js
var dateTimeFormat = memoize(
  (...args) => {
    return new Intl.DateTimeFormat(...args);
  }
);
var relativeTimeFormat = memoize(
  (...args) => {
    return new Intl.RelativeTimeFormat(...args);
  }
);
var listFormat = memoize(
  (...args) => {
    return new Intl.ListFormat(...args);
  }
);
var numberFormat = memoize(
  (...args) => {
    return new Intl.NumberFormat(...args);
  }
);

// node_modules/@liveblocks/react-ui/dist/utils/use-interval.js
var import_react13 = __toESM(require_react(), 1);
function useInterval(callback, delay) {
  const latestCallback = (0, import_react13.useRef)(callback);
  (0, import_react13.useEffect)(() => {
    latestCallback.current = callback;
  }, [callback]);
  (0, import_react13.useEffect)(() => {
    if (!delay && delay !== 0) {
      return;
    }
    const id = setInterval(() => {
      if (latestCallback.current() === false) {
        clearInterval(id);
      }
    }, delay);
    return () => clearInterval(id);
  }, [delay]);
}

// node_modules/@liveblocks/react-ui/dist/utils/use-rerender.js
var import_react14 = __toESM(require_react(), 1);
function useRerender() {
  const [key, update] = (0, import_react14.useReducer)(
    (key2) => key2 + 1,
    0
  );
  return [update, key];
}

// node_modules/@liveblocks/react-ui/dist/primitives/Duration.js
var RENDER_INTERVAL = 0.5 * 1e3;
var DURATION_NAME = "Duration";
function getDurationParts(duration) {
  let remaining = Math.max(duration, 0);
  const milliseconds = remaining % 1e3;
  remaining = Math.floor(remaining / 1e3);
  const seconds = remaining % 60;
  remaining = Math.floor(remaining / 60);
  const minutes = remaining % 60;
  remaining = Math.floor(remaining / 60);
  const hours = remaining % 24;
  remaining = Math.floor(remaining / 24);
  const days = remaining % 7;
  const weeks = Math.floor(remaining / 7);
  return { weeks, days, hours, minutes, seconds, milliseconds };
}
var durationPartsToNumberFormatOptions = {
  weeks: "week",
  days: "day",
  hours: "hour",
  minutes: "minute",
  seconds: "second",
  milliseconds: "millisecond"
};
function formatShortDuration(duration, locale) {
  let resolvedLocale;
  if (locale) {
    resolvedLocale = locale;
  } else {
    const formatter = numberFormat();
    resolvedLocale = formatter.resolvedOptions().locale;
  }
  const parts = getDurationParts(duration);
  const formattedParts = [];
  for (const [unit, value] of Object.entries(parts)) {
    if (value === 0 || unit === "milliseconds") {
      continue;
    }
    const formatter = numberFormat(resolvedLocale, {
      style: "unit",
      unit: durationPartsToNumberFormatOptions[unit],
      unitDisplay: "narrow"
    });
    formattedParts.push(formatter.format(value));
  }
  if (!formattedParts.length) {
    formattedParts.push(
      numberFormat(resolvedLocale, {
        style: "unit",
        unit: "second",
        unitDisplay: "narrow"
      }).format(0)
    );
  }
  return formattedParts.join(" ");
}
function formatVerboseDuration(duration, locale) {
  let resolvedLocale;
  if (locale) {
    resolvedLocale = locale;
  } else {
    const formatter = numberFormat();
    resolvedLocale = formatter.resolvedOptions().locale;
  }
  const parts = getDurationParts(duration);
  const formattedParts = [];
  for (const [unit, value] of Object.entries(parts)) {
    if (value === 0 || unit === "milliseconds") {
      continue;
    }
    const formatter = numberFormat(resolvedLocale, {
      style: "unit",
      unit: durationPartsToNumberFormatOptions[unit],
      unitDisplay: "long"
    });
    formattedParts.push(formatter.format(value));
  }
  if (!formattedParts.length) {
    formattedParts.push(
      numberFormat(resolvedLocale, {
        style: "unit",
        unit: "second",
        unitDisplay: "long"
      }).format(0)
    );
  }
  return formattedParts.join(" ");
}
function formatIso8601Duration(duration) {
  const normalizedDuration = Math.max(duration, 0);
  if (normalizedDuration === 0) {
    return "PT0S";
  }
  const { weeks, days, hours, minutes, seconds, milliseconds } = getDurationParts(normalizedDuration);
  let isoDuration = "P";
  if (weeks > 0) {
    isoDuration += `${weeks}W`;
  }
  if (days > 0) {
    isoDuration += `${days}D`;
  }
  if (hours > 0 || minutes > 0 || seconds > 0 || milliseconds > 0) {
    isoDuration += "T";
    if (hours > 0) {
      isoDuration += `${hours}H`;
    }
    if (minutes > 0) {
      isoDuration += `${minutes}M`;
    }
    if (seconds > 0 || milliseconds > 0) {
      if (milliseconds > 0) {
        isoDuration += `${seconds}.${milliseconds.toString().padStart(3, "0").replace(/0+$/, "")}S`;
      } else {
        isoDuration += `${seconds}S`;
      }
    }
  }
  return isoDuration;
}
function getDateTime(date) {
  if (date instanceof Date) {
    return date.getTime();
  }
  return new Date(date).getTime();
}
function getDuration(from2, to) {
  return getDateTime(to) - getDateTime(from2);
}
var Duration = (0, import_react15.forwardRef)(
  ({
    duration,
    from: from2,
    to,
    locale,
    dateTime,
    title: renderTitle = formatVerboseDuration,
    children: renderChildren = formatShortDuration,
    interval = RENDER_INTERVAL,
    asChild,
    ...props
  }, forwardedRef) => {
    const Component3 = asChild ? Slot : "time";
    const [rerender, key] = useRerender();
    const resolvedDuration = (0, import_react15.useMemo)(() => {
      if (duration !== void 0) {
        return duration;
      }
      if (from2 !== void 0) {
        return getDuration(from2, to ?? Date.now());
      }
      return 0;
    }, [duration, from2, to, key]);
    const normalizedDuration = (0, import_react15.useMemo)(
      () => formatIso8601Duration(resolvedDuration),
      [resolvedDuration]
    );
    const title = (0, import_react15.useMemo)(
      () => typeof renderTitle === "function" ? renderTitle(resolvedDuration, locale) : renderTitle,
      [renderTitle, resolvedDuration, locale]
    );
    const children = (0, import_react15.useMemo)(
      () => typeof renderChildren === "function" ? renderChildren(resolvedDuration, locale) : renderChildren,
      [renderChildren, resolvedDuration, locale]
    );
    useInterval(
      rerender,
      from2 !== void 0 && to === void 0 ? interval : false
    );
    return (0, import_jsx_runtime9.jsx)(Component3, {
      ...props,
      ref: forwardedRef,
      dateTime: dateTime ?? normalizedDuration,
      title,
      children
    });
  }
);
if (true) {
  Duration.displayName = DURATION_NAME;
}

// node_modules/@liveblocks/react-ui/dist/utils/pluralize.js
function pluralize(count4, singular, plural) {
  return count4 === 1 ? singular : plural ?? `${singular}s`;
}

// node_modules/@liveblocks/react-ui/dist/overrides.js
var MINIMUM_VISIBLE_DURATION = 3 * 1e3;
function isDurationVisible(from2, to) {
  return getDuration(from2, to ?? Date.now()) >= MINIMUM_VISIBLE_DURATION;
}
var defaultOverrides = {
  locale: "en",
  dir: "ltr",
  USER_SELF: "you",
  USER_UNKNOWN: "Anonymous",
  COPY_TO_CLIPBOARD: "Copy",
  LIST_REMAINING: (count4) => `${count4} more`,
  LIST_REMAINING_USERS: (count4) => `${count4} ${pluralize(count4, "other")}`,
  LIST_REMAINING_COMMENTS: (count4) => `${count4} more ${pluralize(count4, "comment")}`,
  EMOJI_PICKER_SEARCH_PLACEHOLDER: "Search…",
  EMOJI_PICKER_EMPTY: "No emoji found.",
  EMOJI_PICKER_ERROR: () => "There was an error while getting the list of emoji.",
  EMOJI_PICKER_CHANGE_SKIN_TONE: "Change skin tone",
  ATTACHMENT_TOO_LARGE: (maxSize) => maxSize ? `The file is larger than ${maxSize}` : "The file is too large",
  ATTACHMENT_ERROR: () => "The file couldn’t be uploaded.",
  COMPOSER_INSERT_MENTION: "Mention someone",
  COMPOSER_INSERT_EMOJI: "Add emoji",
  COMPOSER_ATTACH_FILES: "Attach files",
  COMPOSER_REMOVE_ATTACHMENT: "Remove attachment",
  COMPOSER_PLACEHOLDER: "Write a comment…",
  COMPOSER_SEND: "Send",
  COMPOSER_TOGGLE_MARK: (format) => {
    switch (format) {
      case "bold":
        return "Bold";
      case "italic":
        return "Italic";
      case "strikethrough":
        return "Strikethrough";
      case "code":
        return "Inline code";
      default:
        return assertNever(format, "Unexpected mark");
    }
  },
  COMMENT_EDITED: "(edited)",
  COMMENT_DELETED: "This comment has been deleted.",
  COMMENT_MORE: "More",
  COMMENT_EDIT: "Edit comment",
  COMMENT_EDIT_COMPOSER_PLACEHOLDER: "Edit comment…",
  COMMENT_EDIT_COMPOSER_CANCEL: "Cancel",
  COMMENT_EDIT_COMPOSER_SAVE: "Save",
  COMMENT_DELETE: "Delete comment",
  COMMENT_DELETE_ATTACHMENT: "Delete attachment",
  COMMENT_ADD_REACTION: "Add reaction",
  COMMENT_REACTION_LIST: (list2, emoji) => (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      list2,
      " reacted with ",
      (0, import_jsx_runtime10.jsx)(Emoji, {
        emoji
      })
    ]
  }),
  COMMENT_REACTION_DESCRIPTION: (emoji, count4) => `${count4} ${pluralize(count4, "reaction")}, react with ${emoji}`,
  THREAD_RESOLVE: "Resolve thread",
  THREAD_UNRESOLVE: "Re-open thread",
  THREAD_SUBSCRIBE: "Subscribe to thread",
  THREAD_UNSUBSCRIBE: "Unsubscribe from thread",
  THREAD_NEW_INDICATOR: "New",
  THREAD_NEW_INDICATOR_DESCRIPTION: "New comments",
  THREAD_SHOW_MORE_COMMENTS: (count4) => `Show ${count4} more ${pluralize(count4, "reply", "replies")}`,
  THREAD_COMPOSER_PLACEHOLDER: "Reply to thread…",
  THREAD_COMPOSER_SEND: "Reply",
  INBOX_NOTIFICATION_MORE: "More",
  INBOX_NOTIFICATION_MARK_AS_READ: "Mark as read",
  INBOX_NOTIFICATION_DELETE: "Delete notification",
  INBOX_NOTIFICATION_THREAD_COMMENTS_LIST: (list2, room) => (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      list2,
      " commented",
      room ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
        children: [
          " in ",
          room
        ]
      }) : (0, import_jsx_runtime10.jsx)(import_jsx_runtime10.Fragment, {
        children: " in a thread"
      })
    ]
  }),
  INBOX_NOTIFICATION_THREAD_MENTION: (user, room) => (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      user,
      " mentioned you",
      room ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
        children: [
          " in ",
          room
        ]
      }) : null
    ]
  }),
  INBOX_NOTIFICATION_TEXT_MENTION: (user, room) => (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      user,
      " mentioned you",
      room ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
        children: [
          " in ",
          room
        ]
      }) : null
    ]
  }),
  HISTORY_VERSION_PREVIEW_AUTHORS_LIST: (list2) => (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      "Edits from ",
      list2
    ]
  }),
  HISTORY_VERSION_PREVIEW_RESTORE: "Restore",
  HISTORY_VERSION_PREVIEW_EMPTY: "No content.",
  HISTORY_VERSION_PREVIEW_ERROR: () => "There was an error while getting this version.",
  AI_COMPOSER_PLACEHOLDER: "Ask anything…",
  AI_COMPOSER_SEND: "Send",
  AI_COMPOSER_ABORT: "Abort response",
  AI_CHAT_MESSAGE_DELETED: "This message has been deleted.",
  AI_CHAT_MESSAGE_THINKING: "Thinking…",
  AI_CHAT_MESSAGE_REASONING: (isStreaming, part) => isStreaming ? (0, import_jsx_runtime10.jsx)(import_jsx_runtime10.Fragment, {
    children: "Reasoning…"
  }) : (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      "Reasoned",
      isDurationVisible(part.startedAt, part.endedAt) ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
        children: [
          " ",
          "for",
          " ",
          (0, import_jsx_runtime10.jsx)(Duration, {
            className: "lb-duration lb-ai-chat-message-reasoning-duration",
            from: part.startedAt,
            to: part.endedAt
          })
        ]
      }) : null
    ]
  }),
  AI_CHAT_MESSAGE_RETRIEVAL: (isStreaming, part) => isStreaming ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      "Searching",
      " ",
      (0, import_jsx_runtime10.jsx)("span", {
        className: "lb-ai-chat-message-retrieval-query",
        children: part.query
      }),
      "…"
    ]
  }) : (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [
      "Searched",
      " ",
      (0, import_jsx_runtime10.jsx)("span", {
        className: "lb-ai-chat-message-retrieval-query",
        children: part.query
      }),
      isDurationVisible(part.startedAt, part.endedAt) ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
        children: [
          " ",
          "for",
          " ",
          (0, import_jsx_runtime10.jsx)(Duration, {
            className: "lb-duration lb-ai-chat-message-retrieval-duration",
            from: part.startedAt,
            to: part.endedAt
          })
        ]
      }) : null
    ]
  }),
  AI_CHAT_MESSAGES_ERROR: () => "There was an error while getting the messages.",
  AI_TOOL_CONFIRMATION_CONFIRM: "Confirm",
  AI_TOOL_CONFIRMATION_CANCEL: "Cancel"
};
var OverridesContext = (0, import_react16.createContext)(void 0);
function useOverrides(overrides) {
  const contextOverrides = (0, import_react16.useContext)(OverridesContext);
  return (0, import_react16.useMemo)(
    () => ({
      ...defaultOverrides,
      ...contextOverrides,
      ...overrides
    }),
    [contextOverrides, overrides]
  );
}
function OverridesProvider({
  children,
  overrides: providerOverrides
}) {
  const contextOverrides = (0, import_react16.useContext)(OverridesContext);
  const overrides = (0, import_react16.useMemo)(
    () => ({
      ...defaultOverrides,
      ...contextOverrides,
      ...providerOverrides
    }),
    [contextOverrides, providerOverrides]
  );
  return (0, import_jsx_runtime10.jsx)(OverridesContext.Provider, {
    value: overrides,
    children
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/List.js
var List = (0, import_react17.forwardRef)(
  ({ values, formatRemaining, truncate, locale, className, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "span";
    const $3 = useOverrides();
    const formatRemainingWithDefault = formatRemaining ?? $3.LIST_REMAINING;
    const formattedList = (0, import_react17.useMemo)(() => {
      const elements = truncate && truncate < values.length - 1 ? [
        ...values.slice(0, truncate),
        formatRemainingWithDefault(values.length - truncate)
      ] : [...values];
      const placeholders = Array(elements.length).fill(".");
      const parts = listFormat(locale).formatToParts(placeholders);
      return parts.map(
        (part) => part.type === "element" ? elements.shift() : part.value
      );
    }, [formatRemainingWithDefault, locale, truncate, values]);
    return (0, import_jsx_runtime11.jsx)(Component3, {
      className: cn("lb-list", className),
      ...props,
      ref: forwardedRef,
      children: formattedList
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/internal/Prose.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/components.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var defaultComponents = {
  Anchor: "a"
};
var ComponentsContext = (0, import_react18.createContext)(
  void 0
);
function useComponents(components) {
  const contextComponents = (0, import_react18.useContext)(ComponentsContext);
  return (0, import_react18.useMemo)(
    () => ({
      ...defaultComponents,
      ...contextComponents,
      ...components
    }),
    [contextComponents, components]
  );
}
function ComponentsProvider({
  children,
  components: providerComponents
}) {
  const contextComponents = (0, import_react18.useContext)(ComponentsContext);
  const components = (0, import_react18.useMemo)(
    () => ({
      ...defaultComponents,
      ...contextComponents,
      ...providerComponents
    }),
    [contextComponents, providerComponents]
  );
  return (0, import_jsx_runtime12.jsx)(ComponentsContext.Provider, {
    value: components,
    children
  });
}

// node_modules/@liveblocks/react-ui/dist/primitives/Markdown.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var noopTest = { exec: () => null };
function edit(regex, opt = "") {
  let source = typeof regex === "string" ? regex : regex.source;
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(other.caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
var other = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
  htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")
};
var newline = /^(?:[ \t]*(?:\n|$))+/;
var blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var bullet = /(?:[*+-]|\d{1,9}[.)])/;
var lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var blockText = /^[^\n]+/;
var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var html = edit(
  "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
  "i"
).replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
var blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
var gfmTable = edit(
  "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockGfm = {
  ...blockNormal,
  lheading: lheadingGfm,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
};
var blockPedantic = {
  ...blockNormal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
};
var escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var br = /^( {2,}|\\)\n(?!\s*$)/;
var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var _punctuation = /[\p{P}\p{S}]/u;
var _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
var punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
var _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
var _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
var blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
var emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
var emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimUnd = edit(
  "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
  "gu"
).replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
var tag = edit(
  "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
).replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var link = edit(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
var inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
var inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
};
var inlineGfm = {
  ...inlineNormal,
  emStrongRDelimAst: emStrongRDelimAstGfm,
  emStrongLDelim: emStrongLDelimGfm,
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
var inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
var block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
var inline4 = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape2(html2, encode2) {
  if (encode2) {
    if (other.escapeTest.test(html2)) {
      return html2.replace(other.escapeReplace, getEscapeReplacement);
    }
  } else {
    if (other.escapeTestNoEncode.test(html2)) {
      return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(other.percentDecode, "%");
  } catch {
    return null;
  }
  return href;
}
function splitCells(tableRow, count4) {
  var _a3;
  const row = tableRow.replace(other.findPipe, (match, offset4, str) => {
    let escaped = false;
    let curr = offset4;
    while (--curr >= 0 && str[curr] === "\\") escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(other.splitPipe);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !((_a3 = cells.at(-1)) == null ? void 0 : _a3.trim())) {
    cells.pop();
  }
  if (count4) {
    if (cells.length > count4) {
      cells.splice(count4);
    } else {
      while (cells.length < count4) cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(other.slashPipe, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l2 = str.length;
  if (l2 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l2) {
    const currChar = str.charAt(l2 - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l2 - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  if (level > 0) {
    return -2;
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer2, rules) {
  const href = link2.href;
  const title = link2.title || null;
  const text = cap[1].replace(rules.other.outputLinkReplace, "$1");
  lexer2.state.inLink = true;
  const token = {
    type: cap[0].charAt(0) === "!" ? "image" : "link",
    raw,
    href,
    title,
    text,
    tokens: lexer2.inlineTokens(text)
  };
  lexer2.state.inLink = false;
  return token;
}
function indentCodeCompensation(raw, text, rules) {
  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node3) => {
    const matchIndentInNode = node3.match(rules.other.beginningSpace);
    if (matchIndentInNode === null) {
      return node3;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node3.slice(indentToCode.length);
    }
    return node3;
  }).join("\n");
}
var _Tokenizer = class {
  // set by the lexer
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "rules");
    // set by the lexer
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "", this.rules);
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (this.rules.other.endingHash.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: rtrim(cap[0], "\n")
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      let lines = rtrim(cap[0], "\n").split("\n");
      let raw = "";
      let text = "";
      const tokens = [];
      while (lines.length > 0) {
        let inBlockquote = false;
        const currentLines = [];
        let i;
        for (i = 0; i < lines.length; i++) {
          if (this.rules.other.blockquoteStart.test(lines[i])) {
            currentLines.push(lines[i]);
            inBlockquote = true;
          } else if (!inBlockquote) {
            currentLines.push(lines[i]);
          } else {
            break;
          }
        }
        lines = lines.slice(i);
        const currentRaw = currentLines.join("\n");
        const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
        raw = raw ? `${raw}
${currentRaw}` : currentRaw;
        text = text ? `${text}
${currentText}` : currentText;
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        this.lexer.blockTokens(currentText, tokens, true);
        this.lexer.state.top = top;
        if (lines.length === 0) {
          break;
        }
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "code") {
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.blockquote(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.list(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
          lines = newText.substring(tokens.at(-1).raw.length).split("\n");
          continue;
        }
      }
      return {
        type: "blockquote",
        raw,
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = this.rules.other.listItemRegex(bull);
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        let raw = "";
        let itemContents = "";
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t3) => " ".repeat(3 * t3.length));
        let nextLine = src.split("\n", 1)[0];
        let blankLine = !line.trim();
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else if (blankLine) {
          indent = cap[1].length + 1;
        } else {
          indent = cap[2].search(this.rules.other.nonSpaceChar);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        if (blankLine && this.rules.other.blankLine.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
          const hrRegex = this.rules.other.hrRegex(indent);
          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            let nextLineWithoutTabs;
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
              nextLineWithoutTabs = nextLine;
            } else {
              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (htmlBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(nextLine)) {
              break;
            }
            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLineWithoutTabs.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLineWithoutTabs.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (this.rules.other.doubleBlankLine.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = this.rules.other.listIsTask.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list2.raw += raw;
      }
      const lastItem = list2.items.at(-1);
      if (lastItem) {
        lastItem.raw = lastItem.raw.trimEnd();
        lastItem.text = lastItem.text.trimEnd();
      } else {
        return;
      }
      list2.raw = list2.raw.trimEnd();
      for (let i = 0; i < list2.items.length; i++) {
        this.lexer.state.top = false;
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t3) => t3.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t3) => this.rules.other.anyLine.test(t3.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (let i = 0; i < list2.items.length; i++) {
          list2.items[i].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    var _a3;
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!this.rules.other.tableDelimiter.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
    const rows = ((_a3 = cap[3]) == null ? void 0 : _a3.trim()) ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (this.rules.other.tableAlignRight.test(align)) {
        item.align.push("right");
      } else if (this.rules.other.tableAlignCenter.test(align)) {
        item.align.push("center");
      } else if (this.rules.other.tableAlignLeft.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (let i = 0; i < headers.length; i++) {
      item.header.push({
        text: headers[i],
        tokens: this.lexer.inline(headers[i]),
        header: true,
        align: item.align[i]
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell),
          header: false,
          align: item.align[i]
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: cap[1]
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
        if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex === -2) {
          return;
        }
        if (lastParenIndex > -1) {
          const start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start2 + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = this.rules.other.pedanticHrefTitle.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (this.rules.other.startAngleBracket.test(href)) {
        if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer, this.rules);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer, this.rules);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrongLDelim.exec(src);
    if (!match) return;
    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim) continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0) continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[1];
        href = "mailto:" + text;
      } else {
        text = cap[1];
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    var _a3;
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[0];
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = ((_a3 = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a3[0]) ?? "";
        } while (prevCapZero !== cap[0]);
        text = cap[0];
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      const escaped = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        escaped
      };
    }
  }
};
var _Lexer = class __Lexer {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      other,
      block: block.normal,
      inline: inline4.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline4.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline4.breaks;
      } else {
        rules.inline = inline4.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline: inline4
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(other.carriageReturn, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next3 = this.inlineQueue[i];
      this.inlineTokens(next3.src, next3.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = [], lastParagraphClipped = false) {
    var _a3, _b, _c;
    if (this.options.pedantic) {
      src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
    }
    while (src) {
      let token;
      if ((_b = (_a3 = this.options.extensions) == null ? void 0 : _a3.block) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.raw.length === 1 && lastToken !== void 0) {
          lastToken.raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        const lastToken = tokens.at(-1);
        if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    var _a3, _b, _c;
    let maskedSrc = src;
    let match = null;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    let keepPrevChar = false;
    let prevChar = "";
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      let token;
      if ((_b = (_a3 = this.options.extensions) == null ? void 0 : _a3.inline) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.type === "text" && (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  // set by the parser
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = options2 || _defaults;
  }
  space(token) {
    return "";
  }
  code({ text, lang, escaped }) {
    var _a3;
    const langString = (_a3 = (lang || "").match(other.notSpaceStart)) == null ? void 0 : _a3[0];
    const code = text.replace(other.endingNewline, "") + "\n";
    if (!langString) {
      return "<pre><code>" + (escaped ? code : escape2(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape2(langString) + '">' + (escaped ? code : escape2(code, true)) + "</code></pre>\n";
  }
  blockquote({ tokens }) {
    const body = this.parser.parse(tokens);
    return `<blockquote>
${body}</blockquote>
`;
  }
  html({ text }) {
    return text;
  }
  heading({ tokens, depth }) {
    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
  }
  hr(token) {
    return "<hr>\n";
  }
  list(token) {
    const ordered = token.ordered;
    const start2 = token.start;
    let body = "";
    for (let j = 0; j < token.items.length; j++) {
      const item = token.items[j];
      body += this.listitem(item);
    }
    const type = ordered ? "ol" : "ul";
    const startAttr = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
    return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
  }
  listitem(item) {
    var _a3;
    let itemBody = "";
    if (item.task) {
      const checkbox = this.checkbox({ checked: !!item.checked });
      if (item.loose) {
        if (((_a3 = item.tokens[0]) == null ? void 0 : _a3.type) === "paragraph") {
          item.tokens[0].text = checkbox + " " + item.tokens[0].text;
          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
            item.tokens[0].tokens[0].text = checkbox + " " + escape2(item.tokens[0].tokens[0].text);
            item.tokens[0].tokens[0].escaped = true;
          }
        } else {
          item.tokens.unshift({
            type: "text",
            raw: checkbox + " ",
            text: checkbox + " ",
            escaped: true
          });
        }
      } else {
        itemBody += checkbox + " ";
      }
    }
    itemBody += this.parser.parse(item.tokens, !!item.loose);
    return `<li>${itemBody}</li>
`;
  }
  checkbox({ checked }) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens }) {
    return `<p>${this.parser.parseInline(tokens)}</p>
`;
  }
  table(token) {
    let header = "";
    let cell = "";
    for (let j = 0; j < token.header.length; j++) {
      cell += this.tablecell(token.header[j]);
    }
    header += this.tablerow({ text: cell });
    let body = "";
    for (let j = 0; j < token.rows.length; j++) {
      const row = token.rows[j];
      cell = "";
      for (let k3 = 0; k3 < row.length; k3++) {
        cell += this.tablecell(row[k3]);
      }
      body += this.tablerow({ text: cell });
    }
    if (body) body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow({ text }) {
    return `<tr>
${text}</tr>
`;
  }
  tablecell(token) {
    const content = this.parser.parseInline(token.tokens);
    const type = token.header ? "th" : "td";
    const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens }) {
    return `<strong>${this.parser.parseInline(tokens)}</strong>`;
  }
  em({ tokens }) {
    return `<em>${this.parser.parseInline(tokens)}</em>`;
  }
  codespan({ text }) {
    return `<code>${escape2(text, true)}</code>`;
  }
  br(token) {
    return "<br>";
  }
  del({ tokens }) {
    return `<del>${this.parser.parseInline(tokens)}</del>`;
  }
  link({ href, title, tokens }) {
    const text = this.parser.parseInline(tokens);
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + escape2(title) + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image({ href, title, text, tokens }) {
    if (tokens) {
      text = this.parser.parseInline(tokens, this.parser.textRenderer);
    }
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return escape2(text);
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${escape2(title)}"`;
    }
    out += ">";
    return out;
  }
  text(token) {
    return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape2(token.text);
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong({ text }) {
    return text;
  }
  em({ text }) {
    return text;
  }
  codespan({ text }) {
    return text;
  }
  del({ text }) {
    return text;
  }
  html({ text }) {
    return text;
  }
  text({ text }) {
    return text;
  }
  link({ text }) {
    return "" + text;
  }
  image({ text }) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Parser = class __Parser {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.renderer.parser = this;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    var _a3, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a3 = this.options.extensions) == null ? void 0 : _a3.renderers) == null ? void 0 : _b[anyToken.type]) {
        const genericToken = anyToken;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "space": {
          out += this.renderer.space(token);
          continue;
        }
        case "hr": {
          out += this.renderer.hr(token);
          continue;
        }
        case "heading": {
          out += this.renderer.heading(token);
          continue;
        }
        case "code": {
          out += this.renderer.code(token);
          continue;
        }
        case "table": {
          out += this.renderer.table(token);
          continue;
        }
        case "blockquote": {
          out += this.renderer.blockquote(token);
          continue;
        }
        case "list": {
          out += this.renderer.list(token);
          continue;
        }
        case "html": {
          out += this.renderer.html(token);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(token);
          continue;
        }
        case "text": {
          let textToken = token;
          let body = this.renderer.text(textToken);
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + this.renderer.text(textToken);
          }
          if (top) {
            out += this.renderer.paragraph({
              type: "paragraph",
              raw: body,
              text: body,
              tokens: [{ type: "text", raw: body, text: body, escaped: true }]
            });
          } else {
            out += body;
          }
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer = this.renderer) {
    var _a3, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a3 = this.options.extensions) == null ? void 0 : _a3.renderers) == null ? void 0 : _b[anyToken.type]) {
        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "escape": {
          out += renderer.text(token);
          break;
        }
        case "html": {
          out += renderer.html(token);
          break;
        }
        case "link": {
          out += renderer.link(token);
          break;
        }
        case "image": {
          out += renderer.image(token);
          break;
        }
        case "strong": {
          out += renderer.strong(token);
          break;
        }
        case "em": {
          out += renderer.em(token);
          break;
        }
        case "codespan": {
          out += renderer.codespan(token);
          break;
        }
        case "br": {
          out += renderer.br(token);
          break;
        }
        case "del": {
          out += renderer.del(token);
          break;
        }
        case "text": {
          out += renderer.text(token);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _a;
var _Hooks = (_a = class {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? _Lexer.lex : _Lexer.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? _Parser.parse : _Parser.parseInline;
  }
}, __publicField(_a, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
])), _a);
var Marked = class {
  constructor(...args) {
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a3, _b;
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if ((_b = (_a3 = this.defaults.extensions) == null ? void 0 : _a3.childTokens) == null ? void 0 : _b[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (["options", "parser"].includes(prop)) {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (["options", "block"].includes(prop)) {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 ?? this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 ?? this.defaults);
  }
  parseMarkdown(blockType) {
    const parse2 = (src, options2) => {
      const origOpt = { ...options2 };
      const opt = { ...this.defaults, ...origOpt };
      const throwError = this.onError(!!opt.silent, !!opt.async);
      if (this.defaults.async === true && origOpt.async === false) {
        return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      }
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
        opt.hooks.block = blockType;
      }
      const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
      const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer2(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser2(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e3) {
        return throwError(e3);
      }
    };
    return parse2;
  }
  onError(silent, async) {
    return (e3) => {
      e3.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg2 = "<p>An error occurred:</p><pre>" + escape2(e3.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg2);
        }
        return msg2;
      }
      if (async) {
        return Promise.reject(e3);
      }
      throw e3;
    };
  }
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// node_modules/@liveblocks/react-ui/dist/primitives/Markdown.js
var import_react19 = __toESM(require_react(), 1);
var LIST_ITEM_CHECKBOX_REGEX = /^\[\s?(x)?\]?$/i;
var PARTIAL_LINK_IMAGE_REGEX = new RegExp("(?<!\\\\)(?<image>!)?\\[(?!\\^)(?<text>[^\\]]*)(?:\\](?:\\((?<url>[^)]*)?)?)?$");
var PARTIAL_TABLE_HEADER_REGEX = /^\s*\|(?:[^|\n]+(?:\|[^|\n]+)*?)?\|?\s*(?:\n\s*\|\s*[-:|\s]*\s*)?$/;
var PARTIAL_EMOJI_REGEX = new RegExp("(?:\\u200D|\\uFE0F|\\u20E3|\\p{Regional_Indicator}|\\p{Emoji_Presentation}|\\p{Emoji_Modifier_Base}|\\p{Emoji_Modifier})+$", "u");
var TRAILING_NON_WHITESPACE_REGEX = /^\S*/;
var WHITESPACE_REGEX = /\s/;
var NEWLINE_REGEX = /\r\n?/g;
var BUFFERED_CHARACTERS_REGEX = new RegExp("(?<!\\\\)((\\*+|_+|~+|`+|\\++|-{0,2}|={0,2}|\\\\|!|<\\/?)\\s*)$");
var SINGLE_CHARACTER_REGEX = /^\s*(\S\s*)$/;
var LEFT_ANGLE_BRACKET_REGEX = /</g;
var RIGHT_ANGLE_BRACKET_REGEX = />/g;
var AMPERSAND_REGEX = /&(?!#?[0-9A-Za-z]+;)/g;
var DEFAULT_PARTIAL_LINK_URL = "#";
var defaultComponents2 = {
  Paragraph: ({ children }) => {
    return (0, import_jsx_runtime13.jsx)("p", {
      children
    });
  },
  Inline: ({ type, children }) => {
    switch (type) {
      case "strong":
        return (0, import_jsx_runtime13.jsx)("strong", {
          children
        });
      case "em":
        return (0, import_jsx_runtime13.jsx)("em", {
          children
        });
      case "code":
        return (0, import_jsx_runtime13.jsx)("code", {
          children
        });
      case "del":
        return (0, import_jsx_runtime13.jsx)("del", {
          children
        });
      default:
        assertNever(type, "Unknown inline type");
    }
  },
  CodeBlock: ({ language, code }) => {
    return (0, import_jsx_runtime13.jsx)("pre", {
      "data-language": language ?? void 0,
      children: (0, import_jsx_runtime13.jsx)("code", {
        children: code
      })
    });
  },
  Link: ({ href, title, children }) => {
    return (0, import_jsx_runtime13.jsx)("a", {
      href,
      title,
      target: "_blank",
      rel: "noopener noreferrer",
      children
    });
  },
  Heading: ({ level, children }) => {
    const Heading = `h${level}`;
    return (0, import_jsx_runtime13.jsx)(Heading, {
      children
    });
  },
  Image: ({ src, alt, title }) => {
    return (0, import_jsx_runtime13.jsx)("img", {
      src,
      alt,
      title
    });
  },
  Blockquote: ({ children }) => {
    return (0, import_jsx_runtime13.jsx)("blockquote", {
      children
    });
  },
  Table: ({ headings, rows }) => {
    return (0, import_jsx_runtime13.jsxs)("table", {
      children: [
        (0, import_jsx_runtime13.jsx)("thead", {
          children: (0, import_jsx_runtime13.jsx)("tr", {
            children: headings.map((heading2, index2) => {
              return (0, import_jsx_runtime13.jsx)("th", {
                align: heading2.align,
                children: heading2.children
              }, index2);
            })
          })
        }),
        (0, import_jsx_runtime13.jsx)("tbody", {
          children: rows.map((row, index2) => {
            return (0, import_jsx_runtime13.jsx)("tr", {
              children: row.map((cell, index22) => {
                return (0, import_jsx_runtime13.jsx)("td", {
                  align: cell.align,
                  children: cell.children
                }, index22);
              })
            }, index2);
          })
        })
      ]
    });
  },
  List: ({ type, items, start: start2 }) => {
    const List2 = type === "ordered" ? "ol" : "ul";
    return (0, import_jsx_runtime13.jsx)(List2, {
      start: start2 === 1 ? void 0 : start2,
      children: items.map((item, index2) => (0, import_jsx_runtime13.jsx)("li", {
        children: item.children
      }, index2))
    });
  },
  Separator: () => {
    return (0, import_jsx_runtime13.jsx)("hr", {});
  }
};
var Markdown = (0, import_react19.forwardRef)(
  ({ content, partial, components, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "div";
    const tokens = (0, import_react19.useMemo)(() => {
      if (!content) {
        return [];
      }
      return partial ? tokenizePartial(content) : tokenize(content);
    }, [content, partial]);
    return (0, import_jsx_runtime13.jsx)(Component3, {
      ...props,
      ref: forwardedRef,
      children: tokens.map((token, index2) => {
        return (0, import_jsx_runtime13.jsx)(MemoizedMarkdownToken, {
          token,
          components,
          partial
        }, index2);
      })
    });
  }
);
var MemoizedMarkdownToken = (0, import_react19.memo)(
  ({
    token,
    components
  }) => {
    return (0, import_jsx_runtime13.jsx)(MarkdownToken, {
      token,
      components
    });
  },
  (previousProps, nextProps) => {
    const previousToken = previousProps.token;
    const nextToken = nextProps.token;
    if (previousToken.type !== nextToken.type || previousProps.partial !== nextProps.partial) {
      return false;
    }
    let previousContent = previousToken.raw;
    let nextContent = nextToken.raw;
    if ("text" in previousToken && "text" in nextToken) {
      previousContent = previousToken.text;
      nextContent = nextToken.text;
    }
    if (previousContent.length !== nextContent.length) {
      return false;
    }
    return previousContent === nextContent;
  }
);
function MarkdownToken({
  token,
  components
}) {
  var _a3;
  switch (token.type) {
    case "escape": {
      return token.text;
    }
    case "space": {
      return null;
    }
    case "text": {
      if (token.tokens !== void 0) {
        return (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        });
      } else {
        return parseHtmlEntities(token.text);
      }
    }
    case "br": {
      return (0, import_jsx_runtime13.jsx)("br", {});
    }
    case "paragraph": {
      const Paragraph = (components == null ? void 0 : components.Paragraph) ?? defaultComponents2.Paragraph;
      return (0, import_jsx_runtime13.jsx)(Paragraph, {
        children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        })
      });
    }
    case "heading": {
      const Heading = (components == null ? void 0 : components.Heading) ?? defaultComponents2.Heading;
      return (0, import_jsx_runtime13.jsx)(Heading, {
        level: clampHeadingLevel(token.depth),
        children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        })
      });
    }
    case "strong": {
      const Inline = (components == null ? void 0 : components.Inline) ?? defaultComponents2.Inline;
      return (0, import_jsx_runtime13.jsx)(Inline, {
        type: "strong",
        children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        })
      });
    }
    case "em": {
      const Inline = (components == null ? void 0 : components.Inline) ?? defaultComponents2.Inline;
      return (0, import_jsx_runtime13.jsx)(Inline, {
        type: "em",
        children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        })
      });
    }
    case "codespan": {
      const Inline = (components == null ? void 0 : components.Inline) ?? defaultComponents2.Inline;
      return (0, import_jsx_runtime13.jsx)(Inline, {
        type: "code",
        children: parseHtmlEntities(token.text)
      });
    }
    case "del": {
      const Inline = (components == null ? void 0 : components.Inline) ?? defaultComponents2.Inline;
      return (0, import_jsx_runtime13.jsx)(Inline, {
        type: "del",
        children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        })
      });
    }
    case "link": {
      const href = sanitizeUrl(token.href);
      if (href === null) {
        return (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        });
      }
      const Link2 = (components == null ? void 0 : components.Link) ?? defaultComponents2.Link;
      return (0, import_jsx_runtime13.jsx)(Link2, {
        href,
        title: token.title ?? void 0,
        children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components
        })
      });
    }
    case "code": {
      let language = void 0;
      if (token.lang !== void 0) {
        language = ((_a3 = token.lang.match(TRAILING_NON_WHITESPACE_REGEX)) == null ? void 0 : _a3[0]) ?? void 0;
      }
      const CodeBlock3 = (components == null ? void 0 : components.CodeBlock) ?? defaultComponents2.CodeBlock;
      return (0, import_jsx_runtime13.jsx)(CodeBlock3, {
        language,
        code: token.text || " "
      });
    }
    case "blockquote": {
      const Blockquote = (components == null ? void 0 : components.Blockquote) ?? defaultComponents2.Blockquote;
      return (0, import_jsx_runtime13.jsx)(Blockquote, {
        children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
          tokens: token.tokens,
          components,
          normalizeToBlockTokens: true
        })
      });
    }
    case "list": {
      const List2 = (components == null ? void 0 : components.List) ?? defaultComponents2.List;
      const items = token.items.map((item) => {
        let tokens = item.tokens;
        if (item.task) {
          tokens = [
            {
              type: "checkbox",
              checked: Boolean(item.checked),
              raw: `[${item.checked ? "x" : " "}]`
            },
            ...tokens
          ];
        }
        return {
          checked: item.task ? item.checked : void 0,
          children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
            tokens,
            components,
            normalizeToBlockTokens: item.tokens.length > 0 ? item.loose : false
          })
        };
      });
      const props = token.ordered ? { type: "ordered", items, start: token.start || 1 } : { type: "unordered", items };
      return (0, import_jsx_runtime13.jsx)(List2, {
        ...props
      });
    }
    case "checkbox": {
      return (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, {
        children: [
          (0, import_jsx_runtime13.jsx)("input", {
            type: "checkbox",
            disabled: true,
            checked: token.checked
          }),
          " "
        ]
      });
    }
    case "table": {
      const Table = (components == null ? void 0 : components.Table) ?? defaultComponents2.Table;
      const headings = token.header.map(
        (cell) => ({
          align: cell.align ?? void 0,
          children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
            tokens: cell.tokens,
            components
          })
        })
      );
      const rows = token.rows.map(
        (row) => row.map((cell) => ({
          align: cell.align ?? void 0,
          children: (0, import_jsx_runtime13.jsx)(MarkdownTokens, {
            tokens: cell.tokens,
            components
          })
        }))
      );
      return (0, import_jsx_runtime13.jsx)(Table, {
        headings,
        rows
      });
    }
    case "image": {
      const href = sanitizeUrl(token.href);
      if (href === null) {
        return token.text;
      }
      const Image = (components == null ? void 0 : components.Image) ?? defaultComponents2.Image;
      return (0, import_jsx_runtime13.jsx)(Image, {
        src: href,
        alt: token.text,
        title: token.title ?? void 0
      });
    }
    case "hr": {
      const Separator2 = (components == null ? void 0 : components.Separator) ?? defaultComponents2.Separator;
      return (0, import_jsx_runtime13.jsx)(Separator2, {});
    }
    case "html": {
      return parseHtmlEntities(token.text);
    }
    default: {
      return null;
    }
  }
}
function MarkdownTokens({
  tokens,
  components,
  normalizeToBlockTokens = false
}) {
  var _a3;
  assertTokens(tokens);
  let normalizedTokens = [];
  if (normalizeToBlockTokens) {
    let leadingCheckboxToken = ((_a3 = tokens[0]) == null ? void 0 : _a3.type) === "checkbox" ? tokens[0] : null;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      switch (token.type) {
        case "text": {
          const paragraphTextTokens = [token];
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            i++;
            paragraphTextTokens.push(tokens[i]);
          }
          const paragraphRaw = paragraphTextTokens.map((text) => text.raw).join("");
          const paragraphText = paragraphTextTokens.map((text) => text.text).join("");
          normalizedTokens.push({
            type: "paragraph",
            tokens: leadingCheckboxToken ? [leadingCheckboxToken, ...paragraphTextTokens] : paragraphTextTokens,
            raw: paragraphRaw,
            text: paragraphText
          });
          leadingCheckboxToken = null;
          break;
        }
        case "checkbox":
          break;
        default: {
          normalizedTokens.push(token);
        }
      }
    }
  } else {
    normalizedTokens = tokens;
  }
  return normalizedTokens.map((token, index2) => (0, import_jsx_runtime13.jsx)(MarkdownToken, {
    token,
    components
  }, index2));
}
function assertTokens(_2) {
}
function isBlockToken(token) {
  return token.type === "paragraph" || token.type === "heading" || token.type === "blockquote" || token.type === "list_item";
}
function tokenize(markdown) {
  return new _Lexer().lex(markdown);
}
function tokenizePartial(markdown) {
  const preprocessedContent = trimPartialMarkdown(normalizeNewlines(markdown));
  const tokens = tokenize(preprocessedContent);
  try {
    return completePartialTokens(tokens);
  } catch {
    return tokens;
  }
}
function findPotentiallyPartialToken(tokens, parentToken) {
  if (tokens.length === 0) {
    return parentToken;
  }
  assertTokens(tokens);
  const lastIndex = tokens.length - 1;
  let lastToken = tokens[lastIndex];
  if (lastToken.type === "space") {
    const penultimateToken = tokens[lastIndex - 1];
    if (!penultimateToken) {
      return parentToken;
    }
    lastToken = penultimateToken;
  }
  if (lastToken.type === "list") {
    const listToken = lastToken;
    const lastListItem = listToken.items[listToken.items.length - 1];
    if (!lastListItem) {
      return parentToken;
    }
    const lastListItemTokens = lastListItem.tokens;
    if (lastListItemTokens.some((token) => token.type === "space") && lastListItemTokens.length > 0) {
      const lastListItemLastToken = lastListItemTokens[lastListItemTokens.length - 1];
      if (lastListItemLastToken) {
        if (lastListItemLastToken.type === "text") {
          return lastListItemLastToken;
        }
        if (isBlockToken(lastListItemLastToken)) {
          return findPotentiallyPartialToken(
            lastListItemLastToken.tokens,
            lastListItemLastToken
          );
        }
        return void 0;
      }
    }
    return findPotentiallyPartialToken(lastListItem.tokens, lastListItem);
  }
  if (lastToken.type === "table") {
    const tableToken = lastToken;
    const lastTableRow = tableToken.rows[tableToken.rows.length - 1];
    if (!lastTableRow) {
      return parentToken;
    }
    const firstEmptyTableCellIndex = lastTableRow.findIndex(
      (cell) => cell.tokens.length === 0
    );
    const lastNonEmptyTableCell = firstEmptyTableCellIndex === -1 ? void 0 : firstEmptyTableCellIndex === 0 ? lastTableRow[firstEmptyTableCellIndex] : lastTableRow[firstEmptyTableCellIndex - 1];
    if (!lastNonEmptyTableCell) {
      return parentToken;
    }
    return findPotentiallyPartialToken(
      lastNonEmptyTableCell.tokens,
      lastNonEmptyTableCell
    );
  }
  if (isBlockToken(lastToken)) {
    return findPotentiallyPartialToken(lastToken.tokens, lastToken);
  }
  return parentToken;
}
function normalizeNewlines(string3) {
  return string3.replace(NEWLINE_REGEX, "\n");
}
function trimPartialMarkdown(markdown) {
  const lines = markdown.split("\n");
  if (lines.length === 0) {
    return markdown;
  }
  const [singleCharacterMatch] = lines[lines.length - 1].match(SINGLE_CHARACTER_REGEX) ?? [];
  if (singleCharacterMatch) {
    lines[lines.length - 1] = lines[lines.length - 1].slice(
      0,
      -singleCharacterMatch.length
    );
    return lines.join("\n");
  }
  const [bufferedCharactersMatch] = lines[lines.length - 1].match(BUFFERED_CHARACTERS_REGEX) ?? [];
  if (bufferedCharactersMatch) {
    lines[lines.length - 1] = lines[lines.length - 1].slice(
      0,
      -bufferedCharactersMatch.length
    );
    return lines.join("\n");
  }
  return markdown;
}
function completePartialInlineMarkdown(markdown, options2 = {}) {
  var _a3;
  const stack = [];
  const allowLinksImages = options2.allowLinksImages ?? true;
  let completedMarkdown = markdown;
  const partialEmojiMatch = completedMarkdown.match(PARTIAL_EMOJI_REGEX);
  if (partialEmojiMatch) {
    const partialEmoji = partialEmojiMatch[0];
    completedMarkdown = completedMarkdown.slice(0, -partialEmoji.length);
    if (partialEmoji.includes("️") || partialEmoji.includes("⃣")) {
      const codepoints = Array.from(completedMarkdown);
      if (codepoints.length > 0) {
        completedMarkdown = codepoints.slice(0, -1).join("");
      }
    }
  }
  for (let i = 0; i < completedMarkdown.length; i++) {
    const character = completedMarkdown[i];
    const isEscaped = i > 0 ? completedMarkdown[i - 1] === "\\" : false;
    if (isEscaped) {
      continue;
    }
    if (character === "`") {
      const lastDelimiter = stack[stack.length - 1];
      const isClosingPreviousDelimiter = (lastDelimiter == null ? void 0 : lastDelimiter.string) === "`" && i > lastDelimiter.index;
      if (isClosingPreviousDelimiter) {
        stack.pop();
      } else {
        const characterAfterDelimiter = completedMarkdown[i + 1];
        if (characterAfterDelimiter && !WHITESPACE_REGEX.test(characterAfterDelimiter)) {
          stack.push({ string: "`", length: 1, index: i });
        }
      }
      continue;
    }
    if (character === "*" || character === "_" || character === "~") {
      const isInsideInlineCode = ((_a3 = stack[stack.length - 1]) == null ? void 0 : _a3.string) === "`";
      let j = i;
      while (j < completedMarkdown.length && completedMarkdown[j] === character) {
        j++;
      }
      const consecutiveDelimiterCharacters = j - i;
      if (isInsideInlineCode) {
        i += consecutiveDelimiterCharacters - 1;
        continue;
      }
      let remainingConsecutiveDelimiterCharacters = consecutiveDelimiterCharacters;
      let consecutiveDelimiterCharacterIndex = 0;
      while (remainingConsecutiveDelimiterCharacters > 0) {
        const lastDelimiter = stack[stack.length - 1];
        if (!lastDelimiter || lastDelimiter.string[0] !== character) {
          break;
        }
        if (remainingConsecutiveDelimiterCharacters >= lastDelimiter.length) {
          stack.pop();
          remainingConsecutiveDelimiterCharacters -= lastDelimiter.length;
          consecutiveDelimiterCharacterIndex += lastDelimiter.length;
          continue;
        }
        break;
      }
      if (remainingConsecutiveDelimiterCharacters > 0) {
        if (i + consecutiveDelimiterCharacters >= completedMarkdown.length) {
          completedMarkdown = completedMarkdown.slice(
            0,
            completedMarkdown.length - remainingConsecutiveDelimiterCharacters
          );
          break;
        }
        const characterAfterDelimiters = completedMarkdown[i + consecutiveDelimiterCharacters];
        if (characterAfterDelimiters && !WHITESPACE_REGEX.test(characterAfterDelimiters)) {
          let delimiterStartIndex = i + consecutiveDelimiterCharacterIndex;
          if (remainingConsecutiveDelimiterCharacters % 2 === 1) {
            stack.push({
              string: character,
              length: 1,
              index: delimiterStartIndex
            });
            delimiterStartIndex += 1;
            remainingConsecutiveDelimiterCharacters -= 1;
          }
          while (remainingConsecutiveDelimiterCharacters >= 2) {
            stack.push({
              string: character + character,
              length: 2,
              index: delimiterStartIndex
            });
            delimiterStartIndex += 2;
            remainingConsecutiveDelimiterCharacters -= 2;
          }
        }
      }
      i += consecutiveDelimiterCharacters - 1;
      continue;
    }
  }
  if (allowLinksImages) {
    const partialLinkImageMatch = completedMarkdown.match(
      PARTIAL_LINK_IMAGE_REGEX
    );
    if (partialLinkImageMatch) {
      const linkImageStartIndex = partialLinkImageMatch.index;
      const linkImageEndIndex = linkImageStartIndex + partialLinkImageMatch[0].length;
      const isInsideInlineCode = stack.some(
        (delimiter) => delimiter.string === "`" && delimiter.index < linkImageStartIndex
      );
      if (!isInsideInlineCode) {
        const partialLinkImageContent = partialLinkImageMatch[0];
        const {
          text: partialLinkText,
          url: partialLinkUrl,
          image: isImage
        } = partialLinkImageMatch.groups;
        if (isImage) {
          completedMarkdown = completedMarkdown.slice(
            0,
            -partialLinkImageContent.length
          );
        } else {
          for (let i = stack.length - 1; i >= 0; i--) {
            const delimiter = stack[i];
            if (delimiter.index >= linkImageStartIndex && delimiter.index < linkImageEndIndex) {
              stack.splice(i, 1);
            }
          }
          const completedLinkText = partialLinkText ? partialLinkUrl ? partialLinkText : completePartialInlineMarkdown(partialLinkText, {
            allowLinksImages: false
          }) : "";
          const completedLinkUrl = partialLinkUrl && !WHITESPACE_REGEX.test(partialLinkUrl) && isUrl(partialLinkUrl) ? partialLinkUrl : DEFAULT_PARTIAL_LINK_URL;
          const completedLink = `[${completedLinkText}](${completedLinkUrl})`;
          completedMarkdown = completedMarkdown.slice(
            0,
            -partialLinkImageContent.length
          );
          completedMarkdown += completedLink;
        }
      }
    }
  }
  for (let i = stack.length - 1; i >= 0; i--) {
    const delimiter = stack[i];
    if (delimiter.index + delimiter.length >= completedMarkdown.length) {
      completedMarkdown = completedMarkdown.slice(0, delimiter.index);
      continue;
    }
    if (delimiter.string !== "`") {
      completedMarkdown = completedMarkdown.trimEnd();
    }
    completedMarkdown += delimiter.string;
  }
  return completedMarkdown;
}
function completePartialTableMarkdown(markdown) {
  const tableLines = markdown.split("\n");
  if (tableLines.length === 0) {
    return void 0;
  }
  const tableHeader = tableLines[0];
  if (tableHeader === "|") {
    return void 0;
  }
  const tableHeadings = tableHeader.split("|").map((cell) => cell.trim()).filter((cell) => cell !== "");
  if (tableHeadings.length === 0) {
    return void 0;
  }
  if (!tableHeader.endsWith("|")) {
    const lastTableHeading = tableHeadings[tableHeadings.length - 1];
    const completedLastTableHeading = completePartialInlineMarkdown(lastTableHeading);
    tableHeadings[tableHeadings.length - 1] = completedLastTableHeading;
  }
  return `| ${tableHeadings.join(" | ")} |
| ${tableHeadings.map(() => "---").join(" | ")} |`;
}
function completePartialTokens(tokens) {
  var _a3;
  const potentiallyPartialToken = findPotentiallyPartialToken(tokens);
  if (!potentiallyPartialToken) {
    return tokens;
  }
  if (potentiallyPartialToken.type === "paragraph" || potentiallyPartialToken.type === "text") {
    if (PARTIAL_TABLE_HEADER_REGEX.test(potentiallyPartialToken.raw)) {
      const completedTableMarkdown = completePartialTableMarkdown(
        potentiallyPartialToken.raw
      );
      if (completedTableMarkdown) {
        const completedTable = tokenize(completedTableMarkdown)[0];
        if (completedTable) {
          const table = potentiallyPartialToken;
          table.type = "table";
          table.header = completedTable.header;
          table.align = completedTable.align;
          table.rows = completedTable.rows;
          return tokens;
        }
      } else {
        potentiallyPartialToken.text = "";
        potentiallyPartialToken.tokens = [];
      }
    }
  }
  if (potentiallyPartialToken.type === "list_item") {
    const listItem = potentiallyPartialToken;
    const listItemTokens = listItem.tokens;
    if (!listItem.task && listItemTokens.length === 1 && listItemTokens[0].type === "text") {
      const listItemText = listItemTokens[0];
      const checkboxMatch = listItemText.text.match(LIST_ITEM_CHECKBOX_REGEX);
      if (checkboxMatch) {
        listItem.task = true;
        if (checkboxMatch[1] === "x") {
          listItem.checked = true;
        } else {
          listItem.checked = false;
        }
        listItem.text = "";
        listItem.tokens = [];
      }
    }
  }
  if (potentiallyPartialToken.text.length === 0) {
    return tokens;
  }
  const completedMarkdown = completePartialInlineMarkdown(
    potentiallyPartialToken.text
  );
  const completedMarkdownTokens = ((_a3 = tokenize(completedMarkdown)[0]) == null ? void 0 : _a3.tokens) ?? [];
  potentiallyPartialToken.text = completedMarkdown;
  potentiallyPartialToken.tokens = completedMarkdownTokens;
  return tokens;
}
function parseHtmlEntities(input) {
  const document2 = new DOMParser().parseFromString(
    `<!doctype html><body>${input.replace(AMPERSAND_REGEX, "&amp;").replace(LEFT_ANGLE_BRACKET_REGEX, "&lt;").replace(RIGHT_ANGLE_BRACKET_REGEX, "&gt;")}`,
    "text/html"
  );
  return document2.body.textContent;
}
function clampHeadingLevel(level) {
  return Math.max(1, Math.min(6, level));
}

// node_modules/@liveblocks/react-ui/dist/components/internal/CodeBlock.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/ArrowCornerDownRight.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function ArrowCornerDownRightIcon(props) {
  return (0, import_jsx_runtime14.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime14.jsx)("path", {
      d: "M16 12.5H7.5a3 3 0 0 1-3-3V4M16 12.5 12.5 16m3.5-3.5L12.5 9"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/ArrowCornerUpRight.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/ArrowDown.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
function ArrowDownIcon(props) {
  return (0, import_jsx_runtime16.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime16.jsx)("path", {
      d: "M10 4v12m6-6-6 6-6-6"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/ArrowUp.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/Attachment.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
function AttachmentIcon(props) {
  return (0, import_jsx_runtime18.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime18.jsx)("path", {
      d: "m14.077 11.737-3.723 3.62c-1.55 1.507-4.128 1.507-5.678 0-1.543-1.5-1.543-4.02 0-5.52l5.731-5.573c1.034-1.006 2.754-1.007 3.789-.003 1.03 1 1.032 2.682.003 3.684l-5.744 5.572a1.377 1.377 0 0 1-1.893 0 1.283 1.283 0 0 1-.392-.92c0-.345.14-.676.392-.92L10.348 8"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Bell.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
function BellIcon(props) {
  return (0, import_jsx_runtime19.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime19.jsx)("path", {
      d: "M10 4a3.5 3.5 0 0 0-3.5 3.5c0 3.5-2 6.5-2 6.5h11s-2-3-2-6.5A3.5 3.5 0 0 0 10 4ZM7.55 14a2.5 2.5 0 0 0 4.9 0"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/BellCrossed.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function BellCrossedIcon(props) {
  return (0, import_jsx_runtime20.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime20.jsx)("path", {
      d: "M14 14H4.5s2-3 2-6.5c0-.3.05-.6.12-.88M8.2 4.5a3.5 3.5 0 0 1 5.3 3c0 .96.15 1.88.37 2.7M7.55 14a2.5 2.5 0 0 0 4.9 0M4.5 4.5l11 11"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Blockquote.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
function BlockquoteIcon(props) {
  return (0, import_jsx_runtime21.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime21.jsx)("path", {
      d: "M16 14.25H9M16 10H9m7-4.25H4M4 10l2 2.13-2 2.12"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Bold.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function BoldIcon(props) {
  return (0, import_jsx_runtime22.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime22.jsx)("path", {
      d: "M5.5 10h6.63m0 5.75H5.5V4.25h5.63M11.125 10a2.875 2.875 0 0 0 0-5.75m1 11.5a2.875 2.875 0 0 0 0-5.75"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Check.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
function CheckIcon(props) {
  return (0, import_jsx_runtime23.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime23.jsx)("path", {
      d: "M16 6L8 14L4 10"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/CheckCircle.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
function CheckCircleIcon(props) {
  return (0, import_jsx_runtime24.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime24.jsx)("circle", {
        cx: 10,
        cy: 10,
        r: 7
      }),
      (0, import_jsx_runtime24.jsx)("path", {
        d: "m13 8-4 4-2-2"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/CheckCircleFill.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function CheckCircleFillIcon(props) {
  return (0, import_jsx_runtime25.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime25.jsx)("circle", {
        cx: 10,
        cy: 10,
        r: 7,
        fill: "currentColor"
      }),
      (0, import_jsx_runtime25.jsx)("path", {
        d: "m13 8-4 4-2-2",
        stroke: "var(--lb-icon-background)"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/ChevronLeft.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/ChevronRight.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
function ChevronRightIcon(props) {
  return (0, import_jsx_runtime27.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime27.jsx)("path", {
      d: "M8.5 5.5 13 10l-4.5 4.5"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/ChevronUp.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/Code.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
function CodeIcon(props) {
  return (0, import_jsx_runtime29.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime29.jsx)("path", {
      d: "m7.5 6-4 4 4 4m5-8 4 4-4 4"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Comment.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
function CommentIcon(props) {
  return (0, import_jsx_runtime30.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime30.jsx)("path", {
      d: "M10 16a6 6 0 1 0-5.552-3.72c.094.229.12.482.052.719l-.753 2.636a.5.5 0 0 0 .618.618l2.636-.753a1.1 1.1 0 0 1 .719.052A6.002 6.002 0 0 0 10 16Z"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Copy.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
function CopyIcon(props) {
  return (0, import_jsx_runtime31.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime31.jsx)("path", {
        d: "M4.5 12.91c-.58-.2-1-.76-1-1.41v-6c0-1.1.9-2 2-2h6c.65 0 1.2.42 1.41 1"
      }),
      (0, import_jsx_runtime31.jsx)("rect", {
        x: 7,
        y: 7,
        width: 9.5,
        height: 9.5,
        rx: 1.5
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Cross.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
function CrossIcon(props) {
  return (0, import_jsx_runtime32.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime32.jsx)("path", {
        d: "M15 5L5 15"
      }),
      (0, import_jsx_runtime32.jsx)("path", {
        d: "M5 5L15 15"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/CrossCircleFill.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
function CrossCircleFillIcon(props) {
  return (0, import_jsx_runtime33.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime33.jsx)("circle", {
        cx: 10,
        cy: 10,
        r: 7,
        fill: "currentColor"
      }),
      (0, import_jsx_runtime33.jsx)("path", {
        d: "m12.5 7.5-5 5m0-5 5 5",
        stroke: "var(--lb-icon-background)"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Delete.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
function DeleteIcon(props) {
  return (0, import_jsx_runtime34.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime34.jsx)("path", {
      d: "M4.5 6.5h11M14 6.5V14a1.5 1.5 0 0 1-1.5 1.5h-5A1.5 1.5 0 0 1 6 14V6.5M7.5 6.5V5a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v1.5"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Edit.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
function EditIcon(props) {
  return (0, import_jsx_runtime35.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime35.jsx)("path", {
      d: "m11.784 5.797-6.13 6.138a4 4 0 0 0-1.03 1.775L4 16l2.285-.624a4 4 0 0 0 1.776-1.032l6.145-6.152m-2.422-2.395 1.244-1.246c.608-.608 1.826-.81 2.53-.104.7.7.499 1.893-.122 2.515l-1.23 1.23m-2.422-2.395 2.422 2.395"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Ellipsis.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
function EllipsisIcon(props) {
  return (0, import_jsx_runtime36.jsxs)(Icon, {
    fill: "currentColor",
    ...props,
    children: [
      (0, import_jsx_runtime36.jsx)("circle", {
        cx: 5,
        cy: 10,
        r: 0.75
      }),
      (0, import_jsx_runtime36.jsx)("circle", {
        cx: 10,
        cy: 10,
        r: 0.75
      }),
      (0, import_jsx_runtime36.jsx)("circle", {
        cx: 15,
        cy: 10,
        r: 0.75
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Emoji.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
function EmojiIcon(props) {
  return (0, import_jsx_runtime37.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime37.jsx)("path", {
        d: "M10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14Z"
      }),
      (0, import_jsx_runtime37.jsx)("path", {
        d: "M7.5 11.5S8.25 13 10 13s2.5-1.5 2.5-1.5M8 8h.007"
      }),
      (0, import_jsx_runtime37.jsx)("path", {
        d: "M12 8h.007"
      }),
      (0, import_jsx_runtime37.jsx)("circle", {
        cx: 8,
        cy: 8,
        r: 0.25
      }),
      (0, import_jsx_runtime37.jsx)("circle", {
        cx: 12,
        cy: 8,
        r: 0.25
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/EmojiPlus.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
function EmojiPlusIcon(props) {
  return (0, import_jsx_runtime38.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime38.jsx)("path", {
        d: "M11 3.07A7 7 0 1 0 16.93 9"
      }),
      (0, import_jsx_runtime38.jsx)("path", {
        d: "M7.5 11.5S8.25 13 10 13s2.5-1.5 2.5-1.5M8 8h0"
      }),
      (0, import_jsx_runtime38.jsx)("path", {
        d: "M12 8h0"
      }),
      (0, import_jsx_runtime38.jsx)("path", {
        d: "M13 5h4m-2-2v4"
      }),
      (0, import_jsx_runtime38.jsx)("circle", {
        cx: "8",
        cy: "8",
        r: ".25"
      }),
      (0, import_jsx_runtime38.jsx)("circle", {
        cx: "12",
        cy: "8",
        r: ".25"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/H1.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
function H1Icon(props) {
  return (0, import_jsx_runtime39.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime39.jsx)("path", {
      d: "M4 10h5m-5 4V6m5 8V6m3.5 1.5 2-1.5v8m0 0H13m1.5 0H16"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/H2.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
function H2Icon(props) {
  return (0, import_jsx_runtime40.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime40.jsx)("path", {
      d: "M4 10h5m-5 4V6m5 8V6m3 1c.37-.6 1.21-1 2-1 1 0 2 .5 2 2 0 1.788-1.5 3-4 6h4"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/H3.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
function H3Icon(props) {
  return (0, import_jsx_runtime41.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime41.jsx)("path", {
      d: "M4 10h5m-5 4V6m5 8V6m3 1c.37-.6 1.2-1 2-1 .97 0 2 .5 2 2 0 1.79-1.47 2-2 2 .53 0 2 .21 2 2 0 1.5-1.03 2-2 2-.8 0-1.63-.4-2-1"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Italic.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
function ItalicIcon(props) {
  return (0, import_jsx_runtime42.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime42.jsx)("path", {
      d: "M15 4.25H8m4 11.5H5m6.75-11.5-3.5 11.5"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Lengthen.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
function LengthenIcon(props) {
  return (0, import_jsx_runtime43.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime43.jsx)("path", {
      d: "M15.5 11.5H13m2.5 3h-4m4-6H10m5.5-3H10m-3.5 0v9m0 0 3-3m-3 3-3-3"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/ListOrdered.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
function ListOrderedIcon(props) {
  return (0, import_jsx_runtime44.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime44.jsx)("path", {
      d: "M16 14.25H9M16 10H9m7-4.25H9m-5 0 1-.5V8.5m0 0H4m1 0h1m-2 3.4c.18-.24.6-.4 1-.4.5 0 1 .2 1 .81 0 .73-.75 1.22-2 2.44h2"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/ListUnordered.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
function ListUnorderedIcon(props) {
  return (0, import_jsx_runtime45.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime45.jsx)("path", {
        d: "M16 14.25H8M16 10H8m8-4.25H8m-3.75 0h0"
      }),
      (0, import_jsx_runtime45.jsx)("circle", {
        cx: 4.25,
        cy: 5.75,
        r: 0.25
      }),
      (0, import_jsx_runtime45.jsx)("path", {
        d: "M4.25 14.25h0"
      }),
      (0, import_jsx_runtime45.jsx)("circle", {
        cx: 4.25,
        cy: 14.25,
        r: 0.25
      }),
      (0, import_jsx_runtime45.jsx)("path", {
        d: "M4.25 10h0"
      }),
      (0, import_jsx_runtime45.jsx)("circle", {
        cx: 4.25,
        cy: 10,
        r: 0.25
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Mention.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
function MentionIcon(props) {
  return (0, import_jsx_runtime46.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime46.jsx)("path", {
        d: "M10 13a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"
      }),
      (0, import_jsx_runtime46.jsx)("path", {
        d: "M13 7v3.7c0 1.105.855 2.1 1.9 2.1a2.12 2.12 0 0 0 2.1-2.1V10a7 7 0 1 0-2.8 5.6"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/MinusCircle.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
function MinusCircleIcon(props) {
  return (0, import_jsx_runtime47.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime47.jsx)("circle", {
        cx: 10,
        cy: 10,
        r: 7
      }),
      (0, import_jsx_runtime47.jsx)("path", {
        d: "M7 10h6"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/QuestionMark.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
function QuestionMarkIcon(props) {
  return (0, import_jsx_runtime48.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime48.jsx)("path", {
        d: "M10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0-3h.007"
      }),
      (0, import_jsx_runtime48.jsx)("path", {
        d: "M8 7.5C8 7 8.5 6 10 6s2 1 2 2c0 1.5-2 2-2 3.5"
      }),
      (0, import_jsx_runtime48.jsx)("circle", {
        cx: 10,
        cy: 14,
        r: 0.25
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Redo.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
function RedoIcon(props) {
  return (0, import_jsx_runtime49.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime49.jsx)("path", {
        d: "M16 8H7.5A3.5 3.5 0 0 0 4 11.5v0A3.5 3.5 0 0 0 7.5 15H9"
      }),
      (0, import_jsx_runtime49.jsx)("path", {
        d: "m13 5 3 3-3 3"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Restore.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
function RestoreIcon(props) {
  return (0, import_jsx_runtime50.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime50.jsx)("path", {
        d: "M3.674 7a7 7 0 1 1-.603 4"
      }),
      (0, import_jsx_runtime50.jsx)("path", {
        d: "M3.5 3.5V7H7m3-.5V10l2.5 1.5"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Retry.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/Search.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
function SearchIcon(props) {
  return (0, import_jsx_runtime52.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime52.jsx)("path", {
      d: "M9 15A6 6 0 1 0 9 3a6 6 0 0 0 0 12Zm7.5 1.5-3.25-3.25"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Send.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
function SendIcon(props) {
  return (0, import_jsx_runtime53.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime53.jsx)("path", {
      d: "m5 16 12-6L5 4l2 6-2 6ZM7 10h10"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Shorten.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
function ShortenIcon(props) {
  return (0, import_jsx_runtime54.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime54.jsx)("path", {
      d: "M15.5 8.5H13m2.5-3h-4m-5 9v-9m0 0 3 3m-3-3-3 3"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Sparkles.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
function SparklesIcon(props) {
  return (0, import_jsx_runtime55.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime55.jsx)("path", {
      d: "M8.333 7.833a.333.333 0 0 0-.666 0 3.833 3.833 0 0 1-3.834 3.834.333.333 0 1 0 0 .666 3.833 3.833 0 0 1 3.834 3.834.333.333 0 0 0 .666 0 3.833 3.833 0 0 1 3.834-3.834.333.333 0 1 0 0-.666 3.833 3.833 0 0 1-3.834-3.834ZM16 6.5A2.5 2.5 0 0 1 13.5 4 2.5 2.5 0 0 1 11 6.5 2.5 2.5 0 0 1 13.5 9 2.5 2.5 0 0 1 16 6.5Z"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/SparklesText.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
function SparklesTextIcon(props) {
  return (0, import_jsx_runtime56.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime56.jsx)("path", {
        d: "M9 11.5H4.5m3.5 3H4.5m11-6h-11m11-3h-11"
      }),
      (0, import_jsx_runtime56.jsx)("path", {
        d: "M16 13.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1-2.5 2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1 2.5-2.5Z"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Spinner.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
function SpinnerIcon(props) {
  return (0, import_jsx_runtime57.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime57.jsx)("path", {
      d: "M3 10a7 7 0 0 1 7-7",
      className: "lb-icon-spinner"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Stop.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
function StopIcon(props) {
  return (0, import_jsx_runtime58.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime58.jsx)("rect", {
      x: 5,
      y: 5,
      width: 10,
      height: 10,
      rx: 1,
      fill: "currentColor"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Strikethrough.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
function StrikethroughIcon(props) {
  return (0, import_jsx_runtime59.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime59.jsx)("path", {
      d: "M15.5 10h-11m4.669 0C7.599 9.44 6.5 8.484 6.5 7.125 6.5 5.537 7.79 4.25 10 4.25c1.654 0 2.793.721 3.261 1.75M6.74 14c.468 1.029 1.607 1.75 3.261 1.75 2 0 3.5-1 3.5-2.5 0-.085-.004-.169-.013-.25"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Text.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
function TextIcon(props) {
  return (0, import_jsx_runtime60.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime60.jsx)("path", {
      d: "M5 6V4.75h10V6m-6.5 9.25h3M10 4.75v10.5"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Translate.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/Underline.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
function UnderlineIcon(props) {
  return (0, import_jsx_runtime62.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime62.jsx)("path", {
      d: "M6.5 4.5V9a3.5 3.5 0 0 0 3.5 3.5v0A3.5 3.5 0 0 0 13.5 9V4.5M15 16H5"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Undo.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
function UndoIcon(props) {
  return (0, import_jsx_runtime63.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime63.jsx)("path", {
        d: "M4 8h8.5a3.5 3.5 0 0 1 3.5 3.5v0a3.5 3.5 0 0 1-3.5 3.5H11"
      }),
      (0, import_jsx_runtime63.jsx)("path", {
        d: "M7 5 4 8l3 3"
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/User.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/icons/Users.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
function UsersIcon(props) {
  return (0, import_jsx_runtime65.jsx)(Icon, {
    ...props,
    children: (0, import_jsx_runtime65.jsx)("path", {
      d: "M8 9.75a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Zm0 0c-2.42 0-4.055 1.72-4.422 4.004-.087.545.37.996.922.996h7c.552 0 1.01-.45.922-.996C12.055 11.47 10.42 9.75 8 9.75ZM15 14.75h.5c.552 0 1.004-.45.912-.995-.317-1.888-1.485-4.114-3.412-4.505.863-.222 1.5-1.068 1.5-2a2 2 0 0 0-2-2"
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/icons/Warning.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
function WarningIcon(props) {
  return (0, import_jsx_runtime66.jsxs)(Icon, {
    ...props,
    children: [
      (0, import_jsx_runtime66.jsx)("path", {
        d: "m3.794 13.526 5.326-9.89a1 1 0 0 1 1.76 0l5.326 9.89a1 1 0 0 1-.88 1.474H4.674a1 1 0 0 1-.88-1.474ZM10 7.5v2m0 2.5h.007"
      }),
      (0, import_jsx_runtime66.jsx)("circle", {
        cx: 10,
        cy: 12,
        r: 0.25
      })
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
var React19 = __toESM(require_react(), 1);

// node_modules/@radix-ui/primitive/dist/index.mjs
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@radix-ui/react-context/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context = React4.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = React4.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime67.jsx)(Context.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React4.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React4.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      var _a3;
      const { scope, children, ...context } = props;
      const Context = ((_a3 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a3[index2]) || BaseContext;
      const value = React4.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime67.jsx)(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a3;
      const Context = ((_a3 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a3[index2]) || BaseContext;
      const context = React4.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext22];
  }
  const createScope2 = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React4.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React4.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope2.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope2, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope2 = () => {
    const scopeHooks = scopes.map((createScope22) => ({
      useScope: createScope22(),
      scopeName: createScope22.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope2 = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope2 };
      }, {});
      return React4.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope2.scopeName = baseScope.scopeName;
  return createScope2;
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React8 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node3) => {
  const Slot6 = createSlot(`Primitive.${node3}`);
  const Node4 = React5.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot6 : node3;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime68.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node4.displayName = `Primitive.${node3}`;
  return { ...primitive, [node3]: Node4 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM2.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React6 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React6.useRef(callback);
  React6.useEffect(() => {
    callbackRef.current = callback;
  });
  return React6.useMemo(() => (...args) => {
    var _a3;
    return (_a3 = callbackRef.current) == null ? void 0 : _a3.call(callbackRef, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React7 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React7.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React8.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React8.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React8.useContext(DismissableLayerContext);
    const [node3, setNode] = React8.useState(null);
    const ownerDocument = (node3 == null ? void 0 : node3.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React8.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node22) => setNode(node22));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node3 ? layers.indexOf(node3) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React8.useEffect(() => {
      if (!node3) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node3);
      }
      context.layers.add(node3);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node3, ownerDocument, disableOutsidePointerEvents, context]);
    React8.useEffect(() => {
      return () => {
        if (!node3) return;
        context.layers.delete(node3);
        context.layersWithOutsidePointerEventsDisabled.delete(node3);
        dispatchUpdate();
      };
    }, [node3, context]);
    React8.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime69.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React8.forwardRef((props, forwardedRef) => {
  const context = React8.useContext(DismissableLayerContext);
  const ref = React8.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React8.useEffect(() => {
    const node3 = ref.current;
    if (node3) {
      context.branches.add(node3);
      return () => {
        context.branches.delete(node3);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime69.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React8.useRef(false);
  const handleClickRef = React8.useRef(() => {
  });
  React8.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React8.useRef(false);
  React8.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var React10 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var useLayoutEffect22 = (globalThis == null ? void 0 : globalThis.document) ? React9.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React10[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React10.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var React13 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow = React11.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime70.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime70.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root = Arrow;

// node_modules/@radix-ui/react-use-size/dist/index.mjs
var React12 = __toESM(require_react(), 1);
function useSize(element) {
  const [size5, setSize] = React12.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size5;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React13.useState(null);
  return (0, import_jsx_runtime71.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React13.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React13.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = React13.useRef(null);
    React13.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = (virtualRef == null ? void 0 : virtualRef.current) || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : (0, import_jsx_runtime71.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React13.forwardRef(
  (props, forwardedRef) => {
    var _a3, _b, _c, _d, _e3, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React13.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node3) => setContent(node3));
    const [arrow4, setArrow] = React13.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a3 = middlewareData.arrow) == null ? void 0 : _a3.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React13.useState();
    useLayoutEffect22(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime71.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e3 = middlewareData.transformOrigin) == null ? void 0 : _e3.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime71.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime71.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React13.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime71.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime71.jsx)(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options2) => ({
  name: "transformOrigin",
  options: options2,
  fn(data) {
    var _a3, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a3 = middlewareData.arrow) == null ? void 0 : _a3.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options2.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options2.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// node_modules/@radix-ui/react-portal/dist/index.mjs
var React14 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React14.forwardRef((props, forwardedRef) => {
  var _a3;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React14.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a3 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a3.body);
  return container ? import_react_dom2.default.createPortal((0, import_jsx_runtime72.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-presence/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var React15 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React15.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node3, setNode] = React22.useState();
  const stylesRef = React22.useRef(null);
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node3) {
      let timeoutId;
      const ownerWindow = node3.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node3 && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node3.style.animationFillMode;
            node3.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node3.style.animationFillMode === "forwards") {
                node3.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node3) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node3.addEventListener("animationstart", handleAnimationStart);
      node3.addEventListener("animationcancel", handleAnimationEnd);
      node3.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node3.removeEventListener("animationstart", handleAnimationStart);
        node3.removeEventListener("animationcancel", handleAnimationEnd);
        node3.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node3, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node22) => {
      stylesRef.current = node22 ? getComputedStyle(node22) : null;
      setNode(node22);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a3, _b;
  let getter = (_a3 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a3.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React17 = __toESM(require_react(), 1);
var React23 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-effect-event/dist/index.mjs
var React16 = __toESM(require_react(), 1);
var useReactEffectEvent = React16[" useEffectEvent ".trim().toString()];
var useReactInsertionEffect = React16[" useInsertionEffect ".trim().toString()];

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var useInsertionEffect = React17[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React17.useRef(prop !== void 0);
    React17.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from2 = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from2} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React17.useCallback(
    (nextValue) => {
      var _a3;
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a3 = onChangeRef.current) == null ? void 0 : _a3.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React17.useState(defaultProp);
  const prevValueRef = React17.useRef(value);
  const onChangeRef = React17.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React17.useEffect(() => {
    var _a3;
    if (prevValueRef.current !== value) {
      (_a3 = onChangeRef.current) == null ? void 0 : _a3.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React18 = __toESM(require_react(), 1);
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME2 = "VisuallyHidden";
var VisuallyHidden = React18.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime73.jsx)(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME2;
var Root3 = VisuallyHidden;

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React19.useRef(true);
  const isPointerInTransitRef = React19.useRef(false);
  const skipDelayTimerRef = React19.useRef(0);
  React19.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return (0, import_jsx_runtime74.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: React19.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: React19.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React19.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger2, setTrigger] = React19.useState(null);
  const contentId = useId();
  const openTimerRef = React19.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React19.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React19.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React19.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React19.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React19.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React19.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return (0, import_jsx_runtime74.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime74.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: React19.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React19.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = React19.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React19.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React19.useRef(false);
    const hasPointerMoveOpenedRef = React19.useRef(false);
    const handlePointerUp = React19.useCallback(() => isPointerDownRef.current = false, []);
    React19.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return (0, import_jsx_runtime74.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime74.jsx)(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME2, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME2, __scopeTooltip);
  return (0, import_jsx_runtime74.jsx)(PortalProvider, { scope: __scopeTooltip, forceMount, children: (0, import_jsx_runtime74.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime74.jsx)(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "TooltipContent";
var TooltipContent = React19.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
    return (0, import_jsx_runtime74.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? (0, import_jsx_runtime74.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime74.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React19.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME2, props.__scopeTooltip);
  const ref = React19.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React19.useState(null);
  const { trigger: trigger2, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React19.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React19.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React19.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React19.useEffect(() => {
    if (trigger2 && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React19.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger2 == null ? void 0 : trigger2.contains(target)) || (content == null ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return (0, import_jsx_runtime74.jsx)(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable2 = createSlottable("TooltipContent");
var TooltipContentImpl = React19.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME2, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React19.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React19.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return (0, import_jsx_runtime74.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: (0, import_jsx_runtime74.jsxs)(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              (0, import_jsx_runtime74.jsx)(Slottable2, { children }),
              (0, import_jsx_runtime74.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: (0, import_jsx_runtime74.jsx)(Root3, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME2;
var ARROW_NAME2 = "TooltipArrow";
var TooltipArrow = React19.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME2,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : (0, import_jsx_runtime74.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME2;
function getExitSideFromRect(point3, rect) {
  const top = Math.abs(rect.top - point3.y);
  const bottom = Math.abs(rect.bottom - point3.y);
  const right = Math.abs(rect.right - point3.x);
  const left = Math.abs(rect.left - point3.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point3, polygon) {
  const { x: x2, y } = point3;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Root32 = Tooltip;
var Trigger = TooltipTrigger;
var Portal2 = TooltipPortal;
var Content2 = TooltipContent;

// node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.js
var import_react21 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/config.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
var LiveblocksUiConfigContext = (0, import_react20.createContext)({});
function useLiveblocksUiConfig() {
  return (0, import_react20.useContext)(LiveblocksUiConfigContext);
}

// node_modules/@liveblocks/react-ui/dist/utils/is-apple.js
var APPLE_REGEX = /Mac|iPod|iPhone|iPad/;
function isApple() {
  return typeof window !== "undefined" && APPLE_REGEX.test(window.navigator.platform);
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.js
var ALT_KEY = { title: "Alt", key: "⌥" };
var COMMAND_KEY = { title: "Command", key: "⌘" };
var CONTROL_KEY = { title: "Ctrl", key: "⌃" };
var SHIFT_KEY = { title: "Shift", key: "⇧" };
var ENTER_KEY = { title: "Enter", key: "⏎" };
var SPACE_KEY = { title: "Space", key: "␣" };
var ESCAPE_KEY = { title: "Escape", key: "⎋" };
var KEYS = {
  alt: () => ALT_KEY,
  mod: () => isApple() ? COMMAND_KEY : CONTROL_KEY,
  control: () => CONTROL_KEY,
  ctrl: () => CONTROL_KEY,
  command: () => COMMAND_KEY,
  cmd: () => COMMAND_KEY,
  shift: () => SHIFT_KEY,
  enter: () => ENTER_KEY,
  " ": () => SPACE_KEY,
  space: () => SPACE_KEY,
  escape: () => ESCAPE_KEY,
  esc: () => ESCAPE_KEY
};
function getShortcutKbdFromKeymap(keymap) {
  const keys = keymap.split("-");
  return (0, import_jsx_runtime76.jsx)(import_jsx_runtime76.Fragment, {
    children: keys.map((key, index2) => {
      const lowerKey = key.toLowerCase();
      if (lowerKey in KEYS) {
        return (0, import_jsx_runtime76.jsx)(ShortcutTooltipKey, {
          name: lowerKey
        }, index2);
      }
      return (0, import_jsx_runtime76.jsx)("span", {
        children: key
      }, index2);
    })
  });
}
var Tooltip2 = (0, import_react21.forwardRef)(
  ({ children, content, multiline, className, ...props }, forwardedRef) => {
    const { portalContainer } = useLiveblocksUiConfig();
    return (0, import_jsx_runtime76.jsxs)(Root32, {
      disableHoverableContent: true,
      children: [
        (0, import_jsx_runtime76.jsx)(Trigger, {
          asChild: true,
          ref: forwardedRef,
          children
        }),
        (0, import_jsx_runtime76.jsx)(Portal2, {
          container: portalContainer,
          children: (0, import_jsx_runtime76.jsx)(Content2, {
            className: cn(
              "lb-root lb-portal lb-tooltip",
              multiline && "lb-tooltip:multiline",
              className
            ),
            side: "top",
            align: "center",
            sideOffset: FLOATING_ELEMENT_SIDE_OFFSET,
            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,
            ...props,
            children: content
          })
        })
      ]
    });
  }
);
var ShortcutTooltip = (0, import_react21.forwardRef)(({ children, content, shortcut, ...props }, forwardedRef) => {
  const shortcutKbd = (0, import_react21.useMemo)(() => {
    return shortcut ? getShortcutKbdFromKeymap(shortcut) : null;
  }, [shortcut]);
  return (0, import_jsx_runtime76.jsx)(Tooltip2, {
    content: (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
      children: [
        content,
        shortcutKbd && (0, import_jsx_runtime76.jsx)("kbd", {
          className: "lb-tooltip-shortcut",
          children: shortcutKbd
        })
      ]
    }),
    ...props,
    ref: forwardedRef,
    children
  });
});
function ShortcutTooltipKey({ name, ...props }) {
  const { title, key } = (0, import_react21.useMemo)(() => {
    var _a3;
    return (_a3 = KEYS[name]) == null ? void 0 : _a3.call(KEYS);
  }, [name]);
  return (0, import_jsx_runtime76.jsx)("abbr", {
    title,
    ...props,
    children: key
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/CodeBlock.js
var COPY_DELAY = 1500;
function CodeBlock({ title, code, overrides }) {
  const $3 = useOverrides(overrides);
  const [isCopied, setCopied] = (0, import_react22.useState)(false);
  const timeoutRef = (0, import_react22.useRef)(null);
  (0, import_react22.useEffect)(() => {
    if (isCopied) {
      timeoutRef.current = setTimeout(() => {
        setCopied(false);
      }, COPY_DELAY);
    }
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [isCopied]);
  const handleCopy = (0, import_react22.useCallback)(() => {
    try {
      navigator.clipboard.writeText(code);
      setCopied(true);
    } catch (error) {
      console.error(error);
    }
  }, [code]);
  return (0, import_jsx_runtime77.jsx)(TooltipProvider, {
    children: (0, import_jsx_runtime77.jsxs)("div", {
      className: "lb-root lb-code-block",
      children: [
        (0, import_jsx_runtime77.jsxs)("div", {
          className: "lb-code-block-header",
          children: [
            (0, import_jsx_runtime77.jsx)("span", {
              className: "lb-code-block-title",
              children: title
            }),
            (0, import_jsx_runtime77.jsx)("div", {
              className: "lb-code-block-header-actions",
              children: (0, import_jsx_runtime77.jsx)(Tooltip2, {
                content: isCopied ? null : $3.COPY_TO_CLIPBOARD,
                children: (0, import_jsx_runtime77.jsx)(Button, {
                  className: "lb-code-block-header-action",
                  icon: isCopied ? (0, import_jsx_runtime77.jsx)(CheckIcon, {}) : (0, import_jsx_runtime77.jsx)(CopyIcon, {}),
                  onClick: handleCopy,
                  "aria-label": $3.COPY_TO_CLIPBOARD
                })
              })
            })
          ]
        }),
        (0, import_jsx_runtime77.jsx)("pre", {
          className: "lb-code-block-content",
          children: (0, import_jsx_runtime77.jsx)("code", {
            children: code
          })
        })
      ]
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Prose.js
function Link({ href, title, children }) {
  const { Anchor: Anchor3 } = useComponents();
  return (0, import_jsx_runtime78.jsx)(Anchor3, {
    href,
    title,
    children
  });
}
function CodeBlock2({ language, code }) {
  return (0, import_jsx_runtime78.jsx)(CodeBlock, {
    title: language || "Plain text",
    code
  });
}
var defaultMarkdownComponents = {
  Link,
  CodeBlock: CodeBlock2
};
function Prose({
  content,
  partial,
  components,
  className,
  ...props
}) {
  return (0, import_jsx_runtime78.jsx)(ComponentsProvider, {
    components,
    children: (0, import_jsx_runtime78.jsx)(Markdown, {
      content,
      components: { ...defaultMarkdownComponents, ...components == null ? void 0 : components.markdown },
      className: cn("lb-root lb-prose", className),
      partial,
      ...props
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/User.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/shared.js
function useCurrentUserId() {
  const client = useClient();
  return useSignal(client[kInternal].currentUserId) ?? null;
}

// node_modules/@liveblocks/react-ui/dist/components/internal/User.js
function User({
  userId,
  replaceSelf,
  className,
  children,
  ...props
}) {
  const currentId = useCurrentUserId();
  const { user, isLoading } = _useUser(userId);
  const $3 = useOverrides();
  const resolvedUserName = (0, import_react25.useMemo)(() => {
    return replaceSelf && currentId === userId ? $3.USER_SELF : (user == null ? void 0 : user.name) ?? $3.USER_UNKNOWN;
  }, [replaceSelf, currentId, userId, $3.USER_SELF, $3.USER_UNKNOWN, user == null ? void 0 : user.name]);
  return (0, import_jsx_runtime79.jsxs)("span", {
    className: cn("lb-name lb-user", className),
    "data-loading": isLoading ? "" : void 0,
    ...props,
    children: [
      isLoading ? null : resolvedUserName,
      children
    ]
  });
}

// node_modules/@liveblocks/react-ui/dist/utils/capitalize.js
function capitalize(string3) {
  return string3.charAt(0).toUpperCase() + string3.slice(1);
}

// node_modules/@liveblocks/react-ui/dist/utils/use-refs.js
var import_react26 = __toESM(require_react(), 1);
function applyRef(ref, value) {
  if (value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref && "current" in ref) {
      ref.current = value;
    }
  }
}
function mergeRefs(value, ...refs) {
  for (const ref of refs) {
    applyRef(ref, value);
  }
}
function useRefs(...refs) {
  return (0, import_react26.useCallback)((value) => mergeRefs(value, ...refs), refs);
}

// node_modules/@liveblocks/react-ui/dist/primitives/AiComposer/index.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o3) {
  return Object.prototype.toString.call(o3) === "[object Object]";
}
function isPlainObject(o3) {
  var ctor, prot;
  if (isObject(o3) === false) return false;
  ctor = o3.constructor;
  if (ctor === void 0) return true;
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = true ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (true) {
    const e3 = errors[error];
    const msg2 = typeof e3 === "function" ? e3.apply(null, args) : e3;
    throw new Error(`[Immer] ${msg2}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a3;
  if (!value)
    return false;
  return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a3 = value.constructor) == null ? void 0 : _a3[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index2) => iter(index2, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t3 = getArchtype(thing);
  if (t3 === 2)
    thing.set(propOrOldValue, value);
  else if (t3 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x2, y) {
  if (x2 === y) {
    return x2 !== 0 || 1 / x2 === 1 / y;
  } else {
    return x2 !== x2 && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject2(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: { value: dontMutateFrozenCollections },
      add: { value: dontMutateFrozenCollections },
      clear: { value: dontMutateFrozenCollections },
      delete: { value: dontMutateFrozenCollections }
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path3) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path3)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path3, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path3 && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path3,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path3 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path3);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent3) {
  const isArray2 = Array.isArray(base);
  const state = {
    type_: isArray2 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent3 ? parent3.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent3,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray2) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a3;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a3 = desc.get) == null ? void 0 : _a3.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p2 = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
          patchListener(p2, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p2, ip) => {
        patches = p2;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent3) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent3) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent3) : createProxyProxy(value, parent3);
  const scope = parent3 ? parent3.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(
  immer
);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(
  immer
);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);

// node_modules/slate/dist/index.es.js
var PathRef = {
  transform(ref, op) {
    var {
      current: current2,
      affinity
    } = ref;
    if (current2 == null) {
      return;
    }
    var path3 = Path.transform(current2, op, {
      affinity
    });
    ref.current = path3;
    if (path3 == null) {
      ref.unref();
    }
  }
};
var PointRef = {
  transform(ref, op) {
    var {
      current: current2,
      affinity
    } = ref;
    if (current2 == null) {
      return;
    }
    var point3 = Point.transform(current2, op, {
      affinity
    });
    ref.current = point3;
    if (point3 == null) {
      ref.unref();
    }
  }
};
var RangeRef = {
  transform(ref, op) {
    var {
      current: current2,
      affinity
    } = ref;
    if (current2 == null) {
      return;
    }
    var path3 = Range.transform(current2, op, {
      affinity
    });
    ref.current = path3;
    if (path3 == null) {
      ref.unref();
    }
  }
};
var DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
var DIRTY_PATH_KEYS = /* @__PURE__ */ new WeakMap();
var FLUSHING = /* @__PURE__ */ new WeakMap();
var NORMALIZING = /* @__PURE__ */ new WeakMap();
var PATH_REFS = /* @__PURE__ */ new WeakMap();
var POINT_REFS = /* @__PURE__ */ new WeakMap();
var RANGE_REFS = /* @__PURE__ */ new WeakMap();
var Path = {
  ancestors(path3) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options2;
    var paths = Path.levels(path3, options2);
    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }
    return paths;
  },
  common(path3, another) {
    var common = [];
    for (var i = 0; i < path3.length && i < another.length; i++) {
      var av = path3[i];
      var bv = another[i];
      if (av !== bv) {
        break;
      }
      common.push(av);
    }
    return common;
  },
  compare(path3, another) {
    var min2 = Math.min(path3.length, another.length);
    for (var i = 0; i < min2; i++) {
      if (path3[i] < another[i]) return -1;
      if (path3[i] > another[i]) return 1;
    }
    return 0;
  },
  endsAfter(path3, another) {
    var i = path3.length - 1;
    var as = path3.slice(0, i);
    var bs = another.slice(0, i);
    var av = path3[i];
    var bv = another[i];
    return Path.equals(as, bs) && av > bv;
  },
  endsAt(path3, another) {
    var i = path3.length;
    var as = path3.slice(0, i);
    var bs = another.slice(0, i);
    return Path.equals(as, bs);
  },
  endsBefore(path3, another) {
    var i = path3.length - 1;
    var as = path3.slice(0, i);
    var bs = another.slice(0, i);
    var av = path3[i];
    var bv = another[i];
    return Path.equals(as, bs) && av < bv;
  },
  equals(path3, another) {
    return path3.length === another.length && path3.every((n3, i) => n3 === another[i]);
  },
  hasPrevious(path3) {
    return path3[path3.length - 1] > 0;
  },
  isAfter(path3, another) {
    return Path.compare(path3, another) === 1;
  },
  isAncestor(path3, another) {
    return path3.length < another.length && Path.compare(path3, another) === 0;
  },
  isBefore(path3, another) {
    return Path.compare(path3, another) === -1;
  },
  isChild(path3, another) {
    return path3.length === another.length + 1 && Path.compare(path3, another) === 0;
  },
  isCommon(path3, another) {
    return path3.length <= another.length && Path.compare(path3, another) === 0;
  },
  isDescendant(path3, another) {
    return path3.length > another.length && Path.compare(path3, another) === 0;
  },
  isParent(path3, another) {
    return path3.length + 1 === another.length && Path.compare(path3, another) === 0;
  },
  isPath(value) {
    return Array.isArray(value) && (value.length === 0 || typeof value[0] === "number");
  },
  isSibling(path3, another) {
    if (path3.length !== another.length) {
      return false;
    }
    var as = path3.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path3[path3.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },
  levels(path3) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options2;
    var list2 = [];
    for (var i = 0; i <= path3.length; i++) {
      list2.push(path3.slice(0, i));
    }
    if (reverse) {
      list2.reverse();
    }
    return list2;
  },
  next(path3) {
    if (path3.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path3, "], because it has no next index."));
    }
    var last2 = path3[path3.length - 1];
    return path3.slice(0, -1).concat(last2 + 1);
  },
  operationCanTransformPath(operation) {
    switch (operation.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return true;
      default:
        return false;
    }
  },
  parent(path3) {
    if (path3.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path3, "]."));
    }
    return path3.slice(0, -1);
  },
  previous(path3) {
    if (path3.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path3, "], because it has no previous index."));
    }
    var last2 = path3[path3.length - 1];
    if (last2 <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path3, "] because it would result in a negative index."));
    }
    return path3.slice(0, -1).concat(last2 - 1);
  },
  relative(path3, ancestor) {
    if (!Path.isAncestor(ancestor, path3) && !Path.equals(path3, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path3, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }
    return path3.slice(ancestor.length);
  },
  transform(path3, operation) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!path3) return null;
    var p2 = [...path3];
    var {
      affinity = "forward"
    } = options2;
    if (path3.length === 0) {
      return p2;
    }
    switch (operation.type) {
      case "insert_node": {
        var {
          path: op
        } = operation;
        if (Path.equals(op, p2) || Path.endsBefore(op, p2) || Path.isAncestor(op, p2)) {
          p2[op.length - 1] += 1;
        }
        break;
      }
      case "remove_node": {
        var {
          path: _op
        } = operation;
        if (Path.equals(_op, p2) || Path.isAncestor(_op, p2)) {
          return null;
        } else if (Path.endsBefore(_op, p2)) {
          p2[_op.length - 1] -= 1;
        }
        break;
      }
      case "merge_node": {
        var {
          path: _op2,
          position
        } = operation;
        if (Path.equals(_op2, p2) || Path.endsBefore(_op2, p2)) {
          p2[_op2.length - 1] -= 1;
        } else if (Path.isAncestor(_op2, p2)) {
          p2[_op2.length - 1] -= 1;
          p2[_op2.length] += position;
        }
        break;
      }
      case "split_node": {
        var {
          path: _op3,
          position: _position
        } = operation;
        if (Path.equals(_op3, p2)) {
          if (affinity === "forward") {
            p2[p2.length - 1] += 1;
          } else if (affinity === "backward") ;
          else {
            return null;
          }
        } else if (Path.endsBefore(_op3, p2)) {
          p2[_op3.length - 1] += 1;
        } else if (Path.isAncestor(_op3, p2) && path3[_op3.length] >= _position) {
          p2[_op3.length - 1] += 1;
          p2[_op3.length] -= _position;
        }
        break;
      }
      case "move_node": {
        var {
          path: _op4,
          newPath: onp
        } = operation;
        if (Path.equals(_op4, onp)) {
          return p2;
        }
        if (Path.isAncestor(_op4, p2) || Path.equals(_op4, p2)) {
          var copy = onp.slice();
          if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
            copy[_op4.length - 1] -= 1;
          }
          return copy.concat(p2.slice(_op4.length));
        } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p2) || Path.equals(onp, p2))) {
          if (Path.endsBefore(_op4, p2)) {
            p2[_op4.length - 1] -= 1;
          } else {
            p2[_op4.length - 1] += 1;
          }
        } else if (Path.endsBefore(onp, p2) || Path.equals(onp, p2) || Path.isAncestor(onp, p2)) {
          if (Path.endsBefore(_op4, p2)) {
            p2[_op4.length - 1] -= 1;
          }
          p2[onp.length - 1] += 1;
        } else if (Path.endsBefore(_op4, p2)) {
          if (Path.equals(onp, p2)) {
            p2[onp.length - 1] += 1;
          }
          p2[_op4.length - 1] -= 1;
        }
        break;
      }
    }
    return p2;
  }
};
function _typeof(o3) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof(o3);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$e(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$e(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$e(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$e(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var applyToDraft = (editor, selection, op) => {
  switch (op.type) {
    case "insert_node": {
      var {
        path: path3,
        node: node3
      } = op;
      var parent3 = Node3.parent(editor, path3);
      var index2 = path3[path3.length - 1];
      if (index2 > parent3.children.length) {
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path3, "] because the destination is past the end of the node."));
      }
      parent3.children.splice(index2, 0, node3);
      if (selection) {
        for (var [point3, key] of Range.points(selection)) {
          selection[key] = Point.transform(point3, op);
        }
      }
      break;
    }
    case "insert_text": {
      var {
        path: _path,
        offset: offset4,
        text
      } = op;
      if (text.length === 0) break;
      var _node = Node3.leaf(editor, _path);
      var before3 = _node.text.slice(0, offset4);
      var after3 = _node.text.slice(offset4);
      _node.text = before3 + text + after3;
      if (selection) {
        for (var [_point, _key] of Range.points(selection)) {
          selection[_key] = Point.transform(_point, op);
        }
      }
      break;
    }
    case "merge_node": {
      var {
        path: _path2
      } = op;
      var _node2 = Node3.get(editor, _path2);
      var prevPath = Path.previous(_path2);
      var prev = Node3.get(editor, prevPath);
      var _parent = Node3.parent(editor, _path2);
      var _index = _path2[_path2.length - 1];
      if (Text.isText(_node2) && Text.isText(prev)) {
        prev.text += _node2.text;
      } else if (!Text.isText(_node2) && !Text.isText(prev)) {
        prev.children.push(..._node2.children);
      } else {
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev)));
      }
      _parent.children.splice(_index, 1);
      if (selection) {
        for (var [_point2, _key2] of Range.points(selection)) {
          selection[_key2] = Point.transform(_point2, op);
        }
      }
      break;
    }
    case "move_node": {
      var {
        path: _path3,
        newPath
      } = op;
      if (Path.isAncestor(_path3, newPath)) {
        throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
      }
      var _node3 = Node3.get(editor, _path3);
      var _parent2 = Node3.parent(editor, _path3);
      var _index2 = _path3[_path3.length - 1];
      _parent2.children.splice(_index2, 1);
      var truePath = Path.transform(_path3, op);
      var newParent = Node3.get(editor, Path.parent(truePath));
      var newIndex = truePath[truePath.length - 1];
      newParent.children.splice(newIndex, 0, _node3);
      if (selection) {
        for (var [_point3, _key3] of Range.points(selection)) {
          selection[_key3] = Point.transform(_point3, op);
        }
      }
      break;
    }
    case "remove_node": {
      var {
        path: _path4
      } = op;
      var _index3 = _path4[_path4.length - 1];
      var _parent3 = Node3.parent(editor, _path4);
      _parent3.children.splice(_index3, 1);
      if (selection) {
        for (var [_point4, _key4] of Range.points(selection)) {
          var result = Point.transform(_point4, op);
          if (selection != null && result != null) {
            selection[_key4] = result;
          } else {
            var _prev = void 0;
            var next3 = void 0;
            for (var [n3, p2] of Node3.texts(editor)) {
              if (Path.compare(p2, _path4) === -1) {
                _prev = [n3, p2];
              } else {
                next3 = [n3, p2];
                break;
              }
            }
            var preferNext = false;
            if (_prev && next3) {
              if (Path.equals(next3[1], _path4)) {
                preferNext = !Path.hasPrevious(next3[1]);
              } else {
                preferNext = Path.common(_prev[1], _path4).length < Path.common(next3[1], _path4).length;
              }
            }
            if (_prev && !preferNext) {
              _point4.path = _prev[1];
              _point4.offset = _prev[0].text.length;
            } else if (next3) {
              _point4.path = next3[1];
              _point4.offset = 0;
            } else {
              selection = null;
            }
          }
        }
      }
      break;
    }
    case "remove_text": {
      var {
        path: _path5,
        offset: _offset,
        text: _text
      } = op;
      if (_text.length === 0) break;
      var _node4 = Node3.leaf(editor, _path5);
      var _before = _node4.text.slice(0, _offset);
      var _after = _node4.text.slice(_offset + _text.length);
      _node4.text = _before + _after;
      if (selection) {
        for (var [_point5, _key5] of Range.points(selection)) {
          selection[_key5] = Point.transform(_point5, op);
        }
      }
      break;
    }
    case "set_node": {
      var {
        path: _path6,
        properties,
        newProperties
      } = op;
      if (_path6.length === 0) {
        throw new Error("Cannot set properties on the root node!");
      }
      var _node5 = Node3.get(editor, _path6);
      for (var _key6 in newProperties) {
        if (_key6 === "children" || _key6 === "text") {
          throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
        }
        var value = newProperties[_key6];
        if (value == null) {
          delete _node5[_key6];
        } else {
          _node5[_key6] = value;
        }
      }
      for (var _key7 in properties) {
        if (!newProperties.hasOwnProperty(_key7)) {
          delete _node5[_key7];
        }
      }
      break;
    }
    case "set_selection": {
      var {
        newProperties: _newProperties
      } = op;
      if (_newProperties == null) {
        selection = _newProperties;
      } else {
        if (selection == null) {
          if (!Range.isRange(_newProperties)) {
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
          }
          selection = _objectSpread$e({}, _newProperties);
        }
        for (var _key8 in _newProperties) {
          var _value = _newProperties[_key8];
          if (_value == null) {
            if (_key8 === "anchor" || _key8 === "focus") {
              throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
            }
            delete selection[_key8];
          } else {
            selection[_key8] = _value;
          }
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: _path7,
        position,
        properties: _properties
      } = op;
      if (_path7.length === 0) {
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
      }
      var _node6 = Node3.get(editor, _path7);
      var _parent4 = Node3.parent(editor, _path7);
      var _index4 = _path7[_path7.length - 1];
      var newNode;
      if (Text.isText(_node6)) {
        var _before2 = _node6.text.slice(0, position);
        var _after2 = _node6.text.slice(position);
        _node6.text = _before2;
        newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
          text: _after2
        });
      } else {
        var _before3 = _node6.children.slice(0, position);
        var _after3 = _node6.children.slice(position);
        _node6.children = _before3;
        newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
          children: _after3
        });
      }
      _parent4.children.splice(_index4 + 1, 0, newNode);
      if (selection) {
        for (var [_point6, _key9] of Range.points(selection)) {
          selection[_key9] = Point.transform(_point6, op);
        }
      }
      break;
    }
  }
  return selection;
};
var GeneralTransforms = {
  transform(editor, op) {
    editor.children = createDraft(editor.children);
    var selection = editor.selection && createDraft(editor.selection);
    try {
      selection = applyToDraft(editor, selection, op);
    } finally {
      editor.children = finishDraft(editor.children);
      if (selection) {
        editor.selection = isDraft(selection) ? finishDraft(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }
};
var NodeTransforms = {
  insertNodes(editor, nodes2, options2) {
    editor.insertNodes(nodes2, options2);
  },
  liftNodes(editor, options2) {
    editor.liftNodes(options2);
  },
  mergeNodes(editor, options2) {
    editor.mergeNodes(options2);
  },
  moveNodes(editor, options2) {
    editor.moveNodes(options2);
  },
  removeNodes(editor, options2) {
    editor.removeNodes(options2);
  },
  setNodes(editor, props, options2) {
    editor.setNodes(props, options2);
  },
  splitNodes(editor, options2) {
    editor.splitNodes(options2);
  },
  unsetNodes(editor, props, options2) {
    editor.unsetNodes(props, options2);
  },
  unwrapNodes(editor, options2) {
    editor.unwrapNodes(options2);
  },
  wrapNodes(editor, element, options2) {
    editor.wrapNodes(element, options2);
  }
};
var SelectionTransforms = {
  collapse(editor, options2) {
    editor.collapse(options2);
  },
  deselect(editor) {
    editor.deselect();
  },
  move(editor, options2) {
    editor.move(options2);
  },
  select(editor, target) {
    editor.select(target);
  },
  setPoint(editor, props, options2) {
    editor.setPoint(props, options2);
  },
  setSelection(editor, props) {
    editor.setSelection(props);
  }
};
var isDeepEqual = (node3, another) => {
  for (var key in node3) {
    var a = node3[key];
    var b = another[key];
    if (isPlainObject(a) && isPlainObject(b)) {
      if (!isDeepEqual(a, b)) return false;
    } else if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
    } else if (a !== b) {
      return false;
    }
  }
  for (var _key in another) {
    if (node3[_key] === void 0 && another[_key] !== void 0) {
      return false;
    }
  }
  return true;
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var _excluded$4 = ["anchor", "focus"];
function ownKeys$d(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$d(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$d(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$d(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var Range = {
  edges(range2) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options2;
    var {
      anchor,
      focus: focus3
    } = range2;
    return Range.isBackward(range2) === reverse ? [anchor, focus3] : [focus3, anchor];
  },
  end(range2) {
    var [, end2] = Range.edges(range2);
    return end2;
  },
  equals(range2, another) {
    return Point.equals(range2.anchor, another.anchor) && Point.equals(range2.focus, another.focus);
  },
  surrounds(range2, target) {
    var intersectionRange = Range.intersection(range2, target);
    if (!intersectionRange) {
      return false;
    }
    return Range.equals(intersectionRange, target);
  },
  includes(range2, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range2, target.anchor) || Range.includes(range2, target.focus)) {
        return true;
      }
      var [rs, re2] = Range.edges(range2);
      var [ts, te2] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re2, te2);
    }
    var [start2, end2] = Range.edges(range2);
    var isAfterStart = false;
    var isBeforeEnd = false;
    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start2) >= 0;
      isBeforeEnd = Point.compare(target, end2) <= 0;
    } else {
      isAfterStart = Path.compare(target, start2.path) >= 0;
      isBeforeEnd = Path.compare(target, end2.path) <= 0;
    }
    return isAfterStart && isBeforeEnd;
  },
  intersection(range2, another) {
    var rest = _objectWithoutProperties(range2, _excluded$4);
    var [s1, e1] = Range.edges(range2);
    var [s2, e22] = Range.edges(another);
    var start2 = Point.isBefore(s1, s2) ? s2 : s1;
    var end2 = Point.isBefore(e1, e22) ? e1 : e22;
    if (Point.isBefore(end2, start2)) {
      return null;
    } else {
      return _objectSpread$d({
        anchor: start2,
        focus: end2
      }, rest);
    }
  },
  isBackward(range2) {
    var {
      anchor,
      focus: focus3
    } = range2;
    return Point.isAfter(anchor, focus3);
  },
  isCollapsed(range2) {
    var {
      anchor,
      focus: focus3
    } = range2;
    return Point.equals(anchor, focus3);
  },
  isExpanded(range2) {
    return !Range.isCollapsed(range2);
  },
  isForward(range2) {
    return !Range.isBackward(range2);
  },
  isRange(value) {
    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
  },
  *points(range2) {
    yield [range2.anchor, "anchor"];
    yield [range2.focus, "focus"];
  },
  start(range2) {
    var [start2] = Range.edges(range2);
    return start2;
  },
  transform(range2, op) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return produce(range2, (r2) => {
      if (r2 === null) {
        return null;
      }
      var {
        affinity = "inward"
      } = options2;
      var affinityAnchor;
      var affinityFocus;
      if (affinity === "inward") {
        var isCollapsed = Range.isCollapsed(r2);
        if (Range.isForward(r2)) {
          affinityAnchor = "forward";
          affinityFocus = isCollapsed ? affinityAnchor : "backward";
        } else {
          affinityAnchor = "backward";
          affinityFocus = isCollapsed ? affinityAnchor : "forward";
        }
      } else if (affinity === "outward") {
        if (Range.isForward(r2)) {
          affinityAnchor = "backward";
          affinityFocus = "forward";
        } else {
          affinityAnchor = "forward";
          affinityFocus = "backward";
        }
      } else {
        affinityAnchor = affinity;
        affinityFocus = affinity;
      }
      var anchor = Point.transform(r2.anchor, op, {
        affinity: affinityAnchor
      });
      var focus3 = Point.transform(r2.focus, op, {
        affinity: affinityFocus
      });
      if (!anchor || !focus3) {
        return null;
      }
      r2.anchor = anchor;
      r2.focus = focus3;
    });
  }
};
var isElement2 = (value) => {
  return isPlainObject(value) && Node3.isNodeList(value.children) && !Editor.isEditor(value);
};
var Element2 = {
  isAncestor(value) {
    return isPlainObject(value) && Node3.isNodeList(value.children);
  },
  isElement: isElement2,
  isElementList(value) {
    return Array.isArray(value) && value.every((val) => Element2.isElement(val));
  },
  isElementProps(props) {
    return props.children !== void 0;
  },
  isElementType: function isElementType(value, elementVal) {
    var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return isElement2(value) && value[elementKey] === elementVal;
  },
  matches(element, props) {
    for (var key in props) {
      if (key === "children") {
        continue;
      }
      if (element[key] !== props[key]) {
        return false;
      }
    }
    return true;
  }
};
var _excluded$3 = ["children"];
var _excluded2$3 = ["text"];
var IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
var Node3 = {
  ancestor(root, path3) {
    var node3 = Node3.get(root, path3);
    if (Text.isText(node3)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path3, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node3)));
    }
    return node3;
  },
  ancestors(root, path3) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return (function* () {
      for (var p2 of Path.ancestors(path3, options2)) {
        var n3 = Node3.ancestor(root, p2);
        var entry = [n3, p2];
        yield entry;
      }
    })();
  },
  child(root, index2) {
    if (Text.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
    }
    var c = root.children[index2];
    if (c == null) {
      throw new Error("Cannot get child at index `".concat(index2, "` in node: ").concat(Scrubber.stringify(root)));
    }
    return c;
  },
  children(root, path3) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return (function* () {
      var {
        reverse = false
      } = options2;
      var ancestor = Node3.ancestor(root, path3);
      var {
        children
      } = ancestor;
      var index2 = reverse ? children.length - 1 : 0;
      while (reverse ? index2 >= 0 : index2 < children.length) {
        var child = Node3.child(ancestor, index2);
        var childPath = path3.concat(index2);
        yield [child, childPath];
        index2 = reverse ? index2 - 1 : index2 + 1;
      }
    })();
  },
  common(root, path3, another) {
    var p2 = Path.common(path3, another);
    var n3 = Node3.get(root, p2);
    return [n3, p2];
  },
  descendant(root, path3) {
    var node3 = Node3.get(root, path3);
    if (Editor.isEditor(node3)) {
      throw new Error("Cannot get the descendant node at path [".concat(path3, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node3)));
    }
    return node3;
  },
  descendants(root) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return (function* () {
      for (var [node3, path3] of Node3.nodes(root, options2)) {
        if (path3.length !== 0) {
          yield [node3, path3];
        }
      }
    })();
  },
  elements(root) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return (function* () {
      for (var [node3, path3] of Node3.nodes(root, options2)) {
        if (Element2.isElement(node3)) {
          yield [node3, path3];
        }
      }
    })();
  },
  extractProps(node3) {
    if (Element2.isAncestor(node3)) {
      var properties = _objectWithoutProperties(node3, _excluded$3);
      return properties;
    } else {
      var properties = _objectWithoutProperties(node3, _excluded2$3);
      return properties;
    }
  },
  first(root, path3) {
    var p2 = path3.slice();
    var n3 = Node3.get(root, p2);
    while (n3) {
      if (Text.isText(n3) || n3.children.length === 0) {
        break;
      } else {
        n3 = n3.children[0];
        p2.push(0);
      }
    }
    return [n3, p2];
  },
  fragment(root, range2) {
    if (Text.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
    }
    var newRoot = produce({
      children: root.children
    }, (r2) => {
      var [start2, end2] = Range.edges(range2);
      var nodeEntries = Node3.nodes(r2, {
        reverse: true,
        pass: (_ref) => {
          var [, path4] = _ref;
          return !Range.includes(range2, path4);
        }
      });
      for (var [, path3] of nodeEntries) {
        if (!Range.includes(range2, path3)) {
          var parent3 = Node3.parent(r2, path3);
          var index2 = path3[path3.length - 1];
          parent3.children.splice(index2, 1);
        }
        if (Path.equals(path3, end2.path)) {
          var leaf3 = Node3.leaf(r2, path3);
          leaf3.text = leaf3.text.slice(0, end2.offset);
        }
        if (Path.equals(path3, start2.path)) {
          var _leaf = Node3.leaf(r2, path3);
          _leaf.text = _leaf.text.slice(start2.offset);
        }
      }
      if (Editor.isEditor(r2)) {
        r2.selection = null;
      }
    });
    return newRoot.children;
  },
  get(root, path3) {
    var node3 = Node3.getIf(root, path3);
    if (node3 === void 0) {
      throw new Error("Cannot find a descendant at path [".concat(path3, "] in node: ").concat(Scrubber.stringify(root)));
    }
    return node3;
  },
  getIf(root, path3) {
    var node3 = root;
    for (var i = 0; i < path3.length; i++) {
      var p2 = path3[i];
      if (Text.isText(node3) || !node3.children[p2]) {
        return;
      }
      node3 = node3.children[p2];
    }
    return node3;
  },
  has(root, path3) {
    var node3 = root;
    for (var i = 0; i < path3.length; i++) {
      var p2 = path3[i];
      if (Text.isText(node3) || !node3.children[p2]) {
        return false;
      }
      node3 = node3.children[p2];
    }
    return true;
  },
  isNode(value) {
    return Text.isText(value) || Element2.isElement(value) || Editor.isEditor(value);
  },
  isNodeList(value) {
    if (!Array.isArray(value)) {
      return false;
    }
    var cachedResult = IS_NODE_LIST_CACHE.get(value);
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    var isNodeList = value.every((val) => Node3.isNode(val));
    IS_NODE_LIST_CACHE.set(value, isNodeList);
    return isNodeList;
  },
  last(root, path3) {
    var p2 = path3.slice();
    var n3 = Node3.get(root, p2);
    while (n3) {
      if (Text.isText(n3) || n3.children.length === 0) {
        break;
      } else {
        var i = n3.children.length - 1;
        n3 = n3.children[i];
        p2.push(i);
      }
    }
    return [n3, p2];
  },
  leaf(root, path3) {
    var node3 = Node3.get(root, path3);
    if (!Text.isText(node3)) {
      throw new Error("Cannot get the leaf node at path [".concat(path3, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node3)));
    }
    return node3;
  },
  levels(root, path3) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return (function* () {
      for (var p2 of Path.levels(path3, options2)) {
        var n3 = Node3.get(root, p2);
        yield [n3, p2];
      }
    })();
  },
  matches(node3, props) {
    return Element2.isElement(node3) && Element2.isElementProps(props) && Element2.matches(node3, props) || Text.isText(node3) && Text.isTextProps(props) && Text.matches(node3, props);
  },
  nodes(root) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return (function* () {
      var {
        pass,
        reverse = false
      } = options2;
      var {
        from: from2 = [],
        to
      } = options2;
      var visited = /* @__PURE__ */ new Set();
      var p2 = [];
      var n3 = root;
      while (true) {
        if (to && (reverse ? Path.isBefore(p2, to) : Path.isAfter(p2, to))) {
          break;
        }
        if (!visited.has(n3)) {
          yield [n3, p2];
        }
        if (!visited.has(n3) && !Text.isText(n3) && n3.children.length !== 0 && (pass == null || pass([n3, p2]) === false)) {
          visited.add(n3);
          var nextIndex = reverse ? n3.children.length - 1 : 0;
          if (Path.isAncestor(p2, from2)) {
            nextIndex = from2[p2.length];
          }
          p2 = p2.concat(nextIndex);
          n3 = Node3.get(root, p2);
          continue;
        }
        if (p2.length === 0) {
          break;
        }
        if (!reverse) {
          var newPath = Path.next(p2);
          if (Node3.has(root, newPath)) {
            p2 = newPath;
            n3 = Node3.get(root, p2);
            continue;
          }
        }
        if (reverse && p2[p2.length - 1] !== 0) {
          var _newPath = Path.previous(p2);
          p2 = _newPath;
          n3 = Node3.get(root, p2);
          continue;
        }
        p2 = Path.parent(p2);
        n3 = Node3.get(root, p2);
        visited.add(n3);
      }
    })();
  },
  parent(root, path3) {
    var parentPath = Path.parent(path3);
    var p2 = Node3.get(root, parentPath);
    if (Text.isText(p2)) {
      throw new Error("Cannot get the parent of path [".concat(path3, "] because it does not exist in the root."));
    }
    return p2;
  },
  string(node3) {
    if (Text.isText(node3)) {
      return node3.text;
    } else {
      return node3.children.map(Node3.string).join("");
    }
  },
  texts(root) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return (function* () {
      for (var [node3, path3] of Node3.nodes(root, options2)) {
        if (Text.isText(node3)) {
          yield [node3, path3];
        }
      }
    })();
  }
};
function ownKeys$c(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$c(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$c(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$c(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var Operation = {
  isNodeOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_node");
  },
  isOperation(value) {
    if (!isPlainObject(value)) {
      return false;
    }
    switch (value.type) {
      case "insert_node":
        return Path.isPath(value.path) && Node3.isNode(value.node);
      case "insert_text":
        return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
      case "merge_node":
        return typeof value.position === "number" && Path.isPath(value.path) && isPlainObject(value.properties);
      case "move_node":
        return Path.isPath(value.path) && Path.isPath(value.newPath);
      case "remove_node":
        return Path.isPath(value.path) && Node3.isNode(value.node);
      case "remove_text":
        return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
      case "set_node":
        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);
      case "set_selection":
        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);
      case "split_node":
        return Path.isPath(value.path) && typeof value.position === "number" && isPlainObject(value.properties);
      default:
        return false;
    }
  },
  isOperationList(value) {
    return Array.isArray(value) && value.every((val) => Operation.isOperation(val));
  },
  isSelectionOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_selection");
  },
  isTextOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_text");
  },
  inverse(op) {
    switch (op.type) {
      case "insert_node": {
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          type: "remove_node"
        });
      }
      case "insert_text": {
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          type: "remove_text"
        });
      }
      case "merge_node": {
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          type: "split_node",
          path: Path.previous(op.path)
        });
      }
      case "move_node": {
        var {
          newPath,
          path: path3
        } = op;
        if (Path.equals(newPath, path3)) {
          return op;
        }
        if (Path.isSibling(path3, newPath)) {
          return _objectSpread$c(_objectSpread$c({}, op), {}, {
            path: newPath,
            newPath: path3
          });
        }
        var inversePath = Path.transform(path3, op);
        var inverseNewPath = Path.transform(Path.next(path3), op);
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          path: inversePath,
          newPath: inverseNewPath
        });
      }
      case "remove_node": {
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          type: "insert_node"
        });
      }
      case "remove_text": {
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          type: "insert_text"
        });
      }
      case "set_node": {
        var {
          properties,
          newProperties
        } = op;
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          properties: newProperties,
          newProperties: properties
        });
      }
      case "set_selection": {
        var {
          properties: _properties,
          newProperties: _newProperties
        } = op;
        if (_properties == null) {
          return _objectSpread$c(_objectSpread$c({}, op), {}, {
            properties: _newProperties,
            newProperties: null
          });
        } else if (_newProperties == null) {
          return _objectSpread$c(_objectSpread$c({}, op), {}, {
            properties: null,
            newProperties: _properties
          });
        } else {
          return _objectSpread$c(_objectSpread$c({}, op), {}, {
            properties: _newProperties,
            newProperties: _properties
          });
        }
      }
      case "split_node": {
        return _objectSpread$c(_objectSpread$c({}, op), {}, {
          type: "merge_node",
          path: Path.next(op.path)
        });
      }
    }
  }
};
var IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
var isEditor = (value) => {
  var cachedIsEditor = IS_EDITOR_CACHE.get(value);
  if (cachedIsEditor !== void 0) {
    return cachedIsEditor;
  }
  if (!isPlainObject(value)) {
    return false;
  }
  var isEditor2 = typeof value.addMark === "function" && typeof value.apply === "function" && typeof value.deleteFragment === "function" && typeof value.insertBreak === "function" && typeof value.insertSoftBreak === "function" && typeof value.insertFragment === "function" && typeof value.insertNode === "function" && typeof value.insertText === "function" && typeof value.isElementReadOnly === "function" && typeof value.isInline === "function" && typeof value.isSelectable === "function" && typeof value.isVoid === "function" && typeof value.normalizeNode === "function" && typeof value.onChange === "function" && typeof value.removeMark === "function" && typeof value.getDirtyPaths === "function" && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node3.isNodeList(value.children) && Operation.isOperationList(value.operations);
  IS_EDITOR_CACHE.set(value, isEditor2);
  return isEditor2;
};
var Editor = {
  above(editor, options2) {
    return editor.above(options2);
  },
  addMark(editor, key, value) {
    editor.addMark(key, value);
  },
  after(editor, at2, options2) {
    return editor.after(at2, options2);
  },
  before(editor, at2, options2) {
    return editor.before(at2, options2);
  },
  deleteBackward(editor) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options2;
    editor.deleteBackward(unit);
  },
  deleteForward(editor) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options2;
    editor.deleteForward(unit);
  },
  deleteFragment(editor, options2) {
    editor.deleteFragment(options2);
  },
  edges(editor, at2) {
    return editor.edges(at2);
  },
  elementReadOnly(editor) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return editor.elementReadOnly(options2);
  },
  end(editor, at2) {
    return editor.end(at2);
  },
  first(editor, at2) {
    return editor.first(at2);
  },
  fragment(editor, at2) {
    return editor.fragment(at2);
  },
  hasBlocks(editor, element) {
    return editor.hasBlocks(element);
  },
  hasInlines(editor, element) {
    return editor.hasInlines(element);
  },
  hasPath(editor, path3) {
    return editor.hasPath(path3);
  },
  hasTexts(editor, element) {
    return editor.hasTexts(element);
  },
  insertBreak(editor) {
    editor.insertBreak();
  },
  insertFragment(editor, fragment2, options2) {
    editor.insertFragment(fragment2, options2);
  },
  insertNode(editor, node3) {
    editor.insertNode(node3);
  },
  insertSoftBreak(editor) {
    editor.insertSoftBreak();
  },
  insertText(editor, text) {
    editor.insertText(text);
  },
  isBlock(editor, value) {
    return editor.isBlock(value);
  },
  isEdge(editor, point3, at2) {
    return editor.isEdge(point3, at2);
  },
  isEditor(value) {
    return isEditor(value);
  },
  isElementReadOnly(editor, element) {
    return editor.isElementReadOnly(element);
  },
  isEmpty(editor, element) {
    return editor.isEmpty(element);
  },
  isEnd(editor, point3, at2) {
    return editor.isEnd(point3, at2);
  },
  isInline(editor, value) {
    return editor.isInline(value);
  },
  isNormalizing(editor) {
    return editor.isNormalizing();
  },
  isSelectable(editor, value) {
    return editor.isSelectable(value);
  },
  isStart(editor, point3, at2) {
    return editor.isStart(point3, at2);
  },
  isVoid(editor, value) {
    return editor.isVoid(value);
  },
  last(editor, at2) {
    return editor.last(at2);
  },
  leaf(editor, at2, options2) {
    return editor.leaf(at2, options2);
  },
  levels(editor, options2) {
    return editor.levels(options2);
  },
  marks(editor) {
    return editor.getMarks();
  },
  next(editor, options2) {
    return editor.next(options2);
  },
  node(editor, at2, options2) {
    return editor.node(at2, options2);
  },
  nodes(editor, options2) {
    return editor.nodes(options2);
  },
  normalize(editor, options2) {
    editor.normalize(options2);
  },
  parent(editor, at2, options2) {
    return editor.parent(at2, options2);
  },
  path(editor, at2, options2) {
    return editor.path(at2, options2);
  },
  pathRef(editor, path3, options2) {
    return editor.pathRef(path3, options2);
  },
  pathRefs(editor) {
    return editor.pathRefs();
  },
  point(editor, at2, options2) {
    return editor.point(at2, options2);
  },
  pointRef(editor, point3, options2) {
    return editor.pointRef(point3, options2);
  },
  pointRefs(editor) {
    return editor.pointRefs();
  },
  positions(editor, options2) {
    return editor.positions(options2);
  },
  previous(editor, options2) {
    return editor.previous(options2);
  },
  range(editor, at2, to) {
    return editor.range(at2, to);
  },
  rangeRef(editor, range2, options2) {
    return editor.rangeRef(range2, options2);
  },
  rangeRefs(editor) {
    return editor.rangeRefs();
  },
  removeMark(editor, key) {
    editor.removeMark(key);
  },
  setNormalizing(editor, isNormalizing2) {
    editor.setNormalizing(isNormalizing2);
  },
  start(editor, at2) {
    return editor.start(at2);
  },
  string(editor, at2, options2) {
    return editor.string(at2, options2);
  },
  unhangRange(editor, range2, options2) {
    return editor.unhangRange(range2, options2);
  },
  void(editor, options2) {
    return editor.void(options2);
  },
  withoutNormalizing(editor, fn) {
    editor.withoutNormalizing(fn);
  },
  shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode) => {
    return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);
  }
};
var Span = {
  isSpan(value) {
    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
  }
};
function ownKeys$b(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$b(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$b(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$b(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var Point = {
  compare(point3, another) {
    var result = Path.compare(point3.path, another.path);
    if (result === 0) {
      if (point3.offset < another.offset) return -1;
      if (point3.offset > another.offset) return 1;
      return 0;
    }
    return result;
  },
  isAfter(point3, another) {
    return Point.compare(point3, another) === 1;
  },
  isBefore(point3, another) {
    return Point.compare(point3, another) === -1;
  },
  equals(point3, another) {
    return point3.offset === another.offset && Path.equals(point3.path, another.path);
  },
  isPoint(value) {
    return isPlainObject(value) && typeof value.offset === "number" && Path.isPath(value.path);
  },
  transform(point3, op) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return produce(point3, (p2) => {
      if (p2 === null) {
        return null;
      }
      var {
        affinity = "forward"
      } = options2;
      var {
        path: path3,
        offset: offset4
      } = p2;
      switch (op.type) {
        case "insert_node":
        case "move_node": {
          p2.path = Path.transform(path3, op, options2);
          break;
        }
        case "insert_text": {
          if (Path.equals(op.path, path3) && (op.offset < offset4 || op.offset === offset4 && affinity === "forward")) {
            p2.offset += op.text.length;
          }
          break;
        }
        case "merge_node": {
          if (Path.equals(op.path, path3)) {
            p2.offset += op.position;
          }
          p2.path = Path.transform(path3, op, options2);
          break;
        }
        case "remove_text": {
          if (Path.equals(op.path, path3) && op.offset <= offset4) {
            p2.offset -= Math.min(offset4 - op.offset, op.text.length);
          }
          break;
        }
        case "remove_node": {
          if (Path.equals(op.path, path3) || Path.isAncestor(op.path, path3)) {
            return null;
          }
          p2.path = Path.transform(path3, op, options2);
          break;
        }
        case "split_node": {
          if (Path.equals(op.path, path3)) {
            if (op.position === offset4 && affinity == null) {
              return null;
            } else if (op.position < offset4 || op.position === offset4 && affinity === "forward") {
              p2.offset -= op.position;
              p2.path = Path.transform(path3, op, _objectSpread$b(_objectSpread$b({}, options2), {}, {
                affinity: "forward"
              }));
            }
          } else {
            p2.path = Path.transform(path3, op, options2);
          }
          break;
        }
      }
    });
  }
};
var _scrubber = void 0;
var Scrubber = {
  setScrubber(scrubber) {
    _scrubber = scrubber;
  },
  stringify(value) {
    return JSON.stringify(value, _scrubber);
  }
};
var _excluded$2 = ["text"];
var _excluded2$2 = ["anchor", "focus"];
function ownKeys$a(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$a(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$a(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$a(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var Text = {
  equals(text, another) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      loose = false
    } = options2;
    function omitText(obj) {
      var rest = _objectWithoutProperties(obj, _excluded$2);
      return rest;
    }
    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
  },
  isText(value) {
    return isPlainObject(value) && typeof value.text === "string";
  },
  isTextList(value) {
    return Array.isArray(value) && value.every((val) => Text.isText(val));
  },
  isTextProps(props) {
    return props.text !== void 0;
  },
  matches(text, props) {
    for (var key in props) {
      if (key === "text") {
        continue;
      }
      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {
        return false;
      }
    }
    return true;
  },
  decorations(node3, decorations) {
    var leaves = [_objectSpread$a({}, node3)];
    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, _excluded2$2);
      var [start2, end2] = Range.edges(dec);
      var next3 = [];
      var leafEnd = 0;
      var decorationStart = start2.offset;
      var decorationEnd = end2.offset;
      for (var leaf3 of leaves) {
        var {
          length
        } = leaf3.text;
        var leafStart = leafEnd;
        leafEnd += length;
        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
          Object.assign(leaf3, rest);
          next3.push(leaf3);
          continue;
        }
        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
          next3.push(leaf3);
          continue;
        }
        var middle = leaf3;
        var before3 = void 0;
        var after3 = void 0;
        if (decorationEnd < leafEnd) {
          var off = decorationEnd - leafStart;
          after3 = _objectSpread$a(_objectSpread$a({}, middle), {}, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
            text: middle.text.slice(0, off)
          });
        }
        if (decorationStart > leafStart) {
          var _off = decorationStart - leafStart;
          before3 = _objectSpread$a(_objectSpread$a({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }
        Object.assign(middle, rest);
        if (before3) {
          next3.push(before3);
        }
        next3.push(middle);
        if (after3) {
          next3.push(after3);
        }
      }
      leaves = next3;
    }
    return leaves;
  }
};
var getDefaultInsertLocation = (editor) => {
  if (editor.selection) {
    return editor.selection;
  } else if (editor.children.length > 0) {
    return Editor.end(editor, []);
  } else {
    return [0];
  }
};
var matchPath = (editor, path3) => {
  var [node3] = Editor.node(editor, path3);
  return (n3) => n3 === node3;
};
var getCharacterDistance = function getCharacterDistance2(str) {
  var isRTL2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var isLTR = !isRTL2;
  var codepoints = isRTL2 ? codepointsIteratorRTL(str) : str;
  var left = CodepointType.None;
  var right = CodepointType.None;
  var distance = 0;
  var gb11 = null;
  var gb12Or13 = null;
  for (var char of codepoints) {
    var code = char.codePointAt(0);
    if (!code) break;
    var type = getCodepointType(char, code);
    [left, right] = isLTR ? [right, type] : [type, left];
    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
      if (isLTR) {
        gb11 = endsWithEmojiZWJ(str.substring(0, distance));
      } else {
        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
      }
      if (!gb11) break;
    }
    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
      if (gb12Or13 !== null) {
        gb12Or13 = !gb12Or13;
      } else {
        if (isLTR) {
          gb12Or13 = true;
        } else {
          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
        }
      }
      if (!gb12Or13) break;
    }
    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
      break;
    }
    distance += char.length;
  }
  return distance || 1;
};
var SPACE = /\s/;
var PUNCTUATION = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var getWordDistance = function getWordDistance2(text) {
  var isRTL2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dist = 0;
  var started = false;
  while (text.length > 0) {
    var charDist = getCharacterDistance(text, isRTL2);
    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL2);
    if (isWordCharacter(char, remaining, isRTL2)) {
      started = true;
      dist += charDist;
    } else if (!started) {
      dist += charDist;
    } else {
      break;
    }
    text = remaining;
  }
  return dist;
};
var splitByCharacterDistance = (str, dist, isRTL2) => {
  if (isRTL2) {
    var at2 = str.length - dist;
    return [str.slice(at2, str.length), str.slice(0, at2)];
  }
  return [str.slice(0, dist), str.slice(dist)];
};
var isWordCharacter = function isWordCharacter2(char, remaining) {
  var isRTL2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (SPACE.test(char)) {
    return false;
  }
  if (CHAMELEON.test(char)) {
    var charDist = getCharacterDistance(remaining, isRTL2);
    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL2);
    if (isWordCharacter2(nextChar, nextRemaining, isRTL2)) {
      return true;
    }
  }
  if (PUNCTUATION.test(char)) {
    return false;
  }
  return true;
};
var codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {
  var end2 = str.length - 1;
  for (var i = 0; i < str.length; i++) {
    var char1 = str.charAt(end2 - i);
    if (isLowSurrogate(char1.charCodeAt(0))) {
      var char2 = str.charAt(end2 - i - 1);
      if (isHighSurrogate(char2.charCodeAt(0))) {
        yield char2 + char1;
        i++;
        continue;
      }
    }
    yield char1;
  }
};
var isHighSurrogate = (charCode) => {
  return charCode >= 55296 && charCode <= 56319;
};
var isLowSurrogate = (charCode) => {
  return charCode >= 56320 && charCode <= 57343;
};
var CodepointType;
(function(CodepointType2) {
  CodepointType2[CodepointType2["None"] = 0] = "None";
  CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
  CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
  CodepointType2[CodepointType2["RI"] = 4] = "RI";
  CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
  CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
  CodepointType2[CodepointType2["L"] = 32] = "L";
  CodepointType2[CodepointType2["V"] = 64] = "V";
  CodepointType2[CodepointType2["T"] = 128] = "T";
  CodepointType2[CodepointType2["LV"] = 256] = "LV";
  CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
  CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
  CodepointType2[CodepointType2["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = (char, code) => {
  var type = CodepointType.Any;
  if (char.search(reExtend) !== -1) {
    type |= CodepointType.Extend;
  }
  if (code === 8205) {
    type |= CodepointType.ZWJ;
  }
  if (code >= 127462 && code <= 127487) {
    type |= CodepointType.RI;
  }
  if (char.search(rePrepend) !== -1) {
    type |= CodepointType.Prepend;
  }
  if (char.search(reSpacingMark) !== -1) {
    type |= CodepointType.SpacingMark;
  }
  if (char.search(reL) !== -1) {
    type |= CodepointType.L;
  }
  if (char.search(reV) !== -1) {
    type |= CodepointType.V;
  }
  if (char.search(reT) !== -1) {
    type |= CodepointType.T;
  }
  if (char.search(reLV) !== -1) {
    type |= CodepointType.LV;
  }
  if (char.search(reLVT) !== -1) {
    type |= CodepointType.LVT;
  }
  if (char.search(reExtPict) !== -1) {
    type |= CodepointType.ExtPict;
  }
  return type;
};
function intersects(x2, y) {
  return (x2 & y) !== 0;
}
var NonBoundaryPairs = [
  // GB6
  [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],
  // GB7
  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],
  // GB8
  [CodepointType.LVT | CodepointType.T, CodepointType.T],
  // GB9
  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],
  // GB9a
  [CodepointType.Any, CodepointType.SpacingMark],
  // GB9b
  [CodepointType.Prepend, CodepointType.Any],
  // GB11
  [CodepointType.ZWJ, CodepointType.ExtPict],
  // GB12 and GB13
  [CodepointType.RI, CodepointType.RI]
];
function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex((r2) => intersects(left, r2[0]) && intersects(right, r2[1])) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = (str) => {
  return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = (str) => {
  var match = str.match(endingRIs);
  if (match === null) {
    return false;
  } else {
    var numRIs = match[0].length / 2;
    return numRIs % 2 === 1;
  }
};
var TextTransforms = {
  delete(editor, options2) {
    editor.delete(options2);
  },
  insertFragment(editor, fragment2, options2) {
    editor.insertFragment(fragment2, options2);
  },
  insertText(editor, text) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options2;
      var {
        at: at2 = getDefaultInsertLocation(editor)
      } = options2;
      if (Path.isPath(at2)) {
        at2 = Editor.range(editor, at2);
      }
      if (Range.isRange(at2)) {
        if (Range.isCollapsed(at2)) {
          at2 = at2.anchor;
        } else {
          var end2 = Range.end(at2);
          if (!voids && Editor.void(editor, {
            at: end2
          })) {
            return;
          }
          var start2 = Range.start(at2);
          var startRef = Editor.pointRef(editor, start2);
          var endRef = Editor.pointRef(editor, end2);
          Transforms.delete(editor, {
            at: at2,
            voids
          });
          var startPoint = startRef.unref();
          var endPoint = endRef.unref();
          at2 = startPoint || endPoint;
          Transforms.setSelection(editor, {
            anchor: at2,
            focus: at2
          });
        }
      }
      if (!voids && Editor.void(editor, {
        at: at2
      }) || Editor.elementReadOnly(editor, {
        at: at2
      })) {
        return;
      }
      var {
        path: path3,
        offset: offset4
      } = at2;
      if (text.length > 0) editor.apply({
        type: "insert_text",
        path: path3,
        offset: offset4,
        text
      });
    });
  }
};
function ownKeys$9(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$9(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$9(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$9(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);
var BATCHING_DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
var isBatchingDirtyPaths = (editor) => {
  return BATCHING_DIRTY_PATHS.get(editor) || false;
};
var batchDirtyPaths = (editor, fn, update) => {
  var value = BATCHING_DIRTY_PATHS.get(editor) || false;
  BATCHING_DIRTY_PATHS.set(editor, true);
  try {
    fn();
    update();
  } finally {
    BATCHING_DIRTY_PATHS.set(editor, value);
  }
};
function updateDirtyPaths(editor, newDirtyPaths, transform) {
  var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
  var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || /* @__PURE__ */ new Set();
  var dirtyPaths;
  var dirtyPathKeys;
  var add2 = (path4) => {
    if (path4) {
      var key = path4.join(",");
      if (!dirtyPathKeys.has(key)) {
        dirtyPathKeys.add(key);
        dirtyPaths.push(path4);
      }
    }
  };
  if (transform) {
    dirtyPaths = [];
    dirtyPathKeys = /* @__PURE__ */ new Set();
    for (var path3 of oldDirtyPaths) {
      var newPath = transform(path3);
      add2(newPath);
    }
  } else {
    dirtyPaths = oldDirtyPaths;
    dirtyPathKeys = oldDirtyPathKeys;
  }
  for (var _path of newDirtyPaths) {
    add2(_path);
  }
  DIRTY_PATHS.set(editor, dirtyPaths);
  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
}
var apply = (editor, op) => {
  for (var ref of Editor.pathRefs(editor)) {
    PathRef.transform(ref, op);
  }
  for (var _ref of Editor.pointRefs(editor)) {
    PointRef.transform(_ref, op);
  }
  for (var _ref2 of Editor.rangeRefs(editor)) {
    RangeRef.transform(_ref2, op);
  }
  if (!isBatchingDirtyPaths(editor)) {
    var transform = Path.operationCanTransformPath(op) ? (p2) => Path.transform(p2, op) : void 0;
    updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);
  }
  Transforms.transform(editor, op);
  editor.operations.push(op);
  Editor.normalize(editor, {
    operation: op
  });
  if (op.type === "set_selection") {
    editor.marks = null;
  }
  if (!FLUSHING.get(editor)) {
    FLUSHING.set(editor, true);
    Promise.resolve().then(() => {
      FLUSHING.set(editor, false);
      editor.onChange({
        operation: op
      });
      editor.operations = [];
    });
  }
};
var getDirtyPaths = (editor, op) => {
  switch (op.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: path3
      } = op;
      return Path.levels(path3);
    }
    case "insert_node": {
      var {
        node: node3,
        path: _path
      } = op;
      var levels2 = Path.levels(_path);
      var descendants = Text.isText(node3) ? [] : Array.from(Node3.nodes(node3), (_ref) => {
        var [, p3] = _ref;
        return _path.concat(p3);
      });
      return [...levels2, ...descendants];
    }
    case "merge_node": {
      var {
        path: _path2
      } = op;
      var ancestors = Path.ancestors(_path2);
      var previousPath = Path.previous(_path2);
      return [...ancestors, previousPath];
    }
    case "move_node": {
      var {
        path: _path3,
        newPath
      } = op;
      if (Path.equals(_path3, newPath)) {
        return [];
      }
      var oldAncestors = [];
      var newAncestors = [];
      for (var ancestor of Path.ancestors(_path3)) {
        var p2 = Path.transform(ancestor, op);
        oldAncestors.push(p2);
      }
      for (var _ancestor of Path.ancestors(newPath)) {
        var _p = Path.transform(_ancestor, op);
        newAncestors.push(_p);
      }
      var newParent = newAncestors[newAncestors.length - 1];
      var newIndex = newPath[newPath.length - 1];
      var resultPath = newParent.concat(newIndex);
      return [...oldAncestors, ...newAncestors, resultPath];
    }
    case "remove_node": {
      var {
        path: _path4
      } = op;
      var _ancestors = Path.ancestors(_path4);
      return [..._ancestors];
    }
    case "split_node": {
      var {
        path: _path5
      } = op;
      var _levels = Path.levels(_path5);
      var nextPath = Path.next(_path5);
      return [..._levels, nextPath];
    }
    default: {
      return [];
    }
  }
};
var getFragment = (editor) => {
  var {
    selection
  } = editor;
  if (selection) {
    return Node3.fragment(editor, selection);
  }
  return [];
};
var normalizeNode = (editor, entry) => {
  var [node3, path3] = entry;
  if (Text.isText(node3)) {
    return;
  }
  if (Element2.isElement(node3) && node3.children.length === 0) {
    var child = {
      text: ""
    };
    Transforms.insertNodes(editor, child, {
      at: path3.concat(0),
      voids: true
    });
    return;
  }
  var shouldHaveInlines = Editor.isEditor(node3) ? false : Element2.isElement(node3) && (editor.isInline(node3) || node3.children.length === 0 || Text.isText(node3.children[0]) || editor.isInline(node3.children[0]));
  var n3 = 0;
  for (var i = 0; i < node3.children.length; i++, n3++) {
    var currentNode = Node3.get(editor, path3);
    if (Text.isText(currentNode)) continue;
    var _child = currentNode.children[n3];
    var prev = currentNode.children[n3 - 1];
    var isLast = i === node3.children.length - 1;
    var isInlineOrText = Text.isText(_child) || Element2.isElement(_child) && editor.isInline(_child);
    if (isInlineOrText !== shouldHaveInlines) {
      Transforms.removeNodes(editor, {
        at: path3.concat(n3),
        voids: true
      });
      n3--;
    } else if (Element2.isElement(_child)) {
      if (editor.isInline(_child)) {
        if (prev == null || !Text.isText(prev)) {
          var newChild = {
            text: ""
          };
          Transforms.insertNodes(editor, newChild, {
            at: path3.concat(n3),
            voids: true
          });
          n3++;
        } else if (isLast) {
          var _newChild = {
            text: ""
          };
          Transforms.insertNodes(editor, _newChild, {
            at: path3.concat(n3 + 1),
            voids: true
          });
          n3++;
        }
      }
    } else {
      if (!Text.isText(_child) && !("children" in _child)) {
        var elementChild = _child;
        elementChild.children = [];
      }
      if (prev != null && Text.isText(prev)) {
        if (Text.equals(_child, prev, {
          loose: true
        })) {
          Transforms.mergeNodes(editor, {
            at: path3.concat(n3),
            voids: true
          });
          n3--;
        } else if (prev.text === "") {
          Transforms.removeNodes(editor, {
            at: path3.concat(n3 - 1),
            voids: true
          });
          n3--;
        } else if (_child.text === "") {
          Transforms.removeNodes(editor, {
            at: path3.concat(n3),
            voids: true
          });
          n3--;
        }
      }
    }
  }
};
var shouldNormalize = (editor, _ref) => {
  var {
    iteration,
    initialDirtyPathsLength
  } = _ref;
  var maxIterations = initialDirtyPathsLength * 42;
  if (iteration > maxIterations) {
    throw new Error("Could not completely normalize the editor after ".concat(maxIterations, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  }
  return true;
};
var above = function above2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var {
    voids = false,
    mode = "lowest",
    at: at2 = editor.selection,
    match
  } = options2;
  if (!at2) {
    return;
  }
  var path3 = Editor.path(editor, at2);
  var reverse = mode === "lowest";
  for (var [n3, p2] of Editor.levels(editor, {
    at: path3,
    voids,
    match,
    reverse
  })) {
    if (Text.isText(n3)) continue;
    if (Range.isRange(at2)) {
      if (Path.isAncestor(p2, at2.anchor.path) && Path.isAncestor(p2, at2.focus.path)) {
        return [n3, p2];
      }
    } else {
      if (!Path.equals(path3, p2)) {
        return [n3, p2];
      }
    }
  }
};
function ownKeys$8(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$8(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$8(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$8(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var addMark = (editor, key, value) => {
  var {
    selection
  } = editor;
  if (selection) {
    var match = (node3, path3) => {
      if (!Text.isText(node3)) {
        return false;
      }
      var [parentNode2, parentPath] = Editor.parent(editor, path3);
      return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
    };
    var expandedSelection = Range.isExpanded(selection);
    var markAcceptingVoidSelected = false;
    if (!expandedSelection) {
      var [selectedNode, selectedPath] = Editor.node(editor, selection);
      if (selectedNode && match(selectedNode, selectedPath)) {
        var [parentNode] = Editor.parent(editor, selectedPath);
        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
      }
    }
    if (expandedSelection || markAcceptingVoidSelected) {
      Transforms.setNodes(editor, {
        [key]: value
      }, {
        match,
        split: true,
        voids: true
      });
    } else {
      var marks3 = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {
        [key]: value
      });
      editor.marks = marks3;
      if (!FLUSHING.get(editor)) {
        editor.onChange();
      }
    }
  }
};
function ownKeys$7(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$7(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$7(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$7(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var after = function after2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var anchor = Editor.point(editor, at2, {
    edge: "end"
  });
  var focus3 = Editor.end(editor, []);
  var range2 = {
    anchor,
    focus: focus3
  };
  var {
    distance = 1
  } = options2;
  var d = 0;
  var target;
  for (var p2 of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options2), {}, {
    at: range2
  }))) {
    if (d > distance) {
      break;
    }
    if (d !== 0) {
      target = p2;
    }
    d++;
  }
  return target;
};
function ownKeys$6(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$6(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$6(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$6(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var before = function before2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var anchor = Editor.start(editor, []);
  var focus3 = Editor.point(editor, at2, {
    edge: "start"
  });
  var range2 = {
    anchor,
    focus: focus3
  };
  var {
    distance = 1
  } = options2;
  var d = 0;
  var target;
  for (var p2 of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options2), {}, {
    at: range2,
    reverse: true
  }))) {
    if (d > distance) {
      break;
    }
    if (d !== 0) {
      target = p2;
    }
    d++;
  }
  return target;
};
var deleteBackward = (editor, unit) => {
  var {
    selection
  } = editor;
  if (selection && Range.isCollapsed(selection)) {
    Transforms.delete(editor, {
      unit,
      reverse: true
    });
  }
};
var deleteForward = (editor, unit) => {
  var {
    selection
  } = editor;
  if (selection && Range.isCollapsed(selection)) {
    Transforms.delete(editor, {
      unit
    });
  }
};
var deleteFragment = function deleteFragment2(editor) {
  var {
    direction = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var {
    selection
  } = editor;
  if (selection && Range.isExpanded(selection)) {
    Transforms.delete(editor, {
      reverse: direction === "backward"
    });
  }
};
var edges = (editor, at2) => {
  return [Editor.start(editor, at2), Editor.end(editor, at2)];
};
function ownKeys$5(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$5(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$5(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$5(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var elementReadOnly = function elementReadOnly2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options2), {}, {
    match: (n3) => Element2.isElement(n3) && Editor.isElementReadOnly(editor, n3)
  }));
};
var end = (editor, at2) => {
  return Editor.point(editor, at2, {
    edge: "end"
  });
};
var first = (editor, at2) => {
  var path3 = Editor.path(editor, at2, {
    edge: "start"
  });
  return Editor.node(editor, path3);
};
var fragment = (editor, at2) => {
  var range2 = Editor.range(editor, at2);
  return Node3.fragment(editor, range2);
};
function ownKeys$4(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$4(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$4(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$4(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var getVoid = function getVoid2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options2), {}, {
    match: (n3) => Element2.isElement(n3) && Editor.isVoid(editor, n3)
  }));
};
var hasBlocks = (editor, element) => {
  return element.children.some((n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3));
};
var hasInlines = (editor, element) => {
  return element.children.some((n3) => Text.isText(n3) || Editor.isInline(editor, n3));
};
var hasPath = (editor, path3) => {
  return Node3.has(editor, path3);
};
var hasTexts = (editor, element) => {
  return element.children.every((n3) => Text.isText(n3));
};
var insertBreak = (editor) => {
  Transforms.splitNodes(editor, {
    always: true
  });
};
var insertNode = (editor, node3, options2) => {
  Transforms.insertNodes(editor, node3, options2);
};
var insertSoftBreak = (editor) => {
  Transforms.splitNodes(editor, {
    always: true
  });
};
function ownKeys$3(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$3(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$3(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$3(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var insertText = function insertText2(editor, text) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    selection,
    marks: marks3
  } = editor;
  if (selection) {
    if (marks3) {
      var node3 = _objectSpread$3({
        text
      }, marks3);
      Transforms.insertNodes(editor, node3, {
        at: options2.at,
        voids: options2.voids
      });
    } else {
      Transforms.insertText(editor, text, options2);
    }
    editor.marks = null;
  }
};
var isBlock = (editor, value) => {
  return !editor.isInline(value);
};
var isEdge = (editor, point3, at2) => {
  return Editor.isStart(editor, point3, at2) || Editor.isEnd(editor, point3, at2);
};
var isEmpty = (editor, element) => {
  var {
    children
  } = element;
  var [first2] = children;
  return children.length === 0 || children.length === 1 && Text.isText(first2) && first2.text === "" && !editor.isVoid(element);
};
var isEnd = (editor, point3, at2) => {
  var end2 = Editor.end(editor, at2);
  return Point.equals(point3, end2);
};
var isNormalizing = (editor) => {
  var isNormalizing2 = NORMALIZING.get(editor);
  return isNormalizing2 === void 0 ? true : isNormalizing2;
};
var isStart = (editor, point3, at2) => {
  if (point3.offset !== 0) {
    return false;
  }
  var start2 = Editor.start(editor, at2);
  return Point.equals(point3, start2);
};
var last = (editor, at2) => {
  var path3 = Editor.path(editor, at2, {
    edge: "end"
  });
  return Editor.node(editor, path3);
};
var leaf = function leaf2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var path3 = Editor.path(editor, at2, options2);
  var node3 = Node3.leaf(editor, path3);
  return [node3, path3];
};
function levels(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return (function* () {
    var {
      at: at2 = editor.selection,
      reverse = false,
      voids = false
    } = options2;
    var {
      match
    } = options2;
    if (match == null) {
      match = () => true;
    }
    if (!at2) {
      return;
    }
    var levels2 = [];
    var path3 = Editor.path(editor, at2);
    for (var [n3, p2] of Node3.levels(editor, path3)) {
      if (!match(n3, p2)) {
        continue;
      }
      levels2.push([n3, p2]);
      if (!voids && Element2.isElement(n3) && Editor.isVoid(editor, n3)) {
        break;
      }
    }
    if (reverse) {
      levels2.reverse();
    }
    yield* levels2;
  })();
}
var _excluded$1 = ["text"];
var _excluded2$1 = ["text"];
var marks = function marks2(editor) {
  var {
    marks: marks3,
    selection
  } = editor;
  if (!selection) {
    return null;
  }
  var {
    anchor,
    focus: focus3
  } = selection;
  if (marks3) {
    return marks3;
  }
  if (Range.isExpanded(selection)) {
    var isBackward = Range.isBackward(selection);
    if (isBackward) {
      [focus3, anchor] = [anchor, focus3];
    }
    var isEnd2 = Editor.isEnd(editor, anchor, anchor.path);
    if (isEnd2) {
      var after3 = Editor.after(editor, anchor);
      if (after3) {
        anchor = after3;
      }
    }
    var [match] = Editor.nodes(editor, {
      match: Text.isText,
      at: {
        anchor,
        focus: focus3
      }
    });
    if (match) {
      var [_node] = match;
      var _rest = _objectWithoutProperties(_node, _excluded$1);
      return _rest;
    } else {
      return {};
    }
  }
  var {
    path: path3
  } = anchor;
  var [node3] = Editor.leaf(editor, path3);
  if (anchor.offset === 0) {
    var prev = Editor.previous(editor, {
      at: path3,
      match: Text.isText
    });
    var markedVoid = Editor.above(editor, {
      match: (n3) => Element2.isElement(n3) && Editor.isVoid(editor, n3) && editor.markableVoid(n3)
    });
    if (!markedVoid) {
      var block2 = Editor.above(editor, {
        match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3)
      });
      if (prev && block2) {
        var [prevNode, prevPath] = prev;
        var [, blockPath] = block2;
        if (Path.isAncestor(blockPath, prevPath)) {
          node3 = prevNode;
        }
      }
    }
  }
  var rest = _objectWithoutProperties(node3, _excluded2$1);
  return rest;
};
var next = function next2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var {
    mode = "lowest",
    voids = false
  } = options2;
  var {
    match,
    at: at2 = editor.selection
  } = options2;
  if (!at2) {
    return;
  }
  var pointAfterLocation = Editor.after(editor, at2, {
    voids
  });
  if (!pointAfterLocation) return;
  var [, to] = Editor.last(editor, []);
  var span = [pointAfterLocation.path, to];
  if (Path.isPath(at2) && at2.length === 0) {
    throw new Error("Cannot get the next node from the root node!");
  }
  if (match == null) {
    if (Path.isPath(at2)) {
      var [parent3] = Editor.parent(editor, at2);
      match = (n3) => parent3.children.includes(n3);
    } else {
      match = () => true;
    }
  }
  var [next3] = Editor.nodes(editor, {
    at: span,
    match,
    mode,
    voids
  });
  return next3;
};
var node = function node2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var path3 = Editor.path(editor, at2, options2);
  var node3 = Node3.get(editor, path3);
  return [node3, path3];
};
function nodes(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return (function* () {
    var {
      at: at2 = editor.selection,
      mode = "all",
      universal = false,
      reverse = false,
      voids = false,
      ignoreNonSelectable = false
    } = options2;
    var {
      match
    } = options2;
    if (!match) {
      match = () => true;
    }
    if (!at2) {
      return;
    }
    var from2;
    var to;
    if (Span.isSpan(at2)) {
      from2 = at2[0];
      to = at2[1];
    } else {
      var first2 = Editor.path(editor, at2, {
        edge: "start"
      });
      var last2 = Editor.path(editor, at2, {
        edge: "end"
      });
      from2 = reverse ? last2 : first2;
      to = reverse ? first2 : last2;
    }
    var nodeEntries = Node3.nodes(editor, {
      reverse,
      from: from2,
      to,
      pass: (_ref) => {
        var [node4] = _ref;
        if (!Element2.isElement(node4)) return false;
        if (!voids && (Editor.isVoid(editor, node4) || Editor.isElementReadOnly(editor, node4))) return true;
        if (ignoreNonSelectable && !Editor.isSelectable(editor, node4)) return true;
        return false;
      }
    });
    var matches = [];
    var hit;
    for (var [node3, path3] of nodeEntries) {
      if (ignoreNonSelectable && Element2.isElement(node3) && !Editor.isSelectable(editor, node3)) {
        continue;
      }
      var isLower = hit && Path.compare(path3, hit[1]) === 0;
      if (mode === "highest" && isLower) {
        continue;
      }
      if (!match(node3, path3)) {
        if (universal && !isLower && Text.isText(node3)) {
          return;
        } else {
          continue;
        }
      }
      if (mode === "lowest" && isLower) {
        hit = [node3, path3];
        continue;
      }
      var emit = mode === "lowest" ? hit : [node3, path3];
      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }
      hit = [node3, path3];
    }
    if (mode === "lowest" && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    }
    if (universal) {
      yield* matches;
    }
  })();
}
var normalize = function normalize2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var {
    force = false,
    operation
  } = options2;
  var getDirtyPaths2 = (editor2) => {
    return DIRTY_PATHS.get(editor2) || [];
  };
  var getDirtyPathKeys = (editor2) => {
    return DIRTY_PATH_KEYS.get(editor2) || /* @__PURE__ */ new Set();
  };
  var popDirtyPath = (editor2) => {
    var path3 = getDirtyPaths2(editor2).pop();
    var key = path3.join(",");
    getDirtyPathKeys(editor2).delete(key);
    return path3;
  };
  if (!Editor.isNormalizing(editor)) {
    return;
  }
  if (force) {
    var allPaths = Array.from(Node3.nodes(editor), (_ref) => {
      var [, p2] = _ref;
      return p2;
    });
    var allPathKeys = new Set(allPaths.map((p2) => p2.join(",")));
    DIRTY_PATHS.set(editor, allPaths);
    DIRTY_PATH_KEYS.set(editor, allPathKeys);
  }
  if (getDirtyPaths2(editor).length === 0) {
    return;
  }
  Editor.withoutNormalizing(editor, () => {
    for (var dirtyPath of getDirtyPaths2(editor)) {
      if (Node3.has(editor, dirtyPath)) {
        var entry = Editor.node(editor, dirtyPath);
        var [node3, _2] = entry;
        if (Element2.isElement(node3) && node3.children.length === 0) {
          editor.normalizeNode(entry, {
            operation
          });
        }
      }
    }
    var dirtyPaths = getDirtyPaths2(editor);
    var initialDirtyPathsLength = dirtyPaths.length;
    var iteration = 0;
    while (dirtyPaths.length !== 0) {
      if (!editor.shouldNormalize({
        dirtyPaths,
        iteration,
        initialDirtyPathsLength,
        operation
      })) {
        return;
      }
      var _dirtyPath = popDirtyPath(editor);
      if (Node3.has(editor, _dirtyPath)) {
        var _entry = Editor.node(editor, _dirtyPath);
        editor.normalizeNode(_entry, {
          operation
        });
      }
      iteration++;
      dirtyPaths = getDirtyPaths2(editor);
    }
  });
};
var parent = function parent2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var path3 = Editor.path(editor, at2, options2);
  var parentPath = Path.parent(path3);
  var entry = Editor.node(editor, parentPath);
  return entry;
};
var pathRef = function pathRef2(editor, path3) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    affinity = "forward"
  } = options2;
  var ref = {
    current: path3,
    affinity,
    unref() {
      var {
        current: current2
      } = ref;
      var pathRefs2 = Editor.pathRefs(editor);
      pathRefs2.delete(ref);
      ref.current = null;
      return current2;
    }
  };
  var refs = Editor.pathRefs(editor);
  refs.add(ref);
  return ref;
};
var pathRefs = (editor) => {
  var refs = PATH_REFS.get(editor);
  if (!refs) {
    refs = /* @__PURE__ */ new Set();
    PATH_REFS.set(editor, refs);
  }
  return refs;
};
var path = function path2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    depth,
    edge
  } = options2;
  if (Path.isPath(at2)) {
    if (edge === "start") {
      var [, firstPath] = Node3.first(editor, at2);
      at2 = firstPath;
    } else if (edge === "end") {
      var [, lastPath] = Node3.last(editor, at2);
      at2 = lastPath;
    }
  }
  if (Range.isRange(at2)) {
    if (edge === "start") {
      at2 = Range.start(at2);
    } else if (edge === "end") {
      at2 = Range.end(at2);
    } else {
      at2 = Path.common(at2.anchor.path, at2.focus.path);
    }
  }
  if (Point.isPoint(at2)) {
    at2 = at2.path;
  }
  if (depth != null) {
    at2 = at2.slice(0, depth);
  }
  return at2;
};
var pointRef = function pointRef2(editor, point3) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    affinity = "forward"
  } = options2;
  var ref = {
    current: point3,
    affinity,
    unref() {
      var {
        current: current2
      } = ref;
      var pointRefs2 = Editor.pointRefs(editor);
      pointRefs2.delete(ref);
      ref.current = null;
      return current2;
    }
  };
  var refs = Editor.pointRefs(editor);
  refs.add(ref);
  return ref;
};
var pointRefs = (editor) => {
  var refs = POINT_REFS.get(editor);
  if (!refs) {
    refs = /* @__PURE__ */ new Set();
    POINT_REFS.set(editor, refs);
  }
  return refs;
};
var point = function point2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    edge = "start"
  } = options2;
  if (Path.isPath(at2)) {
    var path3;
    if (edge === "end") {
      var [, lastPath] = Node3.last(editor, at2);
      path3 = lastPath;
    } else {
      var [, firstPath] = Node3.first(editor, at2);
      path3 = firstPath;
    }
    var node3 = Node3.get(editor, path3);
    if (!Text.isText(node3)) {
      throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at2, "] because it has no ").concat(edge, " text node."));
    }
    return {
      path: path3,
      offset: edge === "end" ? node3.text.length : 0
    };
  }
  if (Range.isRange(at2)) {
    var [start2, end2] = Range.edges(at2);
    return edge === "start" ? start2 : end2;
  }
  return at2;
};
function positions(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return (function* () {
    var {
      at: at2 = editor.selection,
      unit = "offset",
      reverse = false,
      voids = false,
      ignoreNonSelectable = false
    } = options2;
    if (!at2) {
      return;
    }
    var range2 = Editor.range(editor, at2);
    var [start2, end2] = Range.edges(range2);
    var first2 = reverse ? end2 : start2;
    var isNewBlock = false;
    var blockText2 = "";
    var distance = 0;
    var leafTextRemaining = 0;
    var leafTextOffset = 0;
    for (var [node3, path3] of Editor.nodes(editor, {
      at: at2,
      reverse,
      voids,
      ignoreNonSelectable
    })) {
      if (Element2.isElement(node3)) {
        if (!voids && (editor.isVoid(node3) || editor.isElementReadOnly(node3))) {
          yield Editor.start(editor, path3);
          continue;
        }
        if (editor.isInline(node3)) continue;
        if (Editor.hasInlines(editor, node3)) {
          var e3 = Path.isAncestor(path3, end2.path) ? end2 : Editor.end(editor, path3);
          var s = Path.isAncestor(path3, start2.path) ? start2 : Editor.start(editor, path3);
          blockText2 = Editor.string(editor, {
            anchor: s,
            focus: e3
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      if (Text.isText(node3)) {
        var isFirst = Path.equals(path3, first2.path);
        if (isFirst) {
          leafTextRemaining = reverse ? first2.offset : node3.text.length - first2.offset;
          leafTextOffset = first2.offset;
        } else {
          leafTextRemaining = node3.text.length;
          leafTextOffset = reverse ? leafTextRemaining : 0;
        }
        if (isFirst || isNewBlock || unit === "offset") {
          yield {
            path: path3,
            offset: leafTextOffset
          };
          isNewBlock = false;
        }
        while (true) {
          if (distance === 0) {
            if (blockText2 === "") break;
            distance = calcDistance(blockText2, unit, reverse);
            blockText2 = splitByCharacterDistance(blockText2, distance, reverse)[1];
          }
          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
          leafTextRemaining = leafTextRemaining - distance;
          if (leafTextRemaining < 0) {
            distance = -leafTextRemaining;
            break;
          }
          distance = 0;
          yield {
            path: path3,
            offset: leafTextOffset
          };
        }
      }
    }
    function calcDistance(text, unit2, reverse2) {
      if (unit2 === "character") {
        return getCharacterDistance(text, reverse2);
      } else if (unit2 === "word") {
        return getWordDistance(text, reverse2);
      } else if (unit2 === "line" || unit2 === "block") {
        return text.length;
      }
      return 1;
    }
  })();
}
var previous = function previous2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var {
    mode = "lowest",
    voids = false
  } = options2;
  var {
    match,
    at: at2 = editor.selection
  } = options2;
  if (!at2) {
    return;
  }
  var pointBeforeLocation = Editor.before(editor, at2, {
    voids
  });
  if (!pointBeforeLocation) {
    return;
  }
  var [, to] = Editor.first(editor, []);
  var span = [pointBeforeLocation.path, to];
  if (Path.isPath(at2) && at2.length === 0) {
    throw new Error("Cannot get the previous node from the root node!");
  }
  if (match == null) {
    if (Path.isPath(at2)) {
      var [parent3] = Editor.parent(editor, at2);
      match = (n3) => parent3.children.includes(n3);
    } else {
      match = () => true;
    }
  }
  var [previous3] = Editor.nodes(editor, {
    reverse: true,
    at: span,
    match,
    mode,
    voids
  });
  return previous3;
};
var rangeRef = function rangeRef2(editor, range2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    affinity = "forward"
  } = options2;
  var ref = {
    current: range2,
    affinity,
    unref() {
      var {
        current: current2
      } = ref;
      var rangeRefs2 = Editor.rangeRefs(editor);
      rangeRefs2.delete(ref);
      ref.current = null;
      return current2;
    }
  };
  var refs = Editor.rangeRefs(editor);
  refs.add(ref);
  return ref;
};
var rangeRefs = (editor) => {
  var refs = RANGE_REFS.get(editor);
  if (!refs) {
    refs = /* @__PURE__ */ new Set();
    RANGE_REFS.set(editor, refs);
  }
  return refs;
};
var range = (editor, at2, to) => {
  if (Range.isRange(at2) && !to) {
    return at2;
  }
  var start2 = Editor.start(editor, at2);
  var end2 = Editor.end(editor, to || at2);
  return {
    anchor: start2,
    focus: end2
  };
};
function ownKeys$2(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$2(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var removeMark = (editor, key) => {
  var {
    selection
  } = editor;
  if (selection) {
    var match = (node3, path3) => {
      if (!Text.isText(node3)) {
        return false;
      }
      var [parentNode2, parentPath] = Editor.parent(editor, path3);
      return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
    };
    var expandedSelection = Range.isExpanded(selection);
    var markAcceptingVoidSelected = false;
    if (!expandedSelection) {
      var [selectedNode, selectedPath] = Editor.node(editor, selection);
      if (selectedNode && match(selectedNode, selectedPath)) {
        var [parentNode] = Editor.parent(editor, selectedPath);
        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
      }
    }
    if (expandedSelection || markAcceptingVoidSelected) {
      Transforms.unsetNodes(editor, key, {
        match,
        split: true,
        voids: true
      });
    } else {
      var marks3 = _objectSpread$2({}, Editor.marks(editor) || {});
      delete marks3[key];
      editor.marks = marks3;
      if (!FLUSHING.get(editor)) {
        editor.onChange();
      }
    }
  }
};
var setNormalizing = (editor, isNormalizing2) => {
  NORMALIZING.set(editor, isNormalizing2);
};
var start = (editor, at2) => {
  return Editor.point(editor, at2, {
    edge: "start"
  });
};
var string = function string2(editor, at2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    voids = false
  } = options2;
  var range2 = Editor.range(editor, at2);
  var [start2, end2] = Range.edges(range2);
  var text = "";
  for (var [node3, path3] of Editor.nodes(editor, {
    at: range2,
    match: Text.isText,
    voids
  })) {
    var t3 = node3.text;
    if (Path.equals(path3, end2.path)) {
      t3 = t3.slice(0, end2.offset);
    }
    if (Path.equals(path3, start2.path)) {
      t3 = t3.slice(start2.offset);
    }
    text += t3;
  }
  return text;
};
var unhangRange = function unhangRange2(editor, range2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    voids = false
  } = options2;
  var [start2, end2] = Range.edges(range2);
  if (start2.offset !== 0 || end2.offset !== 0 || Range.isCollapsed(range2) || Path.hasPrevious(end2.path)) {
    return range2;
  }
  var endBlock = Editor.above(editor, {
    at: end2,
    match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3),
    voids
  });
  var blockPath = endBlock ? endBlock[1] : [];
  var first2 = Editor.start(editor, start2);
  var before3 = {
    anchor: first2,
    focus: end2
  };
  var skip = true;
  for (var [node3, path3] of Editor.nodes(editor, {
    at: before3,
    match: Text.isText,
    reverse: true,
    voids
  })) {
    if (skip) {
      skip = false;
      continue;
    }
    if (node3.text !== "" || Path.isBefore(path3, blockPath)) {
      end2 = {
        path: path3,
        offset: node3.text.length
      };
      break;
    }
  }
  return {
    anchor: start2,
    focus: end2
  };
};
var withoutNormalizing = (editor, fn) => {
  var value = Editor.isNormalizing(editor);
  Editor.setNormalizing(editor, false);
  try {
    fn();
  } finally {
    Editor.setNormalizing(editor, value);
  }
  Editor.normalize(editor);
};
var shouldMergeNodesRemovePrevNode = (editor, _ref, _ref2) => {
  var [prevNode, prevPath] = _ref;
  return Element2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0;
};
var deleteText = function deleteText2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Editor.withoutNormalizing(editor, () => {
    var _Editor$void, _Editor$void2;
    var {
      reverse = false,
      unit = "character",
      distance = 1,
      voids = false
    } = options2;
    var {
      at: at2 = editor.selection,
      hanging = false
    } = options2;
    if (!at2) {
      return;
    }
    var isCollapsed = false;
    if (Range.isRange(at2) && Range.isCollapsed(at2)) {
      isCollapsed = true;
      at2 = at2.anchor;
    }
    if (Point.isPoint(at2)) {
      var furthestVoid = Editor.void(editor, {
        at: at2,
        mode: "highest"
      });
      if (!voids && furthestVoid) {
        var [, voidPath] = furthestVoid;
        at2 = voidPath;
      } else {
        var opts = {
          unit,
          distance
        };
        var target = reverse ? Editor.before(editor, at2, opts) || Editor.start(editor, []) : Editor.after(editor, at2, opts) || Editor.end(editor, []);
        at2 = {
          anchor: at2,
          focus: target
        };
        hanging = true;
      }
    }
    if (Path.isPath(at2)) {
      Transforms.removeNodes(editor, {
        at: at2,
        voids
      });
      return;
    }
    if (Range.isCollapsed(at2)) {
      return;
    }
    if (!hanging) {
      var [, _end] = Range.edges(at2);
      var endOfDoc = Editor.end(editor, []);
      if (!Point.equals(_end, endOfDoc)) {
        at2 = Editor.unhangRange(editor, at2, {
          voids
        });
      }
    }
    var [start2, end2] = Range.edges(at2);
    var startBlock = Editor.above(editor, {
      match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3),
      at: start2,
      voids
    });
    var endBlock = Editor.above(editor, {
      match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3),
      at: end2,
      voids
    });
    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
    var isSingleText = Path.equals(start2.path, end2.path);
    var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {
      at: start2,
      mode: "highest"
    })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {
      at: start2,
      mode: "highest"
    });
    var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {
      at: end2,
      mode: "highest"
    })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {
      at: end2,
      mode: "highest"
    });
    if (startNonEditable) {
      var before3 = Editor.before(editor, start2);
      if (before3 && startBlock && Path.isAncestor(startBlock[1], before3.path)) {
        start2 = before3;
      }
    }
    if (endNonEditable) {
      var after3 = Editor.after(editor, end2);
      if (after3 && endBlock && Path.isAncestor(endBlock[1], after3.path)) {
        end2 = after3;
      }
    }
    var matches = [];
    var lastPath;
    for (var entry of Editor.nodes(editor, {
      at: at2,
      voids
    })) {
      var [node3, path3] = entry;
      if (lastPath && Path.compare(path3, lastPath) === 0) {
        continue;
      }
      if (!voids && Element2.isElement(node3) && (Editor.isVoid(editor, node3) || Editor.isElementReadOnly(editor, node3)) || !Path.isCommon(path3, start2.path) && !Path.isCommon(path3, end2.path)) {
        matches.push(entry);
        lastPath = path3;
      }
    }
    var pathRefs2 = Array.from(matches, (_ref) => {
      var [, p2] = _ref;
      return Editor.pathRef(editor, p2);
    });
    var startRef = Editor.pointRef(editor, start2);
    var endRef = Editor.pointRef(editor, end2);
    var removedText = "";
    if (!isSingleText && !startNonEditable) {
      var _point = startRef.current;
      var [_node] = Editor.leaf(editor, _point);
      var {
        path: _path
      } = _point;
      var {
        offset: offset4
      } = start2;
      var text = _node.text.slice(offset4);
      if (text.length > 0) {
        editor.apply({
          type: "remove_text",
          path: _path,
          offset: offset4,
          text
        });
        removedText = text;
      }
    }
    pathRefs2.reverse().map((r2) => r2.unref()).filter((r2) => r2 !== null).forEach((p2) => Transforms.removeNodes(editor, {
      at: p2,
      voids
    }));
    if (!endNonEditable) {
      var _point2 = endRef.current;
      var [_node2] = Editor.leaf(editor, _point2);
      var {
        path: _path2
      } = _point2;
      var _offset = isSingleText ? start2.offset : 0;
      var _text = _node2.text.slice(_offset, end2.offset);
      if (_text.length > 0) {
        editor.apply({
          type: "remove_text",
          path: _path2,
          offset: _offset,
          text: _text
        });
        removedText = _text;
      }
    }
    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
      Transforms.mergeNodes(editor, {
        at: endRef.current,
        hanging: true,
        voids
      });
    }
    if (isCollapsed && reverse && unit === "character" && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
      Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));
    }
    var startUnref = startRef.unref();
    var endUnref = endRef.unref();
    var point3 = reverse ? startUnref || endUnref : endUnref || startUnref;
    if (options2.at == null && point3) {
      Transforms.select(editor, point3);
    }
  });
};
var insertFragment = function insertFragment2(editor, fragment2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      hanging = false,
      voids = false
    } = options2;
    var {
      at: at2 = getDefaultInsertLocation(editor),
      batchDirty = true
    } = options2;
    if (!fragment2.length) {
      return;
    }
    if (Range.isRange(at2)) {
      if (!hanging) {
        at2 = Editor.unhangRange(editor, at2, {
          voids
        });
      }
      if (Range.isCollapsed(at2)) {
        at2 = at2.anchor;
      } else {
        var [, end2] = Range.edges(at2);
        if (!voids && Editor.void(editor, {
          at: end2
        })) {
          return;
        }
        var pointRef3 = Editor.pointRef(editor, end2);
        Transforms.delete(editor, {
          at: at2
        });
        at2 = pointRef3.unref();
      }
    } else if (Path.isPath(at2)) {
      at2 = Editor.start(editor, at2);
    }
    if (!voids && Editor.void(editor, {
      at: at2
    })) {
      return;
    }
    var inlineElementMatch = Editor.above(editor, {
      at: at2,
      match: (n3) => Element2.isElement(n3) && Editor.isInline(editor, n3),
      mode: "highest",
      voids
    });
    if (inlineElementMatch) {
      var [, _inlinePath] = inlineElementMatch;
      if (Editor.isEnd(editor, at2, _inlinePath)) {
        var after3 = Editor.after(editor, _inlinePath);
        at2 = after3;
      } else if (Editor.isStart(editor, at2, _inlinePath)) {
        var before3 = Editor.before(editor, _inlinePath);
        at2 = before3;
      }
    }
    var blockMatch = Editor.above(editor, {
      match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3),
      at: at2,
      voids
    });
    var [, blockPath] = blockMatch;
    var isBlockStart = Editor.isStart(editor, at2, blockPath);
    var isBlockEnd = Editor.isEnd(editor, at2, blockPath);
    var isBlockEmpty = isBlockStart && isBlockEnd;
    var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
    var mergeEnd = !isBlockEnd;
    var [, firstPath] = Node3.first({
      children: fragment2
    }, []);
    var [, lastPath] = Node3.last({
      children: fragment2
    }, []);
    var matches = [];
    var matcher = (_ref) => {
      var [n3, p2] = _ref;
      var isRoot = p2.length === 0;
      if (isRoot) {
        return false;
      }
      if (isBlockEmpty) {
        return true;
      }
      if (mergeStart && Path.isAncestor(p2, firstPath) && Element2.isElement(n3) && !editor.isVoid(n3) && !editor.isInline(n3)) {
        return false;
      }
      if (mergeEnd && Path.isAncestor(p2, lastPath) && Element2.isElement(n3) && !editor.isVoid(n3) && !editor.isInline(n3)) {
        return false;
      }
      return true;
    };
    for (var entry of Node3.nodes({
      children: fragment2
    }, {
      pass: matcher
    })) {
      if (matcher(entry)) {
        matches.push(entry);
      }
    }
    var starts = [];
    var middles = [];
    var ends = [];
    var starting = true;
    var hasBlocks2 = false;
    for (var [node3] of matches) {
      if (Element2.isElement(node3) && !editor.isInline(node3)) {
        starting = false;
        hasBlocks2 = true;
        middles.push(node3);
      } else if (starting) {
        starts.push(node3);
      } else {
        ends.push(node3);
      }
    }
    var [inlineMatch] = Editor.nodes(editor, {
      at: at2,
      match: (n3) => Text.isText(n3) || Editor.isInline(editor, n3),
      mode: "highest",
      voids
    });
    var [, inlinePath] = inlineMatch;
    var isInlineStart = Editor.isStart(editor, at2, inlinePath);
    var isInlineEnd = Editor.isEnd(editor, at2, inlinePath);
    var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
    var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
    Transforms.splitNodes(editor, {
      at: at2,
      match: (n3) => hasBlocks2 ? Element2.isElement(n3) && Editor.isBlock(editor, n3) : Text.isText(n3) || Editor.isInline(editor, n3),
      mode: hasBlocks2 ? "lowest" : "highest",
      always: hasBlocks2 && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
      voids
    });
    var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
    Transforms.insertNodes(editor, starts, {
      at: startRef.current,
      match: (n3) => Text.isText(n3) || Editor.isInline(editor, n3),
      mode: "highest",
      voids,
      batchDirty
    });
    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
      Transforms.delete(editor, {
        at: blockPath,
        voids
      });
    }
    Transforms.insertNodes(editor, middles, {
      at: middleRef.current,
      match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3),
      mode: "lowest",
      voids,
      batchDirty
    });
    Transforms.insertNodes(editor, ends, {
      at: endRef.current,
      match: (n3) => Text.isText(n3) || Editor.isInline(editor, n3),
      mode: "highest",
      voids,
      batchDirty
    });
    if (!options2.at) {
      var path3;
      if (ends.length > 0 && endRef.current) {
        path3 = Path.previous(endRef.current);
      } else if (middles.length > 0 && middleRef.current) {
        path3 = Path.previous(middleRef.current);
      } else if (startRef.current) {
        path3 = Path.previous(startRef.current);
      }
      if (path3) {
        var _end = Editor.end(editor, path3);
        Transforms.select(editor, _end);
      }
    }
    startRef.unref();
    middleRef.unref();
    endRef.unref();
  });
};
var collapse = function collapse2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var {
    edge = "anchor"
  } = options2;
  var {
    selection
  } = editor;
  if (!selection) {
    return;
  } else if (edge === "anchor") {
    Transforms.select(editor, selection.anchor);
  } else if (edge === "focus") {
    Transforms.select(editor, selection.focus);
  } else if (edge === "start") {
    var [start2] = Range.edges(selection);
    Transforms.select(editor, start2);
  } else if (edge === "end") {
    var [, end2] = Range.edges(selection);
    Transforms.select(editor, end2);
  }
};
var deselect = (editor) => {
  var {
    selection
  } = editor;
  if (selection) {
    editor.apply({
      type: "set_selection",
      properties: selection,
      newProperties: null
    });
  }
};
var move = function move2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var {
    selection
  } = editor;
  var {
    distance = 1,
    unit = "character",
    reverse = false
  } = options2;
  var {
    edge = null
  } = options2;
  if (!selection) {
    return;
  }
  if (edge === "start") {
    edge = Range.isBackward(selection) ? "focus" : "anchor";
  }
  if (edge === "end") {
    edge = Range.isBackward(selection) ? "anchor" : "focus";
  }
  var {
    anchor,
    focus: focus3
  } = selection;
  var opts = {
    distance,
    unit,
    ignoreNonSelectable: true
  };
  var props = {};
  if (edge == null || edge === "anchor") {
    var point3 = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
    if (point3) {
      props.anchor = point3;
    }
  }
  if (edge == null || edge === "focus") {
    var _point = reverse ? Editor.before(editor, focus3, opts) : Editor.after(editor, focus3, opts);
    if (_point) {
      props.focus = _point;
    }
  }
  Transforms.setSelection(editor, props);
};
var select = (editor, target) => {
  var {
    selection
  } = editor;
  target = Editor.range(editor, target);
  if (selection) {
    Transforms.setSelection(editor, target);
    return;
  }
  if (!Range.isRange(target)) {
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
  }
  editor.apply({
    type: "set_selection",
    properties: selection,
    newProperties: target
  });
};
function ownKeys$1(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$1(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$1(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var setPoint = function setPoint2(editor, props) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    selection
  } = editor;
  var {
    edge = "both"
  } = options2;
  if (!selection) {
    return;
  }
  if (edge === "start") {
    edge = Range.isBackward(selection) ? "focus" : "anchor";
  }
  if (edge === "end") {
    edge = Range.isBackward(selection) ? "anchor" : "focus";
  }
  var {
    anchor,
    focus: focus3
  } = selection;
  var point3 = edge === "anchor" ? anchor : focus3;
  Transforms.setSelection(editor, {
    [edge === "anchor" ? "anchor" : "focus"]: _objectSpread$1(_objectSpread$1({}, point3), props)
  });
};
var setSelection = (editor, props) => {
  var {
    selection
  } = editor;
  var oldProps = {};
  var newProps = {};
  if (!selection) {
    return;
  }
  for (var k3 in props) {
    if (k3 === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k3 === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k3 !== "anchor" && k3 !== "focus" && props[k3] !== selection[k3]) {
      oldProps[k3] = selection[k3];
      newProps[k3] = props[k3];
    }
  }
  if (Object.keys(oldProps).length > 0) {
    editor.apply({
      type: "set_selection",
      properties: oldProps,
      newProperties: newProps
    });
  }
};
var insertNodes = function insertNodes2(editor, nodes2) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      hanging = false,
      voids = false,
      mode = "lowest",
      batchDirty = true
    } = options2;
    var {
      at: at2,
      match,
      select: select2
    } = options2;
    if (Node3.isNode(nodes2)) {
      nodes2 = [nodes2];
    }
    if (nodes2.length === 0) {
      return;
    }
    var [node3] = nodes2;
    if (!at2) {
      at2 = getDefaultInsertLocation(editor);
      if (select2 !== false) {
        select2 = true;
      }
    }
    if (select2 == null) {
      select2 = false;
    }
    if (Range.isRange(at2)) {
      if (!hanging) {
        at2 = Editor.unhangRange(editor, at2, {
          voids
        });
      }
      if (Range.isCollapsed(at2)) {
        at2 = at2.anchor;
      } else {
        var [, end2] = Range.edges(at2);
        var pointRef3 = Editor.pointRef(editor, end2);
        Transforms.delete(editor, {
          at: at2
        });
        at2 = pointRef3.unref();
      }
    }
    if (Point.isPoint(at2)) {
      if (match == null) {
        if (Text.isText(node3)) {
          match = (n3) => Text.isText(n3);
        } else if (editor.isInline(node3)) {
          match = (n3) => Text.isText(n3) || Editor.isInline(editor, n3);
        } else {
          match = (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
        }
      }
      var [entry] = Editor.nodes(editor, {
        at: at2.path,
        match,
        mode,
        voids
      });
      if (entry) {
        var [, matchPath2] = entry;
        var pathRef3 = Editor.pathRef(editor, matchPath2);
        var isAtEnd = Editor.isEnd(editor, at2, matchPath2);
        Transforms.splitNodes(editor, {
          at: at2,
          match,
          mode,
          voids
        });
        var path3 = pathRef3.unref();
        at2 = isAtEnd ? Path.next(path3) : path3;
      } else {
        return;
      }
    }
    var parentPath = Path.parent(at2);
    var index2 = at2[at2.length - 1];
    if (!voids && Editor.void(editor, {
      at: parentPath
    })) {
      return;
    }
    if (batchDirty) {
      var batchedOps = [];
      var newDirtyPaths = Path.levels(parentPath);
      batchDirtyPaths(editor, () => {
        var _loop = function _loop2() {
          var path4 = parentPath.concat(index2);
          index2++;
          var op = {
            type: "insert_node",
            path: path4,
            node: _node
          };
          editor.apply(op);
          at2 = Path.next(at2);
          batchedOps.push(op);
          if (!Text.isText) {
            newDirtyPaths.push(path4);
          } else {
            newDirtyPaths.push(...Array.from(Node3.nodes(_node), (_ref) => {
              var [, p2] = _ref;
              return path4.concat(p2);
            }));
          }
        };
        for (var _node of nodes2) {
          _loop();
        }
      }, () => {
        updateDirtyPaths(editor, newDirtyPaths, (p2) => {
          var newPath = p2;
          for (var op of batchedOps) {
            if (Path.operationCanTransformPath(op)) {
              newPath = Path.transform(newPath, op);
              if (!newPath) {
                return null;
              }
            }
          }
          return newPath;
        });
      });
    } else {
      for (var _node2 of nodes2) {
        var _path = parentPath.concat(index2);
        index2++;
        editor.apply({
          type: "insert_node",
          path: _path,
          node: _node2
        });
        at2 = Path.next(at2);
      }
    }
    at2 = Path.previous(at2);
    if (select2) {
      var point3 = Editor.end(editor, at2);
      if (point3) {
        Transforms.select(editor, point3);
      }
    }
  });
};
var liftNodes = function liftNodes2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      at: at2 = editor.selection,
      mode = "lowest",
      voids = false
    } = options2;
    var {
      match
    } = options2;
    if (match == null) {
      match = Path.isPath(at2) ? matchPath(editor, at2) : (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
    }
    if (!at2) {
      return;
    }
    var matches = Editor.nodes(editor, {
      at: at2,
      match,
      mode,
      voids
    });
    var pathRefs2 = Array.from(matches, (_ref) => {
      var [, p2] = _ref;
      return Editor.pathRef(editor, p2);
    });
    for (var pathRef3 of pathRefs2) {
      var path3 = pathRef3.unref();
      if (path3.length < 2) {
        throw new Error("Cannot lift node at a path [".concat(path3, "] because it has a depth of less than `2`."));
      }
      var parentNodeEntry = Editor.node(editor, Path.parent(path3));
      var [parent3, parentPath] = parentNodeEntry;
      var index2 = path3[path3.length - 1];
      var {
        length
      } = parent3.children;
      if (length === 1) {
        var toPath = Path.next(parentPath);
        Transforms.moveNodes(editor, {
          at: path3,
          to: toPath,
          voids
        });
        Transforms.removeNodes(editor, {
          at: parentPath,
          voids
        });
      } else if (index2 === 0) {
        Transforms.moveNodes(editor, {
          at: path3,
          to: parentPath,
          voids
        });
      } else if (index2 === length - 1) {
        var _toPath = Path.next(parentPath);
        Transforms.moveNodes(editor, {
          at: path3,
          to: _toPath,
          voids
        });
      } else {
        var splitPath = Path.next(path3);
        var _toPath2 = Path.next(parentPath);
        Transforms.splitNodes(editor, {
          at: splitPath,
          voids
        });
        Transforms.moveNodes(editor, {
          at: path3,
          to: _toPath2,
          voids
        });
      }
    }
  });
};
var _excluded = ["text"];
var _excluded2 = ["children"];
var hasSingleChildNest = (editor, node3) => {
  if (Element2.isElement(node3)) {
    var element = node3;
    if (Editor.isVoid(editor, node3)) {
      return true;
    } else if (element.children.length === 1) {
      return hasSingleChildNest(editor, element.children[0]);
    } else {
      return false;
    }
  } else if (Editor.isEditor(node3)) {
    return false;
  } else {
    return true;
  }
};
var mergeNodes = function mergeNodes2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      match,
      at: at2 = editor.selection
    } = options2;
    var {
      hanging = false,
      voids = false,
      mode = "lowest"
    } = options2;
    if (!at2) {
      return;
    }
    if (match == null) {
      if (Path.isPath(at2)) {
        var [parent3] = Editor.parent(editor, at2);
        match = (n3) => parent3.children.includes(n3);
      } else {
        match = (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
      }
    }
    if (!hanging && Range.isRange(at2)) {
      at2 = Editor.unhangRange(editor, at2, {
        voids
      });
    }
    if (Range.isRange(at2)) {
      if (Range.isCollapsed(at2)) {
        at2 = at2.anchor;
      } else {
        var [, end2] = Range.edges(at2);
        var pointRef3 = Editor.pointRef(editor, end2);
        Transforms.delete(editor, {
          at: at2
        });
        at2 = pointRef3.unref();
        if (options2.at == null) {
          Transforms.select(editor, at2);
        }
      }
    }
    var [current2] = Editor.nodes(editor, {
      at: at2,
      match,
      voids,
      mode
    });
    var prev = Editor.previous(editor, {
      at: at2,
      match,
      voids,
      mode
    });
    if (!current2 || !prev) {
      return;
    }
    var [node3, path3] = current2;
    var [prevNode, prevPath] = prev;
    if (path3.length === 0 || prevPath.length === 0) {
      return;
    }
    var newPath = Path.next(prevPath);
    var commonPath = Path.common(path3, prevPath);
    var isPreviousSibling = Path.isSibling(path3, prevPath);
    var levels2 = Array.from(Editor.levels(editor, {
      at: path3
    }), (_ref) => {
      var [n3] = _ref;
      return n3;
    }).slice(commonPath.length).slice(0, -1);
    var emptyAncestor = Editor.above(editor, {
      at: path3,
      mode: "highest",
      match: (n3) => levels2.includes(n3) && hasSingleChildNest(editor, n3)
    });
    var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
    var properties;
    var position;
    if (Text.isText(node3) && Text.isText(prevNode)) {
      var rest = _objectWithoutProperties(node3, _excluded);
      position = prevNode.text.length;
      properties = rest;
    } else if (Element2.isElement(node3) && Element2.isElement(prevNode)) {
      var rest = _objectWithoutProperties(node3, _excluded2);
      position = prevNode.children.length;
      properties = rest;
    } else {
      throw new Error("Cannot merge the node at path [".concat(path3, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node3), " ").concat(Scrubber.stringify(prevNode)));
    }
    if (!isPreviousSibling) {
      Transforms.moveNodes(editor, {
        at: path3,
        to: newPath,
        voids
      });
    }
    if (emptyRef) {
      Transforms.removeNodes(editor, {
        at: emptyRef.current,
        voids
      });
    }
    if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current2)) {
      Transforms.removeNodes(editor, {
        at: prevPath,
        voids
      });
    } else {
      editor.apply({
        type: "merge_node",
        path: newPath,
        position,
        properties
      });
    }
    if (emptyRef) {
      emptyRef.unref();
    }
  });
};
var moveNodes = (editor, options2) => {
  Editor.withoutNormalizing(editor, () => {
    var {
      to,
      at: at2 = editor.selection,
      mode = "lowest",
      voids = false
    } = options2;
    var {
      match
    } = options2;
    if (!at2) {
      return;
    }
    if (match == null) {
      match = Path.isPath(at2) ? matchPath(editor, at2) : (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
    }
    var toRef = Editor.pathRef(editor, to);
    var targets = Editor.nodes(editor, {
      at: at2,
      match,
      mode,
      voids
    });
    var pathRefs2 = Array.from(targets, (_ref) => {
      var [, p2] = _ref;
      return Editor.pathRef(editor, p2);
    });
    for (var pathRef3 of pathRefs2) {
      var path3 = pathRef3.unref();
      var newPath = toRef.current;
      if (path3.length !== 0) {
        editor.apply({
          type: "move_node",
          path: path3,
          newPath
        });
      }
      if (toRef.current && Path.isSibling(newPath, path3) && Path.isAfter(newPath, path3)) {
        toRef.current = Path.next(toRef.current);
      }
    }
    toRef.unref();
  });
};
var removeNodes = function removeNodes2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      hanging = false,
      voids = false,
      mode = "lowest"
    } = options2;
    var {
      at: at2 = editor.selection,
      match
    } = options2;
    if (!at2) {
      return;
    }
    if (match == null) {
      match = Path.isPath(at2) ? matchPath(editor, at2) : (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
    }
    if (!hanging && Range.isRange(at2)) {
      at2 = Editor.unhangRange(editor, at2, {
        voids
      });
    }
    var depths = Editor.nodes(editor, {
      at: at2,
      match,
      mode,
      voids
    });
    var pathRefs2 = Array.from(depths, (_ref) => {
      var [, p2] = _ref;
      return Editor.pathRef(editor, p2);
    });
    for (var pathRef3 of pathRefs2) {
      var path3 = pathRef3.unref();
      if (path3) {
        var [node3] = Editor.node(editor, path3);
        editor.apply({
          type: "remove_node",
          path: path3,
          node: node3
        });
      }
    }
  });
};
var setNodes = function setNodes2(editor, props) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      match,
      at: at2 = editor.selection,
      compare,
      merge
    } = options2;
    var {
      hanging = false,
      mode = "lowest",
      split: split2 = false,
      voids = false
    } = options2;
    if (!at2) {
      return;
    }
    if (match == null) {
      match = Path.isPath(at2) ? matchPath(editor, at2) : (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
    }
    if (!hanging && Range.isRange(at2)) {
      at2 = Editor.unhangRange(editor, at2, {
        voids
      });
    }
    if (split2 && Range.isRange(at2)) {
      if (Range.isCollapsed(at2) && Editor.leaf(editor, at2.anchor)[0].text.length > 0) {
        return;
      }
      var rangeRef3 = Editor.rangeRef(editor, at2, {
        affinity: "inward"
      });
      var [start2, end2] = Range.edges(at2);
      var splitMode = mode === "lowest" ? "lowest" : "highest";
      var endAtEndOfNode = Editor.isEnd(editor, end2, end2.path);
      Transforms.splitNodes(editor, {
        at: end2,
        match,
        mode: splitMode,
        voids,
        always: !endAtEndOfNode
      });
      var startAtStartOfNode = Editor.isStart(editor, start2, start2.path);
      Transforms.splitNodes(editor, {
        at: start2,
        match,
        mode: splitMode,
        voids,
        always: !startAtStartOfNode
      });
      at2 = rangeRef3.unref();
      if (options2.at == null) {
        Transforms.select(editor, at2);
      }
    }
    if (!compare) {
      compare = (prop, nodeProp) => prop !== nodeProp;
    }
    for (var [node3, path3] of Editor.nodes(editor, {
      at: at2,
      match,
      mode,
      voids
    })) {
      var properties = {};
      var newProperties = {};
      if (path3.length === 0) {
        continue;
      }
      var hasChanges = false;
      for (var k3 in props) {
        if (k3 === "children" || k3 === "text") {
          continue;
        }
        if (compare(props[k3], node3[k3])) {
          hasChanges = true;
          if (node3.hasOwnProperty(k3)) properties[k3] = node3[k3];
          if (merge) {
            if (props[k3] != null) newProperties[k3] = merge(node3[k3], props[k3]);
          } else {
            if (props[k3] != null) newProperties[k3] = props[k3];
          }
        }
      }
      if (hasChanges) {
        editor.apply({
          type: "set_node",
          path: path3,
          properties,
          newProperties
        });
      }
    }
  });
};
var deleteRange = (editor, range2) => {
  if (Range.isCollapsed(range2)) {
    return range2.anchor;
  } else {
    var [, end2] = Range.edges(range2);
    var pointRef3 = Editor.pointRef(editor, end2);
    Transforms.delete(editor, {
      at: range2
    });
    return pointRef3.unref();
  }
};
var splitNodes = function splitNodes2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      mode = "lowest",
      voids = false
    } = options2;
    var {
      match,
      at: at2 = editor.selection,
      height = 0,
      always = false
    } = options2;
    if (match == null) {
      match = (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
    }
    if (Range.isRange(at2)) {
      at2 = deleteRange(editor, at2);
    }
    if (Path.isPath(at2)) {
      var path3 = at2;
      var point3 = Editor.point(editor, path3);
      var [parent3] = Editor.parent(editor, path3);
      match = (n3) => n3 === parent3;
      height = point3.path.length - path3.length + 1;
      at2 = point3;
      always = true;
    }
    if (!at2) {
      return;
    }
    var beforeRef = Editor.pointRef(editor, at2, {
      affinity: "backward"
    });
    var afterRef;
    try {
      var [highest] = Editor.nodes(editor, {
        at: at2,
        match,
        mode,
        voids
      });
      if (!highest) {
        return;
      }
      var voidMatch = Editor.void(editor, {
        at: at2,
        mode: "highest"
      });
      var nudge = 0;
      if (!voids && voidMatch) {
        var [voidNode, voidPath] = voidMatch;
        if (Element2.isElement(voidNode) && editor.isInline(voidNode)) {
          var after3 = Editor.after(editor, voidPath);
          if (!after3) {
            var text = {
              text: ""
            };
            var afterPath = Path.next(voidPath);
            Transforms.insertNodes(editor, text, {
              at: afterPath,
              voids
            });
            after3 = Editor.point(editor, afterPath);
          }
          at2 = after3;
          always = true;
        }
        var siblingHeight = at2.path.length - voidPath.length;
        height = siblingHeight + 1;
        always = true;
      }
      afterRef = Editor.pointRef(editor, at2);
      var depth = at2.path.length - height;
      var [, highestPath] = highest;
      var lowestPath = at2.path.slice(0, depth);
      var position = height === 0 ? at2.offset : at2.path[depth] + nudge;
      for (var [node3, _path] of Editor.levels(editor, {
        at: lowestPath,
        reverse: true,
        voids
      })) {
        var split2 = false;
        if (_path.length < highestPath.length || _path.length === 0 || !voids && Element2.isElement(node3) && Editor.isVoid(editor, node3)) {
          break;
        }
        var _point = beforeRef.current;
        var isEnd2 = Editor.isEnd(editor, _point, _path);
        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {
          split2 = true;
          var properties = Node3.extractProps(node3);
          editor.apply({
            type: "split_node",
            path: _path,
            position,
            properties
          });
        }
        position = _path[_path.length - 1] + (split2 || isEnd2 ? 1 : 0);
      }
      if (options2.at == null) {
        var _point2 = afterRef.current || Editor.end(editor, []);
        Transforms.select(editor, _point2);
      }
    } finally {
      var _afterRef;
      beforeRef.unref();
      (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();
    }
  });
};
var unsetNodes = function unsetNodes2(editor, props) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!Array.isArray(props)) {
    props = [props];
  }
  var obj = {};
  for (var key of props) {
    obj[key] = null;
  }
  Transforms.setNodes(editor, obj, options2);
};
var unwrapNodes = function unwrapNodes2(editor) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      mode = "lowest",
      split: split2 = false,
      voids = false
    } = options2;
    var {
      at: at2 = editor.selection,
      match
    } = options2;
    if (!at2) {
      return;
    }
    if (match == null) {
      match = Path.isPath(at2) ? matchPath(editor, at2) : (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
    }
    if (Path.isPath(at2)) {
      at2 = Editor.range(editor, at2);
    }
    var rangeRef3 = Range.isRange(at2) ? Editor.rangeRef(editor, at2) : null;
    var matches = Editor.nodes(editor, {
      at: at2,
      match,
      mode,
      voids
    });
    var pathRefs2 = Array.from(
      matches,
      (_ref) => {
        var [, p2] = _ref;
        return Editor.pathRef(editor, p2);
      }
      // unwrapNode will call liftNode which does not support splitting the node when nested.
      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
      // that wrap target node. So we reverse the order.
    ).reverse();
    var _loop = function _loop2() {
      var path3 = pathRef3.unref();
      var [node3] = Editor.node(editor, path3);
      var range2 = Editor.range(editor, path3);
      if (split2 && rangeRef3) {
        range2 = Range.intersection(rangeRef3.current, range2);
      }
      Transforms.liftNodes(editor, {
        at: range2,
        match: (n3) => Element2.isAncestor(node3) && node3.children.includes(n3),
        voids
      });
    };
    for (var pathRef3 of pathRefs2) {
      _loop();
    }
    if (rangeRef3) {
      rangeRef3.unref();
    }
  });
};
function ownKeys(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t3), true).forEach(function(r3) {
      _defineProperty(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var wrapNodes = function wrapNodes2(editor, element) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Editor.withoutNormalizing(editor, () => {
    var {
      mode = "lowest",
      split: split2 = false,
      voids = false
    } = options2;
    var {
      match,
      at: at2 = editor.selection
    } = options2;
    if (!at2) {
      return;
    }
    if (match == null) {
      if (Path.isPath(at2)) {
        match = matchPath(editor, at2);
      } else if (editor.isInline(element)) {
        match = (n3) => Element2.isElement(n3) && Editor.isInline(editor, n3) || Text.isText(n3);
      } else {
        match = (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3);
      }
    }
    if (split2 && Range.isRange(at2)) {
      var [start2, end2] = Range.edges(at2);
      var rangeRef3 = Editor.rangeRef(editor, at2, {
        affinity: "inward"
      });
      Transforms.splitNodes(editor, {
        at: end2,
        match,
        voids
      });
      Transforms.splitNodes(editor, {
        at: start2,
        match,
        voids
      });
      at2 = rangeRef3.unref();
      if (options2.at == null) {
        Transforms.select(editor, at2);
      }
    }
    var roots = Array.from(Editor.nodes(editor, {
      at: at2,
      match: editor.isInline(element) ? (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3) : (n3) => Editor.isEditor(n3),
      mode: "lowest",
      voids
    }));
    var _loop = function _loop2() {
      var a = Range.isRange(at2) ? Range.intersection(at2, Editor.range(editor, rootPath)) : at2;
      if (!a) {
        return 0;
      }
      var matches = Array.from(Editor.nodes(editor, {
        at: a,
        match,
        mode,
        voids
      }));
      if (matches.length > 0) {
        var [first2] = matches;
        var last2 = matches[matches.length - 1];
        var [, firstPath] = first2;
        var [, lastPath] = last2;
        if (firstPath.length === 0 && lastPath.length === 0) {
          return 0;
        }
        var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
        var range2 = Editor.range(editor, firstPath, lastPath);
        var commonNodeEntry = Editor.node(editor, commonPath);
        var [commonNode] = commonNodeEntry;
        var depth = commonPath.length + 1;
        var wrapperPath = Path.next(lastPath.slice(0, depth));
        var wrapper = _objectSpread(_objectSpread({}, element), {}, {
          children: []
        });
        Transforms.insertNodes(editor, wrapper, {
          at: wrapperPath,
          voids
        });
        Transforms.moveNodes(editor, {
          at: range2,
          match: (n3) => Element2.isAncestor(commonNode) && commonNode.children.includes(n3),
          to: wrapperPath.concat(0),
          voids
        });
      }
    }, _ret;
    for (var [, rootPath] of roots) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
  });
};
var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => false,
    isInline: () => false,
    isSelectable: () => true,
    isVoid: () => false,
    markableVoid: () => false,
    onChange: () => {
    },
    // Core
    apply: function apply$1() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return apply(editor, ...args);
    },
    // Editor
    addMark: function addMark$1() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return addMark(editor, ...args);
    },
    deleteBackward: function deleteBackward$1() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return deleteBackward(editor, ...args);
    },
    deleteForward: function deleteForward$1() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return deleteForward(editor, ...args);
    },
    deleteFragment: function deleteFragment$1() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return deleteFragment(editor, ...args);
    },
    getFragment: function getFragment$1() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return getFragment(editor, ...args);
    },
    insertBreak: function insertBreak$1() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return insertBreak(editor, ...args);
    },
    insertSoftBreak: function insertSoftBreak$1() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return insertSoftBreak(editor, ...args);
    },
    insertFragment: function insertFragment$1() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return insertFragment(editor, ...args);
    },
    insertNode: function insertNode$1() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return insertNode(editor, ...args);
    },
    insertText: function insertText$1() {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return insertText(editor, ...args);
    },
    normalizeNode: function normalizeNode$1() {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return normalizeNode(editor, ...args);
    },
    removeMark: function removeMark$1() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return removeMark(editor, ...args);
    },
    getDirtyPaths: function getDirtyPaths$1() {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return getDirtyPaths(editor, ...args);
    },
    shouldNormalize: function shouldNormalize$1() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return shouldNormalize(editor, ...args);
    },
    // Editor interface
    above: function above$1() {
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return above(editor, ...args);
    },
    after: function after$1() {
      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
        args[_key17] = arguments[_key17];
      }
      return after(editor, ...args);
    },
    before: function before$1() {
      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        args[_key18] = arguments[_key18];
      }
      return before(editor, ...args);
    },
    collapse: function collapse$1() {
      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        args[_key19] = arguments[_key19];
      }
      return collapse(editor, ...args);
    },
    delete: function _delete() {
      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        args[_key20] = arguments[_key20];
      }
      return deleteText(editor, ...args);
    },
    deselect: function deselect$1() {
      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
        args[_key21] = arguments[_key21];
      }
      return deselect(editor, ...args);
    },
    edges: function edges$1() {
      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }
      return edges(editor, ...args);
    },
    elementReadOnly: function elementReadOnly$1() {
      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
        args[_key23] = arguments[_key23];
      }
      return elementReadOnly(editor, ...args);
    },
    end: function end$1() {
      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
        args[_key24] = arguments[_key24];
      }
      return end(editor, ...args);
    },
    first: function first$1() {
      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
        args[_key25] = arguments[_key25];
      }
      return first(editor, ...args);
    },
    fragment: function fragment$1() {
      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
        args[_key26] = arguments[_key26];
      }
      return fragment(editor, ...args);
    },
    getMarks: function getMarks() {
      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
        args[_key27] = arguments[_key27];
      }
      return marks(editor, ...args);
    },
    hasBlocks: function hasBlocks$1() {
      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {
        args[_key28] = arguments[_key28];
      }
      return hasBlocks(editor, ...args);
    },
    hasInlines: function hasInlines$1() {
      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {
        args[_key29] = arguments[_key29];
      }
      return hasInlines(editor, ...args);
    },
    hasPath: function hasPath$1() {
      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {
        args[_key30] = arguments[_key30];
      }
      return hasPath(editor, ...args);
    },
    hasTexts: function hasTexts$1() {
      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {
        args[_key31] = arguments[_key31];
      }
      return hasTexts(editor, ...args);
    },
    insertNodes: function insertNodes$1() {
      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {
        args[_key32] = arguments[_key32];
      }
      return insertNodes(editor, ...args);
    },
    isBlock: function isBlock$1() {
      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {
        args[_key33] = arguments[_key33];
      }
      return isBlock(editor, ...args);
    },
    isEdge: function isEdge$1() {
      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {
        args[_key34] = arguments[_key34];
      }
      return isEdge(editor, ...args);
    },
    isEmpty: function isEmpty$1() {
      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {
        args[_key35] = arguments[_key35];
      }
      return isEmpty(editor, ...args);
    },
    isEnd: function isEnd$1() {
      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {
        args[_key36] = arguments[_key36];
      }
      return isEnd(editor, ...args);
    },
    isNormalizing: function isNormalizing$1() {
      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {
        args[_key37] = arguments[_key37];
      }
      return isNormalizing(editor, ...args);
    },
    isStart: function isStart$1() {
      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {
        args[_key38] = arguments[_key38];
      }
      return isStart(editor, ...args);
    },
    last: function last$1() {
      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {
        args[_key39] = arguments[_key39];
      }
      return last(editor, ...args);
    },
    leaf: function leaf$1() {
      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {
        args[_key40] = arguments[_key40];
      }
      return leaf(editor, ...args);
    },
    levels: function levels$1() {
      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {
        args[_key41] = arguments[_key41];
      }
      return levels(editor, ...args);
    },
    liftNodes: function liftNodes$1() {
      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {
        args[_key42] = arguments[_key42];
      }
      return liftNodes(editor, ...args);
    },
    mergeNodes: function mergeNodes$1() {
      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {
        args[_key43] = arguments[_key43];
      }
      return mergeNodes(editor, ...args);
    },
    move: function move$1() {
      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {
        args[_key44] = arguments[_key44];
      }
      return move(editor, ...args);
    },
    moveNodes: function moveNodes$1() {
      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {
        args[_key45] = arguments[_key45];
      }
      return moveNodes(editor, ...args);
    },
    next: function next$1() {
      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {
        args[_key46] = arguments[_key46];
      }
      return next(editor, ...args);
    },
    node: function node$1() {
      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {
        args[_key47] = arguments[_key47];
      }
      return node(editor, ...args);
    },
    nodes: function nodes$1() {
      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {
        args[_key48] = arguments[_key48];
      }
      return nodes(editor, ...args);
    },
    normalize: function normalize$1() {
      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {
        args[_key49] = arguments[_key49];
      }
      return normalize(editor, ...args);
    },
    parent: function parent$1() {
      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {
        args[_key50] = arguments[_key50];
      }
      return parent(editor, ...args);
    },
    path: function path$1() {
      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {
        args[_key51] = arguments[_key51];
      }
      return path(editor, ...args);
    },
    pathRef: function pathRef$1() {
      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {
        args[_key52] = arguments[_key52];
      }
      return pathRef(editor, ...args);
    },
    pathRefs: function pathRefs$1() {
      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {
        args[_key53] = arguments[_key53];
      }
      return pathRefs(editor, ...args);
    },
    point: function point$1() {
      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {
        args[_key54] = arguments[_key54];
      }
      return point(editor, ...args);
    },
    pointRef: function pointRef$1() {
      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {
        args[_key55] = arguments[_key55];
      }
      return pointRef(editor, ...args);
    },
    pointRefs: function pointRefs$1() {
      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {
        args[_key56] = arguments[_key56];
      }
      return pointRefs(editor, ...args);
    },
    positions: function positions$1() {
      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {
        args[_key57] = arguments[_key57];
      }
      return positions(editor, ...args);
    },
    previous: function previous$1() {
      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {
        args[_key58] = arguments[_key58];
      }
      return previous(editor, ...args);
    },
    range: function range$1() {
      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {
        args[_key59] = arguments[_key59];
      }
      return range(editor, ...args);
    },
    rangeRef: function rangeRef$1() {
      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {
        args[_key60] = arguments[_key60];
      }
      return rangeRef(editor, ...args);
    },
    rangeRefs: function rangeRefs$1() {
      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {
        args[_key61] = arguments[_key61];
      }
      return rangeRefs(editor, ...args);
    },
    removeNodes: function removeNodes$1() {
      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {
        args[_key62] = arguments[_key62];
      }
      return removeNodes(editor, ...args);
    },
    select: function select$1() {
      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {
        args[_key63] = arguments[_key63];
      }
      return select(editor, ...args);
    },
    setNodes: function setNodes$1() {
      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {
        args[_key64] = arguments[_key64];
      }
      return setNodes(editor, ...args);
    },
    setNormalizing: function setNormalizing$1() {
      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {
        args[_key65] = arguments[_key65];
      }
      return setNormalizing(editor, ...args);
    },
    setPoint: function setPoint$1() {
      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {
        args[_key66] = arguments[_key66];
      }
      return setPoint(editor, ...args);
    },
    setSelection: function setSelection$1() {
      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {
        args[_key67] = arguments[_key67];
      }
      return setSelection(editor, ...args);
    },
    splitNodes: function splitNodes$1() {
      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {
        args[_key68] = arguments[_key68];
      }
      return splitNodes(editor, ...args);
    },
    start: function start$1() {
      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {
        args[_key69] = arguments[_key69];
      }
      return start(editor, ...args);
    },
    string: function string$1() {
      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {
        args[_key70] = arguments[_key70];
      }
      return string(editor, ...args);
    },
    unhangRange: function unhangRange$1() {
      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {
        args[_key71] = arguments[_key71];
      }
      return unhangRange(editor, ...args);
    },
    unsetNodes: function unsetNodes$1() {
      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {
        args[_key72] = arguments[_key72];
      }
      return unsetNodes(editor, ...args);
    },
    unwrapNodes: function unwrapNodes$1() {
      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {
        args[_key73] = arguments[_key73];
      }
      return unwrapNodes(editor, ...args);
    },
    void: function _void() {
      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {
        args[_key74] = arguments[_key74];
      }
      return getVoid(editor, ...args);
    },
    withoutNormalizing: function withoutNormalizing$1() {
      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {
        args[_key75] = arguments[_key75];
      }
      return withoutNormalizing(editor, ...args);
    },
    wrapNodes: function wrapNodes$1() {
      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {
        args[_key76] = arguments[_key76];
      }
      return wrapNodes(editor, ...args);
    },
    shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {
      for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {
        args[_key77] = arguments[_key77];
      }
      return shouldMergeNodesRemovePrevNode(editor, ...args);
    }
  };
  return editor;
};

// node_modules/slate-history/dist/index.es.js
var History = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(value) {
    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0].operations));
  }
};
var SAVING = /* @__PURE__ */ new WeakMap();
var MERGING = /* @__PURE__ */ new WeakMap();
var SPLITTING_ONCE = /* @__PURE__ */ new WeakMap();
var HistoryEditor = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(value) {
    return History.isHistory(value.history) && Editor.isEditor(value);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(editor) {
    return MERGING.get(editor);
  },
  /**
   * Get the splitting once flag's current value.
   */
  isSplittingOnce(editor) {
    return SPLITTING_ONCE.get(editor);
  },
  setSplittingOnce(editor, value) {
    SPLITTING_ONCE.set(editor, value);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(editor) {
    return SAVING.get(editor);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(editor) {
    editor.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(editor) {
    editor.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(editor, fn) {
    var prev = HistoryEditor.isMerging(editor);
    MERGING.set(editor, true);
    fn();
    MERGING.set(editor, prev);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, ensuring that the first
   * operation starts a new batch in the history. Subsequent operations will be
   * merged as usual.
   */
  withNewBatch(editor, fn) {
    var prev = HistoryEditor.isMerging(editor);
    MERGING.set(editor, true);
    SPLITTING_ONCE.set(editor, true);
    fn();
    MERGING.set(editor, prev);
    SPLITTING_ONCE.delete(editor);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(editor, fn) {
    var prev = HistoryEditor.isMerging(editor);
    MERGING.set(editor, false);
    fn();
    MERGING.set(editor, prev);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(editor, fn) {
    var prev = HistoryEditor.isSaving(editor);
    SAVING.set(editor, false);
    fn();
    SAVING.set(editor, prev);
  }
};
var withHistory = (editor) => {
  var e3 = editor;
  var {
    apply: apply2
  } = e3;
  e3.history = {
    undos: [],
    redos: []
  };
  e3.redo = () => {
    var {
      history
    } = e3;
    var {
      redos
    } = history;
    if (redos.length > 0) {
      var batch = redos[redos.length - 1];
      if (batch.selectionBefore) {
        Transforms.setSelection(e3, batch.selectionBefore);
      }
      HistoryEditor.withoutSaving(e3, () => {
        Editor.withoutNormalizing(e3, () => {
          for (var op of batch.operations) {
            e3.apply(op);
          }
        });
      });
      history.redos.pop();
      e3.writeHistory("undos", batch);
    }
  };
  e3.undo = () => {
    var {
      history
    } = e3;
    var {
      undos
    } = history;
    if (undos.length > 0) {
      var batch = undos[undos.length - 1];
      HistoryEditor.withoutSaving(e3, () => {
        Editor.withoutNormalizing(e3, () => {
          var inverseOps = batch.operations.map(Operation.inverse).reverse();
          for (var op of inverseOps) {
            e3.apply(op);
          }
          if (batch.selectionBefore) {
            Transforms.setSelection(e3, batch.selectionBefore);
          }
        });
      });
      e3.writeHistory("redos", batch);
      history.undos.pop();
    }
  };
  e3.apply = (op) => {
    var {
      operations,
      history
    } = e3;
    var {
      undos
    } = history;
    var lastBatch = undos[undos.length - 1];
    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];
    var save = HistoryEditor.isSaving(e3);
    var merge = HistoryEditor.isMerging(e3);
    if (save == null) {
      save = shouldSave(op);
    }
    if (save) {
      if (merge == null) {
        if (lastBatch == null) {
          merge = false;
        } else if (operations.length !== 0) {
          merge = true;
        } else {
          merge = shouldMerge(op, lastOp);
        }
      }
      if (HistoryEditor.isSplittingOnce(e3)) {
        merge = false;
        HistoryEditor.setSplittingOnce(e3, void 0);
      }
      if (lastBatch && merge) {
        lastBatch.operations.push(op);
      } else {
        var batch = {
          operations: [op],
          selectionBefore: e3.selection
        };
        e3.writeHistory("undos", batch);
      }
      while (undos.length > 100) {
        undos.shift();
      }
      history.redos = [];
    }
    apply2(op);
  };
  e3.writeHistory = (stack, batch) => {
    e3.history[stack].push(batch);
  };
  return e3;
};
var shouldMerge = (op, prev) => {
  if (prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {
    return true;
  }
  if (prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {
    return true;
  }
  return false;
};
var shouldSave = (op, prev) => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};

// node_modules/slate-react/dist/index.es.js
var import_direction = __toESM(require_direction());
var import_debounce = __toESM(require_debounce());
var import_throttle = __toESM(require_throttle());
var import_react27 = __toESM(require_react());

// node_modules/compute-scroll-into-view/dist/index.js
var t = (t3) => "object" == typeof t3 && null != t3 && 1 === t3.nodeType;
var e = (t3, e3) => (!e3 || "hidden" !== t3) && ("visible" !== t3 && "clip" !== t3);
var n = (t3, n3) => {
  if (t3.clientHeight < t3.scrollHeight || t3.clientWidth < t3.scrollWidth) {
    const o3 = getComputedStyle(t3, null);
    return e(o3.overflowY, n3) || e(o3.overflowX, n3) || ((t4) => {
      const e3 = ((t5) => {
        if (!t5.ownerDocument || !t5.ownerDocument.defaultView) return null;
        try {
          return t5.ownerDocument.defaultView.frameElement;
        } catch (t6) {
          return null;
        }
      })(t4);
      return !!e3 && (e3.clientHeight < t4.scrollHeight || e3.clientWidth < t4.scrollWidth);
    })(t3);
  }
  return false;
};
var o = (t3, e3, n3, o3, l2, r2, i, s) => r2 < t3 && i > e3 || r2 > t3 && i < e3 ? 0 : r2 <= t3 && s <= n3 || i >= e3 && s >= n3 ? r2 - t3 - o3 : i > e3 && s < n3 || r2 < t3 && s > n3 ? i - e3 + l2 : 0;
var l = (t3) => {
  const e3 = t3.parentElement;
  return null == e3 ? t3.getRootNode().host || null : e3;
};
var r = (e3, r2) => {
  var i, s, d, h;
  if ("undefined" == typeof document) return [];
  const { scrollMode: c, block: f, inline: u2, boundary: a, skipOverflowHiddenElements: g } = r2, p2 = "function" == typeof a ? a : (t3) => t3 !== a;
  if (!t(e3)) throw new TypeError("Invalid target");
  const m2 = document.scrollingElement || document.documentElement, w = [];
  let W3 = e3;
  for (; t(W3) && p2(W3); ) {
    if (W3 = l(W3), W3 === m2) {
      w.push(W3);
      break;
    }
    null != W3 && W3 === document.body && n(W3) && !n(document.documentElement) || null != W3 && n(W3, g) && w.push(W3);
  }
  const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H2 = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M2 } = window, { height: v2, width: E2, top: x2, right: C2, bottom: I2, left: R } = e3.getBoundingClientRect(), { top: T2, right: B4, bottom: F2, left: V2 } = ((t3) => {
    const e4 = window.getComputedStyle(t3);
    return { top: parseFloat(e4.scrollMarginTop) || 0, right: parseFloat(e4.scrollMarginRight) || 0, bottom: parseFloat(e4.scrollMarginBottom) || 0, left: parseFloat(e4.scrollMarginLeft) || 0 };
  })(e3);
  let k3 = "start" === f || "nearest" === f ? x2 - T2 : "end" === f ? I2 + F2 : x2 + v2 / 2 - T2 + F2, D3 = "center" === u2 ? R + E2 / 2 - V2 + B4 : "end" === u2 ? C2 + B4 : R - V2;
  const L3 = [];
  for (let t3 = 0; t3 < w.length; t3++) {
    const e4 = w[t3], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h2 } = e4.getBoundingClientRect();
    if ("if-needed" === c && x2 >= 0 && R >= 0 && I2 <= H2 && C2 <= b && (e4 === m2 && !n(e4) || x2 >= i2 && I2 <= d2 && R >= h2 && C2 <= s2)) return L3;
    const a2 = getComputedStyle(e4), g2 = parseInt(a2.borderLeftWidth, 10), p3 = parseInt(a2.borderTopWidth, 10), W4 = parseInt(a2.borderRightWidth, 10), T3 = parseInt(a2.borderBottomWidth, 10);
    let B5 = 0, F3 = 0;
    const V3 = "offsetWidth" in e4 ? e4.offsetWidth - e4.clientWidth - g2 - W4 : 0, S = "offsetHeight" in e4 ? e4.offsetHeight - e4.clientHeight - p3 - T3 : 0, X3 = "offsetWidth" in e4 ? 0 === e4.offsetWidth ? 0 : r3 / e4.offsetWidth : 0, Y3 = "offsetHeight" in e4 ? 0 === e4.offsetHeight ? 0 : l2 / e4.offsetHeight : 0;
    if (m2 === e4) B5 = "start" === f ? k3 : "end" === f ? k3 - H2 : "nearest" === f ? o(M2, M2 + H2, H2, p3, T3, M2 + k3, M2 + k3 + v2, v2) : k3 - H2 / 2, F3 = "start" === u2 ? D3 : "center" === u2 ? D3 - b / 2 : "end" === u2 ? D3 - b : o(y, y + b, b, g2, W4, y + D3, y + D3 + E2, E2), B5 = Math.max(0, B5 + M2), F3 = Math.max(0, F3 + y);
    else {
      B5 = "start" === f ? k3 - i2 - p3 : "end" === f ? k3 - d2 + T3 + S : "nearest" === f ? o(i2, d2, l2, p3, T3 + S, k3, k3 + v2, v2) : k3 - (i2 + l2 / 2) + S / 2, F3 = "start" === u2 ? D3 - h2 - g2 : "center" === u2 ? D3 - (h2 + r3 / 2) + V3 / 2 : "end" === u2 ? D3 - s2 + W4 + V3 : o(h2, s2, r3, g2, W4 + V3, D3, D3 + E2, E2);
      const { scrollLeft: t4, scrollTop: n3 } = e4;
      B5 = 0 === Y3 ? 0 : Math.max(0, Math.min(n3 + B5 / Y3, e4.scrollHeight - l2 / Y3 + S)), F3 = 0 === X3 ? 0 : Math.max(0, Math.min(t4 + F3 / X3, e4.scrollWidth - r3 / X3 + V3)), k3 += n3 - B5, D3 += t4 - F3;
    }
    L3.push({ el: e4, top: B5, left: F3 });
  }
  return L3;
};

// node_modules/scroll-into-view-if-needed/dist/index.js
var o2 = (t3) => false === t3 ? { block: "end", inline: "nearest" } : ((t4) => t4 === Object(t4) && 0 !== Object.keys(t4).length)(t3) ? t3 : { block: "start", inline: "nearest" };
function e2(e3, r2) {
  if (!e3.isConnected || !((t3) => {
    let o3 = t3;
    for (; o3 && o3.parentNode; ) {
      if (o3.parentNode === document) return true;
      o3 = o3.parentNode instanceof ShadowRoot ? o3.parentNode.host : o3.parentNode;
    }
    return false;
  })(e3)) return;
  const n3 = ((t3) => {
    const o3 = window.getComputedStyle(t3);
    return { top: parseFloat(o3.scrollMarginTop) || 0, right: parseFloat(o3.scrollMarginRight) || 0, bottom: parseFloat(o3.scrollMarginBottom) || 0, left: parseFloat(o3.scrollMarginLeft) || 0 };
  })(e3);
  if (((t3) => "object" == typeof t3 && "function" == typeof t3.behavior)(r2)) return r2.behavior(r(e3, r2));
  const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
  for (const { el: a, top: i, left: s } of r(e3, o2(r2))) {
    const t3 = i - n3.top + n3.bottom, o3 = s - n3.left + n3.right;
    a.scroll({ top: t3, left: o3, behavior: l2 });
  }
}

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze2 = function(obj) {
  return Object.freeze(obj);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = /* @__PURE__ */ (function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze2(this);
  }
  return ResizeObserverSize2;
})();

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = (function() {
  function DOMRectReadOnly2(x2, y, width, height) {
    this.x = x2;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze2(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a3 = this, x2 = _a3.x, y = _a3.y, top = _a3.top, right = _a3.right, bottom = _a3.bottom, left = _a3.left, width = _a3.width, height = _a3.height;
    return { x: x2, y, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
})();

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a3 = target.getBBox(), width = _a3.width, height = _a3.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement3 = function(obj) {
  var _a3;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a3 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global2 = typeof window !== "undefined" ? window : {};

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size4 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze2({
  devicePixelContentBoxSize: size4(),
  borderBoxSize: size4(),
  contentBoxSize: size4(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze2({
    devicePixelContentBoxSize: size4(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size4(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size4(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a3 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a3.borderBoxSize, contentBoxSize = _a3.contentBoxSize, devicePixelContentBoxSize = _a3.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = /* @__PURE__ */ (function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze2([boxes.borderBoxSize]);
    this.contentBoxSize = freeze2([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze2([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
})();

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node3) {
  if (isHidden(node3)) {
    return Infinity;
  }
  var depth = 0;
  var parent3 = node3.parentNode;
  while (parent3) {
    depth += 1;
    parent3 = parent3.parentNode;
  }
  return depth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot2) {
      var entry = new ResizeObserverEntry(ot2.target);
      var targetDepth = calculateDepthForNode(ot2.target);
      entries.push(entry);
      ot2.lastReportedSize = calculateBoxSize(ot2.target, ot2.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot2) {
      if (ot2.isActive()) {
        if (calculateDepthForNode(ot2.target) > depth) {
          ro.activeTargets.push(ot2);
        } else {
          ro.skippedTargets.push(ot2);
        }
      }
    });
  });
};

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver3() {
    requestAnimationFrame(cb);
  });
};

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = (function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global2.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global2.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global2.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
})();
var scheduler = new Scheduler();
var updateCount = function(n3) {
  !watching && n3 > 0 && scheduler.start();
  watching += n3;
  !watching && scheduler.stop();
};

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = (function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size5 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size5;
    }
    if (this.lastReportedSize.inlineSize !== size5.inlineSize || this.lastReportedSize.blockSize !== size5.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
})();

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = /* @__PURE__ */ (function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
})();

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = (function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options2) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options2 && options2.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot2) {
      return _this.unobserve(resizeObserver, ot2.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
})();

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver2 = (function() {
  function ResizeObserver3(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver3.prototype.observe = function(target, options2) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement3(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options2);
  };
  ResizeObserver3.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement3(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver3.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver3.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver3;
})();

// node_modules/slate-react/dist/index.es.js
var import_is_hotkey = __toESM(require_lib());
var import_react_dom3 = __toESM(require_react_dom());
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _typeof2(o3) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof2(o3);
}
function _toPrimitive2(input, hint) {
  if (_typeof2(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof2(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof2(key) === "symbol" ? key : String(key);
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EditorContext = (0, import_react27.createContext)(null);
var useSlateStatic = () => {
  var editor = (0, import_react27.useContext)(EditorContext);
  if (!editor) {
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  }
  return editor;
};
var _navigator$userAgent$;
var _navigator$userAgent$2;
var REACT_MAJOR_VERSION = parseInt(import_react27.default.version.split(".")[0], 10);
var IS_IOS = typeof navigator !== "undefined" && typeof window !== "undefined" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
var IS_ANDROID = typeof navigator !== "undefined" && /Android/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_WEBKIT = typeof navigator !== "undefined" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);
var IS_EDGE_LEGACY = typeof navigator !== "undefined" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== "undefined" && /Chrome/i.test(navigator.userAgent);
var IS_CHROME_LEGACY = typeof navigator !== "undefined" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent);
var IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== "undefined" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent);
var IS_FIREFOX_LEGACY = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
var IS_UC_MOBILE = typeof navigator !== "undefined" && /.*UCBrowser/.test(navigator.userAgent);
var IS_WECHATBROWSER = typeof navigator !== "undefined" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent);
var CAN_USE_DOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\/(\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\/(\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);
var HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
typeof globalThis !== "undefined" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges === "function";
var IS_NODE_MAP_DIRTY = /* @__PURE__ */ new WeakMap();
var NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();
var NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_WINDOW = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PLACEHOLDER_ELEMENT = /* @__PURE__ */ new WeakMap();
var ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();
var NODE_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var NODE_TO_KEY = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_KEY_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var IS_READ_ONLY = /* @__PURE__ */ new WeakMap();
var IS_FOCUSED = /* @__PURE__ */ new WeakMap();
var IS_COMPOSING = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_SCHEDULE_FLUSH = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_INSERTION_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_DIFFS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_ACTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_FORCE_RENDER = /* @__PURE__ */ new WeakMap();
var PLACEHOLDER_SYMBOL = Symbol("placeholder");
var MARK_PLACEHOLDER_SYMBOL = Symbol("mark-placeholder");
var DOMNode = globalThis.Node;
var DOMText = globalThis.Text;
var getDefaultView = (value) => {
  return value && value.ownerDocument && value.ownerDocument.defaultView || null;
};
var isDOMComment = (value) => {
  return isDOMNode(value) && value.nodeType === 8;
};
var isDOMElement = (value) => {
  return isDOMNode(value) && value.nodeType === 1;
};
var isDOMNode = (value) => {
  var window2 = getDefaultView(value);
  return !!window2 && value instanceof window2.Node;
};
var isDOMSelection = (value) => {
  var window2 = value && value.anchorNode && getDefaultView(value.anchorNode);
  return !!window2 && value instanceof window2.Selection;
};
var isDOMText = (value) => {
  return isDOMNode(value) && value.nodeType === 3;
};
var isPlainTextOnlyPaste = (event) => {
  return event.clipboardData && event.clipboardData.getData("text/plain") !== "" && event.clipboardData.types.length === 1;
};
var normalizeDOMPoint = (domPoint) => {
  var [node3, offset4] = domPoint;
  if (isDOMElement(node3) && node3.childNodes.length) {
    var isLast = offset4 === node3.childNodes.length;
    var index2 = isLast ? offset4 - 1 : offset4;
    [node3, index2] = getEditableChildAndIndex(node3, index2, isLast ? "backward" : "forward");
    isLast = index2 < offset4;
    while (isDOMElement(node3) && node3.childNodes.length) {
      var i = isLast ? node3.childNodes.length - 1 : 0;
      node3 = getEditableChild(node3, i, isLast ? "backward" : "forward");
    }
    offset4 = isLast && node3.textContent != null ? node3.textContent.length : 0;
  }
  return [node3, offset4];
};
var hasShadowRoot = (node3) => {
  var parent3 = node3 && node3.parentNode;
  while (parent3) {
    if (parent3.toString() === "[object ShadowRoot]") {
      return true;
    }
    parent3 = parent3.parentNode;
  }
  return false;
};
var getEditableChildAndIndex = (parent3, index2, direction) => {
  var {
    childNodes
  } = parent3;
  var child = childNodes[index2];
  var i = index2;
  var triedForward = false;
  var triedBackward = false;
  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute("contenteditable") === "false") {
    if (triedForward && triedBackward) {
      break;
    }
    if (i >= childNodes.length) {
      triedForward = true;
      i = index2 - 1;
      direction = "backward";
      continue;
    }
    if (i < 0) {
      triedBackward = true;
      i = index2 + 1;
      direction = "forward";
      continue;
    }
    child = childNodes[i];
    index2 = i;
    i += direction === "forward" ? 1 : -1;
  }
  return [child, index2];
};
var getEditableChild = (parent3, index2, direction) => {
  var [child] = getEditableChildAndIndex(parent3, index2, direction);
  return child;
};
var getPlainText = (domNode) => {
  var text = "";
  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text += getPlainText(childNode);
    }
    var display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text += "\n";
    }
  }
  return text;
};
var catchSlateFragment = /data-slate-fragment="(.+?)"/m;
var getSlateFragmentAttribute = (dataTransfer) => {
  var htmlData = dataTransfer.getData("text/html");
  var [, fragment2] = htmlData.match(catchSlateFragment) || [];
  return fragment2;
};
var getSelection = (root) => {
  if (root.getSelection != null) {
    return root.getSelection();
  }
  return document.getSelection();
};
var isTrackedMutation = (editor, mutation, batch) => {
  var {
    target
  } = mutation;
  if (isDOMElement(target) && target.matches('[contentEditable="false"]')) {
    return false;
  }
  var {
    document: document2
  } = ReactEditor.getWindow(editor);
  if (document2.contains(target)) {
    return ReactEditor.hasDOMNode(editor, target, {
      editable: true
    });
  }
  var parentMutation = batch.find((_ref) => {
    var {
      addedNodes,
      removedNodes
    } = _ref;
    for (var node3 of addedNodes) {
      if (node3 === target || node3.contains(target)) {
        return true;
      }
    }
    for (var _node of removedNodes) {
      if (_node === target || _node.contains(target)) {
        return true;
      }
    }
  });
  if (!parentMutation || parentMutation === mutation) {
    return false;
  }
  return isTrackedMutation(editor, parentMutation, batch);
};
var getActiveElement = () => {
  var activeElement = document.activeElement;
  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {
    var _activeElement, _activeElement$shadow, _activeElement2;
    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;
  }
  return activeElement;
};
var isBefore = (node3, otherNode) => Boolean(node3.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);
var isAfter = (node3, otherNode) => Boolean(node3.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);
var n2 = 0;
var Key = class {
  constructor() {
    _defineProperty2(this, "id", void 0);
    this.id = "".concat(n2++);
  }
};
var ReactEditor = {
  androidPendingDiffs: (editor) => EDITOR_TO_PENDING_DIFFS.get(editor),
  androidScheduleFlush: (editor) => {
    var _EDITOR_TO_SCHEDULE_F;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();
  },
  blur: (editor) => {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, false);
    if (root.activeElement === el) {
      el.blur();
    }
  },
  deselect: (editor) => {
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = getSelection(root);
    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }
    if (selection) {
      Transforms.deselect(editor);
    }
  },
  findDocumentOrShadowRoot: (editor) => {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = el.getRootNode();
    if (root instanceof Document || root instanceof ShadowRoot) {
      return root;
    }
    return el.ownerDocument;
  },
  findEventRange: (editor, event) => {
    if ("nativeEvent" in event) {
      event = event.nativeEvent;
    }
    var {
      clientX: x2,
      clientY: y,
      target
    } = event;
    if (x2 == null || y == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var node3 = ReactEditor.toSlateNode(editor, event.target);
    var path3 = ReactEditor.findPath(editor, node3);
    if (Element2.isElement(node3) && Editor.isVoid(editor, node3)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node3) ? x2 - rect.left < rect.left + rect.width - x2 : y - rect.top < rect.top + rect.height - y;
      var edge = Editor.point(editor, path3, {
        edge: isPrev ? "start" : "end"
      });
      var point3 = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);
      if (point3) {
        var _range = Editor.range(editor, point3);
        return _range;
      }
    }
    var domRange;
    var {
      document: document2
    } = ReactEditor.getWindow(editor);
    if (document2.caretRangeFromPoint) {
      domRange = document2.caretRangeFromPoint(x2, y);
    } else {
      var position = document2.caretPositionFromPoint(x2, y);
      if (position) {
        domRange = document2.createRange();
        domRange.setStart(position.offsetNode, position.offset);
        domRange.setEnd(position.offsetNode, position.offset);
      }
    }
    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var range2 = ReactEditor.toSlateRange(editor, domRange, {
      exactMatch: false,
      suppressThrow: false
    });
    return range2;
  },
  findKey: (editor, node3) => {
    var key = NODE_TO_KEY.get(node3);
    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node3, key);
    }
    return key;
  },
  findPath: (editor, node3) => {
    var path3 = [];
    var child = node3;
    while (true) {
      var parent3 = NODE_TO_PARENT.get(child);
      if (parent3 == null) {
        if (Editor.isEditor(child)) {
          return path3;
        } else {
          break;
        }
      }
      var i = NODE_TO_INDEX.get(child);
      if (i == null) {
        break;
      }
      path3.unshift(i);
      child = parent3;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Scrubber.stringify(node3)));
  },
  focus: function focus(editor) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (IS_FOCUSED.get(editor)) {
      return;
    }
    if (options2.retries <= 0) {
      throw new Error("Could not set focus, editor seems stuck with pending operations");
    }
    if (editor.operations.length > 0) {
      setTimeout(() => {
        ReactEditor.focus(editor, {
          retries: options2.retries - 1
        });
      }, 10);
      return;
    }
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    if (root.activeElement !== el) {
      if (editor.selection && root instanceof Document) {
        var domSelection = getSelection(root);
        var domRange = ReactEditor.toDOMRange(editor, editor.selection);
        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();
        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);
      }
      if (!editor.selection) {
        Transforms.select(editor, Editor.start(editor, []));
      }
      IS_FOCUSED.set(editor, true);
      el.focus({
        preventScroll: true
      });
    }
  },
  getWindow: (editor) => {
    var window2 = EDITOR_TO_WINDOW.get(editor);
    if (!window2) {
      throw new Error("Unable to find a host window element for this editor");
    }
    return window2;
  },
  hasDOMNode: function hasDOMNode(editor, target) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      editable = false
    } = options2;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl;
    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (err instanceof Error && !err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }
    if (!targetEl) {
      return false;
    }
    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute("data-slate-zero-width"));
  },
  hasEditableTarget: (editor, target) => isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
    editable: true
  }),
  hasRange: (editor, range2) => {
    var {
      anchor,
      focus: focus3
    } = range2;
    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus3.path);
  },
  hasSelectableTarget: (editor, target) => ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target),
  hasTarget: (editor, target) => isDOMNode(target) && ReactEditor.hasDOMNode(editor, target),
  insertData: (editor, data) => {
    editor.insertData(data);
  },
  insertFragmentData: (editor, data) => editor.insertFragmentData(data),
  insertTextData: (editor, data) => editor.insertTextData(data),
  isComposing: (editor) => {
    return !!IS_COMPOSING.get(editor);
  },
  isFocused: (editor) => !!IS_FOCUSED.get(editor),
  isReadOnly: (editor) => !!IS_READ_ONLY.get(editor),
  isTargetInsideNonReadonlyVoid: (editor, target) => {
    if (IS_READ_ONLY.get(editor)) return false;
    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
    return Element2.isElement(slateNode) && Editor.isVoid(editor, slateNode);
  },
  setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),
  toDOMNode: (editor, node3) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    var domNode = Editor.isEditor(node3) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node3));
    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Scrubber.stringify(node3)));
    }
    return domNode;
  },
  toDOMPoint: (editor, point3) => {
    var [node3] = Editor.node(editor, point3.path);
    var el = ReactEditor.toDOMNode(editor, node3);
    var domPoint;
    if (Editor.void(editor, {
      at: point3
    })) {
      point3 = {
        path: point3.path,
        offset: 0
      };
    }
    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start2 = 0;
    for (var i = 0; i < texts.length; i++) {
      var text = texts[i];
      var domNode = text.childNodes[0];
      if (domNode == null || domNode.textContent == null) {
        continue;
      }
      var {
        length
      } = domNode.textContent;
      var attr = text.getAttribute("data-slate-length");
      var trueLength = attr == null ? length : parseInt(attr, 10);
      var end2 = start2 + trueLength;
      var nextText = texts[i + 1];
      if (point3.offset === end2 && nextText !== null && nextText !== void 0 && nextText.hasAttribute("data-slate-mark-placeholder")) {
        var _nextText$textContent;
        var domText = nextText.childNodes[0];
        domPoint = [
          // COMPAT: If we don't explicity set the dom point to be on the actual
          // dom text element, chrome will put the selection behind the actual dom
          // text element, causing domRange.getBoundingClientRect() calls on a collapsed
          // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
          // which will cause issues when scrolling to it.
          domText instanceof DOMText ? domText : nextText,
          (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith("\uFEFF") ? 1 : 0
        ];
        break;
      }
      if (point3.offset <= end2) {
        var offset4 = Math.min(length, Math.max(0, point3.offset - start2));
        domPoint = [domNode, offset4];
        break;
      }
      start2 = end2;
    }
    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Scrubber.stringify(point3)));
    }
    return domPoint;
  },
  toDOMRange: (editor, range2) => {
    var {
      anchor,
      focus: focus3
    } = range2;
    var isBackward = Range.isBackward(range2);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = Range.isCollapsed(range2) ? domAnchor : ReactEditor.toDOMPoint(editor, focus3);
    var window2 = ReactEditor.getWindow(editor);
    var domRange = window2.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;
    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute("data-slate-zero-width");
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute("data-slate-zero-width");
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },
  toSlateNode: (editor, domNode) => {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
    if (domEl && !domEl.hasAttribute("data-slate-node")) {
      domEl = domEl.closest("[data-slate-node]");
    }
    var node3 = domEl ? ELEMENT_TO_NODE.get(domEl) : null;
    if (!node3) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }
    return node3;
  },
  toSlatePoint: (editor, domPoint, options2) => {
    var {
      exactMatch,
      suppressThrow,
      searchDirection = "backward"
    } = options2;
    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset4 = 0;
    if (parentNode) {
      var _domNode$textContent, _domNode$textContent2;
      var editorEl = ReactEditor.toDOMNode(editor, editor);
      var potentialVoidNode = parentNode.closest('[data-slate-void="true"]');
      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
      var potentialNonEditableNode = parentNode.closest('[contenteditable="false"]');
      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;
      var leafNode = parentNode.closest("[data-slate-leaf]");
      var domNode = null;
      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');
        if (textNode) {
          var window2 = ReactEditor.getWindow(editor);
          var range2 = window2.document.createRange();
          range2.setStart(textNode, 0);
          range2.setEnd(nearestNode, nearestOffset);
          var contents = range2.cloneContents();
          var removals = [...Array.prototype.slice.call(contents.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(contents.querySelectorAll("[contenteditable=false]"))];
          removals.forEach((el) => {
            if (IS_ANDROID && !exactMatch && el.hasAttribute("data-slate-zero-width") && el.textContent.length > 0 && el.textContext !== "\uFEFF") {
              if (el.textContent.startsWith("\uFEFF")) {
                el.textContent = el.textContent.slice(1);
              }
              return;
            }
            el.parentNode.removeChild(el);
          });
          offset4 = contents.textContent.length;
          domNode = textNode;
        }
      } else if (voidNode) {
        var leafNodes = voidNode.querySelectorAll("[data-slate-leaf]");
        for (var index2 = 0; index2 < leafNodes.length; index2++) {
          var current2 = leafNodes[index2];
          if (ReactEditor.hasDOMNode(editor, current2)) {
            leafNode = current2;
            break;
          }
        }
        if (!leafNode) {
          offset4 = 1;
        } else {
          textNode = leafNode.closest('[data-slate-node="text"]');
          domNode = leafNode;
          offset4 = domNode.textContent.length;
          domNode.querySelectorAll("[data-slate-zero-width]").forEach((el) => {
            offset4 -= el.textContent.length;
          });
        }
      } else if (nonEditableNode) {
        var getLeafNodes = (node4) => node4 ? node4.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [];
        var elementNode = nonEditableNode.closest('[data-slate-node="element"]');
        if (searchDirection === "forward") {
          var _leafNodes$find;
          var _leafNodes = [...getLeafNodes(elementNode), ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)];
          leafNode = (_leafNodes$find = _leafNodes.find((leaf3) => isAfter(nonEditableNode, leaf3))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;
        } else {
          var _leafNodes2$findLast;
          var _leafNodes2 = [...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling), ...getLeafNodes(elementNode)];
          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast((leaf3) => isBefore(nonEditableNode, leaf3))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;
        }
        if (leafNode) {
          textNode = leafNode.closest('[data-slate-node="text"]');
          domNode = leafNode;
          if (searchDirection === "forward") {
            offset4 = 0;
          } else {
            offset4 = domNode.textContent.length;
            domNode.querySelectorAll("[data-slate-zero-width]").forEach((el) => {
              offset4 -= el.textContent.length;
            });
          }
        }
      }
      if (domNode && offset4 === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      IS_ANDROID && domNode.getAttribute("data-slate-zero-width") === "z" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (parentNode.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith("\n\n"))) {
        offset4--;
      }
    }
    if (IS_ANDROID && !textNode && !exactMatch) {
      var node3 = parentNode.hasAttribute("data-slate-node") ? parentNode : parentNode.closest("[data-slate-node]");
      if (node3 && ReactEditor.hasDOMNode(editor, node3, {
        editable: true
      })) {
        var _slateNode = ReactEditor.toSlateNode(editor, node3);
        var {
          path: _path,
          offset: _offset
        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));
        if (!node3.querySelector("[data-slate-leaf]")) {
          _offset = nearestOffset;
        }
        return {
          path: _path,
          offset: _offset
        };
      }
    }
    if (!textNode) {
      if (suppressThrow) {
        return null;
      }
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    }
    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path3 = ReactEditor.findPath(editor, slateNode);
    return {
      path: path3,
      offset: offset4
    };
  },
  toSlateRange: (editor, domRange, options2) => {
    var _focusNode$textConten;
    var {
      exactMatch,
      suppressThrow
    } = options2;
    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed;
    if (el) {
      if (isDOMSelection(domRange)) {
        if (IS_FIREFOX && domRange.rangeCount > 1) {
          focusNode = domRange.focusNode;
          var firstRange = domRange.getRangeAt(0);
          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);
          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {
            let getLastChildren = function(element) {
              if (element.childElementCount > 0) {
                return getLastChildren(element.children[0]);
              } else {
                return element;
              }
            };
            var firstNodeRow = firstRange.startContainer;
            var lastNodeRow = lastRange.startContainer;
            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);
            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);
            focusOffset = 0;
            if (lastNode.childNodes.length > 0) {
              anchorNode = lastNode.childNodes[0];
            } else {
              anchorNode = lastNode;
            }
            if (firstNode.childNodes.length > 0) {
              focusNode = firstNode.childNodes[0];
            } else {
              focusNode = firstNode;
            }
            if (lastNode instanceof HTMLElement) {
              anchorOffset = lastNode.innerHTML.length;
            } else {
              anchorOffset = 0;
            }
          } else {
            if (firstRange.startContainer === focusNode) {
              anchorNode = lastRange.endContainer;
              anchorOffset = lastRange.endOffset;
              focusOffset = firstRange.startOffset;
            } else {
              anchorNode = firstRange.startContainer;
              anchorOffset = firstRange.endOffset;
              focusOffset = lastRange.startOffset;
            }
          }
        } else {
          anchorNode = domRange.anchorNode;
          anchorOffset = domRange.anchorOffset;
          focusNode = domRange.focusNode;
          focusOffset = domRange.focusOffset;
        }
        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {
          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
        } else {
          isCollapsed = domRange.isCollapsed;
        }
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed = domRange.collapsed;
      }
    }
    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }
    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith("\n\n") && focusOffset === focusNode.textContent.length) {
      focusOffset--;
    }
    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {
      exactMatch,
      suppressThrow
    });
    if (!anchor) {
      return null;
    }
    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;
    var focus3 = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {
      exactMatch,
      suppressThrow,
      searchDirection: focusBeforeAnchor ? "forward" : "backward"
    });
    if (!focus3) {
      return null;
    }
    var range2 = {
      anchor,
      focus: focus3
    };
    if (Range.isExpanded(range2) && Range.isForward(range2) && isDOMElement(focusNode) && Editor.void(editor, {
      at: range2.focus,
      mode: "highest"
    })) {
      range2 = Editor.unhangRange(editor, range2, {
        voids: true
      });
    }
    return range2;
  }
};
function verifyDiffState(editor, textDiff) {
  var {
    path: path3,
    diff
  } = textDiff;
  if (!Editor.hasPath(editor, path3)) {
    return false;
  }
  var node3 = Node3.get(editor, path3);
  if (!Text.isText(node3)) {
    return false;
  }
  if (diff.start !== node3.text.length || diff.text.length === 0) {
    return node3.text.slice(diff.start, diff.start + diff.text.length) === diff.text;
  }
  var nextPath = Path.next(path3);
  if (!Editor.hasPath(editor, nextPath)) {
    return false;
  }
  var nextNode = Node3.get(editor, nextPath);
  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text);
}
function applyStringDiff(text) {
  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    diffs[_key - 1] = arguments[_key];
  }
  return diffs.reduce((text2, diff) => text2.slice(0, diff.start) + diff.text + text2.slice(diff.end), text);
}
function longestCommonPrefixLength(str, another) {
  var length = Math.min(str.length, another.length);
  for (var i = 0; i < length; i++) {
    if (str.charAt(i) !== another.charAt(i)) {
      return i;
    }
  }
  return length;
}
function longestCommonSuffixLength(str, another, max2) {
  var length = Math.min(str.length, another.length, max2);
  for (var i = 0; i < length; i++) {
    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {
      return i;
    }
  }
  return length;
}
function normalizeStringDiff(targetText, diff) {
  var {
    start: start2,
    end: end2,
    text
  } = diff;
  var removedText = targetText.slice(start2, end2);
  var prefixLength = longestCommonPrefixLength(removedText, text);
  var max2 = Math.min(removedText.length - prefixLength, text.length - prefixLength);
  var suffixLength = longestCommonSuffixLength(removedText, text, max2);
  var normalized = {
    start: start2 + prefixLength,
    end: end2 - suffixLength,
    text: text.slice(prefixLength, text.length - suffixLength)
  };
  if (normalized.start === normalized.end && normalized.text.length === 0) {
    return null;
  }
  return normalized;
}
function mergeStringDiffs(targetText, a, b) {
  var start2 = Math.min(a.start, b.start);
  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);
  var applied = applyStringDiff(targetText, a, b);
  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);
  var text = applied.slice(start2, sliceEnd);
  var end2 = Math.max(a.end, b.end - a.text.length + (a.end - a.start));
  return normalizeStringDiff(targetText, {
    start: start2,
    end: end2,
    text
  });
}
function targetRange(textDiff) {
  var {
    path: path3,
    diff
  } = textDiff;
  return {
    anchor: {
      path: path3,
      offset: diff.start
    },
    focus: {
      path: path3,
      offset: diff.end
    }
  };
}
function normalizePoint(editor, point3) {
  var {
    path: path3,
    offset: offset4
  } = point3;
  if (!Editor.hasPath(editor, path3)) {
    return null;
  }
  var leaf3 = Node3.get(editor, path3);
  if (!Text.isText(leaf3)) {
    return null;
  }
  var parentBlock = Editor.above(editor, {
    match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3),
    at: path3
  });
  if (!parentBlock) {
    return null;
  }
  while (offset4 > leaf3.text.length) {
    var entry = Editor.next(editor, {
      at: path3,
      match: Text.isText
    });
    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {
      return null;
    }
    offset4 -= leaf3.text.length;
    leaf3 = entry[0];
    path3 = entry[1];
  }
  return {
    path: path3,
    offset: offset4
  };
}
function normalizeRange(editor, range2) {
  var anchor = normalizePoint(editor, range2.anchor);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range2)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus3 = normalizePoint(editor, range2.focus);
  if (!focus3) {
    return null;
  }
  return {
    anchor,
    focus: focus3
  };
}
function transformPendingPoint(editor, point3, op) {
  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref) => {
    var {
      path: path3
    } = _ref;
    return Path.equals(path3, point3.path);
  });
  if (!textDiff || point3.offset <= textDiff.diff.start) {
    return Point.transform(point3, op, {
      affinity: "backward"
    });
  }
  var {
    diff
  } = textDiff;
  if (point3.offset <= diff.start + diff.text.length) {
    var _anchor = {
      path: point3.path,
      offset: diff.start
    };
    var _transformed = Point.transform(_anchor, op, {
      affinity: "backward"
    });
    if (!_transformed) {
      return null;
    }
    return {
      path: _transformed.path,
      offset: _transformed.offset + point3.offset - diff.start
    };
  }
  var anchor = {
    path: point3.path,
    offset: point3.offset - diff.text.length + diff.end - diff.start
  };
  var transformed = Point.transform(anchor, op, {
    affinity: "backward"
  });
  if (!transformed) {
    return null;
  }
  if (op.type === "split_node" && Path.equals(op.path, point3.path) && anchor.offset < op.position && diff.start < op.position) {
    return transformed;
  }
  return {
    path: transformed.path,
    offset: transformed.offset + diff.text.length - diff.end + diff.start
  };
}
function transformPendingRange(editor, range2, op) {
  var anchor = transformPendingPoint(editor, range2.anchor, op);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range2)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus3 = transformPendingPoint(editor, range2.focus, op);
  if (!focus3) {
    return null;
  }
  return {
    anchor,
    focus: focus3
  };
}
function transformTextDiff(textDiff, op) {
  var {
    path: path3,
    diff,
    id
  } = textDiff;
  switch (op.type) {
    case "insert_text": {
      if (!Path.equals(op.path, path3) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset <= diff.start) {
        return {
          diff: {
            start: op.text.length + diff.start,
            end: op.text.length + diff.end,
            text: diff.text
          },
          id,
          path: path3
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end + op.text.length,
          text: diff.text
        },
        id,
        path: path3
      };
    }
    case "remove_text": {
      if (!Path.equals(op.path, path3) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset + op.text.length <= diff.start) {
        return {
          diff: {
            start: diff.start - op.text.length,
            end: diff.end - op.text.length,
            text: diff.text
          },
          id,
          path: path3
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end - op.text.length,
          text: diff.text
        },
        id,
        path: path3
      };
    }
    case "split_node": {
      if (!Path.equals(op.path, path3) || op.position >= diff.end) {
        return {
          diff,
          id,
          path: Path.transform(path3, op, {
            affinity: "backward"
          })
        };
      }
      if (op.position > diff.start) {
        return {
          diff: {
            start: diff.start,
            end: Math.min(op.position, diff.end),
            text: diff.text
          },
          id,
          path: path3
        };
      }
      return {
        diff: {
          start: diff.start - op.position,
          end: diff.end - op.position,
          text: diff.text
        },
        id,
        path: Path.transform(path3, op, {
          affinity: "forward"
        })
      };
    }
    case "merge_node": {
      if (!Path.equals(op.path, path3)) {
        return {
          diff,
          id,
          path: Path.transform(path3, op)
        };
      }
      return {
        diff: {
          start: diff.start + op.position,
          end: diff.end + op.position,
          text: diff.text
        },
        id,
        path: Path.transform(path3, op)
      };
    }
  }
  var newPath = Path.transform(path3, op);
  if (!newPath) {
    return null;
  }
  return {
    diff,
    path: newPath,
    id
  };
}
function ownKeys$62(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$62(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$62(Object(t3), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$62(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var RESOLVE_DELAY = 25;
var FLUSH_DELAY = 200;
var debug = function debug2() {
};
var isDataTransfer = (value) => (value === null || value === void 0 ? void 0 : value.constructor.name) === "DataTransfer";
function createAndroidInputManager(_ref) {
  var {
    editor,
    scheduleOnDOMSelectionChange,
    onDOMSelectionChange
  } = _ref;
  var flushing = false;
  var compositionEndTimeoutId = null;
  var flushTimeoutId = null;
  var actionTimeoutId = null;
  var idCounter2 = 0;
  var insertPositionHint = false;
  var applyPendingSelection = () => {
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    if (pendingSelection) {
      var {
        selection
      } = editor;
      var normalized = normalizeRange(editor, pendingSelection);
      if (normalized && (!selection || !Range.equals(normalized, selection))) {
        Transforms.select(editor, normalized);
      }
    }
  };
  var performAction = () => {
    var action = EDITOR_TO_PENDING_ACTION.get(editor);
    EDITOR_TO_PENDING_ACTION.delete(editor);
    if (!action) {
      return;
    }
    if (action.at) {
      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);
      if (!target) {
        return;
      }
      var _targetRange = Editor.range(editor, target);
      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {
        Transforms.select(editor, target);
      }
    }
    action.run();
  };
  var flush = () => {
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    if (actionTimeoutId) {
      clearTimeout(actionTimeoutId);
      actionTimeoutId = null;
    }
    if (!hasPendingDiffs() && !hasPendingAction()) {
      applyPendingSelection();
      return;
    }
    if (!flushing) {
      flushing = true;
      setTimeout(() => flushing = false);
    }
    if (hasPendingAction()) {
      flushing = "action";
    }
    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {
      affinity: "forward"
    });
    EDITOR_TO_USER_MARKS.set(editor, editor.marks);
    debug("flush", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));
    var scheduleSelectionChange = hasPendingDiffs();
    var diff;
    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {
      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;
      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
      if (pendingMarks !== void 0) {
        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
        editor.marks = pendingMarks;
      }
      if (pendingMarks && insertPositionHint === false) {
        insertPositionHint = null;
      }
      var range2 = targetRange(diff);
      if (!editor.selection || !Range.equals(editor.selection, range2)) {
        Transforms.select(editor, range2);
      }
      if (diff.diff.text) {
        Editor.insertText(editor, diff.diff.text);
      } else {
        Editor.deleteFragment(editor);
      }
      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2) => {
        var {
          id
        } = _ref2;
        return id !== diff.id;
      }));
      if (!verifyDiffState(editor, diff)) {
        scheduleSelectionChange = false;
        EDITOR_TO_PENDING_ACTION.delete(editor);
        EDITOR_TO_USER_MARKS.delete(editor);
        flushing = "action";
        EDITOR_TO_PENDING_SELECTION.delete(editor);
        scheduleOnDOMSelectionChange.cancel();
        onDOMSelectionChange.cancel();
        selectionRef === null || selectionRef === void 0 || selectionRef.unref();
      }
    }
    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {
      Transforms.select(editor, selection);
    }
    if (hasPendingAction()) {
      performAction();
      return;
    }
    if (scheduleSelectionChange) {
      scheduleOnDOMSelectionChange();
    }
    scheduleOnDOMSelectionChange.flush();
    onDOMSelectionChange.flush();
    applyPendingSelection();
    var userMarks = EDITOR_TO_USER_MARKS.get(editor);
    EDITOR_TO_USER_MARKS.delete(editor);
    if (userMarks !== void 0) {
      editor.marks = userMarks;
      editor.onChange();
    }
  };
  var handleCompositionEnd = (_event) => {
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
    }
    compositionEndTimeoutId = setTimeout(() => {
      IS_COMPOSING.set(editor, false);
      flush();
    }, RESOLVE_DELAY);
  };
  var handleCompositionStart = (_event) => {
    IS_COMPOSING.set(editor, true);
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
      compositionEndTimeoutId = null;
    }
  };
  var updatePlaceholderVisibility = function updatePlaceholderVisibility2() {
    var forceHide = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);
    if (!placeholderElement) {
      return;
    }
    if (hasPendingDiffs() || forceHide) {
      placeholderElement.style.display = "none";
      return;
    }
    placeholderElement.style.removeProperty("display");
  };
  var storeDiff = (path3, diff) => {
    var _EDITOR_TO_PENDING_DI3;
    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];
    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);
    var target = Node3.leaf(editor, path3);
    var idx = pendingDiffs.findIndex((change) => Path.equals(change.path, path3));
    if (idx < 0) {
      var normalized = normalizeStringDiff(target.text, diff);
      if (normalized) {
        pendingDiffs.push({
          path: path3,
          diff,
          id: idCounter2++
        });
      }
      updatePlaceholderVisibility();
      return;
    }
    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);
    if (!merged) {
      pendingDiffs.splice(idx, 1);
      updatePlaceholderVisibility();
      return;
    }
    pendingDiffs[idx] = _objectSpread$62(_objectSpread$62({}, pendingDiffs[idx]), {}, {
      diff: merged
    });
  };
  var scheduleAction = function scheduleAction2(run) {
    var {
      at: at2
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    insertPositionHint = false;
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    scheduleOnDOMSelectionChange.cancel();
    onDOMSelectionChange.cancel();
    if (hasPendingAction()) {
      flush();
    }
    EDITOR_TO_PENDING_ACTION.set(editor, {
      at: at2,
      run
    });
    actionTimeoutId = setTimeout(flush);
  };
  var handleDOMBeforeInput = (event) => {
    var _targetRange2;
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    if (IS_NODE_MAP_DIRTY.get(editor)) {
      return;
    }
    var {
      inputType: type
    } = event;
    var targetRange2 = null;
    var data = event.dataTransfer || event.data || void 0;
    if (insertPositionHint !== false && type !== "insertText" && type !== "insertCompositionText") {
      insertPositionHint = false;
    }
    var [nativeTargetRange] = event.getTargetRanges();
    if (nativeTargetRange) {
      targetRange2 = ReactEditor.toSlateRange(editor, nativeTargetRange, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    var window2 = ReactEditor.getWindow(editor);
    var domSelection = window2.getSelection();
    if (!targetRange2 && domSelection) {
      nativeTargetRange = domSelection;
      targetRange2 = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    targetRange2 = (_targetRange2 = targetRange2) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;
    if (!targetRange2) {
      return;
    }
    var canStoreDiff = true;
    if (type.startsWith("delete")) {
      if (Range.isExpanded(targetRange2)) {
        var [_start, _end] = Range.edges(targetRange2);
        var _leaf = Node3.leaf(editor, _start.path);
        if (_leaf.text.length === _start.offset && _end.offset === 0) {
          var next3 = Editor.next(editor, {
            at: _start.path,
            match: Text.isText
          });
          if (next3 && Path.equals(next3[1], _end.path)) {
            targetRange2 = {
              anchor: _end,
              focus: _end
            };
          }
        }
      }
      var direction = type.endsWith("Backward") ? "backward" : "forward";
      var [start2, end2] = Range.edges(targetRange2);
      var [leaf3, path3] = Editor.leaf(editor, start2.path);
      var diff = {
        text: "",
        start: start2.offset,
        end: end2.offset
      };
      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change) => Path.equals(change.path, path3));
      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];
      var text = applyStringDiff(leaf3.text, ...diffs);
      if (text.length === 0) {
        canStoreDiff = false;
      }
      if (Range.isExpanded(targetRange2)) {
        if (canStoreDiff && Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var point3 = {
            path: targetRange2.anchor.path,
            offset: start2.offset
          };
          var range2 = Editor.range(editor, point3, point3);
          handleUserSelect(range2);
          return storeDiff(targetRange2.anchor.path, {
            text: "",
            end: end2.offset,
            start: start2.offset
          });
        }
        return scheduleAction(() => Editor.deleteFragment(editor, {
          direction
        }), {
          at: targetRange2
        });
      }
    }
    switch (type) {
      case "deleteByComposition":
      case "deleteByCut":
      case "deleteByDrag": {
        return scheduleAction(() => Editor.deleteFragment(editor), {
          at: targetRange2
        });
      }
      case "deleteContent":
      case "deleteContentForward": {
        var {
          anchor
        } = targetRange2;
        if (canStoreDiff && Range.isCollapsed(targetRange2)) {
          var targetNode = Node3.leaf(editor, anchor.path);
          if (anchor.offset < targetNode.text.length) {
            return storeDiff(anchor.path, {
              text: "",
              start: anchor.offset,
              end: anchor.offset + 1
            });
          }
        }
        return scheduleAction(() => Editor.deleteForward(editor), {
          at: targetRange2
        });
      }
      case "deleteContentBackward": {
        var _nativeTargetRange;
        var {
          anchor: _anchor
        } = targetRange2;
        var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);
        if (canStoreDiff && nativeCollapsed && Range.isCollapsed(targetRange2) && _anchor.offset > 0) {
          return storeDiff(_anchor.path, {
            text: "",
            start: _anchor.offset - 1,
            end: _anchor.offset
          });
        }
        return scheduleAction(() => Editor.deleteBackward(editor), {
          at: targetRange2
        });
      }
      case "deleteEntireSoftLine": {
        return scheduleAction(() => {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
        }, {
          at: targetRange2
        });
      }
      case "deleteHardLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteHardLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "insertLineBreak": {
        return scheduleAction(() => Editor.insertSoftBreak(editor), {
          at: targetRange2
        });
      }
      case "insertParagraph": {
        return scheduleAction(() => Editor.insertBreak(editor), {
          at: targetRange2
        });
      }
      case "insertCompositionText":
      case "deleteCompositionText":
      case "insertFromComposition":
      case "insertFromDrop":
      case "insertFromPaste":
      case "insertFromYank":
      case "insertReplacementText":
      case "insertText": {
        if (isDataTransfer(data)) {
          return scheduleAction(() => ReactEditor.insertData(editor, data), {
            at: targetRange2
          });
        }
        var _text = data !== null && data !== void 0 ? data : "";
        if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {
          _text = _text.replace("\uFEFF", "");
        }
        if (type === "insertText" && /.*\n.*\n$/.test(_text)) {
          _text = _text.slice(0, -1);
        }
        if (_text.includes("\n")) {
          return scheduleAction(() => {
            var parts = _text.split("\n");
            parts.forEach((line, i) => {
              if (line) {
                Editor.insertText(editor, line);
              }
              if (i !== parts.length - 1) {
                Editor.insertSoftBreak(editor);
              }
            });
          }, {
            at: targetRange2
          });
        }
        if (Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var [_start2, _end2] = Range.edges(targetRange2);
          var _diff = {
            start: _start2.offset,
            end: _end2.offset,
            text: _text
          };
          if (_text && insertPositionHint && type === "insertCompositionText") {
            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\S|$/);
            var diffPosition = _diff.start + _diff.text.search(/\S|$/);
            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {
              _diff.start -= 1;
              insertPositionHint = null;
              scheduleFlush();
            } else {
              insertPositionHint = false;
            }
          } else if (type === "insertText") {
            if (insertPositionHint === null) {
              insertPositionHint = _diff;
            } else if (insertPositionHint && Range.isCollapsed(targetRange2) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {
              insertPositionHint = _objectSpread$62(_objectSpread$62({}, insertPositionHint), {}, {
                text: insertPositionHint.text + _text
              });
            } else {
              insertPositionHint = false;
            }
          } else {
            insertPositionHint = false;
          }
          if (canStoreDiff) {
            storeDiff(_start2.path, _diff);
            return;
          }
        }
        return scheduleAction(() => Editor.insertText(editor, _text), {
          at: targetRange2
        });
      }
    }
  };
  var hasPendingAction = () => {
    return !!EDITOR_TO_PENDING_ACTION.get(editor);
  };
  var hasPendingDiffs = () => {
    var _EDITOR_TO_PENDING_DI4;
    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);
  };
  var hasPendingChanges = () => {
    return hasPendingAction() || hasPendingDiffs();
  };
  var isFlushing = () => {
    return flushing;
  };
  var handleUserSelect = (range2) => {
    EDITOR_TO_PENDING_SELECTION.set(editor, range2);
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      selection
    } = editor;
    if (!range2) {
      return;
    }
    var pathChanged = !selection || !Path.equals(selection.anchor.path, range2.anchor.path);
    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range2.anchor.path.slice(0, -1));
    if (pathChanged && insertPositionHint || parentPathChanged) {
      insertPositionHint = false;
    }
    if (pathChanged || hasPendingDiffs()) {
      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);
    }
  };
  var handleInput = () => {
    if (hasPendingAction() || !hasPendingDiffs()) {
      flush();
    }
  };
  var handleKeyDown = (_2) => {
    if (!hasPendingDiffs()) {
      updatePlaceholderVisibility(true);
      setTimeout(updatePlaceholderVisibility);
    }
  };
  var scheduleFlush = () => {
    if (!hasPendingAction()) {
      actionTimeoutId = setTimeout(flush);
    }
  };
  var handleDomMutations = (mutations) => {
    if (hasPendingDiffs() || hasPendingAction()) {
      return;
    }
    if (mutations.some((mutation) => isTrackedMutation(editor, mutation, mutations))) {
      var _EDITOR_TO_FORCE_REND;
      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 || _EDITOR_TO_FORCE_REND();
    }
  };
  return {
    flush,
    scheduleFlush,
    hasPendingDiffs,
    hasPendingAction,
    hasPendingChanges,
    isFlushing,
    handleUserSelect,
    handleCompositionEnd,
    handleCompositionStart,
    handleDOMBeforeInput,
    handleKeyDown,
    handleDomMutations,
    handleInput
  };
}
function useIsMounted() {
  var isMountedRef = (0, import_react27.useRef)(false);
  (0, import_react27.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef.current;
}
var useIsomorphicLayoutEffect = CAN_USE_DOM ? import_react27.useLayoutEffect : import_react27.useEffect;
function useMutationObserver(node3, callback, options2) {
  var [mutationObserver] = (0, import_react27.useState)(() => new MutationObserver(callback));
  useIsomorphicLayoutEffect(() => {
    mutationObserver.takeRecords();
  });
  (0, import_react27.useEffect)(() => {
    if (!node3.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    mutationObserver.observe(node3.current, options2);
    return () => mutationObserver.disconnect();
  }, [mutationObserver, node3, options2]);
}
var _excluded$32 = ["node"];
function ownKeys$52(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$52(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$52(Object(t3), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$52(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var MUTATION_OBSERVER_CONFIG$1 = {
  subtree: true,
  childList: true,
  characterData: true
};
var useAndroidInputManager = !IS_ANDROID ? () => null : (_ref) => {
  var {
    node: node3
  } = _ref, options2 = _objectWithoutProperties2(_ref, _excluded$32);
  if (!IS_ANDROID) {
    return null;
  }
  var editor = useSlateStatic();
  var isMounted = useIsMounted();
  var [inputManager] = (0, import_react27.useState)(() => createAndroidInputManager(_objectSpread$52({
    editor
  }, options2)));
  useMutationObserver(node3, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);
  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);
  if (isMounted) {
    inputManager.flush();
  }
  return inputManager;
};
var _excluded$22 = ["anchor", "focus"];
var _excluded2$12 = ["anchor", "focus"];
var shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
var isDecorationFlagsEqual = (range2, other2) => {
  var rangeOwnProps = _objectWithoutProperties2(range2, _excluded$22);
  var otherOwnProps = _objectWithoutProperties2(other2, _excluded2$12);
  return range2[PLACEHOLDER_SYMBOL] === other2[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);
};
var isElementDecorationsEqual = (list2, another) => {
  if (list2.length !== another.length) {
    return false;
  }
  for (var i = 0; i < list2.length; i++) {
    var range2 = list2[i];
    var other2 = another[i];
    if (!Range.equals(range2, other2) || !isDecorationFlagsEqual(range2, other2)) {
      return false;
    }
  }
  return true;
};
var isTextDecorationsEqual = (list2, another) => {
  if (list2.length !== another.length) {
    return false;
  }
  for (var i = 0; i < list2.length; i++) {
    var range2 = list2[i];
    var other2 = another[i];
    if (range2.anchor.offset !== other2.anchor.offset || range2.focus.offset !== other2.focus.offset || !isDecorationFlagsEqual(range2, other2)) {
      return false;
    }
  }
  return true;
};
function ownKeys$42(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$42(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$42(Object(t3), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$42(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var String$1 = (props) => {
  var {
    isLast,
    leaf: leaf3,
    parent: parent3,
    text
  } = props;
  var editor = useSlateStatic();
  var path3 = ReactEditor.findPath(editor, text);
  var parentPath = Path.parent(path3);
  var isMarkPlaceholder = Boolean(leaf3[MARK_PLACEHOLDER_SYMBOL]);
  if (editor.isVoid(parent3)) {
    return import_react27.default.createElement(ZeroWidthString, {
      length: Node3.string(parent3).length
    });
  }
  if (leaf3.text === "" && parent3.children[parent3.children.length - 1] === text && !editor.isInline(parent3) && Editor.string(editor, parentPath) === "") {
    return import_react27.default.createElement(ZeroWidthString, {
      isLineBreak: true,
      isMarkPlaceholder
    });
  }
  if (leaf3.text === "") {
    return import_react27.default.createElement(ZeroWidthString, {
      isMarkPlaceholder
    });
  }
  if (isLast && leaf3.text.slice(-1) === "\n") {
    return import_react27.default.createElement(TextString, {
      isTrailing: true,
      text: leaf3.text
    });
  }
  return import_react27.default.createElement(TextString, {
    text: leaf3.text
  });
};
var TextString = (props) => {
  var {
    text,
    isTrailing = false
  } = props;
  var ref = (0, import_react27.useRef)(null);
  var getTextContent = () => {
    return "".concat(text !== null && text !== void 0 ? text : "").concat(isTrailing ? "\n" : "");
  };
  var [initialText] = (0, import_react27.useState)(getTextContent);
  useIsomorphicLayoutEffect(() => {
    var textWithTrailing = getTextContent();
    if (ref.current && ref.current.textContent !== textWithTrailing) {
      ref.current.textContent = textWithTrailing;
    }
  });
  return import_react27.default.createElement(MemoizedText$1, {
    ref
  }, initialText);
};
var MemoizedText$1 = (0, import_react27.memo)((0, import_react27.forwardRef)((props, ref) => {
  return import_react27.default.createElement("span", {
    "data-slate-string": true,
    ref
  }, props.children);
}));
var ZeroWidthString = (props) => {
  var {
    length = 0,
    isLineBreak = false,
    isMarkPlaceholder = false
  } = props;
  var attributes = {
    "data-slate-zero-width": isLineBreak ? "n" : "z",
    "data-slate-length": length
  };
  if (isMarkPlaceholder) {
    attributes["data-slate-mark-placeholder"] = true;
  }
  return import_react27.default.createElement("span", _objectSpread$42({}, attributes), !(IS_ANDROID || IS_IOS) || !isLineBreak ? "\uFEFF" : null, isLineBreak ? import_react27.default.createElement("br", null) : null);
};
function ownKeys$32(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$32(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$32(Object(t3), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$32(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var PLACEHOLDER_DELAY = IS_ANDROID ? 300 : 0;
function disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {
  if (placeholderResizeObserver.current) {
    placeholderResizeObserver.current.disconnect();
    if (releaseObserver) {
      placeholderResizeObserver.current = null;
    }
  }
}
function clearTimeoutRef(timeoutRef) {
  if (timeoutRef.current) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = null;
  }
}
var Leaf = (props) => {
  var {
    leaf: leaf3,
    isLast,
    text,
    parent: parent3,
    renderPlaceholder,
    renderLeaf = (props2) => import_react27.default.createElement(DefaultLeaf, _objectSpread$32({}, props2))
  } = props;
  var editor = useSlateStatic();
  var placeholderResizeObserver = (0, import_react27.useRef)(null);
  var placeholderRef = (0, import_react27.useRef)(null);
  var [showPlaceholder, setShowPlaceholder] = (0, import_react27.useState)(false);
  var showPlaceholderTimeoutRef = (0, import_react27.useRef)(null);
  var callbackPlaceholderRef = (0, import_react27.useCallback)((placeholderEl) => {
    disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);
    if (placeholderEl == null) {
      var _leaf$onPlaceholderRe;
      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
      (_leaf$onPlaceholderRe = leaf3.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 || _leaf$onPlaceholderRe.call(leaf3, null);
    } else {
      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);
      if (!placeholderResizeObserver.current) {
        var ResizeObserver$1 = window.ResizeObserver || ResizeObserver2;
        placeholderResizeObserver.current = new ResizeObserver$1(() => {
          var _leaf$onPlaceholderRe2;
          (_leaf$onPlaceholderRe2 = leaf3.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 || _leaf$onPlaceholderRe2.call(leaf3, placeholderEl);
        });
      }
      placeholderResizeObserver.current.observe(placeholderEl);
      placeholderRef.current = placeholderEl;
    }
  }, [placeholderRef, leaf3, editor]);
  var children = import_react27.default.createElement(String$1, {
    isLast,
    leaf: leaf3,
    parent: parent3,
    text
  });
  var leafIsPlaceholder = Boolean(leaf3[PLACEHOLDER_SYMBOL]);
  (0, import_react27.useEffect)(() => {
    if (leafIsPlaceholder) {
      if (!showPlaceholderTimeoutRef.current) {
        showPlaceholderTimeoutRef.current = setTimeout(() => {
          setShowPlaceholder(true);
          showPlaceholderTimeoutRef.current = null;
        }, PLACEHOLDER_DELAY);
      }
    } else {
      clearTimeoutRef(showPlaceholderTimeoutRef);
      setShowPlaceholder(false);
    }
    return () => clearTimeoutRef(showPlaceholderTimeoutRef);
  }, [leafIsPlaceholder, setShowPlaceholder]);
  if (leafIsPlaceholder && showPlaceholder) {
    var placeholderProps = {
      children: leaf3.placeholder,
      attributes: {
        "data-slate-placeholder": true,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: IS_WEBKIT ? "inherit" : void 0
        },
        contentEditable: false,
        ref: callbackPlaceholderRef
      }
    };
    children = import_react27.default.createElement(import_react27.default.Fragment, null, renderPlaceholder(placeholderProps), children);
  }
  var attributes = {
    "data-slate-leaf": true
  };
  return renderLeaf({
    attributes,
    children,
    leaf: leaf3,
    text
  });
};
var MemoizedLeaf = import_react27.default.memo(Leaf, (prev, next3) => {
  return next3.parent === prev.parent && next3.isLast === prev.isLast && next3.renderLeaf === prev.renderLeaf && next3.renderPlaceholder === prev.renderPlaceholder && next3.text === prev.text && Text.equals(next3.leaf, prev.leaf) && next3.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];
});
var DefaultLeaf = (props) => {
  var {
    attributes,
    children
  } = props;
  return import_react27.default.createElement("span", _objectSpread$32({}, attributes), children);
};
var Text2 = (props) => {
  var {
    decorations,
    isLast,
    parent: parent3,
    renderPlaceholder,
    renderLeaf,
    text
  } = props;
  var editor = useSlateStatic();
  var ref = (0, import_react27.useRef)(null);
  var leaves = Text.decorations(text, decorations);
  var key = ReactEditor.findKey(editor, text);
  var children = [];
  for (var i = 0; i < leaves.length; i++) {
    var leaf3 = leaves[i];
    children.push(import_react27.default.createElement(MemoizedLeaf, {
      isLast: isLast && i === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i),
      renderPlaceholder,
      leaf: leaf3,
      text,
      parent: parent3,
      renderLeaf
    }));
  }
  var callbackRef = (0, import_react27.useCallback)((span) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (span) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, span);
      NODE_TO_ELEMENT.set(text, span);
      ELEMENT_TO_NODE.set(span, text);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text);
      if (ref.current) {
        ELEMENT_TO_NODE.delete(ref.current);
      }
    }
    ref.current = span;
  }, [ref, editor, key, text]);
  return import_react27.default.createElement("span", {
    "data-slate-node": "text",
    ref: callbackRef
  }, children);
};
var MemoizedText = import_react27.default.memo(Text2, (prev, next3) => {
  return next3.parent === prev.parent && next3.isLast === prev.isLast && next3.renderLeaf === prev.renderLeaf && next3.renderPlaceholder === prev.renderPlaceholder && next3.text === prev.text && isTextDecorationsEqual(next3.decorations, prev.decorations);
});
function ownKeys$22(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$22(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$22(Object(t3), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$22(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var Element3 = (props) => {
  var {
    decorations,
    element,
    renderElement = (p2) => import_react27.default.createElement(DefaultElement, _objectSpread$22({}, p2)),
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var editor = useSlateStatic();
  var readOnly = useReadOnly();
  var isInline = editor.isInline(element);
  var key = ReactEditor.findKey(editor, element);
  var ref = (0, import_react27.useCallback)((ref2) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (ref2) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, ref2);
      NODE_TO_ELEMENT.set(element, ref2);
      ELEMENT_TO_NODE.set(ref2, element);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element);
    }
  }, [editor, key, element]);
  var children = useChildren({
    decorations,
    node: element,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  });
  var attributes = {
    "data-slate-node": "element",
    ref
  };
  if (isInline) {
    attributes["data-slate-inline"] = true;
  }
  if (!isInline && Editor.hasInlines(editor, element)) {
    var text = Node3.string(element);
    var dir = (0, import_direction.default)(text);
    if (dir === "rtl") {
      attributes.dir = dir;
    }
  }
  if (Editor.isVoid(editor, element)) {
    attributes["data-slate-void"] = true;
    if (!readOnly && isInline) {
      attributes.contentEditable = false;
    }
    var Tag = isInline ? "span" : "div";
    var [[_text]] = Node3.texts(element);
    children = import_react27.default.createElement(Tag, {
      "data-slate-spacer": true,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, import_react27.default.createElement(MemoizedText, {
      renderPlaceholder,
      decorations: [],
      isLast: false,
      parent: element,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element);
  }
  return renderElement({
    attributes,
    children,
    element
  });
};
var MemoizedElement = import_react27.default.memo(Element3, (prev, next3) => {
  return prev.element === next3.element && prev.renderElement === next3.renderElement && prev.renderLeaf === next3.renderLeaf && prev.renderPlaceholder === next3.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next3.decorations) && (prev.selection === next3.selection || !!prev.selection && !!next3.selection && Range.equals(prev.selection, next3.selection));
});
var DefaultElement = (props) => {
  var {
    attributes,
    children,
    element
  } = props;
  var editor = useSlateStatic();
  var Tag = editor.isInline(element) ? "span" : "div";
  return import_react27.default.createElement(Tag, _objectSpread$22(_objectSpread$22({}, attributes), {}, {
    style: {
      position: "relative"
    }
  }), children);
};
var DecorateContext = (0, import_react27.createContext)(() => []);
var useDecorate = () => {
  return (0, import_react27.useContext)(DecorateContext);
};
var SelectedContext = (0, import_react27.createContext)(false);
var useSelected = () => {
  return (0, import_react27.useContext)(SelectedContext);
};
var useChildren = (props) => {
  var {
    decorations,
    node: node3,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var decorate = useDecorate();
  var editor = useSlateStatic();
  IS_NODE_MAP_DIRTY.set(editor, false);
  var path3 = ReactEditor.findPath(editor, node3);
  var children = [];
  var isLeafBlock = Element2.isElement(node3) && !editor.isInline(node3) && Editor.hasInlines(editor, node3);
  for (var i = 0; i < node3.children.length; i++) {
    var p2 = path3.concat(i);
    var n3 = node3.children[i];
    var key = ReactEditor.findKey(editor, n3);
    var range2 = Editor.range(editor, p2);
    var sel = selection && Range.intersection(range2, selection);
    var ds = decorate([n3, p2]);
    for (var dec of decorations) {
      var d = Range.intersection(dec, range2);
      if (d) {
        ds.push(d);
      }
    }
    if (Element2.isElement(n3)) {
      children.push(import_react27.default.createElement(SelectedContext.Provider, {
        key: "provider-".concat(key.id),
        value: !!sel
      }, import_react27.default.createElement(MemoizedElement, {
        decorations: ds,
        element: n3,
        key: key.id,
        renderElement,
        renderPlaceholder,
        renderLeaf,
        selection: sel
      })));
    } else {
      children.push(import_react27.default.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i === node3.children.length - 1,
        parent: node3,
        renderPlaceholder,
        renderLeaf,
        text: n3
      }));
    }
    NODE_TO_INDEX.set(n3, i);
    NODE_TO_PARENT.set(n3, node3);
  }
  return children;
};
var ReadOnlyContext = (0, import_react27.createContext)(false);
var useReadOnly = () => {
  return (0, import_react27.useContext)(ReadOnlyContext);
};
var SlateContext = (0, import_react27.createContext)(null);
var useSlate = () => {
  var context = (0, import_react27.useContext)(SlateContext);
  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  }
  var {
    editor
  } = context;
  return editor;
};
function useTrackUserInput() {
  var editor = useSlateStatic();
  var receivedUserInput = (0, import_react27.useRef)(false);
  var animationFrameIdRef = (0, import_react27.useRef)(0);
  var onUserInput = (0, import_react27.useCallback)(() => {
    if (receivedUserInput.current) {
      return;
    }
    receivedUserInput.current = true;
    var window2 = ReactEditor.getWindow(editor);
    window2.cancelAnimationFrame(animationFrameIdRef.current);
    animationFrameIdRef.current = window2.requestAnimationFrame(() => {
      receivedUserInput.current = false;
    });
  }, [editor]);
  (0, import_react27.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);
  return {
    receivedUserInput,
    onUserInput
  };
}
var TRIPLE_CLICK = 3;
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
};
var APPLE_HOTKEYS = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create3 = (key) => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && (0, import_is_hotkey.isHotkey)(generic);
  var isApple2 = apple && (0, import_is_hotkey.isHotkey)(apple);
  var isWindows = windows && (0, import_is_hotkey.isHotkey)(windows);
  return (event) => {
    if (isGeneric && isGeneric(event)) return true;
    if (IS_APPLE && isApple2 && isApple2(event)) return true;
    if (!IS_APPLE && isWindows && isWindows(event)) return true;
    return false;
  };
};
var Hotkeys = {
  isBold: create3("bold"),
  isCompose: create3("compose"),
  isMoveBackward: create3("moveBackward"),
  isMoveForward: create3("moveForward"),
  isDeleteBackward: create3("deleteBackward"),
  isDeleteForward: create3("deleteForward"),
  isDeleteLineBackward: create3("deleteLineBackward"),
  isDeleteLineForward: create3("deleteLineForward"),
  isDeleteWordBackward: create3("deleteWordBackward"),
  isDeleteWordForward: create3("deleteWordForward"),
  isExtendBackward: create3("extendBackward"),
  isExtendForward: create3("extendForward"),
  isExtendLineBackward: create3("extendLineBackward"),
  isExtendLineForward: create3("extendLineForward"),
  isItalic: create3("italic"),
  isMoveLineBackward: create3("moveLineBackward"),
  isMoveLineForward: create3("moveLineForward"),
  isMoveWordBackward: create3("moveWordBackward"),
  isMoveWordForward: create3("moveWordForward"),
  isRedo: create3("redo"),
  isSoftBreak: create3("insertSoftBreak"),
  isSplitBlock: create3("splitBlock"),
  isTransposeCharacter: create3("transposeCharacter"),
  isUndo: create3("undo")
};
var createRestoreDomManager = (editor, receivedUserInput) => {
  var bufferedMutations = [];
  var clear = () => {
    bufferedMutations = [];
  };
  var registerMutations = (mutations) => {
    if (!receivedUserInput.current) {
      return;
    }
    var trackedMutations = mutations.filter((mutation) => isTrackedMutation(editor, mutation, mutations));
    bufferedMutations.push(...trackedMutations);
  };
  function restoreDOM() {
    if (bufferedMutations.length > 0) {
      bufferedMutations.reverse().forEach((mutation) => {
        if (mutation.type === "characterData") {
          return;
        }
        mutation.removedNodes.forEach((node3) => {
          mutation.target.insertBefore(node3, mutation.nextSibling);
        });
        mutation.addedNodes.forEach((node3) => {
          mutation.target.removeChild(node3);
        });
      });
      clear();
    }
  }
  return {
    registerMutations,
    restoreDOM,
    clear
  };
};
var MUTATION_OBSERVER_CONFIG = {
  subtree: true,
  childList: true,
  characterData: true,
  characterDataOldValue: true
};
var RestoreDOMComponent = class extends import_react27.Component {
  constructor() {
    super(...arguments);
    _defineProperty2(this, "context", null);
    _defineProperty2(this, "manager", null);
    _defineProperty2(this, "mutationObserver", null);
  }
  observe() {
    var _this$mutationObserve;
    var {
      node: node3
    } = this.props;
    if (!node3.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(node3.current, MUTATION_OBSERVER_CONFIG);
  }
  componentDidMount() {
    var {
      receivedUserInput
    } = this.props;
    var editor = this.context;
    this.manager = createRestoreDomManager(editor, receivedUserInput);
    this.mutationObserver = new MutationObserver(this.manager.registerMutations);
    this.observe();
  }
  getSnapshotBeforeUpdate() {
    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;
    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();
    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {
      var _this$manager;
      (_this$manager = this.manager) === null || _this$manager === void 0 || _this$manager.registerMutations(pendingMutations);
    }
    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 || _this$mutationObserve3.disconnect();
    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 || _this$manager2.restoreDOM();
    return null;
  }
  componentDidUpdate() {
    var _this$manager3;
    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 || _this$manager3.clear();
    this.observe();
  }
  componentWillUnmount() {
    var _this$mutationObserve4;
    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 || _this$mutationObserve4.disconnect();
  }
  render() {
    return this.props.children;
  }
};
_defineProperty2(RestoreDOMComponent, "contextType", EditorContext);
var RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref) => {
  var {
    children
  } = _ref;
  return import_react27.default.createElement(import_react27.default.Fragment, null, children);
};
var ComposingContext = (0, import_react27.createContext)(false);
var _excluded$12 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"];
var _excluded22 = ["text"];
function ownKeys$12(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$12(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$12(Object(t3), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$12(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var Children3 = (props) => import_react27.default.createElement(import_react27.default.Fragment, null, useChildren(props));
var Editable = (0, import_react27.forwardRef)((props, forwardedRef) => {
  var defaultRenderPlaceholder = (0, import_react27.useCallback)((props2) => import_react27.default.createElement(DefaultPlaceholder, _objectSpread$12({}, props2)), []);
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement,
    renderLeaf,
    renderPlaceholder = defaultRenderPlaceholder,
    scrollSelectionIntoView = defaultScrollSelectionIntoView,
    style: userStyle = {},
    as: Component3 = "div",
    disableDefaultStyles = false
  } = props, attributes = _objectWithoutProperties2(props, _excluded$12);
  var editor = useSlate();
  var [isComposing, setIsComposing] = (0, import_react27.useState)(false);
  var ref = (0, import_react27.useRef)(null);
  var deferredOperations = (0, import_react27.useRef)([]);
  var [placeholderHeight, setPlaceholderHeight] = (0, import_react27.useState)();
  var processing = (0, import_react27.useRef)(false);
  var {
    onUserInput,
    receivedUserInput
  } = useTrackUserInput();
  var [, forceRender] = (0, import_react27.useReducer)((s) => s + 1, 0);
  EDITOR_TO_FORCE_RENDER.set(editor, forceRender);
  IS_READ_ONLY.set(editor, readOnly);
  var state = (0, import_react27.useMemo)(() => ({
    isDraggingInternally: false,
    isUpdatingSelection: false,
    latestElement: null,
    hasMarkPlaceholder: false
  }), []);
  (0, import_react27.useEffect)(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]);
  var androidInputManagerRef = (0, import_react27.useRef)();
  var onDOMSelectionChange = (0, import_react27.useMemo)(() => (0, import_throttle.default)(() => {
    if (IS_NODE_MAP_DIRTY.get(editor)) {
      onDOMSelectionChange();
      return;
    }
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = el.getRootNode();
    if (!processing.current && IS_WEBKIT && root instanceof ShadowRoot) {
      processing.current = true;
      var active = getActiveElement();
      if (active) {
        document.execCommand("indent");
      } else {
        Transforms.deselect(editor);
      }
      processing.current = false;
      return;
    }
    var androidInputManager = androidInputManagerRef.current;
    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {
      var _root = ReactEditor.findDocumentOrShadowRoot(editor);
      var {
        activeElement
      } = _root;
      var _el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = getSelection(_root);
      if (activeElement === _el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }
      if (!domSelection) {
        return Transforms.deselect(editor);
      }
      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);
      var focusNodeInEditor = ReactEditor.hasTarget(editor, focusNode);
      if (anchorNodeSelectable && focusNodeInEditor) {
        var range2 = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        if (range2) {
          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {
            Transforms.select(editor, range2);
          } else {
            androidInputManager === null || androidInputManager === void 0 || androidInputManager.handleUserSelect(range2);
          }
        }
      }
      if (readOnly && (!anchorNodeSelectable || !focusNodeInEditor)) {
        Transforms.deselect(editor);
      }
    }
  }, 100), [editor, readOnly, state]);
  var scheduleOnDOMSelectionChange = (0, import_react27.useMemo)(() => (0, import_debounce.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);
  androidInputManagerRef.current = useAndroidInputManager({
    node: ref,
    onDOMSelectionChange,
    scheduleOnDOMSelectionChange
  });
  useIsomorphicLayoutEffect(() => {
    var _androidInputManagerR, _androidInputManagerR2;
    var window2;
    if (ref.current && (window2 = getDefaultView(ref.current))) {
      EDITOR_TO_WINDOW.set(editor, window2);
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = getSelection(root);
    if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {
      return;
    }
    var setDomSelection = (forceChange) => {
      var hasDomSelection = domSelection.type !== "None";
      if (!selection && !hasDomSelection) {
        return;
      }
      var focusNode = domSelection.focusNode;
      var anchorNode;
      if (IS_FIREFOX && domSelection.rangeCount > 1) {
        var firstRange = domSelection.getRangeAt(0);
        var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1);
        if (firstRange.startContainer === focusNode) {
          anchorNode = lastRange.endContainer;
        } else {
          anchorNode = firstRange.startContainer;
        }
      } else {
        anchorNode = domSelection.anchorNode;
      }
      var editorElement = EDITOR_TO_ELEMENT.get(editor);
      var hasDomSelectionInEditor = false;
      if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {
        hasDomSelectionInEditor = true;
      }
      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {
        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: true,
          // domSelection is not necessarily a valid Slate range
          // (e.g. when clicking on contentEditable:false element)
          suppressThrow: true
        });
        if (slateRange && Range.equals(slateRange, selection)) {
          var _anchorNode;
          if (!state.hasMarkPlaceholder) {
            return;
          }
          if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode = _anchorNode.parentElement) !== null && _anchorNode !== void 0 && _anchorNode.hasAttribute("data-slate-mark-placeholder")) {
            return;
          }
        }
      }
      if (selection && !ReactEditor.hasRange(editor, selection)) {
        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        return;
      }
      state.isUpdatingSelection = true;
      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);
      if (newDomRange) {
        if (ReactEditor.isComposing(editor) && !IS_ANDROID) {
          domSelection.collapseToEnd();
        } else if (Range.isBackward(selection)) {
          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);
        } else {
          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);
        }
        scrollSelectionIntoView(editor, newDomRange);
      } else {
        domSelection.removeAllRanges();
      }
      return newDomRange;
    };
    if (domSelection.rangeCount <= 1) {
      setDomSelection();
    }
    var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === "action";
    if (!IS_ANDROID || !ensureSelection) {
      setTimeout(() => {
        state.isUpdatingSelection = false;
      });
      return;
    }
    var timeoutId = null;
    var animationFrameId = requestAnimationFrame(() => {
      if (ensureSelection) {
        var ensureDomSelection = (forceChange) => {
          try {
            var el = ReactEditor.toDOMNode(editor, editor);
            el.focus();
            setDomSelection(forceChange);
          } catch (e3) {
          }
        };
        ensureDomSelection();
        timeoutId = setTimeout(() => {
          ensureDomSelection(true);
          state.isUpdatingSelection = false;
        });
      }
    });
    return () => {
      cancelAnimationFrame(animationFrameId);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  });
  var onDOMBeforeInput = (0, import_react27.useCallback)((event) => {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = el.getRootNode();
    if (processing !== null && processing !== void 0 && processing.current && IS_WEBKIT && root instanceof ShadowRoot) {
      var ranges = event.getTargetRanges();
      var range2 = ranges[0];
      var newRange = new window.Range();
      newRange.setStart(range2.startContainer, range2.startOffset);
      newRange.setEnd(range2.endContainer, range2.endOffset);
      var slateRange = ReactEditor.toSlateRange(editor, newRange, {
        exactMatch: false,
        suppressThrow: false
      });
      Transforms.select(editor, slateRange);
      event.preventDefault();
      event.stopImmediatePropagation();
      return;
    }
    onUserInput();
    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var _EDITOR_TO_USER_SELEC;
      if (androidInputManagerRef.current) {
        return androidInputManagerRef.current.handleDOMBeforeInput(event);
      }
      scheduleOnDOMSelectionChange.flush();
      onDOMSelectionChange.flush();
      var {
        selection
      } = editor;
      var {
        inputType: type
      } = event;
      var data = event.dataTransfer || event.data || void 0;
      var isCompositionChange = type === "insertCompositionText" || type === "deleteCompositionText";
      if (isCompositionChange && ReactEditor.isComposing(editor)) {
        return;
      }
      var native = false;
      if (type === "insertText" && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      selection.anchor.offset !== 0) {
        native = true;
        if (editor.marks) {
          native = false;
        }
        if (!IS_NODE_MAP_DIRTY.get(editor)) {
          var _node$parentElement, _window$getComputedSt;
          var {
            anchor: anchor2
          } = selection;
          var [node3, offset4] = ReactEditor.toDOMPoint(editor, anchor2);
          var anchorNode = (_node$parentElement = node3.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest("a");
          var _window = ReactEditor.getWindow(editor);
          if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
            var _lastText$textContent;
            var lastText = _window === null || _window === void 0 ? void 0 : _window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();
            if (lastText === node3 && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset4) {
              native = false;
            }
          }
          if (native && node3.parentElement && (_window === null || _window === void 0 || (_window$getComputedSt = _window.getComputedStyle(node3.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === "pre") {
            var block2 = Editor.above(editor, {
              at: anchor2.path,
              match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3)
            });
            if (block2 && Node3.string(block2[0]).includes("	")) {
              native = false;
            }
          }
        }
      }
      if ((!type.startsWith("delete") || type.startsWith("deleteBy")) && !IS_NODE_MAP_DIRTY.get(editor)) {
        var [targetRange2] = event.getTargetRanges();
        if (targetRange2) {
          var _range = ReactEditor.toSlateRange(editor, targetRange2, {
            exactMatch: false,
            suppressThrow: false
          });
          if (!selection || !Range.equals(selection, _range)) {
            native = false;
            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);
            Transforms.select(editor, _range);
            if (selectionRef) {
              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);
            }
          }
        }
      }
      if (isCompositionChange) {
        return;
      }
      if (!native) {
        event.preventDefault();
      }
      if (selection && Range.isExpanded(selection) && type.startsWith("delete")) {
        var direction = type.endsWith("Backward") ? "backward" : "forward";
        Editor.deleteFragment(editor, {
          direction
        });
        return;
      }
      switch (type) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          Editor.deleteFragment(editor);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          Editor.deleteForward(editor);
          break;
        }
        case "deleteContentBackward": {
          Editor.deleteBackward(editor);
          break;
        }
        case "deleteEntireSoftLine": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          Editor.deleteForward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          Editor.deleteBackward(editor, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          Editor.deleteForward(editor, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          Editor.insertSoftBreak(editor);
          break;
        case "insertParagraph": {
          Editor.insertBreak(editor);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          if (type === "insertFromComposition") {
            if (ReactEditor.isComposing(editor)) {
              setIsComposing(false);
              IS_COMPOSING.set(editor, false);
            }
          }
          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === "DataTransfer") {
            ReactEditor.insertData(editor, data);
          } else if (typeof data === "string") {
            if (native) {
              deferredOperations.current.push(() => Editor.insertText(editor, data));
            } else {
              Editor.insertText(editor, data);
            }
          }
          break;
        }
      }
      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
      EDITOR_TO_USER_SELECTION.delete(editor);
      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {
        Transforms.select(editor, toRestore);
      }
    }
  }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly, scheduleOnDOMSelectionChange]);
  var callbackRef = (0, import_react27.useCallback)((node3) => {
    if (node3 == null) {
      onDOMSelectionChange.cancel();
      scheduleOnDOMSelectionChange.cancel();
      EDITOR_TO_ELEMENT.delete(editor);
      NODE_TO_ELEMENT.delete(editor);
      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {
        ref.current.removeEventListener("beforeinput", onDOMBeforeInput);
      }
    } else {
      if (HAS_BEFORE_INPUT_SUPPORT) {
        node3.addEventListener("beforeinput", onDOMBeforeInput);
      }
    }
    ref.current = node3;
    if (typeof forwardedRef === "function") {
      forwardedRef(node3);
    } else if (forwardedRef) {
      forwardedRef.current = node3;
    }
  }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput, forwardedRef]);
  useIsomorphicLayoutEffect(() => {
    var window2 = ReactEditor.getWindow(editor);
    window2.document.addEventListener("selectionchange", scheduleOnDOMSelectionChange);
    var stoppedDragging = () => {
      state.isDraggingInternally = false;
    };
    window2.document.addEventListener("dragend", stoppedDragging);
    window2.document.addEventListener("drop", stoppedDragging);
    return () => {
      window2.document.removeEventListener("selectionchange", scheduleOnDOMSelectionChange);
      window2.document.removeEventListener("dragend", stoppedDragging);
      window2.document.removeEventListener("drop", stoppedDragging);
    };
  }, [scheduleOnDOMSelectionChange, state]);
  var decorations = decorate([editor, []]);
  var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(Node3.texts(editor)).length === 1 && Node3.string(editor) === "" && !isComposing;
  var placeHolderResizeHandler = (0, import_react27.useCallback)((placeholderEl) => {
    if (placeholderEl && showPlaceholder) {
      var _placeholderEl$getBou;
      setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);
    } else {
      setPlaceholderHeight(void 0);
    }
  }, [showPlaceholder]);
  if (showPlaceholder) {
    var start2 = Editor.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      onPlaceholderResize: placeHolderResizeHandler,
      anchor: start2,
      focus: start2
    });
  }
  var {
    marks: marks3
  } = editor;
  state.hasMarkPlaceholder = false;
  if (editor.selection && Range.isCollapsed(editor.selection) && marks3) {
    var {
      anchor
    } = editor.selection;
    var leaf3 = Node3.leaf(editor, anchor.path);
    var rest = _objectWithoutProperties2(leaf3, _excluded22);
    if (!Text.equals(leaf3, marks3, {
      loose: true
    })) {
      state.hasMarkPlaceholder = true;
      var unset = Object.fromEntries(Object.keys(rest).map((mark) => [mark, null]));
      decorations.push(_objectSpread$12(_objectSpread$12(_objectSpread$12({
        [MARK_PLACEHOLDER_SYMBOL]: true
      }, unset), marks3), {}, {
        anchor,
        focus: anchor
      }));
    }
  }
  (0, import_react27.useEffect)(() => {
    setTimeout(() => {
      var {
        selection
      } = editor;
      if (selection) {
        var {
          anchor: _anchor
        } = selection;
        var _text = Node3.leaf(editor, _anchor.path);
        if (marks3 && !Text.equals(_text, marks3, {
          loose: true
        })) {
          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks3);
          return;
        }
      }
      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
    });
  });
  return import_react27.default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, import_react27.default.createElement(ComposingContext.Provider, {
    value: isComposing
  }, import_react27.default.createElement(DecorateContext.Provider, {
    value: decorate
  }, import_react27.default.createElement(RestoreDOM, {
    node: ref,
    receivedUserInput
  }, import_react27.default.createElement(Component3, _objectSpread$12(_objectSpread$12({
    role: readOnly ? void 0 : "textbox",
    "aria-multiline": readOnly ? void 0 : true
  }, attributes), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,
    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : "false",
    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : "false",
    "data-slate-editor": true,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !readOnly,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: true,
    ref: callbackRef,
    style: _objectSpread$12(_objectSpread$12({}, disableDefaultStyles ? {} : _objectSpread$12({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, placeholderHeight ? {
      minHeight: placeholderHeight
    } : {})), userStyle),
    onBeforeInput: (0, import_react27.useCallback)((event) => {
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {
        event.preventDefault();
        if (!ReactEditor.isComposing(editor)) {
          var _text2 = event.data;
          Editor.insertText(editor, _text2);
        }
      }
    }, [attributes.onBeforeInput, editor, readOnly]),
    onInput: (0, import_react27.useCallback)((event) => {
      if (isEventHandled(event, attributes.onInput)) {
        return;
      }
      if (androidInputManagerRef.current) {
        androidInputManagerRef.current.handleInput();
        return;
      }
      for (var op of deferredOperations.current) {
        op();
      }
      deferredOperations.current = [];
      if (!ReactEditor.isFocused(editor)) {
        var native = event.nativeEvent;
        var maybeHistoryEditor = editor;
        if (native.inputType === "historyUndo" && typeof maybeHistoryEditor.undo === "function") {
          maybeHistoryEditor.undo();
          return;
        }
        if (native.inputType === "historyRedo" && typeof maybeHistoryEditor.redo === "function") {
          maybeHistoryEditor.redo();
          return;
        }
      }
    }, [attributes.onInput, editor]),
    onBlur: (0, import_react27.useCallback)((event) => {
      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      }
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      if (state.latestElement === root.activeElement) {
        return;
      }
      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor);
      if (relatedTarget === el) {
        return;
      }
      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute("data-slate-spacer")) {
        return;
      }
      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node3 = ReactEditor.toSlateNode(editor, relatedTarget);
        if (Element2.isElement(node3) && !editor.isVoid(node3)) {
          return;
        }
      }
      if (IS_WEBKIT) {
        var domSelection = getSelection(root);
        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();
      }
      IS_FOCUSED.delete(editor);
    }, [readOnly, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),
    onClick: (0, import_react27.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node3 = ReactEditor.toSlateNode(editor, event.target);
        var path3 = ReactEditor.findPath(editor, node3);
        if (!Editor.hasPath(editor, path3) || Node3.get(editor, path3) !== node3) {
          return;
        }
        if (event.detail === TRIPLE_CLICK && path3.length >= 1) {
          var blockPath = path3;
          if (!(Element2.isElement(node3) && Editor.isBlock(editor, node3))) {
            var _block$;
            var block2 = Editor.above(editor, {
              match: (n3) => Element2.isElement(n3) && Editor.isBlock(editor, n3),
              at: path3
            });
            blockPath = (_block$ = block2 === null || block2 === void 0 ? void 0 : block2[1]) !== null && _block$ !== void 0 ? _block$ : path3.slice(0, 1);
          }
          var range2 = Editor.range(editor, blockPath);
          Transforms.select(editor, range2);
          return;
        }
        if (readOnly) {
          return;
        }
        var _start = Editor.start(editor, path3);
        var end2 = Editor.end(editor, path3);
        var startVoid = Editor.void(editor, {
          at: _start
        });
        var endVoid = Editor.void(editor, {
          at: end2
        });
        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
          var _range2 = Editor.range(editor, _start);
          Transforms.select(editor, _range2);
        }
      }
    }, [editor, attributes.onClick, readOnly]),
    onCompositionEnd: (0, import_react27.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        var _androidInputManagerR3;
        if (ReactEditor.isComposing(editor)) {
          Promise.resolve().then(() => {
            setIsComposing(false);
            IS_COMPOSING.set(editor, false);
          });
        }
        (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 || _androidInputManagerR3.handleCompositionEnd(event);
        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {
          return;
        }
        if (!IS_WEBKIT && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {
          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
          if (placeholderMarks !== void 0) {
            EDITOR_TO_USER_MARKS.set(editor, editor.marks);
            editor.marks = placeholderMarks;
          }
          Editor.insertText(editor, event.data);
          var userMarks = EDITOR_TO_USER_MARKS.get(editor);
          EDITOR_TO_USER_MARKS.delete(editor);
          if (userMarks !== void 0) {
            editor.marks = userMarks;
          }
        }
      }
    }, [attributes.onCompositionEnd, editor]),
    onCompositionUpdate: (0, import_react27.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        if (!ReactEditor.isComposing(editor)) {
          setIsComposing(true);
          IS_COMPOSING.set(editor, true);
        }
      }
    }, [attributes.onCompositionUpdate, editor]),
    onCompositionStart: (0, import_react27.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        var _androidInputManagerR4;
        (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 || _androidInputManagerR4.handleCompositionStart(event);
        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {
          return;
        }
        setIsComposing(true);
        var {
          selection
        } = editor;
        if (selection && Range.isExpanded(selection)) {
          Editor.deleteFragment(editor);
          return;
        }
      }
    }, [attributes.onCompositionStart, editor]),
    onCopy: (0, import_react27.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "copy");
      }
    }, [attributes.onCopy, editor]),
    onCut: (0, import_react27.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "cut");
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
          } else {
            var node3 = Node3.parent(editor, selection.anchor.path);
            if (Editor.isVoid(editor, node3)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, editor, attributes.onCut]),
    onDragOver: (0, import_react27.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        var node3 = ReactEditor.toSlateNode(editor, event.target);
        if (Element2.isElement(node3) && Editor.isVoid(editor, node3)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver, editor]),
    onDragStart: (0, import_react27.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node3 = ReactEditor.toSlateNode(editor, event.target);
        var path3 = ReactEditor.findPath(editor, node3);
        var voidMatch = Element2.isElement(node3) && Editor.isVoid(editor, node3) || Editor.void(editor, {
          at: path3,
          voids: true
        });
        if (voidMatch) {
          var range2 = Editor.range(editor, path3);
          Transforms.select(editor, range2);
        }
        state.isDraggingInternally = true;
        ReactEditor.setFragmentData(editor, event.dataTransfer, "drag");
      }
    }, [readOnly, editor, attributes.onDragStart, state]),
    onDrop: (0, import_react27.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
        event.preventDefault();
        var draggedRange = editor.selection;
        var range2 = ReactEditor.findEventRange(editor, event);
        var data = event.dataTransfer;
        Transforms.select(editor, range2);
        if (state.isDraggingInternally) {
          if (draggedRange && !Range.equals(draggedRange, range2) && !Editor.void(editor, {
            at: range2,
            voids: true
          })) {
            Transforms.delete(editor, {
              at: draggedRange
            });
          }
        }
        ReactEditor.insertData(editor, data);
        if (!ReactEditor.isFocused(editor)) {
          ReactEditor.focus(editor);
        }
      }
    }, [readOnly, editor, attributes.onDrop, state]),
    onDragEnd: (0, import_react27.useCallback)((event) => {
      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {
        attributes.onDragEnd(event);
      }
    }, [readOnly, state, attributes, editor]),
    onFocus: (0, import_react27.useCallback)((event) => {
      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root.activeElement;
        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }
        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, state, editor, attributes.onFocus]),
    onKeyDown: (0, import_react27.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {
        var _androidInputManagerR5;
        (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 || _androidInputManagerR5.handleKeyDown(event);
        var {
          nativeEvent
        } = event;
        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {
          IS_COMPOSING.set(editor, false);
          setIsComposing(false);
        }
        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {
          return;
        }
        var {
          selection
        } = editor;
        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];
        var isRTL2 = (0, import_direction.default)(Node3.string(element)) === "rtl";
        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();
          var maybeHistoryEditor = editor;
          if (typeof maybeHistoryEditor.redo === "function") {
            maybeHistoryEditor.redo();
          }
          return;
        }
        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();
          var _maybeHistoryEditor = editor;
          if (typeof _maybeHistoryEditor.undo === "function") {
            _maybeHistoryEditor.undo();
          }
          return;
        }
        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line"
          });
          return;
        }
        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: !isRTL2
            });
          } else {
            Transforms.collapse(editor, {
              edge: isRTL2 ? "end" : "start"
            });
          }
          return;
        }
        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: isRTL2
            });
          } else {
            Transforms.collapse(editor, {
              edge: isRTL2 ? "start" : "end"
            });
          }
          return;
        }
        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: !isRTL2
          });
          return;
        }
        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: isRTL2
          });
          return;
        }
        if (!HAS_BEFORE_INPUT_SUPPORT) {
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }
          if (Hotkeys.isSoftBreak(nativeEvent)) {
            event.preventDefault();
            Editor.insertSoftBreak(editor);
            return;
          }
          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            Editor.insertBreak(editor);
            return;
          }
          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "word"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "word"
              });
            }
            return;
          }
        } else {
          if (IS_CHROME || IS_WEBKIT) {
            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {
              var currentNode = Node3.parent(editor, selection.anchor.path);
              if (Element2.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {
                event.preventDefault();
                Editor.deleteBackward(editor, {
                  unit: "block"
                });
                return;
              }
            }
          }
        }
      }
    }, [readOnly, editor, attributes.onKeyDown]),
    onPaste: (0, import_react27.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_WEBKIT) {
          event.preventDefault();
          ReactEditor.insertData(editor, event.clipboardData);
        }
      }
    }, [readOnly, editor, attributes.onPaste])
  }), import_react27.default.createElement(Children3, {
    decorations,
    node: editor,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection: editor.selection
  }))))));
});
var DefaultPlaceholder = (_ref) => {
  var {
    attributes,
    children
  } = _ref;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    import_react27.default.createElement("span", _objectSpread$12({}, attributes), children, IS_ANDROID && import_react27.default.createElement("br", null))
  );
};
var defaultDecorate = () => [];
var defaultScrollSelectionIntoView = (editor, domRange) => {
  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {
    var leafEl = domRange.startContainer.parentElement;
    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
    e2(leafEl, {
      scrollMode: "if-needed"
    });
    delete leafEl.getBoundingClientRect;
  }
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isDefaultPrevented() || event.isPropagationStopped();
};
var isDOMEventTargetInput = (event) => {
  return isDOMNode(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);
};
var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.defaultPrevented;
};
var FocusedContext = (0, import_react27.createContext)(false);
var SlateSelectorContext = (0, import_react27.createContext)({});
function useSelectorContext(editor) {
  var eventListeners = (0, import_react27.useRef)([]).current;
  var slateRef = (0, import_react27.useRef)({
    editor
  }).current;
  var onChange = (0, import_react27.useCallback)((editor2) => {
    slateRef.editor = editor2;
    eventListeners.forEach((listener) => listener(editor2));
  }, [eventListeners, slateRef]);
  var selectorContext = (0, import_react27.useMemo)(() => {
    return {
      getSlate: () => slateRef.editor,
      addEventListener: (callback) => {
        eventListeners.push(callback);
        return () => {
          eventListeners.splice(eventListeners.indexOf(callback), 1);
        };
      }
    };
  }, [eventListeners, slateRef]);
  return {
    selectorContext,
    onChange
  };
}
var _excluded3 = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"];
var Slate = (props) => {
  var {
    editor,
    children,
    onChange,
    onSelectionChange,
    onValueChange,
    initialValue
  } = props, rest = _objectWithoutProperties2(props, _excluded3);
  var [context, setContext] = import_react27.default.useState(() => {
    if (!Node3.isNodeList(initialValue)) {
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Scrubber.stringify(initialValue)));
    }
    if (!Editor.isEditor(editor)) {
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Scrubber.stringify(editor)));
    }
    editor.children = initialValue;
    Object.assign(editor, rest);
    return {
      v: 0,
      editor
    };
  });
  var {
    selectorContext,
    onChange: handleSelectorChange
  } = useSelectorContext(editor);
  var onContextChange = (0, import_react27.useCallback)((options2) => {
    var _options$operation;
    if (onChange) {
      onChange(editor.children);
    }
    switch (options2 === null || options2 === void 0 || (_options$operation = options2.operation) === null || _options$operation === void 0 ? void 0 : _options$operation.type) {
      case "set_selection":
        onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(editor.selection);
        break;
      default:
        onValueChange === null || onValueChange === void 0 || onValueChange(editor.children);
    }
    setContext((prevContext) => ({
      v: prevContext.v + 1,
      editor
    }));
    handleSelectorChange(editor);
  }, [editor, handleSelectorChange, onChange, onSelectionChange, onValueChange]);
  (0, import_react27.useEffect)(() => {
    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {
      });
    };
  }, [editor, onContextChange]);
  var [isFocused, setIsFocused] = (0, import_react27.useState)(ReactEditor.isFocused(editor));
  (0, import_react27.useEffect)(() => {
    setIsFocused(ReactEditor.isFocused(editor));
  }, [editor]);
  useIsomorphicLayoutEffect(() => {
    var fn = () => setIsFocused(ReactEditor.isFocused(editor));
    if (REACT_MAJOR_VERSION >= 17) {
      document.addEventListener("focusin", fn);
      document.addEventListener("focusout", fn);
      return () => {
        document.removeEventListener("focusin", fn);
        document.removeEventListener("focusout", fn);
      };
    } else {
      document.addEventListener("focus", fn, true);
      document.addEventListener("blur", fn, true);
      return () => {
        document.removeEventListener("focus", fn, true);
        document.removeEventListener("blur", fn, true);
      };
    }
  }, []);
  return import_react27.default.createElement(SlateSelectorContext.Provider, {
    value: selectorContext
  }, import_react27.default.createElement(SlateContext.Provider, {
    value: context
  }, import_react27.default.createElement(EditorContext.Provider, {
    value: context.editor
  }, import_react27.default.createElement(FocusedContext.Provider, {
    value: isFocused
  }, children))));
};
var doRectsIntersect = (rect, compareRect) => {
  var middle = (compareRect.top + compareRect.bottom) / 2;
  return rect.top <= middle && rect.bottom >= middle;
};
var areRangesSameLine = (editor, range1, range2) => {
  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();
  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();
  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
};
var findCurrentLineRange = (editor, parentRange) => {
  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));
  var positions2 = Array.from(Editor.positions(editor, {
    at: parentRange
  }));
  var left = 0;
  var right = positions2.length;
  var middle = Math.floor(right / 2);
  if (areRangesSameLine(editor, Editor.range(editor, positions2[left]), parentRangeBoundary)) {
    return Editor.range(editor, positions2[left], parentRangeBoundary);
  }
  if (positions2.length < 2) {
    return Editor.range(editor, positions2[positions2.length - 1], parentRangeBoundary);
  }
  while (middle !== positions2.length && middle !== left) {
    if (areRangesSameLine(editor, Editor.range(editor, positions2[middle]), parentRangeBoundary)) {
      right = middle;
    } else {
      left = middle;
    }
    middle = Math.floor((left + right) / 2);
  }
  return Editor.range(editor, positions2[right], parentRangeBoundary);
};
function ownKeys2(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys2(Object(t3), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys2(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var withReact = function withReact2(editor) {
  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment";
  var e3 = editor;
  var {
    apply: apply2,
    onChange,
    deleteBackward: deleteBackward2,
    addMark: addMark2,
    removeMark: removeMark2
  } = e3;
  EDITOR_TO_KEY_TO_ELEMENT.set(e3, /* @__PURE__ */ new WeakMap());
  e3.addMark = (key, value) => {
    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e3)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e3) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e3)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e3, null);
    }
    EDITOR_TO_USER_MARKS.delete(e3);
    addMark2(key, value);
  };
  e3.removeMark = (key) => {
    var _EDITOR_TO_PENDING_DI2;
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e3) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e3)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e3, null);
    }
    EDITOR_TO_USER_MARKS.delete(e3);
    removeMark2(key);
  };
  e3.deleteBackward = (unit) => {
    if (unit !== "line") {
      return deleteBackward2(unit);
    }
    if (e3.selection && Range.isCollapsed(e3.selection)) {
      var parentBlockEntry = Editor.above(e3, {
        match: (n3) => Element2.isElement(n3) && Editor.isBlock(e3, n3),
        at: e3.selection
      });
      if (parentBlockEntry) {
        var [, parentBlockPath] = parentBlockEntry;
        var parentElementRange = Editor.range(e3, parentBlockPath, e3.selection.anchor);
        var currentLineRange = findCurrentLineRange(e3, parentElementRange);
        if (!Range.isCollapsed(currentLineRange)) {
          Transforms.delete(e3, {
            at: currentLineRange
          });
        }
      }
    }
  };
  e3.apply = (op) => {
    var matches = [];
    var pathRefMatches = [];
    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e3);
    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {
      var transformed = pendingDiffs.map((textDiff) => transformTextDiff(textDiff, op)).filter(Boolean);
      EDITOR_TO_PENDING_DIFFS.set(e3, transformed);
    }
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e3);
    if (pendingSelection) {
      EDITOR_TO_PENDING_SELECTION.set(e3, transformPendingRange(e3, pendingSelection, op));
    }
    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e3);
    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {
      var at2 = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e3, pendingAction.at, op) : transformPendingRange(e3, pendingAction.at, op);
      EDITOR_TO_PENDING_ACTION.set(e3, at2 ? _objectSpread2(_objectSpread2({}, pendingAction), {}, {
        at: at2
      }) : null);
    }
    switch (op.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        matches.push(...getMatches(e3, op.path));
        break;
      }
      case "set_selection": {
        var _EDITOR_TO_USER_SELEC;
        (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e3)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();
        EDITOR_TO_USER_SELECTION.delete(e3);
        break;
      }
      case "insert_node":
      case "remove_node": {
        matches.push(...getMatches(e3, Path.parent(op.path)));
        break;
      }
      case "merge_node": {
        var prevPath = Path.previous(op.path);
        matches.push(...getMatches(e3, prevPath));
        break;
      }
      case "move_node": {
        var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));
        matches.push(...getMatches(e3, commonPath));
        var changedPath;
        if (Path.isBefore(op.path, op.newPath)) {
          matches.push(...getMatches(e3, Path.parent(op.path)));
          changedPath = op.newPath;
        } else {
          matches.push(...getMatches(e3, Path.parent(op.newPath)));
          changedPath = op.path;
        }
        var changedNode = Node3.get(editor, Path.parent(changedPath));
        var changedNodeKey = ReactEditor.findKey(e3, changedNode);
        var changedPathRef = Editor.pathRef(e3, Path.parent(changedPath));
        pathRefMatches.push([changedPathRef, changedNodeKey]);
        break;
      }
    }
    apply2(op);
    switch (op.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node": {
        IS_NODE_MAP_DIRTY.set(e3, true);
      }
    }
    for (var [path3, key] of matches) {
      var [node3] = Editor.node(e3, path3);
      NODE_TO_KEY.set(node3, key);
    }
    for (var [pathRef3, _key] of pathRefMatches) {
      if (pathRef3.current) {
        var [_node] = Editor.node(e3, pathRef3.current);
        NODE_TO_KEY.set(_node, _key);
      }
      pathRef3.unref();
    }
  };
  e3.setFragmentData = (data) => {
    var {
      selection
    } = e3;
    if (!selection) {
      return;
    }
    var [start2, end2] = Range.edges(selection);
    var startVoid = Editor.void(e3, {
      at: start2.path
    });
    var endVoid = Editor.void(e3, {
      at: end2.path
    });
    if (Range.isCollapsed(selection) && !startVoid) {
      return;
    }
    var domRange = ReactEditor.toDOMRange(e3, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0];
    contents.childNodes.forEach((node3) => {
      if (node3.textContent && node3.textContent.trim() !== "") {
        attach = node3;
      }
    });
    if (endVoid) {
      var [voidNode] = endVoid;
      var r2 = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e3, voidNode);
      r2.setEndAfter(domNode);
      contents = r2.cloneContents();
    }
    if (startVoid) {
      attach = contents.querySelector("[data-slate-spacer]");
    }
    Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
      var isNewline = zw.getAttribute("data-slate-zero-width") === "n";
      zw.textContent = isNewline ? "\n" : "";
    });
    if (isDOMText(attach)) {
      var span = attach.ownerDocument.createElement("span");
      span.style.whiteSpace = "pre";
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }
    var fragment2 = e3.getFragment();
    var string3 = JSON.stringify(fragment2);
    var encoded = window.btoa(encodeURIComponent(string3));
    attach.setAttribute("data-slate-fragment", encoded);
    data.setData("application/".concat(clipboardFormatKey), encoded);
    var div = contents.ownerDocument.createElement("div");
    div.appendChild(contents);
    div.setAttribute("hidden", "true");
    contents.ownerDocument.body.appendChild(div);
    data.setData("text/html", div.innerHTML);
    data.setData("text/plain", getPlainText(div));
    contents.ownerDocument.body.removeChild(div);
    return data;
  };
  e3.insertData = (data) => {
    if (!e3.insertFragmentData(data)) {
      e3.insertTextData(data);
    }
  };
  e3.insertFragmentData = (data) => {
    var fragment2 = data.getData("application/".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);
    if (fragment2) {
      var decoded = decodeURIComponent(window.atob(fragment2));
      var parsed = JSON.parse(decoded);
      e3.insertFragment(parsed);
      return true;
    }
    return false;
  };
  e3.insertTextData = (data) => {
    var text = data.getData("text/plain");
    if (text) {
      var lines = text.split(/\r\n|\r|\n/);
      var split2 = false;
      for (var line of lines) {
        if (split2) {
          Transforms.splitNodes(e3, {
            always: true
          });
        }
        e3.insertText(line);
        split2 = true;
      }
      return true;
    }
    return false;
  };
  e3.onChange = (options2) => {
    var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? import_react_dom3.default.unstable_batchedUpdates : (callback) => callback();
    maybeBatchUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e3);
      if (onContextChange) {
        onContextChange(options2);
      }
      onChange(options2);
    });
  };
  return e3;
};
var getMatches = (e3, path3) => {
  var matches = [];
  for (var [n3, p2] of Editor.levels(e3, {
    at: path3
  })) {
    var key = ReactEditor.findKey(e3, n3);
    matches.push([p2, key]);
  }
  return matches;
};

// node_modules/@liveblocks/react-ui/dist/utils/request-submit.js
function requestSubmit(form, submitter) {
  if (typeof form.requestSubmit === "function") {
    return form.requestSubmit(submitter);
  }
  if (submitter) {
    submitter.click();
  } else {
    submitter = document.createElement("input");
    submitter.type = "submit";
    submitter.hidden = true;
    form.appendChild(submitter);
    submitter.click();
    form.removeChild(submitter);
  }
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/plugins/normalize.js
function withNormalize(editor) {
  const { normalizeNode: normalizeNode2 } = editor;
  editor.normalizeNode = (entry) => {
    const [node3, path3] = entry;
    if (Element2.isElement(node3) && node3.type === "paragraph") {
      for (const [child, childPath] of Node3.children(editor, path3)) {
        if (Element2.isElement(child) && !editor.isInline(child)) {
          Transforms.unwrapNodes(editor, { at: childPath });
          return;
        }
      }
    }
    normalizeNode2(entry);
  };
  return editor;
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/is-empty-string.js
function isEmptyString(string3) {
  return !string3.trim();
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/is-text.js
function isText(element) {
  return !("type" in element) && "text" in element && typeof element.text === "string";
}
function isPlainText(node3) {
  return isText(node3) && Object.keys(node3).length === 1;
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/is-empty.js
function isEmpty2(editor, children) {
  for (const child of children) {
    if (isText(child)) {
      if (!isEmptyString(child.text)) {
        return false;
      }
    } else if (child.type === "paragraph") {
      if (child.children.length > 1 || child.children[0] && !(isText(child.children[0]) && isEmptyString(child.children[0].text))) {
        return false;
      }
    } else {
      if (!Editor.isEmpty(editor, child)) {
        return false;
      }
    }
  }
  return true;
}

// node_modules/@liveblocks/react-ui/dist/primitives/AiComposer/contexts.js
var import_react28 = __toESM(require_react(), 1);
var AiComposerContext = (0, import_react28.createContext)(null);
var AiComposerEditorContext = (0, import_react28.createContext)(null);
function useAiComposerEditorContext() {
  const composerEditorContext = (0, import_react28.useContext)(AiComposerEditorContext);
  return nn(
    composerEditorContext,
    "AiComposer.Form is missing from the React tree."
  );
}
function useAiComposer() {
  const composerContext = (0, import_react28.useContext)(AiComposerContext);
  return nn(composerContext, "AiComposer.Form is missing from the React tree.");
}

// node_modules/@liveblocks/react-ui/dist/primitives/AiComposer/index.js
var AI_COMPOSER_SUBMIT_NAME = "AiComposerSubmit";
var AI_COMPOSER_ABORT_NAME = "AiComposerAbort";
var AI_COMPOSER_EDITOR_NAME = "AiComposerEditor";
var AI_COMPOSER_FORM_NAME = "AiComposerForm";
var emptyMessagesΣ = new Signal([]);
function getLastMessageId(messages) {
  const lastMessage = messages[messages.length - 1];
  if (lastMessage === void 0) {
    return null;
  }
  return lastMessage.id;
}
function getAbortableMessageId(messages) {
  var _a3;
  return (_a3 = messages.find(
    (message) => message.role === "assistant" && (message.status === "generating" || message.status === "awaiting-tool")
  )) == null ? void 0 : _a3.id;
}
var AiComposerForm = (0, import_react30.forwardRef)(
  ({
    onComposerSubmit,
    onSubmit,
    disabled,
    chatId,
    branchId,
    asChild,
    ...props
  }, forwardedRef) => {
    const Component3 = asChild ? Slot : "form";
    const client = useClient();
    const formRef = (0, import_react30.useRef)(null);
    const editor = useInitial(
      () => withNormalize(withHistory(withReact(createEditor())))
    );
    const [isEditorEmpty, setEditorEmpty] = (0, import_react30.useState)(true);
    const [isSubmitting, setSubmitting] = (0, import_react30.useState)(false);
    const [isFocused, setFocused] = (0, import_react30.useState)(false);
    const messagesΣ = chatId ? client[kInternal].ai.signals.getChatMessagesForBranchΣ(chatId, branchId) : emptyMessagesΣ;
    const lastMessageId = useSignal(messagesΣ, getLastMessageId);
    const abortableMessageId = useSignal(messagesΣ, getAbortableMessageId);
    const isDisabled = isSubmitting || disabled === true;
    const canAbort = abortableMessageId !== void 0;
    const canSubmit = !isEditorEmpty && !canAbort;
    const clear = (0, import_react30.useCallback)(() => {
      Transforms.delete(editor, {
        at: {
          anchor: Editor.start(editor, []),
          focus: Editor.end(editor, [])
        }
      });
    }, [editor]);
    const select2 = (0, import_react30.useCallback)(() => {
      Transforms.select(editor, Editor.end(editor, []));
    }, [editor]);
    const focus3 = (0, import_react30.useCallback)(
      (resetSelection = true) => {
        try {
          if (!ReactEditor.isFocused(editor)) {
            Transforms.select(
              editor,
              resetSelection || !editor.selection ? Editor.end(editor, []) : editor.selection
            );
            ReactEditor.focus(editor);
          }
        } catch {
        }
      },
      [editor]
    );
    const blur = (0, import_react30.useCallback)(() => {
      try {
        ReactEditor.blur(editor);
      } catch {
      }
    }, [editor]);
    const onSubmitEnd = (0, import_react30.useCallback)(() => {
      clear();
      setSubmitting(false);
    }, [clear]);
    const handleSubmit = (0, import_react30.useCallback)(
      (event) => {
        if (disabled) {
          return;
        }
        const isEditorEmpty2 = isEmpty2(editor, editor.children);
        if (isEditorEmpty2) {
          event.preventDefault();
          return;
        }
        onSubmit == null ? void 0 : onSubmit(event);
        if (onComposerSubmit === void 0 || event.isDefaultPrevented()) {
          event.preventDefault();
          return;
        }
        const content = editor.children.map((block2) => {
          if ("type" in block2 && block2.type === "paragraph") {
            return block2.children.map((child) => {
              if ("text" in child) {
                return child.text;
              }
              return "";
            }).join("");
          }
          return "";
        }).join("\n");
        const promise = onComposerSubmit(
          { text: content, lastMessageId },
          event
        );
        event.preventDefault();
        if (promise) {
          setSubmitting(true);
          promise.then(onSubmitEnd);
        } else {
          onSubmitEnd();
        }
      },
      [disabled, editor, onSubmit, onComposerSubmit, onSubmitEnd, lastMessageId]
    );
    useLayoutEffect2(() => {
      setEditorEmpty(isEmpty2(editor, editor.children));
    }, [editor]);
    const handleEditorValueChange = (0, import_react30.useCallback)(() => {
      setEditorEmpty(isEmpty2(editor, editor.children));
    }, [editor]);
    const submit = (0, import_react30.useCallback)(() => {
      if (!canSubmit) {
        return;
      }
      requestAnimationFrame(() => {
        if (formRef.current) {
          requestSubmit(formRef.current);
        }
      });
    }, [canSubmit]);
    const abort = (0, import_react30.useCallback)(() => {
      if (!canAbort || !abortableMessageId) {
        return;
      }
      client[kInternal].ai.abort(abortableMessageId);
    }, [canAbort, abortableMessageId, client]);
    (0, import_react30.useImperativeHandle)(
      forwardedRef,
      () => formRef.current,
      []
    );
    return (0, import_jsx_runtime80.jsx)(AiComposerEditorContext.Provider, {
      value: {
        editor,
        onEditorValueChange: handleEditorValueChange,
        abortableMessageId,
        setFocused
      },
      children: (0, import_jsx_runtime80.jsx)(AiComposerContext.Provider, {
        value: {
          isDisabled,
          isEmpty: isEditorEmpty,
          isFocused,
          canSubmit,
          canAbort,
          submit,
          abort,
          clear,
          focus: focus3,
          blur,
          select: select2
        },
        children: (0, import_jsx_runtime80.jsx)(Component3, {
          onSubmit: handleSubmit,
          ...props,
          ref: formRef
        })
      })
    });
  }
);
function AiComposerEditorPlaceholder({
  attributes,
  children
}) {
  const { opacity: _opacity, ...style } = attributes.style;
  return (0, import_jsx_runtime80.jsx)("span", {
    ...attributes,
    style,
    "data-placeholder": "",
    children
  });
}
var AiComposerEditor = (0, import_react30.forwardRef)(
  ({
    defaultValue = "",
    onKeyDown,
    onFocus,
    onBlur,
    disabled,
    autoFocus,
    dir,
    ...props
  }, forwardedRef) => {
    const { editor, onEditorValueChange, setFocused } = useAiComposerEditorContext();
    const {
      submit,
      isDisabled: isComposerDisabled,
      isFocused,
      focus: focus3,
      blur,
      select: select2
    } = useAiComposer();
    const isDisabled = disabled || isComposerDisabled;
    const handleKeyDown = (0, import_react30.useCallback)(
      (event) => {
        onKeyDown == null ? void 0 : onKeyDown(event);
        if (event.isDefaultPrevented())
          return;
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          submit();
        } else if (event.key === "Enter" && event.shiftKey) {
          event.preventDefault();
          editor.insertBreak();
        } else if (event.key === "Escape") {
          blur();
        }
      },
      [editor, onKeyDown, submit, blur]
    );
    const handleFocus = (0, import_react30.useCallback)(
      (event) => {
        onFocus == null ? void 0 : onFocus(event);
        if (!event.isDefaultPrevented()) {
          setFocused(true);
        }
      },
      [onFocus, setFocused]
    );
    const handleBlur = (0, import_react30.useCallback)(
      (event) => {
        onBlur == null ? void 0 : onBlur(event);
        if (!event.isDefaultPrevented()) {
          setFocused(false);
        }
      },
      [onBlur, setFocused]
    );
    (0, import_react30.useImperativeHandle)(
      forwardedRef,
      () => ReactEditor.toDOMNode(editor, editor),
      [editor]
    );
    useLayoutEffect2(() => {
      if (autoFocus) {
        focus3();
      }
    }, [autoFocus, editor, focus3]);
    useLayoutEffect2(() => {
      if (isFocused && editor.selection === null) {
        select2();
      }
    }, [editor, select2, isFocused]);
    const initialValue = (0, import_react30.useMemo)(() => {
      return defaultValue.split("\n").map((text) => ({ type: "paragraph", children: [{ text }] }));
    }, [defaultValue]);
    return (0, import_jsx_runtime80.jsx)(Slate, {
      editor,
      initialValue,
      onValueChange: onEditorValueChange,
      children: (0, import_jsx_runtime80.jsx)(Editable, {
        dir,
        enterKeyHint: "send",
        autoCapitalize: "sentences",
        "aria-label": "Composer editor",
        onKeyDown: handleKeyDown,
        onFocus: handleFocus,
        onBlur: handleBlur,
        "data-focused": isFocused || void 0,
        "data-disabled": isDisabled || void 0,
        ...props,
        readOnly: isDisabled,
        disabled: isDisabled,
        renderPlaceholder: AiComposerEditorPlaceholder
      })
    });
  }
);
var AiComposerSubmit = (0, import_react30.forwardRef)(({ disabled, asChild, ...props }, forwardedRef) => {
  const Component3 = asChild ? Slot : "button";
  const { isDisabled: isComposerDisabled, canSubmit } = useAiComposer();
  const isDisabled = isComposerDisabled || disabled || !canSubmit;
  return (0, import_jsx_runtime80.jsx)(Component3, {
    type: "submit",
    ...props,
    ref: forwardedRef,
    disabled: isDisabled
  });
});
var AiComposerAbort = (0, import_react30.forwardRef)(({ disabled, onClick, asChild, ...props }, forwardedRef) => {
  const Component3 = asChild ? Slot : "button";
  const { isDisabled: isComposerDisabled, canAbort, abort } = useAiComposer();
  const isDisabled = isComposerDisabled || disabled || !canAbort;
  const handleClick = (0, import_react30.useCallback)(
    (event) => {
      onClick == null ? void 0 : onClick(event);
      if (event.isDefaultPrevented()) {
        return;
      }
      abort();
    },
    [abort, onClick]
  );
  return (0, import_jsx_runtime80.jsx)(Component3, {
    type: "button",
    ...props,
    ref: forwardedRef,
    disabled: isDisabled,
    onClick: handleClick
  });
});
if (true) {
  AiComposerEditor.displayName = AI_COMPOSER_EDITOR_NAME;
  AiComposerForm.displayName = AI_COMPOSER_FORM_NAME;
  AiComposerSubmit.displayName = AI_COMPOSER_SUBMIT_NAME;
  AiComposerAbort.displayName = AI_COMPOSER_ABORT_NAME;
}

// node_modules/@liveblocks/react-ui/dist/primitives/AiMessage/index.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/ErrorBoundary.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);
var ErrorBoundaryContext = (0, import_react31.createContext)(null);
var ErrorBoundary = class extends import_react31.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error, errorInfo) {
    console.error(error, errorInfo);
  }
  reset() {
    this.setState({ error: null });
  }
  render() {
    if (this.state.error === null)
      return this.props.children;
    const error = this.state.error;
    const reset = this.reset.bind(this);
    const fallback = this.props.fallback;
    const Fallback = typeof fallback === "function" ? fallback : () => fallback ?? null;
    return (0, import_jsx_runtime81.jsx)(ErrorBoundaryContext.Provider, {
      value: { error, reset },
      children: (0, import_jsx_runtime81.jsx)(Fallback, {
        error: this.state.error
      })
    });
  }
};

// node_modules/@liveblocks/react-ui/dist/primitives/AiMessage/tool-invocation.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react34 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/primitives/AiMessage/contexts.js
var import_react32 = __toESM(require_react(), 1);
var AiToolInvocationContext = (0, import_react32.createContext)(null);
function useAiToolInvocationContext() {
  const context = (0, import_react32.useContext)(AiToolInvocationContext);
  if (context === null) {
    throw new Error(
      "This component must be used within a tool's render method."
    );
  }
  return context;
}

// node_modules/@liveblocks/react-ui/dist/primitives/AiMessage/tool-invocation.js
function StableRenderFn(props) {
  return props.renderFn(props.props);
}
function AiMessageToolInvocation({
  message,
  part
}) {
  const client = useClient();
  const ai = client[kInternal].ai;
  const tool = useSignal(ai.signals.getToolΣ(part.name, message.chatId));
  const respond = (0, import_react34.useCallback)(
    (result) => {
      if (message.status !== "awaiting-tool") {
      } else if (part.stage === "receiving") {
      } else if (part.stage === "executed") {
        console.log(
          `Ignoring respond(): tool '${part.name}' (${part.invocationId}) has already executed`
        );
      } else {
        ai.setToolResult(
          message.chatId,
          message.id,
          part.invocationId,
          result ?? { data: {} },
          { copilotId: message.copilotId }
        );
      }
    },
    [
      ai,
      message.chatId,
      message.id,
      message.status,
      part.invocationId,
      part.name,
      part.stage,
      message.copilotId
    ]
  );
  const partialArgs = part == null ? void 0 : part.partialArgs;
  const props = (0, import_react34.useMemo)(() => {
    partialArgs;
    const { type: _2, ...rest } = part;
    return {
      ...rest,
      respond,
      types: void 0,
      [kInternal]: {
        execute: tool == null ? void 0 : tool.execute,
        messageStatus: message.status
      }
    };
  }, [part, respond, tool == null ? void 0 : tool.execute, message.status, partialArgs]);
  if ((tool == null ? void 0 : tool.render) === void 0)
    return null;
  return (0, import_jsx_runtime82.jsx)(AiToolInvocationContext.Provider, {
    value: props,
    children: (0, import_jsx_runtime82.jsx)(StableRenderFn, {
      renderFn: tool.render,
      props
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/primitives/AiMessage/index.js
var AI_MESSAGE_CONTENT_NAME = "AiMessageContent";
var defaultMessageContentComponents = {
  TextPart: ({ part }) => {
    return (0, import_jsx_runtime83.jsx)(Markdown, {
      content: part.text
    });
  },
  ReasoningPart: ({ part }) => {
    return (0, import_jsx_runtime83.jsx)(Markdown, {
      content: part.text
    });
  },
  RetrievalPart: () => null,
  ToolInvocationPart: ({ part, message }) => {
    return (0, import_jsx_runtime83.jsx)(ErrorBoundary, {
      fallback: null,
      children: (0, import_jsx_runtime83.jsx)(AiMessageToolInvocation, {
        part,
        message
      })
    });
  }
};
var AiMessageContent = (0, import_react35.forwardRef)(
  ({ message, components, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "div";
    const { ReasoningPart: ReasoningPart2, RetrievalPart: RetrievalPart2, TextPart: TextPart3, ToolInvocationPart: ToolInvocationPart2 } = (0, import_react35.useMemo)(
      () => ({ ...defaultMessageContentComponents, ...components }),
      [components]
    );
    const content = message.content ?? message.contentSoFar;
    const numParts = content.length;
    const isGenerating = message.role === "assistant" && message.status === "generating";
    return (0, import_jsx_runtime83.jsx)(Component3, {
      ...props,
      ref: forwardedRef,
      children: content.map((part, index2) => {
        const isStreaming = isGenerating && index2 === numParts - 1;
        const extra = { index: index2, isStreaming };
        switch (part.type) {
          case "text":
            return (0, import_jsx_runtime83.jsx)(TextPart3, {
              part,
              ...extra
            }, index2);
          case "reasoning":
            return (0, import_jsx_runtime83.jsx)(ReasoningPart2, {
              part,
              ...extra
            }, index2);
          case "retrieval":
            return (0, import_jsx_runtime83.jsx)(RetrievalPart2, {
              part,
              ...extra
            }, index2);
          case "tool-invocation":
            return (0, import_jsx_runtime83.jsx)(ToolInvocationPart2, {
              part,
              ...extra,
              message
            }, index2);
          default:
            return null;
        }
      })
    });
  }
);
if (true) {
  AiMessageContent.displayName = AI_MESSAGE_CONTENT_NAME;
}

// node_modules/@liveblocks/react-ui/dist/primitives/Collapsible/index.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react37 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/use-controllable-state.js
var import_react36 = __toESM(require_react(), 1);
function useControllableState2(defaultValue, value, onChange) {
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react36.useState)(defaultValue);
  const isControlled = value !== void 0;
  const wasControlled = (0, import_react36.useRef)(isControlled);
  (0, import_react36.useEffect)(() => {
    if (wasControlled.current !== isControlled) {
      fancy_console_exports.warn(
        `A component is changing from ${wasControlled.current ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`
      );
    }
    wasControlled.current = isControlled;
  }, [isControlled]);
  const currentValue = isControlled ? value : uncontrolledValue;
  const setValue = (0, import_react36.useCallback)(
    (value2) => {
      if (isControlled) {
        return onChange == null ? void 0 : onChange(value2);
      } else {
        setUncontrolledValue(value2);
        return onChange == null ? void 0 : onChange(value2);
      }
    },
    [isControlled, onChange]
  );
  return [currentValue, setValue];
}
function useSemiControllableState(value, onChange) {
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react36.useState)(value);
  const lastChange = (0, import_react36.useRef)("controlled");
  const lastValue = (0, import_react36.useRef)(value);
  const [rerender] = useRerender();
  if (!Object.is(lastValue.current, value)) {
    lastValue.current = value;
    lastChange.current = "controlled";
  }
  const setValue = (0, import_react36.useCallback)(
    (value2) => {
      lastChange.current = "uncontrolled";
      setUncontrolledValue(value2);
      rerender();
      onChange == null ? void 0 : onChange(value2);
    },
    [onChange, rerender]
  );
  const currentValue = lastChange.current === "uncontrolled" ? uncontrolledValue : value;
  return [currentValue, setValue];
}

// node_modules/@liveblocks/react-ui/dist/primitives/Collapsible/index.js
var COLLAPSIBLE_ROOT_NAME = "CollapsibleRoot";
var COLLAPSIBLE_TRIGGER_NAME = "CollapsibleTrigger";
var COLLAPSIBLE_CONTENT_NAME = "CollapsibleContent";
var CollapsibleContext = (0, import_react37.createContext)(null);
var CollapsibleRoot = (0, import_react37.forwardRef)(
  ({
    open: controlledOpen,
    onOpenChange: controlledOnOpenChange,
    defaultOpen,
    disabled = false,
    asChild,
    ...props
  }, forwardedRef) => {
    const [isOpen, onOpenChange] = useControllableState2(
      defaultOpen ?? true,
      controlledOpen,
      controlledOnOpenChange
    );
    const Component3 = asChild ? Slot : "div";
    const id = (0, import_react37.useId)();
    return (0, import_jsx_runtime84.jsx)(CollapsibleContext.Provider, {
      value: { open: isOpen, onOpenChange, disabled, contentId: id },
      children: (0, import_jsx_runtime84.jsx)(Component3, {
        ...props,
        ref: forwardedRef,
        "data-state": isOpen ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0
      })
    });
  }
);
var CollapsibleTrigger = (0, import_react37.forwardRef)(
  ({ onClick, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "button";
    const context = (0, import_react37.useContext)(CollapsibleContext);
    if (!context) {
      throw new Error("Collapsible.Root is missing from the React tree.");
    }
    const { open, disabled, contentId, onOpenChange } = context;
    return (0, import_jsx_runtime84.jsx)(Component3, {
      ...props,
      ref: forwardedRef,
      type: "button",
      "aria-controls": contentId,
      "aria-expanded": open || false,
      "data-state": open ? "open" : "closed",
      "data-disabled": disabled ? "" : void 0,
      disabled,
      onClick: (event) => {
        onClick == null ? void 0 : onClick(event);
        if (event.defaultPrevented)
          return;
        if (disabled)
          return;
        onOpenChange(!open);
      }
    });
  }
);
var CollapsibleContent = (0, import_react37.forwardRef)(
  ({ asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "div";
    const context = (0, import_react37.useContext)(CollapsibleContext);
    const divRef = (0, import_react37.useRef)(null);
    if (!context) {
      throw new Error("Collapsible.Root is missing from the React tree.");
    }
    const { open, onOpenChange, disabled, contentId } = context;
    (0, import_react37.useEffect)(() => {
      const element = divRef.current;
      if (element === null)
        return;
      const isHiddenUntilFoundSupported = "onbeforematch" in document.body;
      if (!isHiddenUntilFoundSupported)
        return;
      function handleBeforeMatch() {
        onOpenChange(true);
      }
      element.addEventListener("beforematch", handleBeforeMatch);
      return () => {
        element.removeEventListener("beforematch", handleBeforeMatch);
      };
    }, [onOpenChange]);
    (0, import_react37.useEffect)(() => {
      const element = divRef.current;
      if (element === null)
        return;
      if (open)
        return;
      const isHiddenUntilFoundSupported = "onbeforematch" in document.body;
      if (!isHiddenUntilFoundSupported)
        return;
      element.setAttribute("hidden", "until-found");
      return () => {
        element.removeAttribute("hidden");
      };
    }, [open]);
    (0, import_react37.useImperativeHandle)(forwardedRef, () => {
      return divRef.current;
    }, []);
    return (0, import_jsx_runtime84.jsx)(Component3, {
      ...props,
      ref: divRef,
      "data-state": open ? "open" : "closed",
      "data-disabled": disabled ? "" : void 0,
      id: contentId,
      hidden: !open
    });
  }
);
if (true) {
  CollapsibleContent.displayName = COLLAPSIBLE_CONTENT_NAME;
  CollapsibleRoot.displayName = COLLAPSIBLE_ROOT_NAME;
  CollapsibleTrigger.displayName = COLLAPSIBLE_TRIGGER_NAME;
}

// node_modules/cmdk/dist/chunk-NZJY6EH4.mjs
var U = 1;
var Y = 0.9;
var H = 0.8;
var J = 0.17;
var p = 0.1;
var u = 0.999;
var $ = 0.9999;
var k = 0.99;
var m = /[\\\/_+.#"@\[\(\{&]/;
var B = /[\\\/_+.#"@\[\(\{&]/g;
var K = /[\s-]/;
var X = /[\s-]/g;
function G(_2, C2, h, P2, A, f, O2) {
  if (f === C2.length) return A === _2.length ? U : k;
  var T2 = `${A},${f}`;
  if (O2[T2] !== void 0) return O2[T2];
  for (var L3 = P2.charAt(f), c = h.indexOf(L3, A), S = 0, E2, N3, R, M2; c >= 0; ) E2 = G(_2, C2, h, P2, c + 1, f + 1, O2), E2 > S && (c === A ? E2 *= U : m.test(_2.charAt(c - 1)) ? (E2 *= H, R = _2.slice(A, c - 1).match(B), R && A > 0 && (E2 *= Math.pow(u, R.length))) : K.test(_2.charAt(c - 1)) ? (E2 *= Y, M2 = _2.slice(A, c - 1).match(X), M2 && A > 0 && (E2 *= Math.pow(u, M2.length))) : (E2 *= J, A > 0 && (E2 *= Math.pow(u, c - A))), _2.charAt(c) !== C2.charAt(f) && (E2 *= $)), (E2 < p && h.charAt(c - 1) === P2.charAt(f + 1) || P2.charAt(f + 1) === P2.charAt(f) && h.charAt(c - 1) !== P2.charAt(f)) && (N3 = G(_2, C2, h, P2, c + 1, f + 2, O2), N3 * p > E2 && (E2 = N3 * p)), E2 > S && (S = E2), c = h.indexOf(L3, c + 1);
  return O2[T2] = S, S;
}
function D(_2) {
  return _2.toLowerCase().replace(X, " ");
}
function W(_2, C2, h) {
  return _2 = h && h.length > 0 ? `${_2 + " " + h.join(" ")}` : _2, G(_2, C2, D(_2), D(C2), 0, 0, {});
}

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var React34 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React21 = __toESM(require_react(), 1);
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React21.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React21.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React21.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node3) => setContainer(node3));
  const focusScope = React21.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React21.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus2(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React21.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus2(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus2(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React21.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first2, last2] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first2 && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop) focus2(first2, { select: true });
          } else if (event.shiftKey && focusedElement === first2) {
            event.preventDefault();
            if (loop) focus2(last2, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime85.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select: select2 = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus2(candidate, { select: select2 });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first2 = findVisible(candidates, container);
  const last2 = findVisible(candidates.reverse(), container);
  return [first2, last2];
}
function getTabbableCandidates(container) {
  const nodes2 = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node3) => {
      const isHiddenInput = node3.tagName === "INPUT" && node3.type === "hidden";
      if (node3.disabled || node3.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node3.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes2.push(walker.currentNode);
  return nodes2;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden2(element, { upTo: container })) return element;
  }
}
function isHidden2(node3, { upTo }) {
  if (getComputedStyle(node3).visibility === "hidden") return true;
  while (node3) {
    if (upTo !== void 0 && node3 === upTo) return false;
    if (getComputedStyle(node3).display === "none") return true;
    node3 = node3.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus2(element, { select: select2 = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select2)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a3;
      stack = arrayRemove(stack, focusScope);
      (_a3 = stack[0]) == null ? void 0 : _a3.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React24 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React24.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node3) => node3.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s, i = 1, n3 = arguments.length; i < n3; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e3) {
  var t3 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t3[p2[i]] = s[p2[i]];
    }
  return t3;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React33 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React29 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react38 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react38.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React25 = __toESM(require_react());
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React25.useLayoutEffect : React25.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect2(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React26 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react39 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options2);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React27 = __toESM(require_react());
var import_react40 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React28 = __toESM(require_react());
var SideCar = function(_a3) {
  var sideCar = _a3.sideCar, rest = __rest(_a3, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React28.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React29.forwardRef(function(props, parentRef) {
  var ref = React29.useRef(null);
  var _a3 = React29.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks2 = _a3[0], setCallbacks = _a3[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks2);
  return React29.createElement(
    React29.Fragment,
    null,
    enabled && React29.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React29.cloneElement(React29.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React29.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React32 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React31 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React30 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag2 = document.createElement("style");
  tag2.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag2.setAttribute("nonce", nonce);
  }
  return tag2;
}
function injectStyles(tag2, css) {
  if (tag2.styleSheet) {
    tag2.styleSheet.cssText = css;
  } else {
    tag2.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag2) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag2);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React30.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a3) {
    var styles = _a3.styles, dynamic = _a3.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a3, allowRelative, gapMode, important) {
  var left = _a3.left, top = _a3.top, right = _a3.right, gap = _a3.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React31.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a3) {
  var noRelative = _a3.noRelative, noImportant = _a3.noImportant, _b = _a3.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React31.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React31.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options2 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (err) {
    passiveSupported = false;
  }
}
var options2;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node3) {
  return node3.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node3, overflow) {
  if (!(node3 instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node3);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node3) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node3) {
  return elementCanBeScrolled(node3, "overflowY");
};
var elementCouldBeHScrolled = function(node3) {
  return elementCanBeScrolled(node3, "overflowX");
};
var locationCouldBeScrolled = function(axis, node3) {
  var ownerDocument = node3.ownerDocument;
  var current2 = node3;
  do {
    if (typeof ShadowRoot !== "undefined" && current2 instanceof ShadowRoot) {
      current2 = current2.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current2);
    if (isScrollable) {
      var _a3 = getScrollVariables(axis, current2), scrollHeight = _a3[1], clientHeight = _a3[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current2 = current2.parentNode;
  } while (current2 && current2 !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a3) {
  var scrollTop = _a3.scrollTop, scrollHeight = _a3.scrollHeight, clientHeight = _a3.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a3) {
  var scrollLeft = _a3.scrollLeft, scrollWidth = _a3.scrollWidth, clientWidth = _a3.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node3) {
  return axis === "v" ? elementCouldBeVScrolled(node3) : elementCouldBeHScrolled(node3);
};
var getScrollVariables = function(axis, node3) {
  return axis === "v" ? getVScrollVariables(node3) : getHScrollVariables(node3);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a3 = getScrollVariables(axis, target), position = _a3[0], scroll_1 = _a3[1], capacity = _a3[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y) {
  return x2[0] === y[0] && x2[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React32.useRef([]);
  var touchStartRef = React32.useRef([0, 0]);
  var activeAxis = React32.useRef();
  var id = React32.useState(idCounter++)[0];
  var Style2 = React32.useState(styleSingleton)[0];
  var lastProps = React32.useRef(props);
  React32.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React32.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React32.useCallback(function(event, parent3) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent3, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React32.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
      return e3.name === event.type && (e3.target === event.target || event.target === e3.shadowParent) && deltaCompare(e3.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node3) {
        return node3.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React32.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
        return e3 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React32.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React32.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React32.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React32.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React32.createElement(
    React32.Fragment,
    null,
    inert ? React32.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React32.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node3) {
  var shadowParent = null;
  while (node3 !== null) {
    if (node3 instanceof ShadowRoot) {
      shadowParent = node3.host;
      node3 = node3.host;
    }
    node3 = node3.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React33.forwardRef(function(props, ref) {
  return React33.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node3) {
  return node3 && (node3.host || unwrapHost(node3.parentNode));
};
var correctTargets = function(parent3, targets) {
  return targets.map(function(target) {
    if (parent3.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent3.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent3, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent3) {
    if (!parent3 || elementsToStop.has(parent3)) {
      return;
    }
    Array.prototype.forEach.call(parent3.children, function(node3) {
      if (elementsToKeep.has(node3)) {
        deep(node3);
      } else {
        try {
          var attr = node3.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node3) || 0) + 1;
          var markerValue = (markerCounter.get(node3) || 0) + 1;
          counterMap.set(node3, counterValue);
          markerCounter.set(node3, markerValue);
          hiddenNodes.push(node3);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node3, true);
          }
          if (markerValue === 1) {
            node3.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node3.setAttribute(controlAttribute, "true");
          }
        } catch (e3) {
          console.error("aria-hidden: cannot operate on ", node3, e3);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node3) {
      var counterValue = counterMap.get(node3) - 1;
      var markerValue = markerCounter.get(node3) - 1;
      counterMap.set(node3, counterValue);
      markerCounter.set(node3, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node3)) {
          node3.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node3);
      }
      if (!markerValue) {
        node3.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React34.useRef(null);
  const contentRef = React34.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return (0, import_jsx_runtime86.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React34.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME2 = "DialogTrigger";
var DialogTrigger = React34.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME2, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime86.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME3 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext(PORTAL_NAME3, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME3, __scopeDialog);
  return (0, import_jsx_runtime86.jsx)(PortalProvider2, { scope: __scopeDialog, forceMount, children: React34.Children.map(children, (child) => (0, import_jsx_runtime86.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime86.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React34.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime86.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime86.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot2 = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React34.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime86.jsx)(Combination_default, { as: Slot2, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime86.jsx)(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React34.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    return (0, import_jsx_runtime86.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime86.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime86.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React34.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const contentRef = React34.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React34.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime86.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a3;
          event.preventDefault();
          (_a3 = context.triggerRef.current) == null ? void 0 : _a3.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React34.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const hasInteractedOutsideRef = React34.useRef(false);
    const hasPointerDownOutsideRef = React34.useRef(false);
    return (0, import_jsx_runtime86.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a3, _b;
          (_a3 = props.onCloseAutoFocus) == null ? void 0 : _a3.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a3, _b;
          (_a3 = props.onInteractOutside) == null ? void 0 : _a3.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React34.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React34.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime86.jsxs)(import_jsx_runtime86.Fragment, { children: [
      (0, import_jsx_runtime86.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime86.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime86.jsxs)(import_jsx_runtime86.Fragment, { children: [
        (0, import_jsx_runtime86.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime86.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React34.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime86.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React34.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime86.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React34.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime86.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React34.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React34.useEffect(() => {
    var _a3;
    const describedById = (_a3 = contentRef.current) == null ? void 0 : _a3.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root4 = Dialog;
var Portal3 = DialogPortal;
var Overlay = DialogOverlay;
var Content3 = DialogContent;

// node_modules/cmdk/dist/index.mjs
var t2 = __toESM(require_react(), 1);
var N = '[cmdk-group=""]';
var Y2 = '[cmdk-group-items=""]';
var be = '[cmdk-group-heading=""]';
var le = '[cmdk-item=""]';
var ce = `${le}:not([aria-disabled="true"])`;
var Z = "cmdk-item-select";
var T = "data-value";
var Re = (r2, o3, n3) => W(r2, o3, n3);
var ue = t2.createContext(void 0);
var K2 = () => t2.useContext(ue);
var de = t2.createContext(void 0);
var ee = () => t2.useContext(de);
var fe = t2.createContext(void 0);
var me = t2.forwardRef((r2, o3) => {
  let n3 = L(() => {
    var e3, a;
    return { search: "", value: (a = (e3 = r2.value) != null ? e3 : r2.defaultValue) != null ? a : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), u2 = L(() => /* @__PURE__ */ new Set()), c = L(() => /* @__PURE__ */ new Map()), d = L(() => /* @__PURE__ */ new Map()), f = L(() => /* @__PURE__ */ new Set()), p2 = pe(r2), { label: b, children: m2, value: R, onValueChange: x2, filter: C2, shouldFilter: S, loop: A, disablePointerSelection: ge2 = false, vimBindings: j = true, ...O2 } = r2, $3 = useId(), q2 = useId(), _2 = useId(), I2 = t2.useRef(null), v2 = ke();
  k2(() => {
    if (R !== void 0) {
      let e3 = R.trim();
      n3.current.value = e3, E2.emit();
    }
  }, [R]), k2(() => {
    v2(6, ne);
  }, []);
  let E2 = t2.useMemo(() => ({ subscribe: (e3) => (f.current.add(e3), () => f.current.delete(e3)), snapshot: () => n3.current, setState: (e3, a, s) => {
    var i, l2, g, y;
    if (!Object.is(n3.current[e3], a)) {
      if (n3.current[e3] = a, e3 === "search") J2(), z2(), v2(1, W3);
      else if (e3 === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let h = document.getElementById(_2);
          h ? h.focus() : (i = document.getElementById($3)) == null || i.focus();
        }
        if (v2(7, () => {
          var h;
          n3.current.selectedItemId = (h = M2()) == null ? void 0 : h.id, E2.emit();
        }), s || v2(5, ne), ((l2 = p2.current) == null ? void 0 : l2.value) !== void 0) {
          let h = a != null ? a : "";
          (y = (g = p2.current).onValueChange) == null || y.call(g, h);
          return;
        }
      }
      E2.emit();
    }
  }, emit: () => {
    f.current.forEach((e3) => e3());
  } }), []), U2 = t2.useMemo(() => ({ value: (e3, a, s) => {
    var i;
    a !== ((i = d.current.get(e3)) == null ? void 0 : i.value) && (d.current.set(e3, { value: a, keywords: s }), n3.current.filtered.items.set(e3, te2(a, s)), v2(2, () => {
      z2(), E2.emit();
    }));
  }, item: (e3, a) => (u2.current.add(e3), a && (c.current.has(a) ? c.current.get(a).add(e3) : c.current.set(a, /* @__PURE__ */ new Set([e3]))), v2(3, () => {
    J2(), z2(), n3.current.value || W3(), E2.emit();
  }), () => {
    d.current.delete(e3), u2.current.delete(e3), n3.current.filtered.items.delete(e3);
    let s = M2();
    v2(4, () => {
      J2(), (s == null ? void 0 : s.getAttribute("id")) === e3 && W3(), E2.emit();
    });
  }), group: (e3) => (c.current.has(e3) || c.current.set(e3, /* @__PURE__ */ new Set()), () => {
    d.current.delete(e3), c.current.delete(e3);
  }), filter: () => p2.current.shouldFilter, label: b || r2["aria-label"], getDisablePointerSelection: () => p2.current.disablePointerSelection, listId: $3, inputId: _2, labelId: q2, listInnerRef: I2 }), []);
  function te2(e3, a) {
    var i, l2;
    let s = (l2 = (i = p2.current) == null ? void 0 : i.filter) != null ? l2 : Re;
    return e3 ? s(e3, n3.current.search, a) : 0;
  }
  function z2() {
    if (!n3.current.search || p2.current.shouldFilter === false) return;
    let e3 = n3.current.filtered.items, a = [];
    n3.current.filtered.groups.forEach((i) => {
      let l2 = c.current.get(i), g = 0;
      l2.forEach((y) => {
        let h = e3.get(y);
        g = Math.max(h, g);
      }), a.push([i, g]);
    });
    let s = I2.current;
    V2().sort((i, l2) => {
      var h, F2;
      let g = i.getAttribute("id"), y = l2.getAttribute("id");
      return ((h = e3.get(y)) != null ? h : 0) - ((F2 = e3.get(g)) != null ? F2 : 0);
    }).forEach((i) => {
      let l2 = i.closest(Y2);
      l2 ? l2.appendChild(i.parentElement === l2 ? i : i.closest(`${Y2} > *`)) : s.appendChild(i.parentElement === s ? i : i.closest(`${Y2} > *`));
    }), a.sort((i, l2) => l2[1] - i[1]).forEach((i) => {
      var g;
      let l2 = (g = I2.current) == null ? void 0 : g.querySelector(`${N}[${T}="${encodeURIComponent(i[0])}"]`);
      l2 == null || l2.parentElement.appendChild(l2);
    });
  }
  function W3() {
    let e3 = V2().find((s) => s.getAttribute("aria-disabled") !== "true"), a = e3 == null ? void 0 : e3.getAttribute(T);
    E2.setState("value", a || void 0);
  }
  function J2() {
    var a, s, i, l2;
    if (!n3.current.search || p2.current.shouldFilter === false) {
      n3.current.filtered.count = u2.current.size;
      return;
    }
    n3.current.filtered.groups = /* @__PURE__ */ new Set();
    let e3 = 0;
    for (let g of u2.current) {
      let y = (s = (a = d.current.get(g)) == null ? void 0 : a.value) != null ? s : "", h = (l2 = (i = d.current.get(g)) == null ? void 0 : i.keywords) != null ? l2 : [], F2 = te2(y, h);
      n3.current.filtered.items.set(g, F2), F2 > 0 && e3++;
    }
    for (let [g, y] of c.current) for (let h of y) if (n3.current.filtered.items.get(h) > 0) {
      n3.current.filtered.groups.add(g);
      break;
    }
    n3.current.filtered.count = e3;
  }
  function ne() {
    var a, s, i;
    let e3 = M2();
    e3 && (((a = e3.parentElement) == null ? void 0 : a.firstChild) === e3 && ((i = (s = e3.closest(N)) == null ? void 0 : s.querySelector(be)) == null || i.scrollIntoView({ block: "nearest" })), e3.scrollIntoView({ block: "nearest" }));
  }
  function M2() {
    var e3;
    return (e3 = I2.current) == null ? void 0 : e3.querySelector(`${le}[aria-selected="true"]`);
  }
  function V2() {
    var e3;
    return Array.from(((e3 = I2.current) == null ? void 0 : e3.querySelectorAll(ce)) || []);
  }
  function X3(e3) {
    let s = V2()[e3];
    s && E2.setState("value", s.getAttribute(T));
  }
  function Q2(e3) {
    var g;
    let a = M2(), s = V2(), i = s.findIndex((y) => y === a), l2 = s[i + e3];
    (g = p2.current) != null && g.loop && (l2 = i + e3 < 0 ? s[s.length - 1] : i + e3 === s.length ? s[0] : s[i + e3]), l2 && E2.setState("value", l2.getAttribute(T));
  }
  function re2(e3) {
    let a = M2(), s = a == null ? void 0 : a.closest(N), i;
    for (; s && !i; ) s = e3 > 0 ? we(s, N) : De(s, N), i = s == null ? void 0 : s.querySelector(ce);
    i ? E2.setState("value", i.getAttribute(T)) : Q2(e3);
  }
  let oe2 = () => X3(V2().length - 1), ie2 = (e3) => {
    e3.preventDefault(), e3.metaKey ? oe2() : e3.altKey ? re2(1) : Q2(1);
  }, se2 = (e3) => {
    e3.preventDefault(), e3.metaKey ? X3(0) : e3.altKey ? re2(-1) : Q2(-1);
  };
  return t2.createElement(Primitive.div, { ref: o3, tabIndex: -1, ...O2, "cmdk-root": "", onKeyDown: (e3) => {
    var s;
    (s = O2.onKeyDown) == null || s.call(O2, e3);
    let a = e3.nativeEvent.isComposing || e3.keyCode === 229;
    if (!(e3.defaultPrevented || a)) switch (e3.key) {
      case "n":
      case "j": {
        j && e3.ctrlKey && ie2(e3);
        break;
      }
      case "ArrowDown": {
        ie2(e3);
        break;
      }
      case "p":
      case "k": {
        j && e3.ctrlKey && se2(e3);
        break;
      }
      case "ArrowUp": {
        se2(e3);
        break;
      }
      case "Home": {
        e3.preventDefault(), X3(0);
        break;
      }
      case "End": {
        e3.preventDefault(), oe2();
        break;
      }
      case "Enter": {
        e3.preventDefault();
        let i = M2();
        if (i) {
          let l2 = new Event(Z);
          i.dispatchEvent(l2);
        }
      }
    }
  } }, t2.createElement("label", { "cmdk-label": "", htmlFor: U2.inputId, id: U2.labelId, style: Te }, b), B2(r2, (e3) => t2.createElement(de.Provider, { value: E2 }, t2.createElement(ue.Provider, { value: U2 }, e3))));
});
var he = t2.forwardRef((r2, o3) => {
  var _2, I2;
  let n3 = useId(), u2 = t2.useRef(null), c = t2.useContext(fe), d = K2(), f = pe(r2), p2 = (I2 = (_2 = f.current) == null ? void 0 : _2.forceMount) != null ? I2 : c == null ? void 0 : c.forceMount;
  k2(() => {
    if (!p2) return d.item(n3, c == null ? void 0 : c.id);
  }, [p2]);
  let b = ve(n3, u2, [r2.value, r2.children, u2], r2.keywords), m2 = ee(), R = P((v2) => v2.value && v2.value === b.current), x2 = P((v2) => p2 || d.filter() === false ? true : v2.search ? v2.filtered.items.get(n3) > 0 : true);
  t2.useEffect(() => {
    let v2 = u2.current;
    if (!(!v2 || r2.disabled)) return v2.addEventListener(Z, C2), () => v2.removeEventListener(Z, C2);
  }, [x2, r2.onSelect, r2.disabled]);
  function C2() {
    var v2, E2;
    S(), (E2 = (v2 = f.current).onSelect) == null || E2.call(v2, b.current);
  }
  function S() {
    m2.setState("value", b.current, true);
  }
  if (!x2) return null;
  let { disabled: A, value: ge2, onSelect: j, forceMount: O2, keywords: $3, ...q2 } = r2;
  return t2.createElement(Primitive.div, { ref: composeRefs(u2, o3), ...q2, id: n3, "cmdk-item": "", role: "option", "aria-disabled": !!A, "aria-selected": !!R, "data-disabled": !!A, "data-selected": !!R, onPointerMove: A || d.getDisablePointerSelection() ? void 0 : S, onClick: A ? void 0 : C2 }, r2.children);
});
var Ee = t2.forwardRef((r2, o3) => {
  let { heading: n3, children: u2, forceMount: c, ...d } = r2, f = useId(), p2 = t2.useRef(null), b = t2.useRef(null), m2 = useId(), R = K2(), x2 = P((S) => c || R.filter() === false ? true : S.search ? S.filtered.groups.has(f) : true);
  k2(() => R.group(f), []), ve(f, p2, [r2.value, r2.heading, b]);
  let C2 = t2.useMemo(() => ({ id: f, forceMount: c }), [c]);
  return t2.createElement(Primitive.div, { ref: composeRefs(p2, o3), ...d, "cmdk-group": "", role: "presentation", hidden: x2 ? void 0 : true }, n3 && t2.createElement("div", { ref: b, "cmdk-group-heading": "", "aria-hidden": true, id: m2 }, n3), B2(r2, (S) => t2.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n3 ? m2 : void 0 }, t2.createElement(fe.Provider, { value: C2 }, S))));
});
var ye = t2.forwardRef((r2, o3) => {
  let { alwaysRender: n3, ...u2 } = r2, c = t2.useRef(null), d = P((f) => !f.search);
  return !n3 && !d ? null : t2.createElement(Primitive.div, { ref: composeRefs(c, o3), ...u2, "cmdk-separator": "", role: "separator" });
});
var Se = t2.forwardRef((r2, o3) => {
  let { onValueChange: n3, ...u2 } = r2, c = r2.value != null, d = ee(), f = P((m2) => m2.search), p2 = P((m2) => m2.selectedItemId), b = K2();
  return t2.useEffect(() => {
    r2.value != null && d.setState("search", r2.value);
  }, [r2.value]), t2.createElement(Primitive.input, { ref: o3, ...u2, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: false, "aria-autocomplete": "list", role: "combobox", "aria-expanded": true, "aria-controls": b.listId, "aria-labelledby": b.labelId, "aria-activedescendant": p2, id: b.inputId, type: "text", value: c ? r2.value : f, onChange: (m2) => {
    c || d.setState("search", m2.target.value), n3 == null || n3(m2.target.value);
  } });
});
var Ce = t2.forwardRef((r2, o3) => {
  let { children: n3, label: u2 = "Suggestions", ...c } = r2, d = t2.useRef(null), f = t2.useRef(null), p2 = P((m2) => m2.selectedItemId), b = K2();
  return t2.useEffect(() => {
    if (f.current && d.current) {
      let m2 = f.current, R = d.current, x2, C2 = new ResizeObserver(() => {
        x2 = requestAnimationFrame(() => {
          let S = m2.offsetHeight;
          R.style.setProperty("--cmdk-list-height", S.toFixed(1) + "px");
        });
      });
      return C2.observe(m2), () => {
        cancelAnimationFrame(x2), C2.unobserve(m2);
      };
    }
  }, []), t2.createElement(Primitive.div, { ref: composeRefs(d, o3), ...c, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": p2, "aria-label": u2, id: b.listId }, B2(r2, (m2) => t2.createElement("div", { ref: composeRefs(f, b.listInnerRef), "cmdk-list-sizer": "" }, m2)));
});
var xe = t2.forwardRef((r2, o3) => {
  let { open: n3, onOpenChange: u2, overlayClassName: c, contentClassName: d, container: f, ...p2 } = r2;
  return t2.createElement(Root4, { open: n3, onOpenChange: u2 }, t2.createElement(Portal3, { container: f }, t2.createElement(Overlay, { "cmdk-overlay": "", className: c }), t2.createElement(Content3, { "aria-label": r2.label, "cmdk-dialog": "", className: d }, t2.createElement(me, { ref: o3, ...p2 }))));
});
var Ie = t2.forwardRef((r2, o3) => P((u2) => u2.filtered.count === 0) ? t2.createElement(Primitive.div, { ref: o3, ...r2, "cmdk-empty": "", role: "presentation" }) : null);
var Pe = t2.forwardRef((r2, o3) => {
  let { progress: n3, children: u2, label: c = "Loading...", ...d } = r2;
  return t2.createElement(Primitive.div, { ref: o3, ...d, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n3, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": c }, B2(r2, (f) => t2.createElement("div", { "aria-hidden": true }, f)));
});
var _e = Object.assign(me, { List: Ce, Item: he, Input: Se, Group: Ee, Separator: ye, Dialog: xe, Empty: Ie, Loading: Pe });
function we(r2, o3) {
  let n3 = r2.nextElementSibling;
  for (; n3; ) {
    if (n3.matches(o3)) return n3;
    n3 = n3.nextElementSibling;
  }
}
function De(r2, o3) {
  let n3 = r2.previousElementSibling;
  for (; n3; ) {
    if (n3.matches(o3)) return n3;
    n3 = n3.previousElementSibling;
  }
}
function pe(r2) {
  let o3 = t2.useRef(r2);
  return k2(() => {
    o3.current = r2;
  }), o3;
}
var k2 = typeof window == "undefined" ? t2.useEffect : t2.useLayoutEffect;
function L(r2) {
  let o3 = t2.useRef();
  return o3.current === void 0 && (o3.current = r2()), o3;
}
function P(r2) {
  let o3 = ee(), n3 = () => r2(o3.snapshot());
  return t2.useSyncExternalStore(o3.subscribe, n3, n3);
}
function ve(r2, o3, n3, u2 = []) {
  let c = t2.useRef(), d = K2();
  return k2(() => {
    var b;
    let f = (() => {
      var m2;
      for (let R of n3) {
        if (typeof R == "string") return R.trim();
        if (typeof R == "object" && "current" in R) return R.current ? (m2 = R.current.textContent) == null ? void 0 : m2.trim() : c.current;
      }
    })(), p2 = u2.map((m2) => m2.trim());
    d.value(r2, f, p2), (b = o3.current) == null || b.setAttribute(T, f), c.current = f;
  }), c;
}
var ke = () => {
  let [r2, o3] = t2.useState(), n3 = L(() => /* @__PURE__ */ new Map());
  return k2(() => {
    n3.current.forEach((u2) => u2()), n3.current = /* @__PURE__ */ new Map();
  }, [r2]), (u2, c) => {
    n3.current.set(u2, c), o3({});
  };
};
function Me(r2) {
  let o3 = r2.type;
  return typeof o3 == "function" ? o3(r2.props) : "render" in o3 ? o3.render(r2.props) : r2;
}
function B2({ asChild: r2, children: o3 }, n3) {
  return r2 && t2.isValidElement(o3) ? t2.cloneElement(Me(o3), { ref: o3.ref }, n3(o3.props.children)) : n3(o3);
}
var Te = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };

// node_modules/@liveblocks/react-tiptap/dist/ai/AiToolbar.js
var import_react43 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);

// node_modules/@liveblocks/react-tiptap/dist/context.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react41 = __toESM(require_react(), 1);
var EditorContext2 = (0, import_react41.createContext)(null);
function EditorProvider({
  editor,
  children
}) {
  return (0, import_jsx_runtime87.jsx)(EditorContext2.Provider, {
    value: editor,
    children
  });
}
function useCurrentEditor(source, parent3) {
  const currentEditor = (0, import_react41.useContext)(EditorContext2);
  return nn(currentEditor, `${source} can’t be used outside of ${parent3}.`);
}

// node_modules/@liveblocks/react-tiptap/dist/types.js
var LIVEBLOCKS_MENTION_KEY = new PluginKey("lb-plugin-mention");
var LIVEBLOCKS_MENTION_PASTE_KEY = new PluginKey(
  "lb-plugin-mention-paste"
);
var LIVEBLOCKS_MENTION_NOTIFIER_KEY = new PluginKey(
  "lb-plugin-mention-notify"
);
var LIVEBLOCKS_MENTION_EXTENSION = "liveblocksMentionExt";
var LIVEBLOCKS_MENTION_TYPE = "liveblocksMention";
var LIVEBLOCKS_GROUP_MENTION_TYPE = "liveblocksGroupMention";
var THREADS_ACTIVE_SELECTION_PLUGIN = new PluginKey(
  "lb-threads-active-selection-plugin"
);
var THREADS_PLUGIN_KEY = new PluginKey(
  "lb-threads-plugin"
);
var AI_TOOLBAR_SELECTION_PLUGIN = new PluginKey(
  "lb-ai-toolbar-selection-plugin"
);
var LIVEBLOCKS_COMMENT_MARK_TYPE = "liveblocksCommentMark";
var ThreadPluginActions = ((ThreadPluginActions2) => {
  ThreadPluginActions2["SET_SELECTED_THREAD_ID"] = "SET_SELECTED_THREAD_ID";
  return ThreadPluginActions2;
})(ThreadPluginActions || {});

// node_modules/@liveblocks/react-tiptap/dist/utils.js
var CONTEXT_TRUNCATION = "[…]";
var CONTEXT_BLOCK_SEPARATOR = "\n";
var getRectFromCoords = (coords) => {
  return {
    ...coords,
    x: coords.left,
    y: coords.top,
    width: coords.right - coords.left,
    height: coords.bottom - coords.top
  };
};
var getMentionsFromNode = (node3, range2) => {
  const mentions = /* @__PURE__ */ new Map();
  node3.nodesBetween(range2.from, range2.to, (child) => {
    if (child.type.name === LIVEBLOCKS_MENTION_TYPE || child.type.name === LIVEBLOCKS_GROUP_MENTION_TYPE) {
      const mention = child.attrs;
      if (mention.id && mention.notificationId) {
        if (child.type.name === LIVEBLOCKS_MENTION_TYPE) {
          mentions.set(mention.notificationId, {
            kind: "user",
            id: mention.id,
            notificationId: mention.notificationId
          });
        } else if (child.type.name === LIVEBLOCKS_GROUP_MENTION_TYPE) {
          let userIds;
          if (mention.userIds) {
            try {
              const parsedUserIds = JSON.parse(mention.userIds);
              if (Array.isArray(parsedUserIds)) {
                userIds = parsedUserIds;
              }
            } catch {
              userIds = void 0;
            }
          }
          mentions.set(mention.notificationId, {
            kind: "group",
            id: mention.id,
            userIds,
            notificationId: mention.notificationId
          });
        } else {
          assertNever(child.type.name, "Unexpected mention kind");
        }
      }
    }
  });
  return mentions;
};
var mapFragment = (fragment2, callback) => {
  const content = [];
  fragment2.forEach((node3) => {
    if (node3.content.childCount > 0) {
      content.push(
        node3.type.create(node3.attrs, mapFragment(node3.content, callback))
      );
      return;
    }
    content.push(callback(node3));
  });
  return Fragment.from(content);
};
function getDomRangeFromSelection(editor, selection) {
  if (selection.from === selection.to) {
    const { parent: parent3, parentOffset } = selection.$from;
    if (parent3.isBlock && parent3.content.size === 0 || parent3.isTextblock && parentOffset === parent3.content.size) {
      selection = TextSelection.create(
        editor.state.doc,
        selection.$from.before(),
        selection.$from.after()
      );
    }
  }
  const from2 = editor.view.domAtPos(selection.from);
  const to = editor.view.domAtPos(selection.to);
  const domRange = document.createRange();
  domRange.setStart(from2.node, from2.offset);
  domRange.setEnd(to.node, to.offset);
  return domRange;
}
function compareSelections(a, b) {
  if (!a || !b) {
    return false;
  }
  return a.eq(b);
}
function getContextualPromptContext(editor, maxLength = 1e4) {
  const { selection, doc } = editor.state;
  const selectionLength = selection.to - selection.from;
  if (maxLength >= doc.content.size) {
    return {
      beforeSelection: doc.textBetween(
        0,
        selection.from,
        CONTEXT_BLOCK_SEPARATOR
      ),
      selection: doc.textBetween(
        selection.from,
        selection.to,
        CONTEXT_BLOCK_SEPARATOR
      ),
      afterSelection: doc.textBetween(
        selection.to,
        doc.content.size,
        CONTEXT_BLOCK_SEPARATOR
      )
    };
  } else if (selectionLength > maxLength) {
    const selectionStart = doc.textBetween(
      selection.from,
      selection.from + Math.floor(maxLength / 2) - CONTEXT_TRUNCATION.length,
      CONTEXT_BLOCK_SEPARATOR
    );
    const selectionEnd = doc.textBetween(
      selection.to - Math.floor(maxLength / 2) + CONTEXT_TRUNCATION.length,
      selection.to,
      CONTEXT_BLOCK_SEPARATOR
    );
    return {
      beforeSelection: "",
      selection: `${selectionStart}${CONTEXT_TRUNCATION}${selectionEnd}`,
      afterSelection: ""
    };
  } else {
    let beforeLength = Math.min(
      selection.from,
      Math.floor((maxLength - selectionLength) / 2)
    );
    const afterLength = Math.min(
      doc.content.size - selection.to,
      maxLength - selectionLength - beforeLength
    );
    if (beforeLength + afterLength + selectionLength < maxLength) {
      beforeLength = Math.min(
        selection.from,
        maxLength - selectionLength - afterLength
      );
    }
    let beforeSelection = doc.textBetween(
      Math.max(0, selection.from - beforeLength),
      selection.from,
      CONTEXT_BLOCK_SEPARATOR
    );
    let afterSelection = doc.textBetween(
      selection.to,
      Math.min(doc.content.size, selection.to + afterLength),
      CONTEXT_BLOCK_SEPARATOR
    );
    if (selection.from - beforeLength > 0) {
      beforeSelection = `${CONTEXT_TRUNCATION}${beforeSelection}`;
    }
    if (selection.to + afterLength < doc.content.size) {
      afterSelection = `${afterSelection}${CONTEXT_TRUNCATION}`;
    }
    return {
      beforeSelection,
      selection: doc.textBetween(
        selection.from,
        selection.to,
        CONTEXT_BLOCK_SEPARATOR
      ),
      afterSelection
    };
  }
}

// node_modules/@liveblocks/react-tiptap/dist/ai/AiExtension.js
var DEFAULT_AI_NAME = "AI";
var DEFAULT_STATE = { phase: "closed" };
var RESOLVE_AI_PROMPT_RETRY_ATTEMPTS = 3;
var RESOLVE_AI_PROMPT_RETRY_DELAYS = [1e3, 2e3, 4e3];
function getYjsBinding(editor) {
  return ySyncPluginKey.getState(editor.view.state).binding;
}
function getLiveblocksYjsProvider(editor) {
  var _a3;
  return (_a3 = editor.extensionStorage.liveblocksExtension) == null ? void 0 : _a3.provider;
}
function isContextualPromptDiffResponse(response) {
  return response.type === "replace" || response.type === "insert";
}
function isResolveContextualPromptResponse(response) {
  return typeof response === "object" && response !== null && typeof response.text === "string" && typeof response.type === "string" && ["insert", "replace", "other"].includes(response.type);
}
function createParagraph(editor, text) {
  const paragraph2 = editor.schema.nodes.paragraph ?? Object.values(editor.schema.nodes).find((node3) => node3.isBlock);
  if (!paragraph2) {
    throw new Error("Could not create a paragraph.");
  }
  return paragraph2.create(null, text ? editor.schema.text(text) : void 0);
}
function getRevertTransaction(tr, editor, storage, doc) {
  if (storage.snapshot) {
    const binding = getYjsBinding(editor);
    if (binding) {
      binding.mapping.clear();
      const docFromSnapshot = createDocFromSnapshot(
        binding.doc,
        storage.snapshot
      );
      const type = docFromSnapshot.getXmlFragment("default");
      const fragmentContent = yXmlFragmentToProseMirrorFragment(
        type,
        editor.state.schema
      );
      tr.setMeta("addToHistory", false);
      tr.replace(
        0,
        editor.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      tr.setMeta(ySyncPluginKey, {
        snapshot: null,
        prevSnapshot: null
      });
      if (doc) {
        doc.gc = true;
      }
      storage.snapshot = void 0;
      return tr;
    }
  }
  return null;
}
var AiExtension = Extension.create({
  name: "liveblocksAi",
  addOptions() {
    return {
      doc: void 0,
      pud: void 0,
      resolveContextualPrompt: () => Promise.reject(),
      name: DEFAULT_AI_NAME
    };
  },
  addStorage() {
    return {
      state: DEFAULT_STATE,
      name: this.options.name
    };
  },
  addCommands() {
    return {
      askAi: (prompt) => () => {
        if (typeof prompt === "string") {
          this.editor.commands.$startAiToolbarThinking(prompt);
        } else {
          this.editor.commands.$openAiToolbarAsking();
        }
        return true;
      },
      closeAi: () => () => {
        this.editor.commands.$closeAiToolbar();
        return true;
      },
      $acceptAiToolbarResponse: () => ({ tr, view }) => {
        var _a3;
        const currentState = this.storage.state;
        if (currentState.phase !== "reviewing") {
          return false;
        }
        if (isContextualPromptDiffResponse(currentState.response)) {
          const binding = getYjsBinding(this.editor);
          if (!binding) {
            return false;
          }
          const fragmentContent = yXmlFragmentToProseMirrorFragment(
            binding.type,
            this.editor.state.schema
          );
          tr.setMeta("addToHistory", false);
          tr.replace(
            0,
            this.editor.state.doc.content.size,
            new Slice(Fragment.from(fragmentContent), 0, 0)
          );
          tr.setMeta(ySyncPluginKey, {
            snapshot: null,
            prevSnapshot: null
          });
          this.storage.snapshot = void 0;
        } else {
          const paragraphs = currentState.response.text.split("\n").map((paragraph2) => createParagraph(this.editor, paragraph2));
          tr.insert(this.editor.state.selection.$to.end(), paragraphs);
          tr.setMeta("addToHistory", true);
          view.dispatch(tr);
          tr.setMeta("preventDispatch", true);
        }
        (_a3 = getLiveblocksYjsProvider(this.editor)) == null ? void 0 : _a3.unpause();
        this.editor.setEditable(true);
        this.storage.state = { phase: "closed" };
        return true;
      },
      $closeAiToolbar: () => ({ tr, view }) => {
        var _a3;
        const currentState = this.storage.state;
        if (currentState.phase === "closed") {
          return false;
        }
        if (currentState.phase === "thinking") {
          currentState.abortController.abort();
        }
        if (currentState.phase === "thinking" || currentState.phase === "reviewing") {
          const revertTr = getRevertTransaction(
            tr,
            this.editor,
            this.storage,
            this.options.doc
          );
          if (revertTr) {
            view.dispatch(revertTr);
            tr.setMeta("preventDispatch", true);
          }
        }
        this.editor.commands.setTextSelection(currentState.initialSelection);
        (_a3 = getLiveblocksYjsProvider(this.editor)) == null ? void 0 : _a3.unpause();
        this.editor.setEditable(true);
        this.storage.state = { phase: "closed" };
        return true;
      },
      $openAiToolbarAsking: () => () => {
        const currentState = this.storage.state;
        if (currentState.phase !== "closed") {
          return false;
        }
        if (this.editor.isFocused) {
          this.editor.commands.blur();
        }
        this.storage.state = {
          phase: "asking",
          initialSelection: {
            from: this.editor.state.selection.from,
            to: this.editor.state.selection.to
          },
          customPrompt: ""
        };
        return true;
      },
      $startAiToolbarThinking: (prompt, withPreviousResponse) => ({ tr, view }) => {
        const currentState = this.storage.state;
        if (currentState.phase === "thinking") {
          return false;
        }
        if (this.editor.isFocused) {
          this.editor.commands.blur();
        }
        const abortController = new AbortController();
        const provider = getLiveblocksYjsProvider(this.editor);
        if (currentState.phase === "reviewing") {
          const revertTr = getRevertTransaction(
            tr,
            this.editor,
            this.storage,
            this.options.doc
          );
          if (revertTr) {
            view.dispatch(revertTr);
            tr.setMeta("preventDispatch", true);
          }
          this.editor.commands.setTextSelection(
            currentState.initialSelection
          );
        }
        this.storage.state = {
          phase: "thinking",
          initialSelection: currentState.initialSelection ?? {
            from: this.editor.state.selection.from,
            to: this.editor.state.selection.to
          },
          customPrompt: currentState.customPrompt ?? "",
          prompt,
          abortController,
          previousResponse: currentState.response
        };
        this.editor.setEditable(false);
        autoRetry(
          async () => {
            var _a3, _b;
            await (provider == null ? void 0 : provider.pause());
            const response = await this.options.resolveContextualPrompt({
              prompt,
              context: getContextualPromptContext(this.editor, 3e3),
              signal: abortController.signal,
              previous: withPreviousResponse && currentState.phase === "reviewing" ? {
                prompt: currentState.prompt,
                response: {
                  type: (_a3 = currentState.response) == null ? void 0 : _a3.type,
                  text: (_b = currentState.response) == null ? void 0 : _b.text
                }
              } : void 0
            });
            if (isResolveContextualPromptResponse(response)) {
              return response;
            } else {
              throw new Error("Failed to resolve AI prompt.");
            }
          },
          RESOLVE_AI_PROMPT_RETRY_ATTEMPTS,
          RESOLVE_AI_PROMPT_RETRY_DELAYS,
          (error) => {
            return abortController.signal.aborted || error instanceof HttpError && error.status >= 400 && error.status < 500;
          }
        ).then((response) => {
          if (abortController.signal.aborted) {
            return;
          }
          this.editor.commands._handleAiToolbarThinkingSuccess({
            type: response.type,
            text: response.text
          });
        }).catch((error) => {
          if (abortController.signal.aborted) {
            return;
          }
          this.editor.commands._handleAiToolbarThinkingError(error);
        });
        return true;
      },
      $cancelAiToolbarThinking: () => () => {
        const currentState = this.storage.state;
        if (currentState.phase !== "thinking") {
          return false;
        }
        currentState.abortController.abort();
        this.editor.setEditable(true);
        this.storage.state = {
          phase: "asking",
          initialSelection: currentState.initialSelection,
          customPrompt: currentState.prompt === currentState.customPrompt ? currentState.customPrompt : ""
        };
        return true;
      },
      _showAiToolbarReviewingDiff: () => () => {
        var _a3;
        if (this.storage.state.phase !== "reviewing") {
          return false;
        }
        if (!this.options.doc || !this.storage.snapshot) {
          return false;
        }
        const previousSnapshot = this.storage.snapshot ?? emptySnapshot;
        const currentSnapshot = snapshot(this.options.doc);
        if (equalSnapshots(previousSnapshot, currentSnapshot)) {
          return true;
        }
        (_a3 = getYjsBinding(this.editor)) == null ? void 0 : _a3.renderSnapshot(
          currentSnapshot,
          previousSnapshot
        );
        return true;
      },
      _handleAiToolbarThinkingSuccess: (response) => ({ view, tr }) => {
        const currentState = this.storage.state;
        if (currentState.phase !== "thinking") {
          return false;
        }
        if (!isContextualPromptDiffResponse(response)) {
          this.storage.state = {
            phase: "reviewing",
            initialSelection: currentState.initialSelection,
            customPrompt: "",
            prompt: currentState.prompt,
            response
          };
          return true;
        }
        if (!this.options.doc) {
          return false;
        }
        this.options.doc.gc = false;
        this.storage.snapshot = snapshot(this.options.doc);
        this.storage.state = {
          phase: "reviewing",
          initialSelection: currentState.initialSelection,
          customPrompt: "",
          prompt: currentState.prompt,
          response
        };
        const [firstParagraph, ...otherParagraphs] = response.text.split("\n");
        tr.insertText(
          firstParagraph,
          response.type === "insert" ? this.editor.state.selection.to : this.editor.state.selection.from,
          this.editor.state.selection.to
        );
        if (otherParagraphs.length > 0) {
          const paragraphs = otherParagraphs.map(
            (paragraph2) => createParagraph(this.editor, paragraph2)
          );
          tr.insert(tr.selection.$to.pos, paragraphs);
        }
        view.dispatch(tr);
        tr.setMeta("preventDispatch", true);
        this.editor.commands._showAiToolbarReviewingDiff();
        return true;
      },
      _handleAiToolbarThinkingError: (error) => () => {
        const currentState = this.storage.state;
        if (currentState.phase !== "thinking") {
          return false;
        }
        this.editor.setEditable(true);
        console.error(error);
        this.storage.state = {
          phase: "asking",
          initialSelection: currentState.initialSelection,
          customPrompt: currentState.prompt === currentState.customPrompt ? currentState.customPrompt : "",
          error: error instanceof Error ? error : new Error(String(error), { cause: error })
        };
        return true;
      },
      _updateAiToolbarCustomPrompt: (customPrompt) => () => {
        const currentState = this.storage.state;
        if (typeof currentState.customPrompt !== "string") {
          return false;
        }
        this.storage.state.customPrompt = typeof customPrompt === "function" ? customPrompt(currentState.customPrompt) : customPrompt;
        return true;
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: AI_TOOLBAR_SELECTION_PLUGIN,
        props: {
          decorations: ({ doc, selection }) => {
            if (this.storage.state.phase === "closed" || this.storage.state.phase === "reviewing" && isContextualPromptDiffResponse(this.storage.state.response)) {
              return DecorationSet.create(doc, []);
            }
            const { from: from2, to } = selection;
            const decorations = [
              Decoration.inline(from2, to, {
                class: "lb-root lb-selection lb-tiptap-active-selection"
              })
            ];
            return DecorationSet.create(doc, decorations);
          }
        }
      })
    ];
  }
});

// node_modules/@liveblocks/react-tiptap/dist/ai/AiToolbar.js
var AI_TOOLBAR_COLLISION_PADDING = 10;
var AiToolbarContext = (0, import_react43.createContext)(null);
function useAiToolbarContext() {
  const context = (0, import_react43.useContext)(AiToolbarContext);
  if (!context) {
    throw new Error("useAiToolbarContext must be used within an AiToolbar");
  }
  return context;
}
function tiptapFloating(editor) {
  return {
    name: "tiptap",
    options: editor,
    fn({ elements }) {
      if (!editor) {
        return {};
      }
      const editorRect = editor.view.dom.getBoundingClientRect();
      elements.floating.style.setProperty(
        "--lb-tiptap-editor-width",
        `${editorRect.width}px`
      );
      elements.floating.style.setProperty(
        "--lb-tiptap-editor-height",
        `${editorRect.height}px`
      );
      return {
        x: editorRect.x
      };
    }
  };
}
function flipToolbar() {
  return {
    name: "flipToolbar",
    fn({ elements, middlewareData, rects }) {
      var _a3;
      const shiftOffsetY = ((_a3 = middlewareData.shift) == null ? void 0 : _a3.y) ?? 0;
      if (Math.abs(shiftOffsetY) >= rects.floating.height) {
        elements.floating.setAttribute("data-liveblocks-ai-toolbar-flip", "");
      } else {
        elements.floating.removeAttribute("data-liveblocks-ai-toolbar-flip");
      }
      return {};
    }
  };
}
var AiToolbarDropdownSeparator = (0, import_react43.forwardRef)(({ className, ...props }, forwardedRef) => {
  return (0, import_jsx_runtime88.jsx)(_e.Separator, {
    className: cn("lb-dropdown-separator", className),
    ...props,
    ref: forwardedRef
  });
});
var AiToolbarSuggestionsSeparator = (0, import_react43.forwardRef)((props, forwardedRef) => {
  return (0, import_jsx_runtime88.jsx)(AiToolbarDropdownSeparator, {
    ref: forwardedRef,
    ...props
  });
});
var AiToolbarDropdownItem = (0, import_react43.forwardRef)(({ children, onSelect, icon, className, ...props }, forwardedRef) => {
  return (0, import_jsx_runtime88.jsxs)(_e.Item, {
    className: cn("lb-dropdown-item", className),
    onSelect,
    ...props,
    ref: forwardedRef,
    children: [
      icon ? (0, import_jsx_runtime88.jsx)("span", {
        className: "lb-icon-container",
        children: icon
      }) : null,
      children ? (0, import_jsx_runtime88.jsx)("span", {
        className: "lb-dropdown-item-label",
        children
      }) : null
    ]
  });
});
var AiToolbarSuggestionsLabel = (0, import_react43.forwardRef)(({ children, className, ...props }, forwardedRef) => {
  return (0, import_jsx_runtime88.jsx)("span", {
    ref: forwardedRef,
    className: cn("lb-dropdown-label", className),
    ...props,
    children
  });
});
var AiToolbarSuggestion = (0, import_react43.forwardRef)(({ prompt: manualPrompt, ...props }, forwardedRef) => {
  const editor = useCurrentEditor("Suggestion", "AiToolbar");
  const handleSelect = (0, import_react43.useCallback)(
    (prompt) => {
      editor.commands.$startAiToolbarThinking(
        manualPrompt ?? prompt
      );
    },
    [editor, manualPrompt]
  );
  return (0, import_jsx_runtime88.jsx)(AiToolbarDropdownItem, {
    ...props,
    onSelect: handleSelect,
    ref: forwardedRef
  });
});
function AiToolbarReviewingSuggestions() {
  const editor = useCurrentEditor("ReviewingSuggestions", "AiToolbar");
  const { state } = useAiToolbarContext();
  const { response } = state;
  if (isContextualPromptDiffResponse(response)) {
    return (0, import_jsx_runtime88.jsxs)(import_jsx_runtime88.Fragment, {
      children: [
        (0, import_jsx_runtime88.jsx)(AiToolbarDropdownItem, {
          icon: (0, import_jsx_runtime88.jsx)(CheckIcon, {}),
          onSelect: editor.commands.$acceptAiToolbarResponse,
          children: "Accept"
        }),
        (0, import_jsx_runtime88.jsx)(AiToolbarDropdownItem, {
          icon: (0, import_jsx_runtime88.jsx)(UndoIcon, {}),
          onSelect: editor.commands.$startAiToolbarThinking,
          children: "Try again"
        }),
        (0, import_jsx_runtime88.jsx)(AiToolbarDropdownItem, {
          icon: (0, import_jsx_runtime88.jsx)(CrossIcon, {}),
          onSelect: editor.commands.$closeAiToolbar,
          children: "Discard"
        })
      ]
    });
  } else {
    return (0, import_jsx_runtime88.jsxs)(import_jsx_runtime88.Fragment, {
      children: [
        (0, import_jsx_runtime88.jsx)(AiToolbarDropdownItem, {
          icon: (0, import_jsx_runtime88.jsx)(ArrowCornerDownRightIcon, {}),
          onSelect: editor.commands.$acceptAiToolbarResponse,
          children: "Insert below"
        }),
        (0, import_jsx_runtime88.jsx)(AiToolbarDropdownItem, {
          icon: (0, import_jsx_runtime88.jsx)(UndoIcon, {}),
          onSelect: editor.commands.$startAiToolbarThinking,
          children: "Try again"
        }),
        (0, import_jsx_runtime88.jsx)(AiToolbarDropdownItem, {
          icon: (0, import_jsx_runtime88.jsx)(CrossIcon, {}),
          onSelect: editor.commands.$closeAiToolbar,
          children: "Discard"
        })
      ]
    });
  }
}
function AiToolbarCustomPromptContent() {
  const editor = useCurrentEditor("CustomPromptContent", "AiToolbar");
  const aiName = editor.storage.liveblocksAi.name;
  const textAreaRef = (0, import_react43.useRef)(null);
  const { state, dropdownRef, isDropdownHidden } = useAiToolbarContext();
  const { customPrompt } = state;
  const isCustomPromptEmpty = (0, import_react43.useMemo)(
    () => customPrompt.trim() === "",
    [customPrompt]
  );
  useLayoutEffect2(
    () => {
      requestAnimationFrame(() => {
        const textArea = textAreaRef.current;
        if (!textArea) {
          return;
        }
        textArea.focus();
        textArea.setSelectionRange(
          textArea.value.length,
          textArea.value.length
        );
      });
    },
    []
  );
  const handlePromptKeyDown = (event) => {
    var _a3;
    if (event.key === "Enter") {
      event.preventDefault();
      event.stopPropagation();
      if (event.shiftKey) {
        editor.commands._updateAiToolbarCustomPrompt(
          (customPrompt2) => customPrompt2 + "\n"
        );
      } else {
        const selectedDropdownItem = (_a3 = dropdownRef.current) == null ? void 0 : _a3.querySelector(
          "[role='option'][data-selected='true']"
        );
        if (!isDropdownHidden && selectedDropdownItem) {
          selectedDropdownItem.click();
        } else if (!isCustomPromptEmpty) {
          editor.commands.$startAiToolbarThinking(
            customPrompt,
            state.phase === "reviewing"
          );
        }
      }
    }
  };
  const handleCustomPromptChange = (0, import_react43.useCallback)(
    (customPrompt2) => {
      editor.commands._updateAiToolbarCustomPrompt(
        customPrompt2
      );
    },
    [editor]
  );
  const handleSendClick = (0, import_react43.useCallback)(() => {
    if (isCustomPromptEmpty) {
      return;
    }
    editor.commands.$startAiToolbarThinking(
      customPrompt,
      state.phase === "reviewing"
    );
  }, [editor, customPrompt, isCustomPromptEmpty, state.phase]);
  return (0, import_jsx_runtime88.jsxs)("div", {
    className: "lb-tiptap-ai-toolbar-content",
    children: [
      (0, import_jsx_runtime88.jsx)("span", {
        className: "lb-icon-container lb-tiptap-ai-toolbar-icon-container",
        children: (0, import_jsx_runtime88.jsx)(SparklesIcon, {})
      }),
      (0, import_jsx_runtime88.jsx)("div", {
        className: "lb-tiptap-ai-toolbar-custom-prompt-container",
        "data-value": customPrompt,
        children: (0, import_jsx_runtime88.jsx)(_e.Input, {
          value: customPrompt,
          onValueChange: handleCustomPromptChange,
          asChild: true,
          children: (0, import_jsx_runtime88.jsx)("textarea", {
            ref: textAreaRef,
            className: "lb-tiptap-ai-toolbar-custom-prompt",
            placeholder: `Ask ${aiName} anything…`,
            onKeyDown: handlePromptKeyDown,
            rows: 1,
            autoFocus: true
          })
        })
      }),
      (0, import_jsx_runtime88.jsx)("div", {
        className: "lb-tiptap-ai-toolbar-actions",
        children: (0, import_jsx_runtime88.jsx)(ShortcutTooltip, {
          content: `Ask ${aiName}`,
          shortcut: "Enter",
          children: (0, import_jsx_runtime88.jsx)(Button, {
            className: "lb-tiptap-ai-toolbar-action",
            variant: "primary",
            "aria-label": `Ask ${aiName}`,
            icon: (0, import_jsx_runtime88.jsx)(SendIcon, {}),
            disabled: isCustomPromptEmpty,
            onClick: handleSendClick
          })
        })
      })
    ]
  });
}
function AiToolbarAsking() {
  const { state } = useAiToolbarContext();
  const { error } = state;
  return (0, import_jsx_runtime88.jsxs)(import_jsx_runtime88.Fragment, {
    children: [
      (0, import_jsx_runtime88.jsx)(AiToolbarCustomPromptContent, {}),
      error ? (0, import_jsx_runtime88.jsxs)("div", {
        className: "lb-tiptap-ai-toolbar-error",
        children: [
          (0, import_jsx_runtime88.jsx)("span", {
            className: "lb-icon-container",
            children: (0, import_jsx_runtime88.jsx)(WarningIcon, {})
          }),
          "There was a problem with your request."
        ]
      }) : null
    ]
  });
}
function AiToolbarThinking() {
  const editor = useCurrentEditor("AiToolbarThinking", "AiToolbar");
  const contentRef = (0, import_react43.useRef)(null);
  const aiName = editor.storage.liveblocksAi.name;
  const handleAbort = (0, import_react43.useCallback)(() => {
    editor.commands.$cancelAiToolbarThinking();
  }, [editor]);
  useLayoutEffect2(() => {
    var _a3, _b;
    (_a3 = contentRef.current) == null ? void 0 : _a3.focus();
    (_b = window.getSelection()) == null ? void 0 : _b.removeAllRanges();
  }, []);
  return (0, import_jsx_runtime88.jsx)(import_jsx_runtime88.Fragment, {
    children: (0, import_jsx_runtime88.jsxs)("div", {
      className: "lb-tiptap-ai-toolbar-content",
      tabIndex: 0,
      ref: contentRef,
      children: [
        (0, import_jsx_runtime88.jsx)("span", {
          className: "lb-icon-container lb-tiptap-ai-toolbar-icon-container",
          children: (0, import_jsx_runtime88.jsx)(SparklesIcon, {})
        }),
        (0, import_jsx_runtime88.jsxs)("div", {
          className: "lb-tiptap-ai-toolbar-thinking",
          children: [
            aiName,
            " is thinking…"
          ]
        }),
        (0, import_jsx_runtime88.jsx)("div", {
          className: "lb-tiptap-ai-toolbar-actions",
          children: (0, import_jsx_runtime88.jsx)(ShortcutTooltip, {
            content: "Abort response",
            shortcut: "Escape",
            children: (0, import_jsx_runtime88.jsx)(Button, {
              className: "lb-tiptap-ai-toolbar-action",
              variant: "secondary",
              "aria-label": "Abort response",
              icon: (0, import_jsx_runtime88.jsx)(StopIcon, {}),
              onClick: handleAbort
            })
          })
        })
      ]
    })
  });
}
function AiToolbarReviewing() {
  const { state } = useAiToolbarContext();
  const { response } = state;
  return (0, import_jsx_runtime88.jsxs)(import_jsx_runtime88.Fragment, {
    children: [
      response.type === "other" ? (0, import_jsx_runtime88.jsx)("div", {
        className: "lb-tiptap-ai-toolbar-response-container",
        children: (0, import_jsx_runtime88.jsx)("div", {
          className: "lb-tiptap-ai-toolbar-response",
          children: response.text
        })
      }) : null,
      (0, import_jsx_runtime88.jsx)(AiToolbarCustomPromptContent, {})
    ]
  });
}
function AiToolbarContainer({
  state,
  toolbarRef,
  dropdownRef,
  children
}) {
  const editor = useCurrentEditor("AiToolbarContainer", "AiToolbar");
  const customPrompt = state.customPrompt;
  const isCustomPromptMultiline = (0, import_react43.useMemo)(
    () => customPrompt == null ? void 0 : customPrompt.includes("\n"),
    [customPrompt]
  );
  const hasDropdownItems = P(
    (state2) => state2.filtered.count > 0
  );
  const isDropdownHidden = isCustomPromptMultiline || !hasDropdownItems;
  (0, import_react43.useEffect)(() => {
    if (!editor) {
      return;
    }
    const handleKeyDown = (event) => {
      if (!event.defaultPrevented && event.key === "Escape") {
        event.preventDefault();
        event.stopPropagation();
        if (state.phase === "thinking") {
          editor.commands.$cancelAiToolbarThinking();
        } else {
          editor.chain().$closeAiToolbar().focus().run();
        }
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [editor, state.phase]);
  return (0, import_jsx_runtime88.jsxs)(AiToolbarContext.Provider, {
    value: {
      state,
      toolbarRef,
      dropdownRef,
      isDropdownHidden
    },
    children: [
      (0, import_jsx_runtime88.jsxs)("div", {
        className: "lb-tiptap-ai-toolbar-container",
        children: [
          (0, import_jsx_runtime88.jsx)("div", {
            className: "lb-elevation lb-tiptap-ai-toolbar",
            children: state.phase === "asking" ? (0, import_jsx_runtime88.jsx)(AiToolbarAsking, {}) : state.phase === "thinking" ? (0, import_jsx_runtime88.jsx)(AiToolbarThinking, {}) : state.phase === "reviewing" ? (0, import_jsx_runtime88.jsx)(AiToolbarReviewing, {}) : null
          }),
          (0, import_jsx_runtime88.jsxs)("div", {
            className: "lb-tiptap-ai-toolbar-halo",
            "data-active": state.phase === "thinking" ? "" : void 0,
            "aria-hidden": true,
            children: [
              (0, import_jsx_runtime88.jsx)("div", {
                className: "lb-tiptap-ai-toolbar-halo-horizontal"
              }),
              (0, import_jsx_runtime88.jsx)("div", {
                className: "lb-tiptap-ai-toolbar-halo-vertical"
              })
            ]
          })
        ]
      }),
      state.phase === "asking" || state.phase === "reviewing" ? (0, import_jsx_runtime88.jsx)(_e.List, {
        className: "lb-elevation lb-dropdown lb-tiptap-ai-toolbar-dropdown",
        "data-hidden": isDropdownHidden ? "" : void 0,
        ref: dropdownRef,
        children: state.phase === "reviewing" ? (0, import_jsx_runtime88.jsx)(AiToolbarReviewingSuggestions, {}) : children
      }) : null
    ]
  });
}
var defaultSuggestions = (0, import_jsx_runtime88.jsxs)(import_jsx_runtime88.Fragment, {
  children: [
    (0, import_jsx_runtime88.jsx)(AiToolbarSuggestion, {
      icon: (0, import_jsx_runtime88.jsx)(EditIcon, {}),
      prompt: "Improve the quality of the text",
      children: "Improve writing"
    }),
    (0, import_jsx_runtime88.jsx)(AiToolbarSuggestion, {
      icon: (0, import_jsx_runtime88.jsx)(CheckIcon, {}),
      prompt: "Fix spelling & grammar errors in the text",
      children: "Fix mistakes"
    }),
    (0, import_jsx_runtime88.jsx)(AiToolbarSuggestion, {
      icon: (0, import_jsx_runtime88.jsx)(ShortenIcon, {}),
      prompt: "Shorten the text, simplifying it",
      children: "Simplify"
    }),
    (0, import_jsx_runtime88.jsx)(AiToolbarSuggestion, {
      icon: (0, import_jsx_runtime88.jsx)(LengthenIcon, {}),
      prompt: "Lengthen the text, going into more detail",
      children: "Add more detail"
    }),
    (0, import_jsx_runtime88.jsx)(AiToolbarSuggestionsSeparator, {}),
    (0, import_jsx_runtime88.jsx)(AiToolbarSuggestion, {
      icon: (0, import_jsx_runtime88.jsx)(SparklesTextIcon, {}),
      prompt: "Continue writing from the text's end",
      children: "Continue writing"
    }),
    (0, import_jsx_runtime88.jsx)(AiToolbarSuggestion, {
      icon: (0, import_jsx_runtime88.jsx)(QuestionMarkIcon, {}),
      prompt: "Explain what the text is about",
      children: "Explain"
    })
  ]
});
var AiToolbar = Object.assign(
  (0, import_react43.forwardRef)(
    ({
      offset: sideOffset = 6,
      editor,
      className,
      suggestions: Suggestions = defaultSuggestions,
      ...props
    }, forwardedRef) => {
      const state = useEditorState({
        editor,
        selector: (ctx) => {
          var _a3, _b;
          return (_b = (_a3 = ctx.editor) == null ? void 0 : _a3.storage.liveblocksAi) == null ? void 0 : _b.state;
        }
      }) ?? DEFAULT_STATE;
      const selection = editor == null ? void 0 : editor.state.selection;
      const floatingOptions = (0, import_react43.useMemo)(() => {
        const detectOverflowOptions = {
          padding: AI_TOOLBAR_COLLISION_PADDING
        };
        return {
          strategy: "fixed",
          placement: "bottom",
          middleware: [
            tiptapFloating(editor),
            hide3(detectOverflowOptions),
            offset3(sideOffset),
            shift3({
              ...detectOverflowOptions,
              mainAxis: false,
              crossAxis: true,
              limiter: limitShift3()
            }),
            flipToolbar()
          ],
          whileElementsMounted: (...args) => {
            return autoUpdate(...args, {
              animationFrame: true
            });
          }
        };
      }, [editor, sideOffset]);
      const isOpen = selection !== void 0 && state.phase !== "closed";
      const {
        refs: { setReference, setFloating },
        strategy,
        x: x2,
        y,
        isPositioned
      } = useFloating({
        ...floatingOptions,
        open: isOpen
      });
      const toolbarRef = (0, import_react43.useRef)(null);
      const mergedRefs = useRefs(forwardedRef, toolbarRef, setFloating);
      const dropdownRef = (0, import_react43.useRef)(null);
      const [selectedDropdownValue, setSelectedDropdownValue] = (0, import_react43.useState)("");
      (0, import_react43.useEffect)(() => {
        if (state.phase === "closed") {
          setSelectedDropdownValue("");
        }
      }, [state.phase]);
      (0, import_react43.useEffect)(() => {
        var _a3, _b;
        if (state.phase === "closed") {
          setSelectedDropdownValue("");
          return;
        }
        const selectedDropdownItem = (_a3 = dropdownRef.current) == null ? void 0 : _a3.querySelector(
          "[role='option'][data-selected='true']"
        );
        if (selectedDropdownItem) {
          return;
        }
        const firstDropdownItem = (_b = dropdownRef.current) == null ? void 0 : _b.querySelector("[role='option']");
        setSelectedDropdownValue(
          (firstDropdownItem == null ? void 0 : firstDropdownItem.dataset.value) ?? ""
        );
      }, [state.phase, dropdownRef, setSelectedDropdownValue]);
      (0, import_react43.useEffect)(() => {
        if (!editor) {
          return;
        }
        if (!selection && state.phase !== "closed") {
          editor.commands.$closeAiToolbar();
        }
      }, [state.phase, editor, selection]);
      useLayoutEffect2(() => {
        if (!editor || !isOpen) {
          return;
        }
        setReference(null);
        setTimeout(() => {
          if (state.phase === "reviewing" && isContextualPromptDiffResponse(state.response)) {
            const changes = editor.view.dom.querySelectorAll(
              "ychange[data-liveblocks]"
            );
            setReference({
              getBoundingClientRect: () => {
                const rects = [];
                changes.forEach((change) => {
                  rects.push(change.getBoundingClientRect());
                });
                const minX = Math.min(...rects.map((rect) => rect.left));
                const minY = Math.min(...rects.map((rect) => rect.top));
                const maxX = Math.max(...rects.map((rect) => rect.right));
                const maxY = Math.max(...rects.map((rect) => rect.bottom));
                return {
                  x: minX,
                  y: minY,
                  width: maxX - minX,
                  height: maxY - minY,
                  top: minY,
                  left: minX,
                  bottom: maxY,
                  right: maxX
                };
              }
            });
          } else if (selection) {
            const domRange = getDomRangeFromSelection(editor, selection);
            setReference(domRange);
          } else {
            setReference(null);
          }
        }, 0);
      }, [
        selection,
        editor,
        isOpen,
        setReference,
        state.phase,
        state.response
      ]);
      (0, import_react43.useEffect)(() => {
        if (!editor || !isOpen) {
          return;
        }
        const handleOutsideEvent = (event) => {
          if (!toolbarRef.current) {
            return;
          }
          if (event.target && !toolbarRef.current.contains(event.target) && (dropdownRef.current ? !dropdownRef.current.contains(event.target) : true)) {
            editor.commands.$closeAiToolbar();
          }
        };
        setTimeout(() => {
          document.addEventListener("pointerdown", handleOutsideEvent);
        }, 0);
        return () => {
          document.removeEventListener("pointerdown", handleOutsideEvent);
        };
      }, [editor, isOpen]);
      if (!editor || !isOpen) {
        return null;
      }
      return (0, import_react_dom5.createPortal)(
        (0, import_jsx_runtime88.jsx)(TooltipProvider, {
          children: (0, import_jsx_runtime88.jsx)(EditorProvider, {
            editor,
            children: (0, import_jsx_runtime88.jsx)(_e, {
              role: "toolbar",
              label: "AI toolbar",
              "aria-orientation": "horizontal",
              className: cn(
                "lb-root lb-portal lb-tiptap-ai-toolbar-portal",
                className
              ),
              ref: mergedRefs,
              style: {
                position: strategy,
                top: 0,
                left: 0,
                transform: isPositioned ? `translate3d(${Math.round(x2)}px, ${Math.round(y)}px, 0)` : "translate3d(0, -200%, 0)"
              },
              value: selectedDropdownValue,
              onValueChange: setSelectedDropdownValue,
              ...props,
              children: (0, import_jsx_runtime88.jsx)(AiToolbarContainer, {
                state,
                dropdownRef,
                toolbarRef,
                children: typeof Suggestions === "function" ? (0, import_jsx_runtime88.jsx)(Suggestions, {
                  children: defaultSuggestions
                }) : Suggestions
              })
            })
          })
        }),
        document.body
      );
    }
  ),
  {
    Suggestion: AiToolbarSuggestion,
    SuggestionsLabel: AiToolbarSuggestionsLabel,
    SuggestionsSeparator: AiToolbarSuggestionsSeparator
  }
);

// node_modules/@liveblocks/react-tiptap/dist/comments/AnchoredThreads.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);

// node_modules/@liveblocks/react-ui/dist/version.js
var PKG_NAME3 = "@liveblocks/react-ui";
var PKG_VERSION3 = "3.7.1";
var PKG_FORMAT3 = "esm";

// node_modules/@liveblocks/react-ui/dist/components/AiChat.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/use-visible.js
var import_react44 = __toESM(require_react(), 1);
var optionlessIntersectionObserver;
var optionlessIntersectionCallbacks = /* @__PURE__ */ new WeakMap();
var individualIntersectionObservers = /* @__PURE__ */ new WeakMap();
function observe(element, callback, options2) {
  var _a3;
  if (!options2) {
    if (!optionlessIntersectionObserver) {
      optionlessIntersectionObserver = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          const callback2 = optionlessIntersectionCallbacks.get(entry.target);
          callback2 == null ? void 0 : callback2(entry);
        }
      });
    }
    optionlessIntersectionCallbacks.set(element, callback);
    optionlessIntersectionObserver.observe(element);
  } else {
    const observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          callback == null ? void 0 : callback(entry);
        }
      },
      {
        root: (_a3 = options2.root) == null ? void 0 : _a3.current,
        rootMargin: typeof options2.rootMargin === "number" ? `${options2.rootMargin}px` : options2.rootMargin,
        threshold: options2.threshold
      }
    );
    individualIntersectionObservers.set(element, observer);
    observer.observe(element);
  }
}
function unobserve(element, options2) {
  if (!options2) {
    optionlessIntersectionCallbacks.delete(element);
    optionlessIntersectionObserver == null ? void 0 : optionlessIntersectionObserver.unobserve(element);
  } else {
    const observer = individualIntersectionObservers.get(element);
    observer == null ? void 0 : observer.unobserve(element);
    individualIntersectionObservers.delete(element);
  }
}
function useIntersectionCallback(ref, callback, options2) {
  const enabled = (options2 == null ? void 0 : options2.enabled) ?? true;
  const latestCallback = useLatest(callback);
  const { root, rootMargin, threshold } = options2 ?? {};
  (0, import_react44.useEffect)(() => {
    const element = ref.current;
    if (!element) {
      return;
    }
    const observeOptions = {
      root,
      rootMargin,
      threshold
    };
    if (enabled) {
      observe(
        element,
        (entry) => {
          latestCallback.current(entry.isIntersecting, entry);
        },
        observeOptions
      );
    } else {
      unobserve(element, observeOptions);
    }
    return () => {
      unobserve(element, observeOptions);
    };
  }, [ref, enabled, latestCallback, root, rootMargin, threshold]);
}

// node_modules/@liveblocks/react-ui/dist/components/internal/AiChatAssistantMessage.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);
var AiChatAssistantMessage = (0, import_react45.memo)(
  (0, import_react45.forwardRef)(
    ({ message, className, overrides, components, ...props }, forwardedRef) => {
      const $3 = useOverrides(overrides);
      let children = null;
      if (message.deletedAt !== void 0) {
        children = (0, import_jsx_runtime89.jsx)("div", {
          className: "lb-ai-chat-message-deleted",
          children: $3.AI_CHAT_MESSAGE_DELETED
        });
      } else if (message.status === "generating" || message.status === "awaiting-tool") {
        if (message.contentSoFar.length === 0) {
          children = (0, import_jsx_runtime89.jsx)("div", {
            className: "lb-ai-chat-message-thinking lb-ai-chat-pending",
            children: $3.AI_CHAT_MESSAGE_THINKING
          });
        } else {
          children = (0, import_jsx_runtime89.jsx)(AssistantMessageContent, {
            message,
            components
          });
        }
      } else if (message.status === "completed") {
        children = (0, import_jsx_runtime89.jsx)(AssistantMessageContent, {
          message,
          components
        });
      } else if (message.status === "failed") {
        if (message.errorReason === "Aborted by user") {
          children = (0, import_jsx_runtime89.jsx)(AssistantMessageContent, {
            message,
            components
          });
        } else {
          children = (0, import_jsx_runtime89.jsxs)(import_jsx_runtime89.Fragment, {
            children: [
              (0, import_jsx_runtime89.jsx)(AssistantMessageContent, {
                message,
                components
              }),
              (0, import_jsx_runtime89.jsxs)("div", {
                className: "lb-ai-chat-message-error",
                children: [
                  (0, import_jsx_runtime89.jsx)("span", {
                    className: "lb-icon-container",
                    children: (0, import_jsx_runtime89.jsx)(WarningIcon, {})
                  }),
                  message.errorReason
                ]
              })
            ]
          });
        }
      }
      return (0, import_jsx_runtime89.jsx)("div", {
        className: cn(
          "lb-ai-chat-message lb-ai-chat-assistant-message",
          className
        ),
        ...props,
        ref: forwardedRef,
        children: (0, import_jsx_runtime89.jsx)(OverridesProvider, {
          overrides,
          children
        })
      });
    }
  )
);
function AssistantMessageContent({
  message,
  components
}) {
  const ref = (0, import_react45.useRef)(components);
  const BoundTextPart = (0, import_react45.useMemo)(
    () => (props) => (0, import_jsx_runtime89.jsx)(TextPart, {
      ...props,
      components: ref.current
    }),
    []
  );
  const BoundReasoningPart = (0, import_react45.useMemo)(
    () => (props) => (0, import_jsx_runtime89.jsx)(ReasoningPart, {
      ...props,
      components: ref.current
    }),
    []
  );
  return (0, import_jsx_runtime89.jsx)(AiMessageContent, {
    message,
    components: {
      TextPart: BoundTextPart,
      ReasoningPart: BoundReasoningPart,
      RetrievalPart,
      ToolInvocationPart
    },
    className: "lb-ai-chat-message-content"
  });
}
function TextPart({ part, components, isStreaming }) {
  return (0, import_jsx_runtime89.jsx)(Prose, {
    content: part.text,
    className: "lb-ai-chat-message-text",
    components,
    partial: isStreaming
  });
}
function ReasoningPart({ part, isStreaming, components }) {
  const [isOpen, setIsOpen] = (0, import_react45.useState)(isStreaming);
  const $3 = useOverrides();
  (0, import_react45.useEffect)(() => {
    if (!isStreaming) {
      setIsOpen(false);
    }
  }, [isStreaming]);
  return (0, import_jsx_runtime89.jsxs)(CollapsibleRoot, {
    className: "lb-collapsible lb-ai-chat-message-reasoning",
    open: isOpen,
    onOpenChange: setIsOpen,
    children: [
      (0, import_jsx_runtime89.jsxs)(CollapsibleTrigger, {
        className: cn(
          "lb-collapsible-trigger",
          isStreaming && "lb-ai-chat-pending"
        ),
        children: [
          $3.AI_CHAT_MESSAGE_REASONING(isStreaming, part),
          (0, import_jsx_runtime89.jsx)("span", {
            className: "lb-collapsible-chevron lb-icon-container",
            children: (0, import_jsx_runtime89.jsx)(ChevronRightIcon, {})
          })
        ]
      }),
      (0, import_jsx_runtime89.jsx)(CollapsibleContent, {
        className: "lb-collapsible-content",
        children: (0, import_jsx_runtime89.jsx)(Prose, {
          content: part.text,
          partial: isStreaming,
          components
        })
      })
    ]
  });
}
function RetrievalPart({ part, isStreaming }) {
  const $3 = useOverrides();
  return (0, import_jsx_runtime89.jsx)("div", {
    className: cn(
      "lb-ai-chat-message-retrieval",
      isStreaming && "lb-ai-chat-pending"
    ),
    children: $3.AI_CHAT_MESSAGE_RETRIEVAL(isStreaming, part)
  });
}
function ToolInvocationPart({
  part,
  message
}) {
  return (0, import_jsx_runtime89.jsx)("div", {
    className: "lb-ai-chat-message-tool-invocation",
    children: (0, import_jsx_runtime89.jsx)(ErrorBoundary, {
      fallback: (0, import_jsx_runtime89.jsxs)("div", {
        className: "lb-ai-chat-message-error",
        children: [
          (0, import_jsx_runtime89.jsx)("span", {
            className: "lb-icon-container",
            children: (0, import_jsx_runtime89.jsx)(WarningIcon, {})
          }),
          (0, import_jsx_runtime89.jsxs)("p", {
            children: [
              "Failed to render tool call result for ",
              (0, import_jsx_runtime89.jsx)("code", {
                children: part.name
              }),
              ". See console for details."
            ]
          })
        ]
      }),
      children: (0, import_jsx_runtime89.jsx)(AiMessageToolInvocation, {
        part,
        message
      })
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/AiChatUserMessage.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);
function TextPart2({ part, components }) {
  return (0, import_jsx_runtime90.jsx)(Prose, {
    content: part.text,
    className: "lb-ai-chat-message-text",
    components
  });
}
var AiChatUserMessage = (0, import_react46.memo)(
  (0, import_react46.forwardRef)(
    ({ message, className, overrides, components, ...props }, forwardedRef) => {
      const $3 = useOverrides(overrides);
      return (0, import_jsx_runtime90.jsx)("div", {
        ref: forwardedRef,
        className: cn(
          "lb-ai-chat-message lb-ai-chat-user-message",
          className
        ),
        ...props,
        children: message.deletedAt !== void 0 ? (0, import_jsx_runtime90.jsx)("div", {
          className: "lb-ai-chat-message-deleted",
          children: $3.AI_CHAT_MESSAGE_DELETED
        }) : (0, import_jsx_runtime90.jsx)(AiMessageContent, {
          className: "lb-ai-chat-message-content",
          message,
          components: {
            TextPart: (props2) => (0, import_jsx_runtime90.jsx)(TextPart2, {
              ...props2,
              components
            })
          }
        })
      });
    }
  )
);

// node_modules/@liveblocks/react-ui/dist/components/internal/AiComposer.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);
function AiComposerAction({
  overrides
}) {
  const { canAbort } = useAiComposer();
  const $3 = useOverrides(overrides);
  const preventDefault = (0, import_react48.useCallback)((event) => {
    event.preventDefault();
  }, []);
  const stopPropagation = (0, import_react48.useCallback)((event) => {
    event.stopPropagation();
  }, []);
  return canAbort ? (0, import_jsx_runtime91.jsx)(ShortcutTooltip, {
    content: $3.AI_COMPOSER_ABORT,
    children: (0, import_jsx_runtime91.jsx)(AiComposerAbort, {
      asChild: true,
      children: (0, import_jsx_runtime91.jsx)(Button, {
        onPointerDown: preventDefault,
        onClick: stopPropagation,
        className: "lb-ai-composer-action",
        variant: "secondary",
        "aria-label": $3.AI_COMPOSER_ABORT,
        icon: (0, import_jsx_runtime91.jsx)(StopIcon, {})
      })
    })
  }) : (0, import_jsx_runtime91.jsx)(ShortcutTooltip, {
    content: $3.AI_COMPOSER_SEND,
    shortcut: "Enter",
    children: (0, import_jsx_runtime91.jsx)(AiComposerSubmit, {
      asChild: true,
      children: (0, import_jsx_runtime91.jsx)(Button, {
        onPointerDown: preventDefault,
        onClick: stopPropagation,
        className: "lb-ai-composer-action",
        variant: "primary",
        "aria-label": $3.AI_COMPOSER_SEND,
        icon: (0, import_jsx_runtime91.jsx)(SendIcon, {})
      })
    })
  });
}
var AiComposer = (0, import_react48.forwardRef)(
  ({
    defaultValue,
    onComposerSubmit,
    disabled,
    autoFocus,
    overrides,
    className,
    chatId,
    knowledge: localKnowledge,
    branchId,
    copilotId,
    stream = true,
    onComposerSubmitted,
    ...props
  }, forwardedRef) => {
    const $3 = useOverrides(overrides);
    const sendAiMessage = useSendAiMessage(chatId, {
      stream,
      copilotId,
      knowledge: localKnowledge
    });
    const handleComposerSubmit = (0, import_react48.useCallback)(
      (message, event) => {
        onComposerSubmit == null ? void 0 : onComposerSubmit(message, event);
        if (event.isDefaultPrevented())
          return;
        const newMessage = sendAiMessage(message.text);
        onComposerSubmitted == null ? void 0 : onComposerSubmitted(newMessage);
      },
      [onComposerSubmit, sendAiMessage, onComposerSubmitted]
    );
    return (0, import_jsx_runtime91.jsx)(TooltipProvider, {
      children: (0, import_jsx_runtime91.jsx)(AiComposerForm, {
        className: cn(
          "lb-root lb-ai-composer lb-ai-composer-form",
          className
        ),
        dir: $3.dir,
        ...props,
        disabled,
        ref: forwardedRef,
        onComposerSubmit: handleComposerSubmit,
        chatId,
        branchId,
        children: (0, import_jsx_runtime91.jsxs)("div", {
          className: "lb-ai-composer-editor-container",
          children: [
            (0, import_jsx_runtime91.jsx)(AiComposerEditor, {
              autoFocus,
              className: "lb-ai-composer-editor",
              placeholder: $3.AI_COMPOSER_PLACEHOLDER,
              defaultValue
            }),
            (0, import_jsx_runtime91.jsxs)("div", {
              className: "lb-ai-composer-footer",
              children: [
                (0, import_jsx_runtime91.jsx)("div", {
                  className: "lb-ai-composer-editor-actions"
                }),
                (0, import_jsx_runtime91.jsx)("div", {
                  className: "lb-ai-composer-actions",
                  children: (0, import_jsx_runtime91.jsx)(AiComposerAction, {
                    overrides
                  })
                })
              ]
            })
          ]
        })
      })
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/AiChat.js
var MIN_DISTANCE_BOTTOM_SCROLL_INDICATOR = 60;
var defaultComponents3 = {
  Empty: () => null,
  Loading: () => (0, import_jsx_runtime92.jsx)("div", {
    className: "lb-loading lb-ai-chat-loading",
    children: (0, import_jsx_runtime92.jsx)(SpinnerIcon, {})
  })
};
var AiChatMessages = (0, import_react50.forwardRef)(
  ({
    messages,
    overrides,
    components,
    lastSentMessageId,
    scrollToBottom,
    onScrollAtBottomChange,
    containerRef,
    footerRef,
    messagesRef,
    bottomTrailingMarkerRef,
    trailingSpacerRef,
    className,
    ...props
  }, forwardedRef) => {
    const hasLastSentMessage = lastSentMessageId !== null;
    (0, import_react50.useEffect)(
      () => {
        if (!hasLastSentMessage) {
          return;
        }
        const container = containerRef.current;
        const footer = footerRef.current;
        const messages2 = messagesRef.current;
        if (!container || !footer || !messages2) {
          return;
        }
        const trailingSpacer = trailingSpacerRef.current;
        const bottomTrailingMarker = bottomTrailingMarkerRef.current;
        let containerHeight = null;
        let footerHeight = null;
        let messagesHeight = null;
        const resetTrailingSpace = () => {
          trailingSpacer == null ? void 0 : trailingSpacer.style.removeProperty("height");
          bottomTrailingMarker == null ? void 0 : bottomTrailingMarker.style.removeProperty("top");
        };
        const resizeObserver = new ResizeObserver((entries) => {
          var _a3, _b;
          if (!trailingSpacer || !bottomTrailingMarker) {
            return;
          }
          const lastMessage = messages2.lastElementChild;
          const penultimateMessage = lastMessage == null ? void 0 : lastMessage.previousElementSibling;
          if (!lastMessage || !penultimateMessage) {
            resetTrailingSpace();
            return;
          }
          if (container.scrollHeight === container.clientHeight) {
            resetTrailingSpace();
            return;
          }
          let updatedContainerHeight = containerHeight;
          let updatedFooterHeight = footerHeight;
          let updatedMessagesHeight = messagesHeight;
          for (const entry of entries) {
            const entryHeight = ((_b = (_a3 = entry.borderBoxSize) == null ? void 0 : _a3[0]) == null ? void 0 : _b.blockSize) ?? entry.contentRect.height;
            if (entry.target === container) {
              updatedContainerHeight = entryHeight ?? null;
            } else if (entry.target === footer) {
              updatedFooterHeight = entryHeight ?? null;
            } else if (entry.target === messages2) {
              updatedMessagesHeight = entryHeight ?? null;
            }
          }
          if (updatedContainerHeight === null || updatedFooterHeight === null || updatedMessagesHeight === null) {
            resetTrailingSpace();
            return;
          }
          if (updatedContainerHeight === containerHeight && updatedFooterHeight === footerHeight && updatedMessagesHeight === messagesHeight) {
            return;
          }
          containerHeight = updatedContainerHeight;
          footerHeight = updatedFooterHeight;
          messagesHeight = updatedMessagesHeight;
          const penultimateMessageScrollMarginTop = Number.parseFloat(
            getComputedStyle(penultimateMessage).scrollMarginTop
          );
          const messagesRect = messages2.getBoundingClientRect();
          const penultimateMessageRect = penultimateMessage.getBoundingClientRect();
          const heightFromPenultimateMessageTopToMessagesListBottom = messagesRect.bottom - penultimateMessageRect.top;
          const differenceHeight = penultimateMessageScrollMarginTop + heightFromPenultimateMessageTopToMessagesListBottom + (footerHeight ?? 0);
          const trailingSpace = Math.max(containerHeight - differenceHeight, 0);
          trailingSpacer.style.height = `${trailingSpace}px`;
          bottomTrailingMarker.style.top = `${-trailingSpace}px`;
        });
        resizeObserver.observe(container);
        resizeObserver.observe(footer);
        resizeObserver.observe(messages2);
        return () => {
          resizeObserver.disconnect();
          resetTrailingSpace();
        };
      },
      [hasLastSentMessage]
    );
    useIntersectionCallback(
      bottomTrailingMarkerRef,
      (isIntersecting) => {
        onScrollAtBottomChange.current(isIntersecting);
      },
      { root: containerRef, rootMargin: MIN_DISTANCE_BOTTOM_SCROLL_INDICATOR }
    );
    (0, import_react50.useEffect)(
      () => {
        scrollToBottom.current("instant");
      },
      []
    );
    (0, import_react50.useEffect)(
      () => {
        if (lastSentMessageId) {
          scrollToBottom.current("smooth", true);
        }
      },
      [lastSentMessageId]
    );
    (0, import_react50.useEffect)(
      () => {
        const onScrollAtBottomChangeCallback = onScrollAtBottomChange.current;
        return () => {
          onScrollAtBottomChangeCallback(null);
        };
      },
      []
    );
    return (0, import_jsx_runtime92.jsx)("div", {
      className: cn("lb-ai-chat-messages", className),
      ref: forwardedRef,
      ...props,
      children: messages.map((message) => {
        if (message.role === "user") {
          return (0, import_jsx_runtime92.jsx)(AiChatUserMessage, {
            message,
            overrides,
            components
          }, message.id);
        } else if (message.role === "assistant") {
          return (0, import_jsx_runtime92.jsx)(AiChatAssistantMessage, {
            message,
            overrides,
            components
          }, message.id);
        } else {
          return null;
        }
      })
    });
  }
);
var AiChat = (0, import_react50.forwardRef)(
  ({
    chatId,
    copilotId,
    autoFocus,
    overrides,
    knowledge: localKnowledge,
    tools = {},
    onComposerSubmit,
    layout = "inset",
    components,
    className,
    ...props
  }, forwardedRef) => {
    const { messages, isLoading, error } = _useAiChatMessages(chatId);
    const [lastSentMessageId, setLastSentMessageId] = (0, import_react50.useState)(null);
    const $3 = useOverrides(overrides);
    const Empty = (components == null ? void 0 : components.Empty) ?? defaultComponents3.Empty;
    const Loading = (components == null ? void 0 : components.Loading) ?? defaultComponents3.Loading;
    const containerRef = (0, import_react50.useRef)(null);
    const messagesRef = (0, import_react50.useRef)(null);
    const footerRef = (0, import_react50.useRef)(null);
    const bottomMarkerRef = (0, import_react50.useRef)(null);
    const bottomTrailingMarkerRef = (0, import_react50.useRef)(null);
    const trailingSpacerRef = (0, import_react50.useRef)(null);
    const [isScrollAtBottom, setScrollAtBottom] = (0, import_react50.useState)(
      null
    );
    const onScrollAtBottomChange = useLatest(setScrollAtBottom);
    const isScrollIndicatorVisible = messages && isScrollAtBottom !== null ? !isScrollAtBottom : false;
    (0, import_react50.useImperativeHandle)(
      forwardedRef,
      () => containerRef.current,
      []
    );
    const scrollToBottom = useLatest(
      (behavior, includeTrailingSpace = false) => {
        var _a3;
        if (includeTrailingSpace) {
          requestAnimationFrame(() => {
            var _a4;
            (_a4 = bottomMarkerRef.current) == null ? void 0 : _a4.scrollIntoView({
              behavior,
              block: "end"
            });
          });
        } else {
          (_a3 = bottomTrailingMarkerRef.current) == null ? void 0 : _a3.scrollIntoView({
            behavior,
            block: "end"
          });
        }
      }
    );
    return (0, import_jsx_runtime92.jsxs)("div", {
      ref: containerRef,
      ...props,
      className: cn(
        "lb-root lb-ai-chat",
        `lb-ai-chat:layout-${layout}`,
        className
      ),
      children: [
        Object.entries(tools).map(([name, tool]) => (0, import_jsx_runtime92.jsx)(RegisterAiTool, {
          chatId,
          name,
          tool
        }, name)),
        (0, import_jsx_runtime92.jsx)("div", {
          className: "lb-ai-chat-content",
          children: isLoading ? (0, import_jsx_runtime92.jsx)(Loading, {}) : error !== void 0 ? (0, import_jsx_runtime92.jsx)("div", {
            className: "lb-error lb-ai-chat-error",
            children: $3.AI_CHAT_MESSAGES_ERROR(error)
          }) : messages.length === 0 ? (0, import_jsx_runtime92.jsx)(Empty, {
            chatId,
            copilotId
          }) : (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, {
            children: [
              (0, import_jsx_runtime92.jsx)(AiChatMessages, {
                ref: messagesRef,
                messages,
                overrides,
                components,
                lastSentMessageId,
                scrollToBottom,
                onScrollAtBottomChange,
                containerRef,
                footerRef,
                messagesRef,
                bottomTrailingMarkerRef,
                trailingSpacerRef
              }),
              (0, import_jsx_runtime92.jsx)("div", {
                ref: trailingSpacerRef,
                "data-trailing-spacer": "",
                style: {
                  pointerEvents: "none"
                },
                "aria-hidden": true
              })
            ]
          })
        }),
        (0, import_jsx_runtime92.jsxs)("div", {
          className: "lb-ai-chat-footer",
          ref: footerRef,
          children: [
            (0, import_jsx_runtime92.jsx)("div", {
              className: "lb-ai-chat-footer-actions",
              children: (0, import_jsx_runtime92.jsx)("div", {
                className: "lb-root lb-elevation lb-elevation-moderate lb-ai-chat-scroll-indicator",
                "data-visible": isScrollIndicatorVisible ? "" : void 0,
                children: (0, import_jsx_runtime92.jsx)("button", {
                  className: "lb-ai-chat-scroll-indicator-button",
                  tabIndex: isScrollIndicatorVisible ? 0 : -1,
                  "aria-hidden": !isScrollIndicatorVisible,
                  onClick: () => scrollToBottom.current("smooth"),
                  children: (0, import_jsx_runtime92.jsx)("span", {
                    className: "lb-icon-container",
                    children: (0, import_jsx_runtime92.jsx)(ArrowDownIcon, {})
                  })
                })
              })
            }),
            (0, import_jsx_runtime92.jsx)(AiComposer, {
              chatId,
              copilotId,
              overrides,
              autoFocus,
              knowledge: localKnowledge,
              onComposerSubmit,
              onComposerSubmitted: ({ id }) => setLastSentMessageId(id),
              className: cn(
                "lb-ai-chat-composer",
                layout === "inset" ? "lb-elevation lb-elevation-moderate" : void 0
              )
            }, chatId)
          ]
        }),
        messages && messages.length > 0 ? (0, import_jsx_runtime92.jsx)("div", {
          ref: bottomMarkerRef,
          style: { position: "sticky", height: 0 },
          "aria-hidden": true,
          "data-bottom-marker": "",
          children: (0, import_jsx_runtime92.jsx)("div", {
            ref: bottomTrailingMarkerRef,
            style: {
              position: "absolute",
              height: 0
            },
            "data-bottom-trailing-marker": ""
          })
        }) : null
      ]
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/AiTool.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
function AiToolIcon({ className, ...props }) {
  return (0, import_jsx_runtime93.jsx)("div", {
    className: cn("lb-ai-tool-icon", className),
    ...props
  });
}
function AiToolInspector({ className, ...props }) {
  const { args, partialArgs, result } = useAiToolInvocationContext();
  return (0, import_jsx_runtime93.jsxs)("div", {
    className: cn("lb-ai-tool-inspector", className),
    ...props,
    children: [
      (0, import_jsx_runtime93.jsx)(CodeBlock, {
        title: "Arguments",
        code: JSON.stringify(args ?? partialArgs, null, 2)
      }),
      result !== void 0 ? (0, import_jsx_runtime93.jsx)(CodeBlock, {
        title: "Result",
        code: JSON.stringify(result, null, 2)
      }) : null
    ]
  });
}
function AiToolConfirmation({
  children,
  variant = "default",
  confirm,
  cancel,
  overrides,
  className,
  ...props
}) {
  const { stage, args, respond, name, invocationId } = useAiToolInvocationContext();
  const $3 = useOverrides(overrides);
  const enabled = stage === "executing";
  const context = (0, import_react51.useMemo)(() => ({ name, invocationId }), [name, invocationId]);
  const onConfirmClick = (0, import_react51.useCallback)(async () => {
    if (enabled) {
      const result = await confirm(args, context);
      respond(result ?? void 0);
    }
  }, [enabled, args, confirm, respond, context]);
  const onCancelClick = (0, import_react51.useCallback)(async () => {
    if (enabled) {
      if (cancel === void 0) {
        respond({ cancel: true });
      } else {
        const result = await cancel(args, context);
        respond(result ?? void 0);
      }
    }
  }, [enabled, args, cancel, respond, context]);
  if (stage === "executed" && !children) {
    return null;
  }
  return (0, import_jsx_runtime93.jsxs)("div", {
    className: cn("lb-ai-tool-confirmation", className),
    ...props,
    children: [
      children ? (0, import_jsx_runtime93.jsx)("div", {
        className: "lb-ai-tool-confirmation-content",
        children
      }) : null,
      stage !== "executed" && (0, import_jsx_runtime93.jsx)("div", {
        className: "lb-ai-tool-confirmation-footer",
        children: (0, import_jsx_runtime93.jsxs)("div", {
          className: "lb-ai-tool-confirmation-actions",
          children: [
            (0, import_jsx_runtime93.jsx)(Button, {
              disabled: !enabled,
              onClick: onCancelClick,
              variant: "secondary",
              children: $3.AI_TOOL_CONFIRMATION_CANCEL
            }),
            (0, import_jsx_runtime93.jsx)(Button, {
              disabled: !enabled,
              onClick: onConfirmClick,
              variant: variant === "destructive" ? "destructive" : "primary",
              children: $3.AI_TOOL_CONFIRMATION_CONFIRM
            })
          ]
        })
      })
    ]
  });
}
function prettifyString(string3) {
  return string3.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/[_-]+/g, " ").replace(/\s+/g, " ").trim().toLowerCase().replace(/^\w/, (character) => character.toUpperCase());
}
var AiTool = Object.assign(
  (0, import_react51.forwardRef)(
    ({
      children,
      title,
      icon,
      collapsible,
      collapsed,
      onCollapsedChange,
      variant = "block",
      className,
      ...props
    }, forwardedRef) => {
      const {
        stage,
        result,
        name,
        [kInternal]: { execute, messageStatus }
      } = useAiToolInvocationContext();
      const isVisuallyPending = execute !== void 0 && stage !== "executed" && (stage === "receiving" ? messageStatus === "generating" : true);
      const [semiControlledCollapsed, onSemiControlledCollapsed] = useSemiControllableState(collapsed ?? false, onCollapsedChange);
      const hasContent = import_react51.Children.count(children) > 0;
      const isCollapsible = hasContent ? collapsible ?? true : false;
      const resolvedTitle = (0, import_react51.useMemo)(() => {
        return title ?? prettifyString(name);
      }, [title, name]);
      const handleCollapsibleOpenChange = (0, import_react51.useCallback)(
        (open) => {
          onSemiControlledCollapsed(!open);
        },
        [onSemiControlledCollapsed]
      );
      return (0, import_jsx_runtime93.jsxs)(CollapsibleRoot, {
        ref: forwardedRef,
        className: cn(
          "lb-collapsible lb-ai-tool",
          `lb-ai-tool:variant-${variant}`,
          className
        ),
        ...props,
        open: hasContent ? !semiControlledCollapsed : false,
        onOpenChange: handleCollapsibleOpenChange,
        disabled: !isCollapsible,
        "data-result": result == null ? void 0 : result.type,
        "data-stage": stage,
        children: [
          (0, import_jsx_runtime93.jsxs)(CollapsibleTrigger, {
            className: cn(
              "lb-collapsible-trigger lb-ai-tool-header",
              variant === "minimal" && isVisuallyPending && "lb-ai-chat-pending"
            ),
            children: [
              icon ? (0, import_jsx_runtime93.jsx)("div", {
                className: "lb-ai-tool-header-icon-container",
                children: icon
              }) : null,
              (0, import_jsx_runtime93.jsx)("span", {
                className: "lb-ai-tool-header-title",
                children: resolvedTitle
              }),
              isCollapsible ? (0, import_jsx_runtime93.jsx)("span", {
                className: "lb-collapsible-chevron lb-icon-container",
                children: (0, import_jsx_runtime93.jsx)(ChevronRightIcon, {})
              }) : null,
              variant !== "minimal" ? (0, import_jsx_runtime93.jsx)("div", {
                className: "lb-ai-tool-header-status",
                children: stage === "executed" ? result.type === "success" ? (0, import_jsx_runtime93.jsx)(CheckCircleFillIcon, {}) : result.type === "error" ? (0, import_jsx_runtime93.jsx)(CrossCircleFillIcon, {}) : result.type === "cancelled" ? (0, import_jsx_runtime93.jsx)(MinusCircleIcon, {}) : null : isVisuallyPending ? (0, import_jsx_runtime93.jsx)(SpinnerIcon, {}) : null
              }) : null
            ]
          }),
          hasContent ? (0, import_jsx_runtime93.jsx)(CollapsibleContent, {
            className: "lb-collapsible-content lb-ai-tool-content-container",
            children: (0, import_jsx_runtime93.jsx)("div", {
              className: "lb-ai-tool-content",
              children
            })
          }) : null
        ]
      });
    }
  ),
  {
    Icon: AiToolIcon,
    Inspector: AiToolInspector,
    Confirmation: AiToolConfirmation
  }
);

// node_modules/@liveblocks/react-ui/dist/components/Comment.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-toggle/dist/index.mjs
var React35 = __toESM(require_react(), 1);
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var NAME3 = "Toggle";
var Toggle = React35.forwardRef((props, forwardedRef) => {
  const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
  const [pressed, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed ?? false,
    caller: NAME3
  });
  return (0, import_jsx_runtime94.jsx)(
    Primitive.button,
    {
      type: "button",
      "aria-pressed": pressed,
      "data-state": pressed ? "on" : "off",
      "data-disabled": props.disabled ? "" : void 0,
      ...buttonProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => {
        if (!props.disabled) {
          setPressed(!pressed);
        }
      })
    }
  );
});
Toggle.displayName = NAME3;
var Root5 = Toggle;

// node_modules/@liveblocks/react-ui/dist/components/Comment.js
var import_react78 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/primitives/Comment/index.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var COMMENT_MENTION_NAME = "CommentMention";
var COMMENT_BODY_NAME = "CommentBody";
var COMMENT_LINK_NAME = "CommentLink";
var CommentMention = (0, import_react52.forwardRef)(
  ({ children, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "span";
    return (0, import_jsx_runtime95.jsx)(Component3, {
      ...props,
      ref: forwardedRef,
      children
    });
  }
);
var CommentLink = (0, import_react52.forwardRef)(
  ({ children, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "a";
    return (0, import_jsx_runtime95.jsx)(Component3, {
      target: "_blank",
      rel: "noopener noreferrer nofollow",
      ...props,
      ref: forwardedRef,
      children
    });
  }
);
var defaultBodyComponents = {
  Mention: ({ mention }) => {
    return (0, import_jsx_runtime95.jsxs)(CommentMention, {
      children: [
        MENTION_CHARACTER,
        mention.id
      ]
    });
  },
  Link: ({ href, children }) => {
    return (0, import_jsx_runtime95.jsx)(CommentLink, {
      href,
      children
    });
  }
};
var CommentBody = (0, import_react52.forwardRef)(
  ({ body, components, style, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "div";
    const { Mention: Mention2, Link: Link2 } = (0, import_react52.useMemo)(
      () => ({ ...defaultBodyComponents, ...components }),
      [components]
    );
    if (!body || !(body == null ? void 0 : body.content)) {
      return null;
    }
    return (0, import_jsx_runtime95.jsx)(Component3, {
      ...props,
      style: { whiteSpace: "break-spaces", ...style },
      ref: forwardedRef,
      children: body.content.map((block2, index2) => {
        switch (block2.type) {
          case "paragraph":
            return (0, import_jsx_runtime95.jsx)("p", {
              style: { minHeight: "1lh" },
              children: block2.children.map((inline5, index22) => {
                if (isCommentBodyMention(inline5)) {
                  const { type: _2, ...mention } = inline5;
                  return mention.id ? (0, import_jsx_runtime95.jsx)(Mention2, {
                    mention
                  }, index22) : null;
                }
                if (isCommentBodyLink(inline5)) {
                  const href = sanitizeUrl(inline5.url);
                  if (href === null) {
                    return (0, import_jsx_runtime95.jsx)("span", {
                      children: inline5.text ?? inline5.url
                    }, index22);
                  }
                  return (0, import_jsx_runtime95.jsx)(Link2, {
                    href,
                    children: inline5.text ?? inline5.url
                  }, index22);
                }
                let children = inline5.text;
                if (inline5.bold) {
                  children = (0, import_jsx_runtime95.jsx)("strong", {
                    children
                  }, index22);
                }
                if (inline5.italic) {
                  children = (0, import_jsx_runtime95.jsx)("em", {
                    children
                  }, index22);
                }
                if (inline5.strikethrough) {
                  children = (0, import_jsx_runtime95.jsx)("s", {
                    children
                  }, index22);
                }
                if (inline5.code) {
                  children = (0, import_jsx_runtime95.jsx)("code", {
                    children
                  }, index22);
                }
                return (0, import_jsx_runtime95.jsx)("span", {
                  children
                }, index22);
              })
            }, index2);
          default:
            return null;
        }
      })
    });
  }
);
if (true) {
  CommentBody.displayName = COMMENT_BODY_NAME;
  CommentMention.displayName = COMMENT_MENTION_NAME;
  CommentLink.displayName = COMMENT_LINK_NAME;
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/index.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react61 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/is-key.js
var MODIFIERS = {
  alt: () => "altKey",
  ctrl: () => "ctrlKey",
  meta: () => "metaKey",
  mod: () => isApple() ? "metaKey" : "ctrlKey",
  shift: () => "shiftKey"
};
function isKey(event, key, modifiers = {}) {
  if (event.key !== key) {
    return false;
  }
  const explicitModifiers = Object.entries(modifiers).filter(
    ([, value]) => typeof value === "boolean"
  );
  return explicitModifiers.every(([modifier, value]) => {
    const property = MODIFIERS[modifier]();
    return event[property] === value;
  });
}

// node_modules/@liveblocks/react-ui/dist/utils/Persist.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);
var PERSIST_NAME = "Persist";
var PersistContext = (0, import_react53.createContext)(null);
function usePersist() {
  const persistContext = (0, import_react53.useContext)(PersistContext);
  return nn(persistContext, "Persist is missing from the React tree.");
}
function getChild(children) {
  const child = Array.isArray(children) ? import_react53.Children.only(children) : children;
  return (0, import_react53.isValidElement)(child) ? child : void 0;
}
function useAnimationPersist(ref) {
  const [isPresent, unmount] = usePersist();
  const previousAnimationName = (0, import_react53.useRef)(null);
  const unmountAnimationName = (0, import_react53.useRef)(null);
  useLayoutEffect2(() => {
    const element = ref.current;
    if (!element) {
      return;
    }
    const handleAnimationEnd = (event) => {
      if (event.animationName === unmountAnimationName.current) {
        unmount();
      }
      previousAnimationName.current = event.animationName;
    };
    element.addEventListener("animationcancel", handleAnimationEnd);
    element.addEventListener("animationend", handleAnimationEnd);
    return () => {
      element.removeEventListener("animationcancel", handleAnimationEnd);
      element.removeEventListener("animationend", handleAnimationEnd);
    };
  }, [ref, unmount]);
  useLayoutEffect2(() => {
    const element = ref.current;
    let animationFrameId;
    if (!element) {
      return;
    }
    if (!isPresent) {
      animationFrameId = requestAnimationFrame(() => {
        const styles = getComputedStyle(element);
        unmountAnimationName.current = styles.animationName;
        if (styles.animationName === "none" || styles.animationName === previousAnimationName.current || styles.display === "none") {
          unmount();
        }
      });
    }
    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [isPresent, ref, unmount]);
}
function Persist({ children }) {
  const [isPersisting, setPersisting] = (0, import_react53.useState)(true);
  const lastPresentChild = (0, import_react53.useRef)(null);
  const child = getChild(children);
  const unmount = (0, import_react53.useCallback)(() => {
    (0, import_react_dom6.flushSync)(() => setPersisting(false));
  }, []);
  useLayoutEffect2(() => {
    if (child) {
      setPersisting(true);
      lastPresentChild.current = child;
    }
  }, [child]);
  return (0, import_jsx_runtime96.jsx)(PersistContext.Provider, {
    value: [Boolean(child), unmount],
    children: child ?? (isPersisting ? lastPresentChild.current : null)
  });
}
if (true) {
  Persist.displayName = PERSIST_NAME;
}

// node_modules/@liveblocks/react-ui/dist/utils/Portal.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);
var import_react_dom7 = __toESM(require_react_dom(), 1);
var PORTAL_NAME4 = "Portal";
var Portal4 = (0, import_react54.forwardRef)(
  ({ container = document == null ? void 0 : document.body, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "div";
    return container ? (0, import_react_dom7.createPortal)(
      (0, import_jsx_runtime97.jsx)(Component3, {
        "data-liveblocks-portal": "",
        ...props,
        ref: forwardedRef
      }),
      container
    ) : null;
  }
);
if (true) {
  Portal4.displayName = PORTAL_NAME4;
}

// node_modules/@liveblocks/react-ui/dist/utils/use-index.js
var import_react55 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/clamp.js
function clamp2(value, min2, max2) {
  return Math.min(Math.max(value, min2), max2);
}

// node_modules/@liveblocks/react-ui/dist/utils/wrap.js
function wrap(value, min2, max2) {
  const range2 = max2 - min2;
  return range2 > 0 ? ((value - min2) % range2 + range2) % range2 + min2 : 0;
}

// node_modules/@liveblocks/react-ui/dist/utils/use-index.js
var defaultOptions = {
  wrap: true
};
function useIndex(initial, length, options2) {
  const { wrap: shouldWrap } = (0, import_react55.useMemo)(() => {
    return {
      ...defaultOptions,
      ...options2
    };
  }, [options2]);
  const transform = (0, import_react55.useMemo)(() => shouldWrap ? wrap : clamp2, [shouldWrap]);
  const [index2, setIndex] = (0, import_react55.useState)(initial);
  (0, import_react55.useEffect)(() => {
    setIndex((index22) => clamp2(index22, 0, Math.max(length - 1, 0)));
  }, [length]);
  const previousIndex = (0, import_react55.useCallback)(() => {
    setIndex((index22) => transform(index22 - 1, 0, Math.max(length, 0)));
  }, [length, transform]);
  const nextIndex = (0, import_react55.useCallback)(() => {
    setIndex((index22) => transform(index22 + 1, 0, Math.max(length, 0)));
  }, [length, transform]);
  return [index2, previousIndex, nextIndex, setIndex];
}

// node_modules/@liveblocks/react-ui/dist/utils/use-observable.js
var import_react56 = __toESM(require_react(), 1);
function useObservable(observable, callback) {
  const latestCallback = useLatest(callback);
  (0, import_react56.useEffect)(() => {
    const unsubscribe = observable.subscribe(() => latestCallback.current());
    return unsubscribe;
  }, [observable, latestCallback]);
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/get-character.js
function getCharacterBefore(editor, at2, options2 = {}) {
  const { filterVoids } = options2;
  const before3 = Editor.before(editor, at2, {
    unit: "character",
    voids: filterVoids
  });
  if (before3) {
    const range2 = Editor.range(
      editor,
      before3,
      Range.isRange(at2) ? Range.start(at2) : at2
    );
    const text = Editor.string(editor, range2);
    return {
      range: range2,
      text,
      void: text.length === 0
    };
  }
  return;
}
function getCharacterAfter(editor, at2, options2 = {}) {
  const { filterVoids } = options2;
  const after3 = Editor.after(editor, at2, {
    unit: "character",
    voids: filterVoids
  });
  if (after3) {
    const range2 = Editor.range(
      editor,
      after3,
      Range.isRange(at2) ? Range.end(at2) : at2
    );
    const text = Editor.string(editor, range2);
    return {
      range: range2,
      text,
      void: text.length === 0
    };
  }
  return;
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/marks.js
var defaultComposerBodyMarks = {
  bold: false,
  italic: false,
  strikethrough: false,
  code: false
};
function getComposerBodyMarks(editor) {
  if (!editor) {
    return { ...defaultComposerBodyMarks };
  }
  const marks3 = Editor.marks(editor);
  return { ...defaultComposerBodyMarks, ...marks3 };
}
function isMarkActive(editor, mark) {
  const marks3 = Editor.marks(editor);
  return marks3 ? marks3[mark] === true : false;
}
function filterActiveMarks(value) {
  return Object.keys(value ?? {}).filter(
    (key) => key !== "text"
  );
}
function toggleMark(editor, mark) {
  const isActive = isMarkActive(editor, mark);
  if (isActive) {
    Editor.removeMark(editor, mark);
  } else {
    Editor.addMark(editor, mark, true);
  }
}
function removeMarks(editor) {
  const marks3 = Editor.marks(editor);
  if (marks3) {
    for (const mark in marks3) {
      Editor.removeMark(editor, mark);
    }
  }
}
function leaveMarkEdge(editor, edge) {
  if (editor.selection && Range.isCollapsed(editor.selection)) {
    const marks3 = Object.keys(Editor.marks(editor) ?? {});
    if (marks3.length > 0) {
      const sibling = edge === "start" ? getCharacterBefore(editor, editor.selection) : getCharacterAfter(editor, editor.selection);
      if (!sibling) {
        removeMarks(editor);
      }
    }
  }
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/plugins/empty-clear-formatting.js
function withEmptyClearFormatting(editor) {
  const { onChange } = editor;
  editor.onChange = (options2) => {
    if (isEmpty2(editor, editor.children)) {
      removeMarks(editor);
    }
    onChange(options2);
  };
  return editor;
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/get-dom-range.js
function getDOMRange(editor, range2) {
  try {
    return ReactEditor.toDOMRange(editor, range2);
  } catch (error) {
    return getDOMRange(editor, {
      anchor: range2.anchor,
      focus: range2.anchor
    });
  }
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/contexts.js
var import_react57 = __toESM(require_react(), 1);
var ComposerContext = (0, import_react57.createContext)(null);
var ComposerEditorContext = (0, import_react57.createContext)(null);
var ComposerAttachmentsContext = (0, import_react57.createContext)(null);
var ComposerSuggestionsContext = (0, import_react57.createContext)(null);
var ComposerFloatingToolbarContext = (0, import_react57.createContext)(null);
function useComposerEditorContext() {
  const composerEditorContext = (0, import_react57.useContext)(ComposerEditorContext);
  return nn(
    composerEditorContext,
    "Composer.Form is missing from the React tree."
  );
}
function useComposerAttachmentsContextOrNull() {
  return (0, import_react57.useContext)(ComposerAttachmentsContext);
}
function useComposerAttachmentsContext() {
  const composerAttachmentsContext = useComposerAttachmentsContextOrNull();
  return nn(
    composerAttachmentsContext,
    "Composer.Form is missing from the React tree."
  );
}
function useComposerSuggestionsContext(source = "useComposerSuggestionsContext") {
  const composerSuggestionsContext = (0, import_react57.useContext)(ComposerSuggestionsContext);
  return nn(
    composerSuggestionsContext,
    `${source} can’t be used outside of Composer.Editor.`
  );
}
function useComposerFloatingToolbarContext(source = "useComposerFloatingToolbarContext") {
  const composerFloatingToolbarContext = (0, import_react57.useContext)(
    ComposerFloatingToolbarContext
  );
  return nn(
    composerFloatingToolbarContext,
    `${source} can’t be used outside of Composer.Editor.`
  );
}
function useComposer() {
  const composerContext = (0, import_react57.useContext)(ComposerContext);
  return nn(composerContext, "Composer.Form is missing from the React tree.");
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/is-whitespace-character.js
var WHITESPACE_REGEX2 = /\s/;
function isWhitespaceCharacter(character) {
  return character ? WHITESPACE_REGEX2.test(character) : false;
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/get-match-range.js
var defaultOptions2 = {
  direction: "before",
  allowConsecutiveWhitespace: true
};
function getMatchRange(editor, at2, terminators = [" "], options2 = defaultOptions2) {
  const { include, direction, ignoreTerminator, allowConsecutiveWhitespace } = {
    ...defaultOptions2,
    ...options2
  };
  let [start2, end2] = Range.edges(at2);
  let point3 = start2;
  let previousCharacterWasWhitespace = false;
  function move3(direction2) {
    const nextPoint = direction2 === "after" ? Editor.after(editor, point3, { unit: "character" }) : Editor.before(editor, point3, { unit: "character" });
    if (!nextPoint || Path.compare(nextPoint.path, point3.path) !== 0) {
      return false;
    }
    const nextCharacter = nextPoint && Editor.string(
      editor,
      direction2 === "after" ? { anchor: point3, focus: nextPoint } : { anchor: nextPoint, focus: point3 }
    );
    const lastCharacter = nextCharacter && nextCharacter[direction2 === "after" ? 0 : nextCharacter.length - 1];
    if (!allowConsecutiveWhitespace && previousCharacterWasWhitespace && isWhitespaceCharacter(lastCharacter)) {
      return false;
    }
    if (nextPoint && lastCharacter && (!terminators.includes(lastCharacter) || (ignoreTerminator == null ? void 0 : ignoreTerminator(lastCharacter, nextPoint, direction2)))) {
      previousCharacterWasWhitespace = isWhitespaceCharacter(lastCharacter);
      point3 = nextPoint;
      if (point3.offset === 0) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  if (direction !== "before") {
    point3 = end2;
    while (move3("after"))
      ;
    end2 = point3;
  }
  if (direction !== "after") {
    point3 = start2;
    while (move3("before"))
      ;
    start2 = point3;
  }
  if (include) {
    return {
      anchor: direction === "before" || direction === "both" ? Editor.before(editor, start2, { unit: "offset" }) ?? start2 : start2,
      focus: direction === "after" || direction === "both" ? Editor.after(editor, end2, { unit: "offset" }) ?? end2 : end2
    };
  }
  return { anchor: start2, focus: end2 };
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/slate/plugins/auto-formatting.js
var formatters = [
  {
    type: "mark",
    mark: "bold",
    character: "*"
  },
  {
    type: "mark",
    mark: "italic",
    character: "_"
  },
  {
    type: "mark",
    mark: "strikethrough",
    character: "~"
  },
  {
    type: "mark",
    mark: "code",
    character: "`"
  }
];
var markFormattingCharacters = formatters.filter((formatter) => formatter.type === "mark").map((formatter) => formatter.character);
function formatMark(editor, text, formatter) {
  if (text !== formatter.character) {
    return false;
  }
  const match = getMatchRange(editor, editor.selection, [formatter.character]);
  if (!match || Range.isCollapsed(match)) {
    return false;
  }
  const formattingCharacter = getCharacterBefore(editor, match);
  if (!formattingCharacter || formattingCharacter.text !== formatter.character) {
    return false;
  }
  const beforeCharacter = getCharacterBefore(editor, formattingCharacter.range);
  if (beforeCharacter && !markFormattingCharacters.includes(beforeCharacter.text) && !isEmptyString(beforeCharacter.text)) {
    return false;
  }
  const matchText = Editor.string(editor, match);
  if (matchText.trim() !== matchText) {
    return false;
  }
  Transforms.select(editor, match);
  editor.addMark(formatter.mark, true);
  Transforms.collapse(editor, { edge: "end" });
  editor.removeMark(formatter.mark);
  Transforms.delete(editor, {
    at: formattingCharacter.range
  });
  return true;
}
function withAutoFormatting(editor) {
  const { insertText: insertText3 } = editor;
  editor.insertText = (text, options2) => {
    if (!editor.selection || !Range.isCollapsed(editor.selection)) {
      return insertText3(text, options2);
    }
    let shouldInsertText = true;
    for (const formatter of formatters) {
      if (formatter.type === "mark") {
        if (formatMark(editor, text, formatter)) {
          shouldInsertText = false;
        }
      }
    }
    if (shouldInsertText) {
      insertText3(text, options2);
    }
  };
  return editor;
}

// node_modules/@liveblocks/react-ui/dist/primitives/slate/utils/selection-contains-inlines.js
function selectionContainsInlines(editor, match) {
  const { selection } = editor;
  if (!selection) {
    return false;
  }
  const roots = Array.from(
    Editor.nodes(editor, {
      at: selection,
      match: (node3) => Element2.isElement(node3) && Editor.isBlock(editor, node3),
      mode: "lowest"
    })
  );
  for (const [, rootPath] of roots) {
    const intersectingSelection = Range.isRange(selection) ? Range.intersection(selection, Editor.range(editor, rootPath)) : selection;
    if (!intersectingSelection) {
      continue;
    }
    const matches = Array.from(
      Editor.nodes(editor, {
        at: intersectingSelection,
        match: (node3) => Editor.isInline(editor, node3) && match(node3)
      })
    );
    if (matches.length > 0) {
      return true;
    }
  }
  return false;
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/slate/plugins/custom-links.js
function withCustomLinks(editor) {
  const { isInline, normalizeNode: normalizeNode2, insertData } = editor;
  editor.isInline = (element) => {
    return element.type === "custom-link" ? true : isInline(element);
  };
  editor.normalizeNode = (entry) => {
    var _a3;
    const [node3, path3] = entry;
    if (Element2.isElement(node3) && node3.type === "custom-link") {
      if (node3.children.length === 0 || node3.children.length === 1 && ((_a3 = node3.children[0]) == null ? void 0 : _a3.text) === "") {
        Transforms.removeNodes(editor, { at: path3 });
      }
    }
    if (isText(node3)) {
      const parentNode = Node3.parent(editor, path3);
      if (isComposerBodyCustomLink(parentNode)) {
        if (!isPlainText(node3)) {
          const marks3 = filterActiveMarks(node3);
          Transforms.unsetNodes(editor, marks3, { at: path3 });
        }
      }
    }
    normalizeNode2(entry);
  };
  editor.insertData = (data) => {
    const { selection } = editor;
    const pastedText = data.getData("text/plain");
    let shouldInvokeDefaultBehavior = true;
    if (selection && !Range.isCollapsed(selection)) {
      if (selection.anchor.path[0] === selection.focus.path[0]) {
        if (isUrl(pastedText)) {
          if (!selectionContainsInlines(editor, (node3) => !isText(node3))) {
            Transforms.wrapNodes(
              editor,
              {
                type: "custom-link",
                url: pastedText,
                children: []
              },
              {
                at: selection,
                split: true,
                match: isPlainText
              }
            );
            shouldInvokeDefaultBehavior = false;
          }
        }
      }
    }
    if (shouldInvokeDefaultBehavior) {
      insertData(data);
    }
  };
  return editor;
}
function isComposerBodyCustomLink(node3) {
  return Element2.isElement(node3) && node3.type === "custom-link";
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/slate/plugins/auto-links.js
function withAutoLinks(editor) {
  const { isInline, normalizeNode: normalizeNode2, deleteBackward: deleteBackward2 } = editor;
  editor.isInline = (element) => {
    return element.type === "auto-link" ? true : isInline(element);
  };
  editor.normalizeNode = (entry) => {
    var _a3;
    const [node3, path3] = entry;
    if (isComposerBodyCustomLink(node3)) {
      return;
    }
    if (Element2.isElement(node3) && node3.type === "auto-link") {
      if (node3.children.length === 0 || node3.children.length === 1 && ((_a3 = node3.children[0]) == null ? void 0 : _a3.text) === "") {
        Transforms.removeNodes(editor, { at: path3 });
      }
    }
    if (isText(node3)) {
      const parentNode = Node3.parent(editor, path3);
      if (isComposerBodyCustomLink(parentNode)) {
        return;
      } else if (isComposerBodyAutoLink(parentNode)) {
        const parentPath = Path.parent(path3);
        handleLinkEdit(editor, [parentNode, parentPath]);
        if (!isPlainText(node3)) {
          const marks3 = filterActiveMarks(node3);
          Transforms.unsetNodes(editor, marks3, { at: path3 });
        }
      } else {
        handleLinkCreate(editor, [node3, path3]);
        handleNeighbours(editor, [node3, path3]);
      }
    }
    normalizeNode2(entry);
  };
  editor.deleteBackward = (unit) => {
    deleteBackward2(unit);
    const { selection } = editor;
    if (!selection)
      return;
    if (!Range.isCollapsed(selection))
      return;
    const [match] = Editor.nodes(editor, {
      at: selection,
      match: isComposerBodyAutoLink,
      mode: "lowest"
    });
    if (!match)
      return;
    Transforms.unwrapNodes(editor, {
      match: isComposerBodyAutoLink
    });
  };
  return editor;
}
function isComposerBodyAutoLink(node3) {
  return Element2.isElement(node3) && node3.type === "auto-link";
}
var URL_REGEX = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9().@:%_+~#?&//=]*)/;
var PUNCTUATION_OR_SPACE = /[.,;!?\s()]/;
var PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC = /^[.?][a-zA-Z0-9]+/;
var PARENTHESES = /[()]/;
function isSeparator(char) {
  return PUNCTUATION_OR_SPACE.test(char);
}
function endsWithSeparator(textContent) {
  const lastCharacter = textContent[textContent.length - 1];
  return lastCharacter !== void 0 ? isSeparator(lastCharacter) : false;
}
function startsWithSeparator(textContent) {
  const firstCharacter = textContent[0];
  return firstCharacter !== void 0 ? isSeparator(firstCharacter) : false;
}
function endsWithPeriodOrQuestionMark(textContent) {
  return textContent[textContent.length - 1] === "." || textContent[textContent.length - 1] === "?";
}
function getUrlLogicalLength(url) {
  if (!PARENTHESES.test(url)) {
    return url.length;
  }
  let logicalLength = 0;
  let parenthesesCount = 0;
  for (const character of url) {
    if (character === "(") {
      parenthesesCount++;
    }
    if (character === ")") {
      parenthesesCount--;
      if (parenthesesCount < 0) {
        break;
      }
    }
    logicalLength++;
  }
  return logicalLength;
}
function isPreviousNodeValid(editor, path3) {
  const entry = Editor.previous(editor, { at: path3 });
  if (!entry)
    return true;
  return isText(entry[0]) && (endsWithSeparator(entry[0].text) || entry[0].text === "");
}
function isNextNodeValid(editor, path3) {
  const entry = Editor.next(editor, { at: path3 });
  if (!entry)
    return true;
  return isText(entry[0]) && (startsWithSeparator(entry[0].text) || entry[0].text === "");
}
function isContentAroundValid(editor, entry, start2, end2) {
  const [node3, path3] = entry;
  const text = node3.text;
  const contentBefore = text[start2 - 1];
  const contentBeforeIsValid = start2 > 0 && contentBefore ? isSeparator(contentBefore) : isPreviousNodeValid(editor, path3);
  const contentAfter = text[end2];
  const contentAfterIsValid = end2 < text.length && contentAfter ? isSeparator(contentAfter) : isNextNodeValid(editor, path3);
  return contentBeforeIsValid && contentAfterIsValid;
}
var handleLinkEdit = (editor, entry) => {
  const [node3, path3] = entry;
  const children = Node3.children(editor, path3);
  for (const [child] of children) {
    if (isText(child))
      continue;
    Transforms.unwrapNodes(editor, { at: path3 });
    return;
  }
  const text = Node3.string(node3);
  const match = URL_REGEX.exec(text);
  const matchContent = match == null ? void 0 : match[0];
  if (!match || matchContent !== text) {
    Transforms.unwrapNodes(editor, { at: path3 });
    return;
  }
  if (endsWithPeriodOrQuestionMark(text)) {
    Transforms.unwrapNodes(editor, { at: path3 });
    const textBeforePeriod = text.slice(0, text.length - 1);
    Transforms.wrapNodes(
      editor,
      {
        type: "auto-link",
        url: textBeforePeriod,
        children: []
      },
      {
        at: {
          anchor: { path: path3, offset: 0 },
          focus: { path: path3, offset: textBeforePeriod.length }
        },
        split: true
      }
    );
    return;
  }
  const logicalLength = getUrlLogicalLength(text);
  if (logicalLength < text.length) {
    Transforms.unwrapNodes(editor, { at: path3 });
    const logicalText = text.slice(0, logicalLength);
    Transforms.wrapNodes(
      editor,
      {
        type: "auto-link",
        url: logicalText,
        children: []
      },
      {
        at: {
          anchor: { path: path3, offset: 0 },
          focus: { path: path3, offset: logicalText.length }
        },
        split: true
      }
    );
    return;
  }
  if (!isPreviousNodeValid(editor, path3) || !isNextNodeValid(editor, path3)) {
    Transforms.unwrapNodes(editor, { at: path3 });
    return;
  }
  if (node3.url !== text) {
    Transforms.setNodes(editor, { url: matchContent }, { at: path3 });
    return;
  }
};
var handleLinkCreate = (editor, entry) => {
  const [node3, path3] = entry;
  const match = URL_REGEX.exec(node3.text);
  const matchContent = match == null ? void 0 : match[0];
  if (!match || matchContent === void 0) {
    return;
  }
  const start2 = match.index;
  const end2 = start2 + matchContent.length;
  if (!isContentAroundValid(editor, entry, start2, end2))
    return;
  Transforms.wrapNodes(
    editor,
    {
      type: "auto-link",
      url: matchContent,
      children: []
    },
    {
      at: {
        anchor: { path: path3, offset: start2 },
        focus: { path: path3, offset: end2 }
      },
      split: true
    }
  );
  return;
};
var handleNeighbours = (editor, entry) => {
  const [node3, path3] = entry;
  const text = node3.text;
  const previousSibling = Editor.previous(editor, { at: path3 });
  if (previousSibling && isComposerBodyAutoLink(previousSibling[0])) {
    if (PERIOD_OR_QUESTION_MARK_FOLLOWED_BY_ALPHANUMERIC.test(text)) {
      Transforms.unwrapNodes(editor, { at: previousSibling[1] });
      Transforms.mergeNodes(editor, { at: path3 });
      return;
    }
    if (!startsWithSeparator(text)) {
      Transforms.unwrapNodes(editor, { at: previousSibling[1] });
      return;
    }
  }
  const nextSibling = Editor.next(editor, { at: path3 });
  if (nextSibling && isComposerBodyAutoLink(nextSibling[0]) && !endsWithSeparator(text)) {
    Transforms.unwrapNodes(editor, { at: nextSibling[1] });
    return;
  }
};

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/slate/plugins/mentions.js
function getMentionDraftAtSelection(editor) {
  const { selection } = editor;
  if (!selection || !Range.isCollapsed(selection)) {
    return;
  }
  const match = getMatchRange(editor, selection, ["@"], {
    include: true,
    allowConsecutiveWhitespace: false,
    ignoreTerminator: (_2, point3) => {
      const characterBefore = getCharacterBefore(editor, point3);
      if (characterBefore && !isWhitespaceCharacter(characterBefore.text)) {
        return true;
      }
      return false;
    }
  });
  if (!match) {
    return;
  }
  const matchText = Editor.string(editor, match);
  if (!matchText.startsWith(MENTION_CHARACTER) || matchText.length > 1 && isWhitespaceCharacter(matchText[1])) {
    return;
  }
  return {
    range: match,
    text: matchText.substring(1)
  };
}
function isComposerBodyMention(node3) {
  return Element2.isElement(node3) && node3.type === "mention";
}
function insertMention(editor, mention) {
  const mentionNode = {
    type: "mention",
    ...mention,
    children: [{ text: "" }]
  };
  Transforms.insertNodes(editor, mentionNode);
  Transforms.move(editor);
  const afterCharacter = editor.selection ? getCharacterAfter(editor, editor.selection) : void 0;
  if (!afterCharacter || afterCharacter.void) {
    Transforms.insertText(editor, " ");
  } else if (isEmptyString(afterCharacter.text)) {
    Transforms.move(editor);
  }
}
function insertMentionCharacter(editor) {
  if (!editor.selection) {
    return;
  }
  const beforeCharacter = getCharacterBefore(editor, editor.selection, {
    filterVoids: true
  });
  const afterCharacter = getCharacterAfter(editor, editor.selection, {
    filterVoids: true
  });
  const shouldInsertSpaceBefore = beforeCharacter && !isEmptyString(beforeCharacter.text);
  const shouldInsertSpaceAfter = afterCharacter && !isEmptyString(afterCharacter.text);
  if (!Range.isCollapsed(editor.selection)) {
    const text = (shouldInsertSpaceBefore ? " " : "") + MENTION_CHARACTER + (shouldInsertSpaceAfter ? " " : "");
    editor.insertText(text);
    if (shouldInsertSpaceAfter) {
      Transforms.move(editor, {
        distance: 1,
        unit: "character",
        reverse: true
      });
    }
  } else {
    const beforeText = (shouldInsertSpaceBefore ? " " : "") + MENTION_CHARACTER;
    editor.insertText(beforeText, { at: Range.start(editor.selection) });
    if (shouldInsertSpaceAfter) {
      editor.insertText(" ", { at: Range.end(editor.selection) });
    }
    Transforms.collapse(editor, { edge: "end" });
  }
}
function withMentions(editor) {
  const { isInline, isVoid, markableVoid, deleteBackward: deleteBackward2 } = editor;
  editor.isInline = (element) => {
    return isComposerBodyMention(element) || isInline(element);
  };
  editor.isVoid = (element) => {
    return isComposerBodyMention(element) || isVoid(element);
  };
  editor.markableVoid = (element) => {
    return isComposerBodyMention(element) || markableVoid(element);
  };
  editor.deleteBackward = (unit) => {
    const { selection } = editor;
    if (selection && Range.isCollapsed(selection)) {
      const [mention] = Editor.nodes(editor, {
        at: unit === "character" ? Editor.before(editor, selection, { unit: "character" }) : selection,
        match: isComposerBodyMention
      });
      deleteBackward2(unit);
      if (mention) {
        Transforms.insertText(editor, MENTION_CHARACTER);
      }
    } else {
      deleteBackward2(unit);
    }
  };
  return editor;
}

// node_modules/slate-hyperscript/dist/index.es.js
function _typeof3(o3) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof3(o3);
}
function _toPrimitive3(input, hint) {
  if (_typeof3(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof3(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return _typeof3(key) === "symbol" ? key : String(key);
}
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ANCHOR = /* @__PURE__ */ new WeakMap();
var FOCUS = /* @__PURE__ */ new WeakMap();
var Token = class {
};
var AnchorToken = class extends Token {
  constructor() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super();
    _defineProperty3(this, "offset", void 0);
    _defineProperty3(this, "path", void 0);
    var {
      offset: offset4,
      path: path3
    } = props;
    this.offset = offset4;
    this.path = path3;
  }
};
var FocusToken = class extends Token {
  constructor() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super();
    _defineProperty3(this, "offset", void 0);
    _defineProperty3(this, "path", void 0);
    var {
      offset: offset4,
      path: path3
    } = props;
    this.offset = offset4;
    this.path = path3;
  }
};
var addAnchorToken = (text, token) => {
  var offset4 = text.text.length;
  ANCHOR.set(text, [offset4, token]);
};
var getAnchorOffset = (text) => {
  return ANCHOR.get(text);
};
var addFocusToken = (text, token) => {
  var offset4 = text.text.length;
  FOCUS.set(text, [offset4, token]);
};
var getFocusOffset = (text) => {
  return FOCUS.get(text);
};
function ownKeys$13(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread$13(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$13(Object(t3), true).forEach(function(r3) {
      _defineProperty3(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys$13(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var STRINGS = /* @__PURE__ */ new WeakSet();
var resolveDescendants = (children) => {
  var nodes2 = [];
  var addChild = (child2) => {
    if (child2 == null) {
      return;
    }
    var prev = nodes2[nodes2.length - 1];
    if (typeof child2 === "string") {
      var text = {
        text: child2
      };
      STRINGS.add(text);
      child2 = text;
    }
    if (Text.isText(child2)) {
      var c = child2;
      if (Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && Text.equals(prev, c, {
        loose: true
      })) {
        prev.text += c.text;
      } else {
        nodes2.push(c);
      }
    } else if (Element2.isElement(child2)) {
      nodes2.push(child2);
    } else if (child2 instanceof Token) {
      var n3 = nodes2[nodes2.length - 1];
      if (!Text.isText(n3)) {
        addChild("");
        n3 = nodes2[nodes2.length - 1];
      }
      if (child2 instanceof AnchorToken) {
        addAnchorToken(n3, child2);
      } else if (child2 instanceof FocusToken) {
        addFocusToken(n3, child2);
      }
    } else {
      throw new Error("Unexpected hyperscript child object: ".concat(child2));
    }
  };
  for (var child of children.flat(Infinity)) {
    addChild(child);
  }
  return nodes2;
};
function createAnchor(tagName, attributes, children) {
  return new AnchorToken(attributes);
}
function createCursor(tagName, attributes, children) {
  return [new AnchorToken(attributes), new FocusToken(attributes)];
}
function createElement9(tagName, attributes, children) {
  return _objectSpread$13(_objectSpread$13({}, attributes), {}, {
    children: resolveDescendants(children)
  });
}
function createFocus(tagName, attributes, children) {
  return new FocusToken(attributes);
}
function createFragment(tagName, attributes, children) {
  return resolveDescendants(children);
}
function createSelection(tagName, attributes, children) {
  var anchor = children.find((c) => c instanceof AnchorToken);
  var focus3 = children.find((c) => c instanceof FocusToken);
  if (!anchor || anchor.offset == null || anchor.path == null) {
    throw new Error("The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.");
  }
  if (!focus3 || focus3.offset == null || focus3.path == null) {
    throw new Error("The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.");
  }
  return _objectSpread$13({
    anchor: {
      offset: anchor.offset,
      path: anchor.path
    },
    focus: {
      offset: focus3.offset,
      path: focus3.path
    }
  }, attributes);
}
function createText(tagName, attributes, children) {
  var nodes2 = resolveDescendants(children);
  if (nodes2.length > 1) {
    throw new Error("The <text> hyperscript tag must only contain a single node's worth of children.");
  }
  var [node3] = nodes2;
  if (node3 == null) {
    node3 = {
      text: ""
    };
  }
  if (!Text.isText(node3)) {
    throw new Error("\n    The <text> hyperscript tag can only contain text content as children.");
  }
  STRINGS.delete(node3);
  Object.assign(node3, attributes);
  return node3;
}
var createEditor2 = (makeEditor) => (tagName, attributes, children) => {
  var otherChildren = [];
  var selectionChild;
  for (var child of children) {
    if (Range.isRange(child)) {
      selectionChild = child;
    } else {
      otherChildren.push(child);
    }
  }
  var descendants = resolveDescendants(otherChildren);
  var selection = {};
  var editor = makeEditor();
  Object.assign(editor, attributes);
  editor.children = descendants;
  for (var [node3, path3] of Node3.texts(editor)) {
    var anchor = getAnchorOffset(node3);
    var focus3 = getFocusOffset(node3);
    if (anchor != null) {
      var [offset4] = anchor;
      selection.anchor = {
        path: path3,
        offset: offset4
      };
    }
    if (focus3 != null) {
      var [_offset] = focus3;
      selection.focus = {
        path: path3,
        offset: _offset
      };
    }
  }
  if (selection.anchor && !selection.focus) {
    throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.");
  }
  if (!selection.anchor && selection.focus) {
    throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.");
  }
  if (selectionChild != null) {
    editor.selection = selectionChild;
  } else if (Range.isRange(selection)) {
    editor.selection = selection;
  }
  return editor;
};
function ownKeys3(e3, r2) {
  var t3 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread3(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t3), true).forEach(function(r3) {
      _defineProperty3(e3, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t3)) : ownKeys3(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e3;
}
var DEFAULT_CREATORS = {
  anchor: createAnchor,
  cursor: createCursor,
  editor: createEditor2(createEditor),
  element: createElement9,
  focus: createFocus,
  fragment: createFragment,
  selection: createSelection,
  text: createText
};
var createHyperscript = function createHyperscript2() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var {
    elements = {}
  } = options2;
  var elementCreators = normalizeElements(elements);
  var creators = _objectSpread3(_objectSpread3(_objectSpread3({}, DEFAULT_CREATORS), elementCreators), options2.creators);
  var jsx129 = createFactory(creators);
  return jsx129;
};
var createFactory = (creators) => {
  var jsx129 = function jsx130(tagName, attributes) {
    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }
    var creator = creators[tagName];
    if (!creator) {
      throw new Error("No hyperscript creator found for tag: <".concat(tagName, ">"));
    }
    if (attributes == null) {
      attributes = {};
    }
    if (!isPlainObject(attributes)) {
      children = [attributes].concat(children);
      attributes = {};
    }
    children = children.filter((child) => Boolean(child)).flat();
    var ret = creator(tagName, attributes, children);
    return ret;
  };
  return jsx129;
};
var normalizeElements = (elements) => {
  var creators = {};
  var _loop = function _loop2() {
    var props = elements[tagName];
    if (typeof props !== "object") {
      throw new Error("Properties specified for a hyperscript shorthand should be an object, but for the custom element <".concat(tagName, ">  tag you passed: ").concat(props));
    }
    creators[tagName] = (tagName2, attributes, children) => {
      return createElement9("element", _objectSpread3(_objectSpread3({}, props), attributes), children);
    };
  };
  for (var tagName in elements) {
    _loop();
  }
  return creators;
};
var jsx96 = createHyperscript();

// node_modules/@liveblocks/react-ui/dist/utils/exists.js
function exists(input) {
  return input !== null && input !== void 0;
}

// node_modules/@liveblocks/react-ui/dist/utils/data-transfer.js
function getFiles(dataTransfer) {
  if (!dataTransfer.types.includes("Files")) {
    return [];
  }
  let files = Array.from(dataTransfer.items).map((item) => {
    const entry = item.webkitGetAsEntry();
    return entry && entry.isFile ? item.getAsFile() : null;
  }).filter(exists);
  if (!files.length) {
    files = Array.from(dataTransfer.files).filter((file) => file.type !== "");
  }
  return files;
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/slate/plugins/paste.js
var NEWLINE_REGEX2 = /[\r\n]/g;
var WHITESPACE_REGEX3 = /\s+/g;
function areUrlsEqual(a, b) {
  try {
    const urlA = new URL(a);
    const urlB = new URL(b);
    return urlA.origin === urlB.origin && urlA.pathname === urlB.pathname;
  } catch {
    return false;
  }
}
var createParagraphElement = () => ({
  type: "paragraph"
});
var ELEMENT_TAGS = {
  A: (element) => {
    const href = element.getAttribute("href");
    const innerText = element.innerText;
    return {
      type: href && areUrlsEqual(href, innerText) ? "auto-link" : "custom-link",
      url: href ?? ""
    };
  },
  P: createParagraphElement,
  BLOCKQUOTE: createParagraphElement,
  H1: createParagraphElement,
  H2: createParagraphElement,
  H3: createParagraphElement,
  H4: createParagraphElement,
  H5: createParagraphElement,
  H6: createParagraphElement,
  LI: createParagraphElement
};
var TEXT_TAGS = {
  CODE: () => ({ code: true }),
  DEL: () => ({ strikethrough: true }),
  EM: () => ({ italic: true }),
  I: () => ({ italic: true }),
  S: () => ({ strikethrough: true }),
  STRONG: () => ({ bold: true }),
  B: () => ({ bold: true })
};
function flattenListItems(node3) {
  const listItems = [];
  if (node3.nodeName === "LI") {
    listItems.push(node3);
  }
  node3.childNodes.forEach((child) => {
    if (child.nodeType === 1) {
      listItems.push(...flattenListItems(child));
    }
  });
  return listItems;
}
function jsxTextChildren(children, attrs) {
  return children.map((child) => jsx96("text", attrs, child));
}
function deserialize(node3) {
  if (node3.nodeType === 3) {
    let text = node3.textContent;
    const isMultiLine = text && NEWLINE_REGEX2.test(text);
    if (text && isMultiLine) {
      text = text.replace(WHITESPACE_REGEX3, " ").trim();
    }
    return text ? { text } : null;
  } else if (node3.nodeType !== 1) {
    return null;
  } else if (node3.nodeName === "BR") {
    return jsx96("element", createParagraphElement(), []);
  }
  const childNodes = Array.from(node3.childNodes);
  let children = childNodes.map(deserialize).flat();
  if (node3.nodeName === "UL" || node3.nodeName === "OL") {
    const listItems = flattenListItems(node3);
    children = listItems.map((li) => deserialize(li)).flat();
  }
  if (children.length === 0) {
    children = [{ text: "" }];
  }
  if (node3.nodeName === "BODY") {
    if (children.length > 0 && children.every((child) => typeof child === "string")) {
      children = [
        { type: "paragraph", children: [{ text: children.join("") }] }
      ];
    }
    return jsx96(
      "fragment",
      {},
      children.filter((child) => typeof child !== "string")
    );
  }
  if (ELEMENT_TAGS[node3.nodeName]) {
    const attrs = ELEMENT_TAGS[node3.nodeName](node3);
    return jsx96("element", attrs, children);
  }
  if (TEXT_TAGS[node3.nodeName]) {
    const attrs = TEXT_TAGS[node3.nodeName](node3);
    if (children.some(
      (child) => child && typeof child !== "string" && "type" in child
    )) {
      return jsx96("fragment", {}, children);
    }
    return jsxTextChildren(children, attrs);
  }
  if (node3.nodeName === "SPAN") {
    const style = node3.style;
    const attrs = {};
    if (style.fontWeight === "bold" || style.fontWeight === "700" || style.fontWeight === "800" || style.fontWeight === "900") {
      attrs.bold = true;
    }
    if (style.fontStyle === "italic") {
      attrs.italic = true;
    }
    if (style.textDecoration === "line-through") {
      attrs.strikethrough = true;
    }
    return jsxTextChildren(children, attrs);
  }
  return children;
}
function withPaste(editor, {
  createAttachments,
  pasteFilesAsAttachments
}) {
  const { insertData } = editor;
  editor.insertData = (data) => {
    var _a3, _b;
    if (data.types.includes("Files") && pasteFilesAsAttachments) {
      const files = getFiles(data);
      if (files.length > 0) {
        createAttachments(files);
        return;
      }
    }
    if (data.types.includes("text/html") && !data.types.includes("application/x-slate-fragment")) {
      const html2 = data.getData("text/html");
      try {
        const { body } = new DOMParser().parseFromString(html2, "text/html");
        (_a3 = body.querySelector("br.Apple-interchange-newline")) == null ? void 0 : _a3.remove();
        if (body.children.length === 1 && ((_b = body.children[0]) == null ? void 0 : _b.nodeName) === "B") {
          const wrapper = body.children[0];
          while (wrapper.firstChild) {
            body.insertBefore(wrapper.firstChild, wrapper);
          }
          body.removeChild(wrapper);
        }
        const fragment2 = deserialize(body);
        if (fragment2 !== null && Array.isArray(fragment2)) {
          Transforms.insertFragment(editor, fragment2);
          return;
        }
      } catch {
      }
    }
    insertData(data);
  };
  return editor;
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/utils.js
var import_react59 = __toESM(require_react(), 1);
function composerBodyMentionToCommentBodyMention(mention) {
  const { children: _2, ...commentBodyMention } = mention;
  return commentBodyMention;
}
function composerBodyAutoLinkToCommentBodyLink(link2) {
  return {
    type: "link",
    url: link2.url
  };
}
function composerBodyCustomLinkToCommentBodyLink(link2) {
  return {
    type: "link",
    url: link2.url,
    text: link2.children.map((child) => child.text).join("")
  };
}
function commentBodyMentionToComposerBodyMention(mention) {
  return {
    ...mention,
    children: [{ text: "" }]
  };
}
function commentBodyLinkToComposerBodyLink(link2) {
  if (link2.text) {
    return {
      type: "custom-link",
      url: link2.url,
      children: [{ text: link2.text }]
    };
  } else {
    return {
      type: "auto-link",
      url: link2.url,
      children: [{ text: link2.url }]
    };
  }
}
function composerBodyToCommentBody(body) {
  return {
    version: 1,
    content: body.map((block2) => {
      if (block2.type !== "paragraph") {
        return null;
      }
      const children = block2.children.map((inline22) => {
        if (isComposerBodyMention(inline22)) {
          return composerBodyMentionToCommentBodyMention(inline22);
        }
        if (isComposerBodyAutoLink(inline22)) {
          return composerBodyAutoLinkToCommentBodyLink(inline22);
        }
        if (isComposerBodyCustomLink(inline22)) {
          return composerBodyCustomLinkToCommentBodyLink(inline22);
        }
        if (isText(inline22)) {
          return inline22;
        }
        return null;
      }).filter(exists);
      return {
        ...block2,
        children
      };
    }).filter(exists)
  };
}
var emptyComposerBody = [];
function commentBodyToComposerBody(body) {
  if (!body || !(body == null ? void 0 : body.content)) {
    return emptyComposerBody;
  }
  return body.content.map((block2) => {
    if (block2.type !== "paragraph") {
      return null;
    }
    const children = block2.children.map((inline22) => {
      if (isCommentBodyMention(inline22)) {
        return commentBodyMentionToComposerBodyMention(inline22);
      }
      if (isCommentBodyLink(inline22)) {
        return commentBodyLinkToComposerBodyLink(inline22);
      }
      if (isCommentBodyText(inline22)) {
        return inline22;
      }
      return null;
    }).filter(exists);
    return {
      ...block2,
      children
    };
  }).filter(exists);
}
function getRtlFloatingAlignment(alignment) {
  switch (alignment) {
    case "start":
      return "end";
    case "end":
      return "start";
    default:
      return "center";
  }
}
function getSideAndAlignFromFloatingPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function useContentZIndex() {
  const [content, setContent] = (0, import_react59.useState)(null);
  const contentRef = (0, import_react59.useCallback)(setContent, [setContent]);
  const [contentZIndex, setContentZIndex] = (0, import_react59.useState)();
  useLayoutEffect2(() => {
    if (content) {
      setContentZIndex(window.getComputedStyle(content).zIndex);
    }
  }, [content]);
  return [contentRef, contentZIndex];
}
function useFloatingWithOptions({
  type = "bounds",
  position,
  alignment,
  dir,
  open
}) {
  const floatingOptions = (0, import_react59.useMemo)(() => {
    const detectOverflowOptions = {
      padding: FLOATING_ELEMENT_COLLISION_PADDING
    };
    const middleware = [
      type === "range" ? inline3(detectOverflowOptions) : null,
      flip3({ ...detectOverflowOptions, crossAxis: false }),
      hide3(detectOverflowOptions),
      shift3({
        ...detectOverflowOptions,
        limiter: limitShift3()
      }),
      type === "range" ? offset3(FLOATING_ELEMENT_SIDE_OFFSET) : null,
      size3({
        ...detectOverflowOptions,
        apply({ availableWidth, availableHeight, elements }) {
          elements.floating.style.setProperty(
            "--lb-composer-floating-available-width",
            `${availableWidth}px`
          );
          elements.floating.style.setProperty(
            "--lb-composer-floating-available-height",
            `${availableHeight}px`
          );
        }
      })
    ];
    return {
      strategy: "fixed",
      placement: alignment === "center" ? position : `${position}-${dir === "rtl" ? getRtlFloatingAlignment(alignment) : alignment}`,
      middleware,
      whileElementsMounted: (...args) => {
        return autoUpdate(...args, {
          animationFrame: true
        });
      }
    };
  }, [alignment, position, dir, type]);
  return useFloating({
    ...floatingOptions,
    open
  });
}
function useComposerAttachmentsDropArea({
  onDragEnter,
  onDragLeave,
  onDragOver,
  onDrop,
  disabled
}) {
  const { isDisabled: isComposerDisabled } = useComposer();
  const isDisabled = isComposerDisabled || disabled;
  const { createAttachments } = useComposerAttachmentsContext();
  const [isDraggingOver, setDraggingOver] = (0, import_react59.useState)(false);
  const latestIsDraggingOver = useLatest(isDraggingOver);
  const handleDragEnter = (0, import_react59.useCallback)(
    (event) => {
      onDragEnter == null ? void 0 : onDragEnter(event);
      if (latestIsDraggingOver.current || isDisabled || event.isDefaultPrevented()) {
        return;
      }
      const dataTransfer = event.dataTransfer;
      if (!dataTransfer.types.includes("Files")) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      setDraggingOver(true);
    },
    [onDragEnter, isDisabled]
  );
  const handleDragLeave = (0, import_react59.useCallback)(
    (event) => {
      onDragLeave == null ? void 0 : onDragLeave(event);
      if (!latestIsDraggingOver.current || isDisabled || event.isDefaultPrevented()) {
        return;
      }
      if (event.relatedTarget ? event.relatedTarget === event.currentTarget || event.currentTarget.contains(event.relatedTarget) : event.currentTarget !== event.target) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      setDraggingOver(false);
    },
    [onDragLeave, isDisabled]
  );
  const handleDragOver = (0, import_react59.useCallback)(
    (event) => {
      onDragOver == null ? void 0 : onDragOver(event);
      if (isDisabled || event.isDefaultPrevented()) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
    },
    [onDragOver, isDisabled]
  );
  const handleDrop = (0, import_react59.useCallback)(
    (event) => {
      onDrop == null ? void 0 : onDrop(event);
      if (!latestIsDraggingOver.current || isDisabled || event.isDefaultPrevented()) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      setDraggingOver(false);
      const files = getFiles(event.dataTransfer);
      createAttachments(files);
    },
    [onDrop, isDisabled, createAttachments]
  );
  return [
    isDraggingOver,
    {
      onDragEnter: handleDragEnter,
      onDragLeave: handleDragLeave,
      onDragOver: handleDragOver,
      onDrop: handleDrop,
      "data-drop": isDraggingOver ? "" : void 0,
      "data-disabled": isDisabled ? "" : void 0
    }
  ];
}
var AttachmentTooLargeError = class extends Error {
  constructor(message, origin = "client") {
    super(message);
    __publicField(this, "origin");
    __publicField(this, "name", "AttachmentTooLargeError");
    this.origin = origin;
  }
};
function createComposerAttachmentsManager(client, roomId, options2) {
  const attachments = /* @__PURE__ */ new Map();
  const abortControllers = /* @__PURE__ */ new Map();
  const eventSource = makeEventSource();
  let cachedSnapshot = null;
  function notifySubscribers() {
    cachedSnapshot = null;
    eventSource.notify();
  }
  function uploadAttachment(attachment) {
    const abortController = new AbortController();
    abortControllers.set(attachment.id, abortController);
    client[kInternal].httpClient.uploadAttachment({
      roomId,
      attachment,
      signal: abortController.signal
    }).then(() => {
      attachments.set(attachment.id, {
        ...attachment,
        status: "uploaded"
      });
      notifySubscribers();
    }).catch((error) => {
      if (error instanceof Error && error.name !== "AbortError" && error.name !== "TimeoutError") {
        attachments.set(attachment.id, {
          ...attachment,
          status: "error",
          error: error instanceof HttpError && error.status === 413 ? new AttachmentTooLargeError("File is too large.", "server") : error
        });
        notifySubscribers();
      }
    });
  }
  function addAttachments(addedAttachments) {
    if (addedAttachments.length === 0) {
      return;
    }
    const newAttachments = addedAttachments.filter(
      (attachment) => !attachments.has(attachment.id)
    );
    const attachmentsToUpload = [];
    for (const attachment of newAttachments) {
      if (attachment.type === "localAttachment") {
        if (attachment.file.size > options2.maxFileSize) {
          attachments.set(attachment.id, {
            ...attachment,
            status: "error",
            error: new AttachmentTooLargeError("File is too large.", "client")
          });
          continue;
        }
        attachments.set(attachment.id, {
          ...attachment,
          status: "uploading"
        });
        attachmentsToUpload.push(attachment);
      } else {
        attachments.set(attachment.id, attachment);
      }
    }
    if (newAttachments.length > 0) {
      notifySubscribers();
    }
    for (const attachment of attachmentsToUpload) {
      uploadAttachment(attachment);
    }
  }
  function removeAttachment(attachmentId) {
    const abortController = abortControllers.get(attachmentId);
    abortController == null ? void 0 : abortController.abort();
    attachments.delete(attachmentId);
    abortControllers.delete(attachmentId);
    notifySubscribers();
  }
  function getSnapshot2() {
    if (!cachedSnapshot) {
      cachedSnapshot = Array.from(attachments.values());
    }
    return cachedSnapshot;
  }
  function clear() {
    abortControllers.forEach((controller) => controller.abort());
    abortControllers.clear();
    attachments.clear();
    notifySubscribers();
  }
  return {
    addAttachments,
    removeAttachment,
    getSnapshot: getSnapshot2,
    subscribe: eventSource.subscribe,
    clear
  };
}
function preventBeforeUnloadDefault(event) {
  event.preventDefault();
}
function useComposerAttachmentsManager(defaultAttachments, options2) {
  const client = useClient();
  const frozenDefaultAttachments = useInitial(defaultAttachments);
  const frozenAttachmentsManager = useInitial(
    () => createComposerAttachmentsManager(client, options2.roomId, options2)
  );
  (0, import_react59.useEffect)(() => {
    frozenAttachmentsManager.addAttachments(frozenDefaultAttachments);
  }, [frozenDefaultAttachments, frozenAttachmentsManager]);
  (0, import_react59.useEffect)(() => {
    return () => {
      frozenAttachmentsManager.clear();
    };
  }, [frozenAttachmentsManager]);
  const attachments = (0, import_react59.useSyncExternalStore)(
    frozenAttachmentsManager.subscribe,
    frozenAttachmentsManager.getSnapshot,
    frozenAttachmentsManager.getSnapshot
  );
  const isUploadingAttachments = (0, import_react59.useMemo)(() => {
    return attachments.some(
      (attachment) => attachment.type === "localAttachment" && attachment.status === "uploading"
    );
  }, [attachments]);
  (0, import_react59.useEffect)(() => {
    if (!isUploadingAttachments) {
      return;
    }
    window.addEventListener("beforeunload", preventBeforeUnloadDefault);
    return () => {
      window.removeEventListener("beforeunload", preventBeforeUnloadDefault);
    };
  }, [isUploadingAttachments]);
  return {
    attachments,
    isUploadingAttachments,
    addAttachments: frozenAttachmentsManager.addAttachments,
    removeAttachment: frozenAttachmentsManager.removeAttachment,
    clearAttachments: frozenAttachmentsManager.clear
  };
}

// node_modules/@liveblocks/react-ui/dist/primitives/Composer/index.js
var MENTION_SUGGESTIONS_POSITION = "top";
var FLOATING_TOOLBAR_POSITION = "top";
var COMPOSER_MENTION_NAME = "ComposerMention";
var COMPOSER_LINK_NAME = "ComposerLink";
var COMPOSER_FLOATING_TOOLBAR_NAME = "ComposerFloatingToolbar";
var COMPOSER_SUGGESTIONS_NAME = "ComposerSuggestions";
var COMPOSER_SUGGESTIONS_LIST_NAME = "ComposerSuggestionsList";
var COMPOSER_SUGGESTIONS_LIST_ITEM_NAME = "ComposerSuggestionsListItem";
var COMPOSER_SUBMIT_NAME = "ComposerSubmit";
var COMPOSER_EDITOR_NAME = "ComposerEditor";
var COMPOSER_ATTACH_FILES_NAME = "ComposerAttachFiles";
var COMPOSER_ATTACHMENTS_DROP_AREA_NAME = "ComposerAttachmentsDropArea";
var COMPOSER_MARK_TOGGLE_NAME = "ComposerMarkToggle";
var COMPOSER_FORM_NAME = "ComposerForm";
var emptyCommentBody = {
  version: 1,
  content: [{ type: "paragraph", children: [{ text: "" }] }]
};
function createComposerEditor({
  createAttachments,
  pasteFilesAsAttachments
}) {
  return withNormalize(
    withMentions(
      withCustomLinks(
        withAutoLinks(
          withAutoFormatting(
            withEmptyClearFormatting(
              withPaste(withHistory(withReact(createEditor())), {
                createAttachments,
                pasteFilesAsAttachments
              })
            )
          )
        )
      )
    )
  );
}
function ComposerEditorMentionWrapper({
  Mention: Mention2,
  attributes,
  children,
  element
}) {
  const isSelected = useSelected();
  const { children: _2, ...mention } = element;
  return (0, import_jsx_runtime98.jsxs)("span", {
    ...attributes,
    children: [
      element.id ? (0, import_jsx_runtime98.jsx)(Mention2, {
        mention,
        isSelected
      }) : null,
      children
    ]
  });
}
function ComposerEditorLinkWrapper({
  Link: Link2,
  attributes,
  element,
  children
}) {
  const href = (0, import_react61.useMemo)(() => sanitizeUrl(element.url) ?? "", [element.url]);
  return (0, import_jsx_runtime98.jsx)("span", {
    ...attributes,
    children: (0, import_jsx_runtime98.jsx)(Link2, {
      href,
      children
    })
  });
}
function ComposerEditorMentionSuggestionsWrapper({
  id,
  itemId,
  mentions,
  selectedMentionId,
  setSelectedMentionId,
  mentionDraft,
  setMentionDraft,
  onItemSelect,
  position = MENTION_SUGGESTIONS_POSITION,
  dir,
  MentionSuggestions
}) {
  const editor = useSlateStatic();
  const { onEditorChange } = useComposerEditorContext();
  const { isFocused } = useComposer();
  const { portalContainer } = useLiveblocksUiConfig();
  const [contentRef, contentZIndex] = useContentZIndex();
  const isOpen = isFocused && (mentionDraft == null ? void 0 : mentionDraft.range) !== void 0 && mentions !== void 0;
  const {
    refs: { setReference, setFloating },
    strategy,
    isPositioned,
    placement,
    x: x2,
    y,
    update,
    elements
  } = useFloatingWithOptions({
    position,
    dir,
    alignment: "start",
    open: isOpen
  });
  useObservable(onEditorChange, () => {
    setMentionDraft(getMentionDraftAtSelection(editor));
  });
  useLayoutEffect2(() => {
    if (!mentionDraft) {
      setReference(null);
      return;
    }
    const domRange = getDOMRange(editor, mentionDraft.range);
    setReference(domRange ?? null);
  }, [setReference, editor, mentionDraft]);
  useLayoutEffect2(() => {
    var _a3;
    if (!isOpen)
      return;
    const mentionSuggestions = (_a3 = elements.floating) == null ? void 0 : _a3.firstChild;
    if (!mentionSuggestions) {
      return;
    }
    mentionSuggestions.style.overflowY = "visible";
    mentionSuggestions.style.maxHeight = "none";
    update();
    const animationFrame = requestAnimationFrame(() => {
      mentionSuggestions.style.overflowY = "auto";
      mentionSuggestions.style.maxHeight = "var(--lb-composer-floating-available-height)";
    });
    return () => {
      cancelAnimationFrame(animationFrame);
    };
  }, [mentions == null ? void 0 : mentions.length, isOpen, elements.floating, update]);
  return (0, import_jsx_runtime98.jsx)(Persist, {
    children: isOpen ? (0, import_jsx_runtime98.jsx)(ComposerSuggestionsContext.Provider, {
      value: {
        id,
        itemId,
        selectedValue: selectedMentionId,
        setSelectedValue: setSelectedMentionId,
        onItemSelect,
        placement,
        dir,
        ref: contentRef
      },
      children: (0, import_jsx_runtime98.jsx)(Portal4, {
        ref: setFloating,
        container: portalContainer,
        style: {
          position: strategy,
          top: 0,
          left: 0,
          transform: isPositioned ? `translate3d(${Math.round(x2)}px, ${Math.round(y)}px, 0)` : "translate3d(0, -200%, 0)",
          minWidth: "max-content",
          zIndex: contentZIndex
        },
        children: (0, import_jsx_runtime98.jsx)(MentionSuggestions, {
          mentions,
          selectedMentionId
        })
      })
    }) : null
  });
}
function ComposerEditorFloatingToolbarWrapper({
  id,
  position = FLOATING_TOOLBAR_POSITION,
  dir,
  FloatingToolbar: FloatingToolbar2,
  hasFloatingToolbarRange,
  setHasFloatingToolbarRange
}) {
  const editor = useSlateStatic();
  const { onEditorChange } = useComposerEditorContext();
  const { isFocused } = useComposer();
  const { portalContainer } = useLiveblocksUiConfig();
  const [contentRef, contentZIndex] = useContentZIndex();
  const [isPointerDown, setPointerDown] = (0, import_react61.useState)(false);
  const isOpen = isFocused && !isPointerDown && hasFloatingToolbarRange;
  const {
    refs: { setReference, setFloating },
    strategy,
    isPositioned,
    placement,
    x: x2,
    y
  } = useFloatingWithOptions({
    type: "range",
    position,
    dir,
    alignment: "center",
    open: isOpen
  });
  useLayoutEffect2(() => {
    if (!isFocused) {
      return;
    }
    const handlePointerDown = () => setPointerDown(true);
    const handlePointerUp = () => setPointerDown(false);
    document.addEventListener("pointerdown", handlePointerDown);
    document.addEventListener("pointerup", handlePointerUp);
    return () => {
      document.removeEventListener("pointerdown", handlePointerDown);
      document.removeEventListener("pointerup", handlePointerUp);
    };
  }, [isFocused]);
  useObservable(onEditorChange, () => {
    setReference(null);
    requestAnimationFrame(() => {
      const domSelection = window.getSelection();
      if (!editor.selection || Range.isCollapsed(editor.selection) || !domSelection || !domSelection.rangeCount) {
        setHasFloatingToolbarRange(false);
        setReference(null);
      } else {
        setHasFloatingToolbarRange(true);
        const domRange = domSelection.getRangeAt(0);
        setReference(domRange);
      }
    });
  });
  return (0, import_jsx_runtime98.jsx)(Persist, {
    children: isOpen ? (0, import_jsx_runtime98.jsx)(ComposerFloatingToolbarContext.Provider, {
      value: {
        id,
        placement,
        dir,
        ref: contentRef
      },
      children: (0, import_jsx_runtime98.jsx)(Portal4, {
        ref: setFloating,
        container: portalContainer,
        style: {
          position: strategy,
          top: 0,
          left: 0,
          transform: isPositioned ? `translate3d(${Math.round(x2)}px, ${Math.round(y)}px, 0)` : "translate3d(0, -200%, 0)",
          minWidth: "max-content",
          zIndex: contentZIndex
        },
        children: (0, import_jsx_runtime98.jsx)(FloatingToolbar2, {})
      })
    }) : null
  });
}
var ComposerFloatingToolbar = (0, import_react61.forwardRef)(({ children, onPointerDown, style, asChild, ...props }, forwardedRef) => {
  const [isPresent] = usePersist();
  const ref = (0, import_react61.useRef)(null);
  const {
    id,
    ref: contentRef,
    placement,
    dir
  } = useComposerFloatingToolbarContext(COMPOSER_FLOATING_TOOLBAR_NAME);
  const mergedRefs = useRefs(forwardedRef, contentRef, ref);
  const [side, align] = (0, import_react61.useMemo)(
    () => getSideAndAlignFromFloatingPlacement(placement),
    [placement]
  );
  const Component3 = asChild ? Slot : "div";
  useAnimationPersist(ref);
  const handlePointerDown = (0, import_react61.useCallback)(
    (event) => {
      onPointerDown == null ? void 0 : onPointerDown(event);
      event.preventDefault();
      event.stopPropagation();
    },
    [onPointerDown]
  );
  return (0, import_jsx_runtime98.jsx)(Component3, {
    dir,
    role: "toolbar",
    id,
    "aria-label": "Floating toolbar",
    ...props,
    onPointerDown: handlePointerDown,
    "data-state": isPresent ? "open" : "closed",
    "data-side": side,
    "data-align": align,
    style: {
      display: "flex",
      flexDirection: "row",
      maxWidth: "var(--lb-composer-floating-available-width)",
      overflowX: "auto",
      ...style
    },
    ref: mergedRefs,
    children
  });
});
function ComposerEditorElement({
  Mention: Mention2,
  Link: Link2,
  ...props
}) {
  const { attributes, children, element } = props;
  switch (element.type) {
    case "mention":
      return (0, import_jsx_runtime98.jsx)(ComposerEditorMentionWrapper, {
        Mention: Mention2,
        ...props
      });
    case "auto-link":
    case "custom-link":
      return (0, import_jsx_runtime98.jsx)(ComposerEditorLinkWrapper, {
        Link: Link2,
        ...props
      });
    case "paragraph":
      return (0, import_jsx_runtime98.jsx)("p", {
        ...attributes,
        style: { position: "relative" },
        children
      });
    default:
      return null;
  }
}
function ComposerEditorLeaf({
  attributes,
  children,
  leaf: leaf3
}) {
  if (leaf3.bold) {
    children = (0, import_jsx_runtime98.jsx)("strong", {
      children
    });
  }
  if (leaf3.italic) {
    children = (0, import_jsx_runtime98.jsx)("em", {
      children
    });
  }
  if (leaf3.strikethrough) {
    children = (0, import_jsx_runtime98.jsx)("s", {
      children
    });
  }
  if (leaf3.code) {
    children = (0, import_jsx_runtime98.jsx)("code", {
      children
    });
  }
  return (0, import_jsx_runtime98.jsx)("span", {
    ...attributes,
    children
  });
}
function ComposerEditorPlaceholder({
  attributes,
  children
}) {
  const { opacity: _opacity, ...style } = attributes.style;
  return (0, import_jsx_runtime98.jsx)("span", {
    ...attributes,
    style,
    "data-placeholder": "",
    children
  });
}
var ComposerMention = (0, import_react61.forwardRef)(
  ({ children, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "span";
    const isSelected = useSelected();
    return (0, import_jsx_runtime98.jsx)(Component3, {
      "data-selected": isSelected || void 0,
      ...props,
      ref: forwardedRef,
      children
    });
  }
);
var ComposerLink = (0, import_react61.forwardRef)(
  ({ children, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "a";
    return (0, import_jsx_runtime98.jsx)(Component3, {
      target: "_blank",
      rel: "noopener noreferrer nofollow",
      ...props,
      ref: forwardedRef,
      children
    });
  }
);
var ComposerSuggestions = (0, import_react61.forwardRef)(({ children, style, asChild, ...props }, forwardedRef) => {
  const [isPresent] = usePersist();
  const ref = (0, import_react61.useRef)(null);
  const {
    ref: contentRef,
    placement,
    dir
  } = useComposerSuggestionsContext(COMPOSER_SUGGESTIONS_NAME);
  const mergedRefs = useRefs(forwardedRef, contentRef, ref);
  const [side, align] = (0, import_react61.useMemo)(
    () => getSideAndAlignFromFloatingPlacement(placement),
    [placement]
  );
  const Component3 = asChild ? Slot : "div";
  useAnimationPersist(ref);
  return (0, import_jsx_runtime98.jsx)(Component3, {
    dir,
    ...props,
    "data-state": isPresent ? "open" : "closed",
    "data-side": side,
    "data-align": align,
    style: {
      display: "flex",
      flexDirection: "column",
      maxHeight: "var(--lb-composer-floating-available-height)",
      overflowY: "auto",
      ...style
    },
    ref: mergedRefs,
    children
  });
});
var ComposerSuggestionsList = (0, import_react61.forwardRef)(({ children, asChild, ...props }, forwardedRef) => {
  const { id } = useComposerSuggestionsContext(COMPOSER_SUGGESTIONS_LIST_NAME);
  const Component3 = asChild ? Slot : "ul";
  return (0, import_jsx_runtime98.jsx)(Component3, {
    role: "listbox",
    id,
    "aria-label": "Suggestions list",
    ...props,
    ref: forwardedRef,
    children
  });
});
var ComposerSuggestionsListItem = (0, import_react61.forwardRef)(
  ({
    value,
    children,
    onPointerMove,
    onPointerDown,
    onClick,
    asChild,
    ...props
  }, forwardedRef) => {
    const ref = (0, import_react61.useRef)(null);
    const mergedRefs = useRefs(forwardedRef, ref);
    const { selectedValue, setSelectedValue, itemId, onItemSelect } = useComposerSuggestionsContext(COMPOSER_SUGGESTIONS_LIST_ITEM_NAME);
    const Component3 = asChild ? Slot : "li";
    const isSelected = (0, import_react61.useMemo)(
      () => selectedValue === value,
      [selectedValue, value]
    );
    const id = (0, import_react61.useMemo)(() => itemId(value), [itemId, value]);
    (0, import_react61.useEffect)(() => {
      if ((ref == null ? void 0 : ref.current) && isSelected) {
        ref.current.scrollIntoView({ block: "nearest" });
      }
    }, [isSelected]);
    const handlePointerMove = (0, import_react61.useCallback)(
      (event) => {
        onPointerMove == null ? void 0 : onPointerMove(event);
        if (!event.isDefaultPrevented()) {
          setSelectedValue(value);
        }
      },
      [onPointerMove, setSelectedValue, value]
    );
    const handlePointerDown = (0, import_react61.useCallback)(
      (event) => {
        onPointerDown == null ? void 0 : onPointerDown(event);
        event.preventDefault();
        event.stopPropagation();
      },
      [onPointerDown]
    );
    const handleClick = (0, import_react61.useCallback)(
      (event) => {
        onClick == null ? void 0 : onClick(event);
        const wasDefaultPrevented = event.isDefaultPrevented();
        event.preventDefault();
        event.stopPropagation();
        if (!wasDefaultPrevented) {
          onItemSelect(value);
        }
      },
      [onClick, onItemSelect, value]
    );
    return (0, import_jsx_runtime98.jsx)(Component3, {
      role: "option",
      id,
      "data-selected": isSelected || void 0,
      "aria-selected": isSelected || void 0,
      onPointerMove: handlePointerMove,
      onPointerDown: handlePointerDown,
      onClick: handleClick,
      ...props,
      ref: mergedRefs,
      children
    });
  }
);
var defaultEditorComponents = {
  Link: ({ href, children }) => {
    return (0, import_jsx_runtime98.jsx)(ComposerLink, {
      href,
      children
    });
  },
  Mention: ({ mention }) => {
    return (0, import_jsx_runtime98.jsxs)(ComposerMention, {
      children: [
        MENTION_CHARACTER,
        mention.id
      ]
    });
  },
  MentionSuggestions: ({ mentions }) => {
    return mentions.length > 0 ? (0, import_jsx_runtime98.jsx)(ComposerSuggestions, {
      children: (0, import_jsx_runtime98.jsx)(ComposerSuggestionsList, {
        children: mentions.map((mention) => (0, import_jsx_runtime98.jsx)(ComposerSuggestionsListItem, {
          value: mention.id,
          children: mention.id
        }, mention.id))
      })
    }) : null;
  }
};
var ComposerEditor = (0, import_react61.forwardRef)(
  ({
    defaultValue,
    onKeyDown,
    onFocus,
    onBlur,
    disabled,
    autoFocus,
    components,
    dir,
    ...props
  }, forwardedRef) => {
    const client = useClientOrNull();
    const { editor, validate, setFocused, onEditorChange, roomId } = useComposerEditorContext();
    const {
      submit,
      focus: focus3,
      blur,
      select: select2,
      canSubmit,
      isDisabled: isComposerDisabled,
      isFocused
    } = useComposer();
    const isDisabled = isComposerDisabled || disabled;
    const initialBody = useInitial(defaultValue ?? emptyCommentBody);
    const initialEditorValue = (0, import_react61.useMemo)(() => {
      return commentBodyToComposerBody(initialBody);
    }, [initialBody]);
    const { Link: Link2, Mention: Mention2, MentionSuggestions, FloatingToolbar: FloatingToolbar2 } = (0, import_react61.useMemo)(
      () => ({ ...defaultEditorComponents, ...components }),
      [components]
    );
    const [hasFloatingToolbarRange, setHasFloatingToolbarRange] = (0, import_react61.useState)(false);
    const resolveMentionSuggestions = useResolveMentionSuggestions();
    const hasResolveMentionSuggestions = client ? resolveMentionSuggestions : true;
    const [mentionDraft, setMentionDraft] = (0, import_react61.useState)();
    const mentionSuggestions = useMentionSuggestions(
      roomId,
      mentionDraft == null ? void 0 : mentionDraft.text
    );
    const [
      selectedMentionSuggestionIndex,
      setPreviousSelectedMentionSuggestionIndex,
      setNextSelectedMentionSuggestionIndex,
      setSelectedMentionSuggestionIndex
    ] = useIndex(0, (mentionSuggestions == null ? void 0 : mentionSuggestions.length) ?? 0);
    const id = (0, import_react61.useId)();
    const floatingToolbarId = `liveblocks-floating-toolbar-${id}`;
    const suggestionsListId = `liveblocks-suggestions-list-${id}`;
    const suggestionsListItemId = (0, import_react61.useCallback)(
      (mentionId) => mentionId ? `liveblocks-suggestions-list-item-${id}-${mentionId}` : void 0,
      [id]
    );
    const renderElement = (0, import_react61.useCallback)(
      (props2) => {
        return (0, import_jsx_runtime98.jsx)(ComposerEditorElement, {
          Mention: Mention2,
          Link: Link2,
          ...props2
        });
      },
      [Link2, Mention2]
    );
    const handleChange = (0, import_react61.useCallback)(
      (value) => {
        validate(value);
        onEditorChange.notify();
      },
      [validate, onEditorChange]
    );
    const createMention = (0, import_react61.useCallback)(
      (mention) => {
        if (!mentionDraft || !mention) {
          return;
        }
        Transforms.select(editor, mentionDraft.range);
        insertMention(editor, mention);
        setMentionDraft(void 0);
        setSelectedMentionSuggestionIndex(0);
      },
      [editor, mentionDraft, setSelectedMentionSuggestionIndex]
    );
    const handleKeyDown = (0, import_react61.useCallback)(
      (event) => {
        onKeyDown == null ? void 0 : onKeyDown(event);
        if (event.isDefaultPrevented()) {
          return;
        }
        if (isKey(event, "ArrowLeft")) {
          leaveMarkEdge(editor, "start");
        }
        if (isKey(event, "ArrowRight")) {
          leaveMarkEdge(editor, "end");
        }
        if (mentionDraft && (mentionSuggestions == null ? void 0 : mentionSuggestions.length)) {
          if (isKey(event, "ArrowDown")) {
            event.preventDefault();
            setNextSelectedMentionSuggestionIndex();
          }
          if (isKey(event, "ArrowUp")) {
            event.preventDefault();
            setPreviousSelectedMentionSuggestionIndex();
          }
          if (isKey(event, "Enter") || isKey(event, "Tab")) {
            event.preventDefault();
            const mention = mentionSuggestions == null ? void 0 : mentionSuggestions[selectedMentionSuggestionIndex];
            createMention(mention);
          }
          if (isKey(event, "Escape")) {
            event.preventDefault();
            setMentionDraft(void 0);
            setSelectedMentionSuggestionIndex(0);
          }
        } else {
          if (hasFloatingToolbarRange) {
            if (isKey(event, "Escape")) {
              event.preventDefault();
              setHasFloatingToolbarRange(false);
            }
          }
          if (isKey(event, "Escape")) {
            blur();
          }
          if (isKey(event, "Enter", { shift: false })) {
            event.preventDefault();
            if (canSubmit) {
              submit();
            }
          }
          if (isKey(event, "Enter", { shift: true })) {
            event.preventDefault();
            editor.insertBreak();
          }
          if (isKey(event, "b", { mod: true })) {
            event.preventDefault();
            toggleMark(editor, "bold");
          }
          if (isKey(event, "i", { mod: true })) {
            event.preventDefault();
            toggleMark(editor, "italic");
          }
          if (isKey(event, "s", { mod: true, shift: true })) {
            event.preventDefault();
            toggleMark(editor, "strikethrough");
          }
          if (isKey(event, "e", { mod: true })) {
            event.preventDefault();
            toggleMark(editor, "code");
          }
        }
      },
      [
        onKeyDown,
        mentionDraft,
        mentionSuggestions,
        hasFloatingToolbarRange,
        editor,
        setNextSelectedMentionSuggestionIndex,
        setPreviousSelectedMentionSuggestionIndex,
        selectedMentionSuggestionIndex,
        createMention,
        setSelectedMentionSuggestionIndex,
        blur,
        canSubmit,
        submit
      ]
    );
    const handleFocus = (0, import_react61.useCallback)(
      (event) => {
        onFocus == null ? void 0 : onFocus(event);
        if (!event.isDefaultPrevented()) {
          setFocused(true);
        }
      },
      [onFocus, setFocused]
    );
    const handleBlur = (0, import_react61.useCallback)(
      (event) => {
        onBlur == null ? void 0 : onBlur(event);
        if (!event.isDefaultPrevented()) {
          setFocused(false);
        }
      },
      [onBlur, setFocused]
    );
    const selectedMention = mentionSuggestions == null ? void 0 : mentionSuggestions[selectedMentionSuggestionIndex];
    const selectedMentionId = selectedMention == null ? void 0 : selectedMention.id;
    const setSelectedMentionId = (0, import_react61.useCallback)(
      (mentionId) => {
        const index2 = mentionSuggestions == null ? void 0 : mentionSuggestions.findIndex(
          (mention) => mention.id === mentionId
        );
        if (index2 !== void 0 && index2 >= 0) {
          setSelectedMentionSuggestionIndex(index2);
        }
      },
      [setSelectedMentionSuggestionIndex, mentionSuggestions]
    );
    const additionalProps = (0, import_react61.useMemo)(
      () => mentionDraft ? {
        role: "combobox",
        "aria-autocomplete": "list",
        "aria-expanded": true,
        "aria-controls": suggestionsListId,
        "aria-activedescendant": suggestionsListItemId(selectedMentionId)
      } : hasFloatingToolbarRange ? {
        "aria-haspopup": true,
        "aria-controls": floatingToolbarId
      } : {},
      [
        mentionDraft,
        suggestionsListId,
        suggestionsListItemId,
        selectedMentionId,
        hasFloatingToolbarRange,
        floatingToolbarId
      ]
    );
    (0, import_react61.useImperativeHandle)(forwardedRef, () => {
      return ReactEditor.toDOMNode(editor, editor);
    }, [editor]);
    useLayoutEffect2(() => {
      if (autoFocus) {
        focus3();
      }
    }, [autoFocus, editor, focus3]);
    useLayoutEffect2(() => {
      if (isFocused && editor.selection === null) {
        select2();
      }
    }, [editor, select2, isFocused]);
    const handleMentionSelect = (0, import_react61.useCallback)(
      (mentionId) => {
        const mention = mentionSuggestions == null ? void 0 : mentionSuggestions.find(
          (mention2) => mention2.id === mentionId
        );
        createMention(mention);
      },
      [createMention, mentionSuggestions]
    );
    return (0, import_jsx_runtime98.jsxs)(Slate, {
      editor,
      initialValue: initialEditorValue,
      onChange: handleChange,
      children: [
        (0, import_jsx_runtime98.jsx)(Editable, {
          dir,
          enterKeyHint: mentionDraft ? "enter" : "send",
          autoCapitalize: "sentences",
          "aria-label": "Composer editor",
          "data-focused": isFocused || void 0,
          "data-disabled": isDisabled || void 0,
          ...additionalProps,
          ...props,
          readOnly: isDisabled,
          disabled: isDisabled,
          onKeyDown: handleKeyDown,
          onFocus: handleFocus,
          onBlur: handleBlur,
          renderElement,
          renderLeaf: ComposerEditorLeaf,
          renderPlaceholder: ComposerEditorPlaceholder
        }),
        hasResolveMentionSuggestions && (0, import_jsx_runtime98.jsx)(ComposerEditorMentionSuggestionsWrapper, {
          dir,
          mentionDraft,
          setMentionDraft,
          selectedMentionId,
          setSelectedMentionId,
          mentions: mentionSuggestions,
          id: suggestionsListId,
          itemId: suggestionsListItemId,
          onItemSelect: handleMentionSelect,
          MentionSuggestions
        }),
        FloatingToolbar2 && (0, import_jsx_runtime98.jsx)(ComposerEditorFloatingToolbarWrapper, {
          dir,
          id: floatingToolbarId,
          hasFloatingToolbarRange,
          setHasFloatingToolbarRange,
          FloatingToolbar: FloatingToolbar2
        })
      ]
    });
  }
);
var MAX_ATTACHMENTS = 10;
var MAX_ATTACHMENT_SIZE = 1024 * 1024 * 1024;
function prepareAttachment(file) {
  return {
    type: "localAttachment",
    status: "idle",
    id: createCommentAttachmentId(),
    name: file.name,
    size: file.size,
    mimeType: file.type,
    file
  };
}
var ComposerForm = (0, import_react61.forwardRef)(
  ({
    children,
    onSubmit,
    onComposerSubmit,
    defaultAttachments = [],
    pasteFilesAsAttachments,
    blurOnSubmit = true,
    preventUnsavedChanges = true,
    disabled,
    asChild,
    roomId: _roomId,
    ...props
  }, forwardedRef) => {
    const Component3 = asChild ? Slot : "form";
    const [isEmpty$1, setEmpty] = (0, import_react61.useState)(true);
    const [isSubmitting, setSubmitting] = (0, import_react61.useState)(false);
    const [isFocused, setFocused] = (0, import_react61.useState)(false);
    const room = _useRoom({ allowOutsideRoom: true });
    const roomId = _roomId !== void 0 ? _roomId : room == null ? void 0 : room.id;
    if (roomId === void 0) {
      throw new Error("Composer.Form must be a descendant of RoomProvider.");
    }
    const maxAttachments = MAX_ATTACHMENTS;
    const maxAttachmentSize = MAX_ATTACHMENT_SIZE;
    const {
      attachments,
      isUploadingAttachments,
      addAttachments,
      removeAttachment,
      clearAttachments
    } = useComposerAttachmentsManager(defaultAttachments, {
      maxFileSize: maxAttachmentSize,
      roomId
    });
    const numberOfAttachments = attachments.length;
    const hasMaxAttachments = numberOfAttachments >= maxAttachments;
    const isDisabled = (0, import_react61.useMemo)(() => {
      return isSubmitting || disabled === true;
    }, [isSubmitting, disabled]);
    const canSubmit = (0, import_react61.useMemo)(() => {
      return !isEmpty$1 && !isUploadingAttachments;
    }, [isEmpty$1, isUploadingAttachments]);
    const [marks3, setMarks] = (0, import_react61.useState)(getComposerBodyMarks);
    const ref = (0, import_react61.useRef)(null);
    const mergedRefs = useRefs(forwardedRef, ref);
    const fileInputRef = (0, import_react61.useRef)(null);
    const syncSource = useSyncSource();
    const isPending = !preventUnsavedChanges ? false : !isEmpty$1 || isUploadingAttachments || attachments.length > 0;
    (0, import_react61.useEffect)(() => {
      syncSource == null ? void 0 : syncSource.setSyncStatus(
        isPending ? "has-local-changes" : "synchronized"
      );
    }, [syncSource, isPending]);
    const createAttachments = (0, import_react61.useCallback)(
      (files) => {
        if (!files.length) {
          return;
        }
        const numberOfAcceptedFiles = Math.max(
          0,
          maxAttachments - numberOfAttachments
        );
        files.splice(numberOfAcceptedFiles);
        const attachments2 = files.map((file) => prepareAttachment(file));
        addAttachments(attachments2);
      },
      [addAttachments, maxAttachments, numberOfAttachments]
    );
    const createAttachmentsRef = (0, import_react61.useRef)(createAttachments);
    (0, import_react61.useEffect)(() => {
      createAttachmentsRef.current = createAttachments;
    }, [createAttachments]);
    const stableCreateAttachments = (0, import_react61.useCallback)((files) => {
      createAttachmentsRef.current(files);
    }, []);
    const editor = useInitial(
      () => createComposerEditor({
        createAttachments: stableCreateAttachments,
        pasteFilesAsAttachments
      })
    );
    const onEditorChange = useInitial(makeEventSource);
    const validate = (0, import_react61.useCallback)(
      (value) => {
        setEmpty(isEmpty2(editor, value));
      },
      [editor]
    );
    const submit = (0, import_react61.useCallback)(() => {
      if (!canSubmit) {
        return;
      }
      requestAnimationFrame(() => {
        if (ref.current) {
          requestSubmit(ref.current);
        }
      });
    }, [canSubmit]);
    const clear = (0, import_react61.useCallback)(() => {
      Transforms.delete(editor, {
        at: {
          anchor: Editor.start(editor, []),
          focus: Editor.end(editor, [])
        }
      });
    }, [editor]);
    const select2 = (0, import_react61.useCallback)(() => {
      Transforms.select(editor, Editor.end(editor, []));
    }, [editor]);
    const focus3 = (0, import_react61.useCallback)(
      (resetSelection = true) => {
        try {
          if (!ReactEditor.isFocused(editor)) {
            Transforms.select(
              editor,
              resetSelection || !editor.selection ? Editor.end(editor, []) : editor.selection
            );
            ReactEditor.focus(editor);
          }
        } catch {
        }
      },
      [editor]
    );
    const blur = (0, import_react61.useCallback)(() => {
      try {
        ReactEditor.blur(editor);
      } catch {
      }
    }, [editor]);
    const createMention = (0, import_react61.useCallback)(() => {
      if (disabled) {
        return;
      }
      focus3();
      insertMentionCharacter(editor);
    }, [disabled, editor, focus3]);
    const insertText$1 = (0, import_react61.useCallback)(
      (text) => {
        if (disabled) {
          return;
        }
        focus3(false);
        insertText(editor, text);
      },
      [disabled, editor, focus3]
    );
    const attachFiles = (0, import_react61.useCallback)(() => {
      if (disabled) {
        return;
      }
      if (fileInputRef.current) {
        fileInputRef.current.click();
      }
    }, [disabled]);
    const handleAttachmentsInputChange = (0, import_react61.useCallback)(
      (event) => {
        if (disabled) {
          return;
        }
        if (event.target.files) {
          createAttachments(Array.from(event.target.files));
          event.target.value = "";
        }
      },
      [createAttachments, disabled]
    );
    const onSubmitEnd = (0, import_react61.useCallback)(() => {
      clear();
      clearAttachments();
      setSubmitting(false);
      if (blurOnSubmit) {
        blur();
      }
    }, [blur, blurOnSubmit, clear, clearAttachments]);
    const handleSubmit = (0, import_react61.useCallback)(
      (event) => {
        if (disabled) {
          return;
        }
        const isEmpty22 = isEmpty2(editor, editor.children);
        if (isEmpty22) {
          event.preventDefault();
          return;
        }
        onSubmit == null ? void 0 : onSubmit(event);
        if (!onComposerSubmit || event.isDefaultPrevented()) {
          event.preventDefault();
          return;
        }
        const body = composerBodyToCommentBody(
          editor.children
        );
        const commentAttachments = attachments.filter(
          (attachment) => attachment.type === "attachment" || attachment.type === "localAttachment" && attachment.status === "uploaded"
        ).map((attachment) => {
          return {
            id: attachment.id,
            type: "attachment",
            mimeType: attachment.mimeType,
            size: attachment.size,
            name: attachment.name
          };
        });
        const promise = onComposerSubmit(
          { body, attachments: commentAttachments },
          event
        );
        event.preventDefault();
        if (promise) {
          setSubmitting(true);
          promise.then(onSubmitEnd);
        } else {
          onSubmitEnd();
        }
      },
      [disabled, editor, attachments, onComposerSubmit, onSubmit, onSubmitEnd]
    );
    const stopPropagation = (0, import_react61.useCallback)((event) => {
      event.stopPropagation();
    }, []);
    const toggleMark$1 = (0, import_react61.useCallback)(
      (mark) => {
        toggleMark(editor, mark);
      },
      [editor]
    );
    useObservable(onEditorChange, () => {
      setMarks(getComposerBodyMarks(editor));
    });
    return (0, import_jsx_runtime98.jsx)(ComposerEditorContext.Provider, {
      value: {
        editor,
        validate,
        setFocused,
        onEditorChange,
        roomId
      },
      children: (0, import_jsx_runtime98.jsx)(ComposerAttachmentsContext.Provider, {
        value: {
          createAttachments,
          isUploadingAttachments,
          hasMaxAttachments,
          maxAttachments,
          maxAttachmentSize
        },
        children: (0, import_jsx_runtime98.jsx)(ComposerContext.Provider, {
          value: {
            isDisabled,
            isFocused,
            isEmpty: isEmpty$1,
            canSubmit,
            submit,
            clear,
            select: select2,
            focus: focus3,
            blur,
            createMention,
            insertText: insertText$1,
            attachments,
            attachFiles,
            removeAttachment,
            toggleMark: toggleMark$1,
            marks: marks3
          },
          children: (0, import_jsx_runtime98.jsxs)(Component3, {
            ...props,
            onSubmit: handleSubmit,
            ref: mergedRefs,
            children: [
              (0, import_jsx_runtime98.jsx)("input", {
                type: "file",
                multiple: true,
                ref: fileInputRef,
                onChange: handleAttachmentsInputChange,
                onClick: stopPropagation,
                tabIndex: -1,
                style: { display: "none" }
              }),
              (0, import_jsx_runtime98.jsx)(Slottable, {
                children
              })
            ]
          })
        })
      })
    });
  }
);
var ComposerSubmit = (0, import_react61.forwardRef)(
  ({ children, disabled, asChild, ...props }, forwardedRef) => {
    const Component3 = asChild ? Slot : "button";
    const { canSubmit, isDisabled: isComposerDisabled } = useComposer();
    const isDisabled = isComposerDisabled || disabled || !canSubmit;
    return (0, import_jsx_runtime98.jsx)(Component3, {
      type: "submit",
      ...props,
      ref: forwardedRef,
      disabled: isDisabled,
      children
    });
  }
);
var ComposerAttachFiles = (0, import_react61.forwardRef)(({ children, onClick, disabled, asChild, ...props }, forwardedRef) => {
  const Component3 = asChild ? Slot : "button";
  const { hasMaxAttachments } = useComposerAttachmentsContext();
  const { isDisabled: isComposerDisabled, attachFiles } = useComposer();
  const isDisabled = isComposerDisabled || hasMaxAttachments || disabled;
  const handleClick = (0, import_react61.useCallback)(
    (event) => {
      onClick == null ? void 0 : onClick(event);
      if (!event.isDefaultPrevented()) {
        attachFiles();
      }
    },
    [attachFiles, onClick]
  );
  return (0, import_jsx_runtime98.jsx)(Component3, {
    type: "button",
    ...props,
    onClick: handleClick,
    ref: forwardedRef,
    disabled: isDisabled,
    children
  });
});
var ComposerAttachmentsDropArea = (0, import_react61.forwardRef)(
  ({
    onDragEnter,
    onDragLeave,
    onDragOver,
    onDrop,
    disabled,
    asChild,
    ...props
  }, forwardedRef) => {
    const Component3 = asChild ? Slot : "div";
    const { isDisabled: isComposerDisabled } = useComposer();
    const isDisabled = isComposerDisabled || disabled;
    const [, dropAreaProps] = useComposerAttachmentsDropArea({
      onDragEnter,
      onDragLeave,
      onDragOver,
      onDrop,
      disabled: isDisabled
    });
    return (0, import_jsx_runtime98.jsx)(Component3, {
      ...dropAreaProps,
      "data-disabled": isDisabled ? "" : void 0,
      ...props,
      ref: forwardedRef
    });
  }
);
var ComposerMarkToggle = (0, import_react61.forwardRef)(
  ({
    children,
    mark,
    onValueChange,
    onClick,
    onPointerDown,
    asChild,
    ...props
  }, forwardedRef) => {
    const Component3 = asChild ? Slot : "button";
    const { marks: marks3, toggleMark: toggleMark2 } = useComposer();
    const handlePointerDown = (0, import_react61.useCallback)(
      (event) => {
        onPointerDown == null ? void 0 : onPointerDown(event);
        event.preventDefault();
        event.stopPropagation();
      },
      [onPointerDown]
    );
    const handleClick = (0, import_react61.useCallback)(
      (event) => {
        onClick == null ? void 0 : onClick(event);
        if (!event.isDefaultPrevented()) {
          event.preventDefault();
          event.stopPropagation();
          toggleMark2(mark);
          onValueChange == null ? void 0 : onValueChange(mark);
        }
      },
      [mark, onClick, onValueChange, toggleMark2]
    );
    return (0, import_jsx_runtime98.jsx)(Root5, {
      asChild: true,
      pressed: marks3[mark],
      onClick: handleClick,
      onPointerDown: handlePointerDown,
      ...props,
      children: (0, import_jsx_runtime98.jsx)(Component3, {
        ...props,
        ref: forwardedRef,
        children
      })
    });
  }
);
if (true) {
  ComposerAttachFiles.displayName = COMPOSER_ATTACH_FILES_NAME;
  ComposerAttachmentsDropArea.displayName = COMPOSER_ATTACHMENTS_DROP_AREA_NAME;
  ComposerEditor.displayName = COMPOSER_EDITOR_NAME;
  ComposerFloatingToolbar.displayName = COMPOSER_FLOATING_TOOLBAR_NAME;
  ComposerForm.displayName = COMPOSER_FORM_NAME;
  ComposerMention.displayName = COMPOSER_MENTION_NAME;
  ComposerLink.displayName = COMPOSER_LINK_NAME;
  ComposerSubmit.displayName = COMPOSER_SUBMIT_NAME;
  ComposerSuggestions.displayName = COMPOSER_SUGGESTIONS_NAME;
  ComposerSuggestionsList.displayName = COMPOSER_SUGGESTIONS_LIST_NAME;
  ComposerSuggestionsListItem.displayName = COMPOSER_SUGGESTIONS_LIST_ITEM_NAME;
  ComposerMarkToggle.displayName = COMPOSER_MARK_TOGGLE_NAME;
}

// node_modules/@liveblocks/react-ui/dist/primitives/Timestamp.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react62 = __toESM(require_react(), 1);
var DYNAMIC_DATE_THRESHOLD = 3 * 24 * 60 * 60 * 1e3;
var RENDER_INTERVAL2 = 30 * 1e3;
var TIMESTAMP_NAME = "Timestamp";
var relativeUnits = {
  seconds: 60,
  minutes: 60,
  hours: 24,
  days: 7,
  weeks: 4.34524,
  months: 12
};
function formatVerboseDate(date, locale) {
  const formatter = dateTimeFormat(locale, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric"
  });
  return capitalize(formatter.format(date));
}
function formatShortDate(date, locale) {
  const formatter = dateTimeFormat(locale, {
    month: "short",
    day: "numeric"
  });
  return capitalize(formatter.format(date));
}
var localesWithBrokenNarrowRelativeFormatting = [
  "br",
  "fr",
  "nb",
  "nn",
  "no",
  "ro",
  "sv"
];
function formatRelativeDate(date, locale) {
  let resolvedLocale;
  if (locale) {
    resolvedLocale = locale;
  } else {
    const formatter2 = relativeTimeFormat();
    resolvedLocale = formatter2.resolvedOptions().locale;
  }
  const isBrokenWhenNarrow = localesWithBrokenNarrowRelativeFormatting.some(
    (locale2) => resolvedLocale === locale2 || resolvedLocale.startsWith(`${locale2}-`)
  );
  const formatter = relativeTimeFormat(resolvedLocale, {
    style: isBrokenWhenNarrow ? "short" : "narrow",
    numeric: "auto"
  });
  let difference = (date.getTime() - Date.now()) / 1e3;
  if (difference > -relativeUnits.seconds && difference < relativeUnits.seconds) {
    return formatter.format(0, "seconds");
  }
  for (const [unit, length] of Object.entries(relativeUnits)) {
    if (Math.abs(difference) < length) {
      return formatter.format(
        Math.round(difference),
        unit
      );
    }
    difference /= length;
  }
  return capitalize(formatter.format(Math.round(difference), "years"));
}
function formatDynamicDate(date, locale) {
  return Math.abs(date.getTime() - Date.now()) <= DYNAMIC_DATE_THRESHOLD ? formatRelativeDate(date, locale) : formatShortDate(date, locale);
}
var Timestamp = (0, import_react62.forwardRef)(
  ({
    date,
    locale,
    children: renderChildren = formatDynamicDate,
    title: renderTitle = formatVerboseDate,
    dateTime,
    interval = RENDER_INTERVAL2,
    asChild,
    ...props
  }, forwardedRef) => {
    const Component3 = asChild ? Slot : "time";
    const [rerender, key] = useRerender();
    const parsedDate = (0, import_react62.useMemo)(() => new Date(date), [date]);
    const normalizedDate = (0, import_react62.useMemo)(
      () => parsedDate.toISOString(),
      [parsedDate]
    );
    const title = (0, import_react62.useMemo)(
      () => typeof renderTitle === "function" ? renderTitle(parsedDate, locale) : renderTitle,
      [renderTitle, parsedDate, locale, key]
    );
    const children = (0, import_react62.useMemo)(
      () => typeof renderChildren === "function" ? renderChildren(parsedDate, locale) : renderChildren,
      [renderChildren, parsedDate, locale, key]
    );
    useInterval(rerender, interval);
    return (0, import_jsx_runtime99.jsx)(Component3, {
      ...props,
      ref: forwardedRef,
      dateTime: dateTime ?? normalizedDate,
      title,
      children
    });
  }
);
if (true) {
  Timestamp.displayName = TIMESTAMP_NAME;
}

// node_modules/@liveblocks/react-ui/dist/utils/download.js
function download(url, name) {
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  a.style.display = "none";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// node_modules/@liveblocks/react-ui/dist/utils/use-group-mention.js
var import_react63 = __toESM(require_react(), 1);
function useIsGroupMentionMember(mention) {
  const frozenMention = useInitial(mention);
  const frozenUserIds = frozenMention.userIds;
  if (frozenMention.kind !== "group") {
    return false;
  } else if (Array.isArray(frozenUserIds)) {
    const currentId = useCurrentUserId();
    const isMember = (0, import_react63.useMemo)(() => {
      return frozenUserIds.some((userId) => userId === currentId);
    }, [frozenUserIds, currentId]);
    return isMember;
  } else {
    const currentId = useCurrentUserId();
    const { group } = useGroup(frozenMention.id);
    const isMember = (0, import_react63.useMemo)(() => {
      return Boolean(group == null ? void 0 : group.members.some((member) => member.id === currentId));
    }, [group, currentId]);
    return isMember;
  }
}

// node_modules/@liveblocks/react-ui/dist/utils/use-window-focus.js
var import_react64 = __toESM(require_react(), 1);
function subscribe(callback) {
  window.addEventListener("blur", callback);
  window.addEventListener("focus", callback);
  return () => {
    window.removeEventListener("blur", callback);
    window.removeEventListener("focus", callback);
  };
}
function getSnapshot() {
  return document.hasFocus();
}
function getServerSnapshot() {
  return true;
}
function useWindowFocus() {
  return (0, import_react64.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);
}

// node_modules/@liveblocks/react-ui/dist/components/Composer.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react74 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/components/internal/Attachment.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/primitives/FileSize.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/utils/format-file-size.js
var BASE = 1e3;
var UNITS = ["B", "KB", "MB", "GB"];
function formatFileSize(bytes, locale) {
  if (bytes === 0) {
    return `0 ${UNITS[1]}`;
  }
  let unit;
  if (bytes === 0) {
    unit = 1;
  } else {
    unit = Math.max(
      1,
      Math.min(
        Math.floor(Math.log(Math.abs(bytes)) / Math.log(BASE)),
        UNITS.length - 1
      )
    );
  }
  let value = bytes / BASE ** unit;
  let maximumDecimals = 1;
  if (unit === 1) {
    if (value >= 10) {
      maximumDecimals = 0;
    }
    if (value < 0.1 && value > 0) {
      maximumDecimals = 2;
    }
    if (value < 0.01) {
      value = 0.01;
    }
  }
  const formattedUnit = UNITS[unit];
  const formattedValue = numberFormat(locale, {
    minimumFractionDigits: 0,
    maximumFractionDigits: maximumDecimals
  }).format(value);
  return `${formattedValue} ${formattedUnit}`;
}

// node_modules/@liveblocks/react-ui/dist/primitives/FileSize.js
var FILE_SIZE_NAME = "FileSize";
var FileSize = (0, import_react65.forwardRef)(
  ({
    size: size5,
    locale,
    children: renderChildren = formatFileSize,
    asChild,
    ...props
  }, forwardedRef) => {
    const Component3 = asChild ? Slot : "span";
    const children = (0, import_react65.useMemo)(
      () => typeof renderChildren === "function" ? renderChildren(size5, locale) : renderChildren,
      [renderChildren, size5]
    );
    return (0, import_jsx_runtime100.jsx)(Component3, {
      ...props,
      ref: forwardedRef,
      children
    });
  }
);
if (true) {
  FileSize.displayName = FILE_SIZE_NAME;
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Attachment.js
var MAX_DISPLAYED_MEDIA_SIZE = 60 * 1024 * 1024;
var fileExtensionRegex = /^(.+?)(\.[^.]+)?$/;
function splitFileName(name) {
  const match = name.match(fileExtensionRegex);
  return { base: (match == null ? void 0 : match[1]) ?? name, extension: match == null ? void 0 : match[2] };
}
function getAttachmentIconGlyph(mimeType) {
  if (mimeType === "application/zip" || mimeType === "application/gzip" || mimeType === "application/vnd.rar" || mimeType === "application/x-rar-compressed" || mimeType === "application/x-7z-compressed" || mimeType === "application/x-zip-compressed" || mimeType === "application/x-tar" || mimeType === "application/x-bzip" || mimeType === "application/x-bzip2") {
    return (0, import_jsx_runtime101.jsx)("path", {
      d: "M13 15h2v1h-1.5a.5.5 0 0 0 0 1H15v1h-1.5a.5.5 0 0 0 0 1H15v1h-1.5a.5.5 0 0 0 0 1h1a.5.5 0 0 0 .5-.5V20h1.5a.5.5 0 0 0 0-1H15v-1h1.5a.5.5 0 0 0 0-1H15v-1h1.5a.5.5 0 0 0 .5-.5V15a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2Z"
    });
  }
  if (mimeType.startsWith("text/") || mimeType.startsWith("font/") || mimeType.startsWith("application/")) {
    return (0, import_jsx_runtime101.jsx)("path", {
      d: "M10 16a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 0 1h-8a.5.5 0 0 1-.5-.5Z"
    });
  }
  if (mimeType.startsWith("image/")) {
    return (0, import_jsx_runtime101.jsx)("path", {
      d: "M12 16h6a1 1 0 0 1 1 1v3l-1.293-1.293a1 1 0 0 0-1.414 0L14.09 20.91l-.464-.386a1 1 0 0 0-1.265-.013l-1.231.985A.995.995 0 0 1 11 21v-4a1 1 0 0 1 1-1Zm-2 1a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-4Zm3 2a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
    });
  }
  if (mimeType.startsWith("video/")) {
    return (0, import_jsx_runtime101.jsx)("path", {
      d: "M12 15.71a1 1 0 0 1 1.49-.872l4.96 2.79a1 1 0 0 1 0 1.744l-4.96 2.79A1 1 0 0 1 12 21.29v-5.58Z"
    });
  }
  if (mimeType.startsWith("audio/")) {
    return (0, import_jsx_runtime101.jsx)("path", {
      d: "M15 15a.5.5 0 0 0-.5.5v7a.5.5 0 0 0 1 0v-7a.5.5 0 0 0-.5-.5Zm-2.5 2.5a.5.5 0 0 1 1 0v3a.5.5 0 0 1-1 0v-3Zm-2 1a.5.5 0 0 1 1 0v1a.5.5 0 0 1-1 0v-1Zm6-1a.5.5 0 0 1 1 0v3a.5.5 0 0 1-1 0v-3ZM19 16a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 1 0v-5a.5.5 0 0 0-.5-.5Z"
    });
  }
  return null;
}
var AttachmentFileIcon = (0, import_react66.memo)(({ mimeType }) => {
  const iconGlyph = (0, import_react66.useMemo)(() => getAttachmentIconGlyph(mimeType), [mimeType]);
  return (0, import_jsx_runtime101.jsxs)("svg", {
    className: "lb-attachment-icon",
    width: 30,
    height: 30,
    viewBox: "0 0 30 30",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime101.jsx)("path", {
        d: "M6 5a2 2 0 0 1 2-2h5.843a4 4 0 0 1 2.829 1.172l6.156 6.156A4 4 0 0 1 24 13.157V25a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V5Z",
        className: "lb-attachment-icon-shadow"
      }),
      (0, import_jsx_runtime101.jsx)("path", {
        d: "M6 5a2 2 0 0 1 2-2h5.843a4 4 0 0 1 2.829 1.172l6.156 6.156A4 4 0 0 1 24 13.157V25a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V5Z",
        className: "lb-attachment-icon-background"
      }),
      (0, import_jsx_runtime101.jsx)("path", {
        d: "M14.382 3.037a4 4 0 0 1 2.29 1.135l6.156 6.157a4 4 0 0 1 1.136 2.289A2 2 0 0 0 22 11h-4a2 2 0 0 1-2-2V5a2 2 0 0 0-1.618-1.963Z",
        className: "lb-attachment-icon-fold"
      }),
      iconGlyph && (0, import_jsx_runtime101.jsx)("g", {
        className: "lb-attachment-icon-glyph",
        children: iconGlyph
      })
    ]
  });
});
function AttachmentImagePreview({
  attachment,
  markPreviewAsUnsupported,
  roomId
}) {
  const { url } = useRoomAttachmentUrl(attachment.id, roomId);
  const [isLoaded, setLoaded] = (0, import_react66.useState)(false);
  const handleLoad = (0, import_react66.useCallback)(() => {
    setLoaded(true);
  }, []);
  return (0, import_jsx_runtime101.jsxs)(import_jsx_runtime101.Fragment, {
    children: [
      !isLoaded ? (0, import_jsx_runtime101.jsx)(SpinnerIcon, {}) : null,
      url ? (0, import_jsx_runtime101.jsx)("div", {
        className: "lb-attachment-preview-media",
        "data-hidden": !isLoaded ? "" : void 0,
        children: (0, import_jsx_runtime101.jsx)("img", {
          src: url,
          loading: "lazy",
          onLoad: handleLoad,
          onError: markPreviewAsUnsupported
        })
      }) : null
    ]
  });
}
function AttachmentVideoPreview({
  attachment,
  markPreviewAsUnsupported,
  roomId
}) {
  const { url } = useRoomAttachmentUrl(attachment.id, roomId);
  const [isLoaded, setLoaded] = (0, import_react66.useState)(false);
  const handleLoad = (0, import_react66.useCallback)(() => {
    setLoaded(true);
  }, []);
  return (0, import_jsx_runtime101.jsxs)(import_jsx_runtime101.Fragment, {
    children: [
      !isLoaded ? (0, import_jsx_runtime101.jsx)(SpinnerIcon, {}) : null,
      url ? (0, import_jsx_runtime101.jsx)("div", {
        className: "lb-attachment-preview-media",
        "data-hidden": !isLoaded ? "" : void 0,
        children: (0, import_jsx_runtime101.jsx)("video", {
          src: url,
          onLoadedData: handleLoad,
          onError: markPreviewAsUnsupported
        })
      }) : null
    ]
  });
}
function AttachmentPreview({
  attachment,
  allowMediaPreview = true,
  roomId
}) {
  const [isUnsupportedPreview, setUnsupportedPreview] = (0, import_react66.useState)(false);
  const isUploaded = attachment.type === "attachment" || attachment.status === "uploaded";
  function markPreviewAsUnsupported() {
    setUnsupportedPreview(true);
  }
  if (!isUnsupportedPreview && allowMediaPreview && isUploaded && attachment.size <= MAX_DISPLAYED_MEDIA_SIZE) {
    if (attachment.mimeType.startsWith("image/")) {
      return (0, import_jsx_runtime101.jsx)(AttachmentImagePreview, {
        attachment,
        markPreviewAsUnsupported,
        roomId
      });
    }
    if (attachment.mimeType.startsWith("video/")) {
      return (0, import_jsx_runtime101.jsx)(AttachmentVideoPreview, {
        attachment,
        markPreviewAsUnsupported,
        roomId
      });
    }
  }
  return (0, import_jsx_runtime101.jsx)(AttachmentFileIcon, {
    mimeType: attachment.mimeType
  });
}
function AttachmentName({
  attachment
}) {
  const { base: fileBaseName, extension: fileExtension } = (0, import_react66.useMemo)(() => {
    return splitFileName(attachment.name);
  }, [attachment.name]);
  return (0, import_jsx_runtime101.jsxs)("span", {
    className: "lb-attachment-name",
    title: attachment.name,
    children: [
      (0, import_jsx_runtime101.jsx)("span", {
        className: "lb-attachment-name-base",
        children: fileBaseName
      }),
      fileExtension && (0, import_jsx_runtime101.jsx)("span", {
        className: "lb-attachment-name-extension",
        children: fileExtension
      })
    ]
  });
}
function useClickOnKeyDown(onKeyDown) {
  const handleKeyDown = (0, import_react66.useCallback)(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (event.isDefaultPrevented()) {
        return;
      }
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        const clickEvent = new MouseEvent("click", {
          bubbles: true,
          cancelable: true,
          view: window
        });
        event.target.dispatchEvent(clickEvent);
      }
    },
    [onKeyDown]
  );
  return handleKeyDown;
}
function useAttachmentContent(attachment, overrides) {
  const $3 = useOverrides(overrides);
  const composerAttachmentsContext = useComposerAttachmentsContextOrNull();
  const isInComposer = Boolean(composerAttachmentsContext);
  const maxAttachmentSize = composerAttachmentsContext == null ? void 0 : composerAttachmentsContext.maxAttachmentSize;
  const status = attachment.type === "localAttachment" ? attachment.status : void 0;
  const isUploading = status === "uploading";
  const isError = status === "error";
  let description;
  if (attachment.type === "localAttachment" && attachment.status === "error") {
    if (attachment.error instanceof AttachmentTooLargeError) {
      if (attachment.error.origin === "server") {
        description = $3.ATTACHMENT_TOO_LARGE();
      } else {
        description = $3.ATTACHMENT_TOO_LARGE(
          maxAttachmentSize ? formatFileSize(maxAttachmentSize, $3.locale) : void 0
        );
      }
    } else {
      description = $3.ATTACHMENT_ERROR(attachment.error);
    }
  } else {
    description = formatFileSize(attachment.size, $3.locale);
  }
  const deleteLabel = isInComposer ? $3.COMPOSER_REMOVE_ATTACHMENT : $3.COMMENT_DELETE_ATTACHMENT;
  return {
    isUploading,
    isError,
    description,
    deleteLabel
  };
}
function MediaAttachment({
  attachment,
  overrides,
  onClick,
  onDeleteClick,
  preventFocusOnDelete,
  allowMediaPreview = true,
  roomId,
  className,
  onKeyDown,
  ...props
}) {
  const { isUploading, isError, description, deleteLabel } = useAttachmentContent(attachment, overrides);
  const handleDeletePointerDown = (0, import_react66.useCallback)(
    (event) => {
      if (preventFocusOnDelete) {
        event.preventDefault();
      }
    },
    [preventFocusOnDelete]
  );
  const handleKeyDown = useClickOnKeyDown(onKeyDown);
  return (0, import_jsx_runtime101.jsxs)("div", {
    className: cn("lb-attachment lb-media-attachment", className),
    "data-error": isError ? "" : void 0,
    ...props,
    role: onClick ? "button" : void 0,
    onClick,
    tabIndex: onClick ? 0 : -1,
    onKeyDown: onClick ? handleKeyDown : void 0,
    children: [
      (0, import_jsx_runtime101.jsx)("div", {
        className: "lb-attachment-preview",
        children: isUploading ? (0, import_jsx_runtime101.jsx)(SpinnerIcon, {}) : isError ? (0, import_jsx_runtime101.jsx)(WarningIcon, {}) : (0, import_jsx_runtime101.jsx)(AttachmentPreview, {
          attachment,
          allowMediaPreview,
          roomId
        })
      }),
      (0, import_jsx_runtime101.jsxs)("div", {
        className: "lb-attachment-details",
        children: [
          (0, import_jsx_runtime101.jsx)(AttachmentName, {
            attachment
          }),
          (0, import_jsx_runtime101.jsx)("span", {
            className: "lb-attachment-description",
            title: description,
            children: description
          })
        ]
      }),
      onDeleteClick && (0, import_jsx_runtime101.jsx)(Tooltip2, {
        content: deleteLabel,
        children: (0, import_jsx_runtime101.jsx)("button", {
          type: "button",
          className: "lb-attachment-delete",
          onClick: onDeleteClick,
          onPointerDown: handleDeletePointerDown,
          "aria-label": deleteLabel,
          children: (0, import_jsx_runtime101.jsx)(CrossIcon, {})
        })
      })
    ]
  });
}
function FileAttachment({
  attachment,
  overrides,
  onClick,
  onDeleteClick,
  preventFocusOnDelete,
  allowMediaPreview = true,
  roomId,
  className,
  onKeyDown,
  ...props
}) {
  const { isUploading, isError, description, deleteLabel } = useAttachmentContent(attachment, overrides);
  const handleDeletePointerDown = (0, import_react66.useCallback)(
    (event) => {
      if (preventFocusOnDelete) {
        event.preventDefault();
      }
    },
    [preventFocusOnDelete]
  );
  const handleKeyDown = useClickOnKeyDown(onKeyDown);
  return (0, import_jsx_runtime101.jsxs)("div", {
    className: cn("lb-attachment lb-file-attachment", className),
    "data-error": isError ? "" : void 0,
    ...props,
    role: onClick ? "button" : void 0,
    onClick,
    tabIndex: onClick ? 0 : -1,
    onKeyDown: onClick ? handleKeyDown : void 0,
    children: [
      (0, import_jsx_runtime101.jsx)("div", {
        className: "lb-attachment-preview",
        children: isUploading ? (0, import_jsx_runtime101.jsx)(SpinnerIcon, {}) : isError ? (0, import_jsx_runtime101.jsx)(WarningIcon, {}) : (0, import_jsx_runtime101.jsx)(AttachmentPreview, {
          attachment,
          allowMediaPreview,
          roomId
        })
      }),
      (0, import_jsx_runtime101.jsxs)("div", {
        className: "lb-attachment-details",
        children: [
          (0, import_jsx_runtime101.jsx)(AttachmentName, {
            attachment
          }),
          (0, import_jsx_runtime101.jsx)("span", {
            className: "lb-attachment-description",
            title: description,
            children: description
          })
        ]
      }),
      onDeleteClick && (0, import_jsx_runtime101.jsx)(Tooltip2, {
        content: deleteLabel,
        children: (0, import_jsx_runtime101.jsx)("button", {
          type: "button",
          className: "lb-attachment-delete",
          onClick: onDeleteClick,
          onPointerDown: handleDeletePointerDown,
          "aria-label": deleteLabel,
          children: (0, import_jsx_runtime101.jsx)(CrossIcon, {})
        })
      })
    ]
  });
}
function separateMediaAttachments(attachments) {
  const mediaAttachments = [];
  const fileAttachments = [];
  for (const attachment of attachments) {
    if ((attachment.mimeType.startsWith("image/") || attachment.mimeType.startsWith("video/")) && attachment.size <= MAX_DISPLAYED_MEDIA_SIZE) {
      mediaAttachments.push(attachment);
    } else {
      fileAttachments.push(attachment);
    }
  }
  return {
    mediaAttachments,
    fileAttachments
  };
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Attribution.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
function Attribution({ className, ...props }) {
  return (0, import_jsx_runtime102.jsx)("a", {
    href: "https://liveblocks.io",
    target: "_blank",
    rel: "noopener noreferrer",
    className: cn("lb-composer-attribution", className),
    ...props,
    children: (0, import_jsx_runtime102.jsx)("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 384 72",
      "aria-label": "Made with Liveblocks",
      children: (0, import_jsx_runtime102.jsx)("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M86 10h-8v50h8V10Zm16 14h-8v36h8V24Zm0-15h-8v9h8V9Zm13 15h-9l12 36h10l13-36h-9l-9 28-8-28Zm44-1c-11 0-18 8-18 19s7 19 18 19c8 0 15-4 17-13h-8c-1 4-5 6-9 6-6 0-9-3-9-10h27c0-10-6-21-18-21Zm0 7c5 0 9 3 9 8h-18c0-5 4-8 9-8Zm42-7c-4 0-8 2-11 6V10h-8v50h8v-5c3 4 7 6 11 6 11 0 16-9 16-19s-5-19-16-19Zm-2 32c-7 0-9-7-9-13s2-13 9-13 9 7 9 13-2 13-9 13Zm32-45h-8v50h8V10Zm24 51c11 0 18-8 18-19s-8-19-18-19c-11 0-19 8-19 19s7 19 19 19Zm0-6c-8 0-10-7-10-13s2-13 10-13c7 0 9 7 9 13s-2 13-9 13Zm39 6c8 0 15-4 17-12l-8-1c-2 4-4 6-9 6-7 0-9-6-9-12s2-12 9-12c5 0 8 3 8 7l9-1c-2-8-9-13-17-13-11 0-18 9-18 19 0 11 7 19 18 19Zm30-14 4-4 10 17h10l-15-23 15-13h-11l-13 13V10h-9v50h9V47Zm39 14c8 0 16-3 16-12 0-8-8-10-15-11-2-1-7-1-7-5 0-3 3-4 6-4 4 0 7 3 7 7l8-1c-1-9-8-12-15-12s-15 3-15 11 9 10 15 11c3 1 8 2 8 5 0 4-4 5-7 5-5 0-8-3-9-7l-8 1c1 8 9 12 16 12ZM41 27H0l12 12v17l29-29ZM20 60h40L48 48V32L20 60Z",
        fill: "currentColor"
      })
    })
  });
}

// node_modules/@liveblocks/react-ui/dist/components/internal/EmojiPicker.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-popover/dist/index.mjs
var React36 = __toESM(require_react(), 1);
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope2 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope2(__scopePopover);
  const triggerRef = React36.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React36.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return (0, import_jsx_runtime103.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime103.jsx)(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React36.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React36.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React36.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME2 = "PopoverAnchor";
var PopoverAnchor = React36.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME2, __scopePopover);
    const popperScope = usePopperScope2(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React36.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return (0, import_jsx_runtime103.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME2;
var TRIGGER_NAME3 = "PopoverTrigger";
var PopoverTrigger = React36.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME3, __scopePopover);
    const popperScope = usePopperScope2(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger2 = (0, import_jsx_runtime103.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger2 : (0, import_jsx_runtime103.jsx)(Anchor, { asChild: true, ...popperScope, children: trigger2 });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME3;
var PORTAL_NAME5 = "PopoverPortal";
var [PortalProvider3, usePortalContext3] = createPopoverContext(PORTAL_NAME5, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME5, __scopePopover);
  return (0, import_jsx_runtime103.jsx)(PortalProvider3, { scope: __scopePopover, forceMount, children: (0, import_jsx_runtime103.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime103.jsx)(Portal, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME5;
var CONTENT_NAME4 = "PopoverContent";
var PopoverContent = React36.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME4, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME4, props.__scopePopover);
    return (0, import_jsx_runtime103.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime103.jsx)(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime103.jsx)(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME4;
var Slot3 = createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = React36.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME4, props.__scopePopover);
    const contentRef = React36.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React36.useRef(false);
    React36.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime103.jsx)(Combination_default, { as: Slot3, allowPinchZoom: true, children: (0, import_jsx_runtime103.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a3;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a3 = context.triggerRef.current) == null ? void 0 : _a3.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React36.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME4, props.__scopePopover);
    const hasInteractedOutsideRef = React36.useRef(false);
    const hasPointerDownOutsideRef = React36.useRef(false);
    return (0, import_jsx_runtime103.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a3, _b;
          (_a3 = props.onCloseAutoFocus) == null ? void 0 : _a3.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a3, _b;
          (_a3 = props.onInteractOutside) == null ? void 0 : _a3.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React36.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME4, __scopePopover);
    const popperScope = usePopperScope2(__scopePopover);
    useFocusGuards();
    return (0, import_jsx_runtime103.jsx)(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: (0, import_jsx_runtime103.jsx)(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: (0, import_jsx_runtime103.jsx)(
              Content,
              {
                "data-state": getState2(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME2 = "PopoverClose";
var PopoverClose = React36.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME2, __scopePopover);
    return (0, import_jsx_runtime103.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME2;
var ARROW_NAME3 = "PopoverArrow";
var PopoverArrow = React36.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope2(__scopePopover);
    return (0, import_jsx_runtime103.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME3;
function getState2(open) {
  return open ? "open" : "closed";
}
var Root22 = Popover;
var Portal5 = PopoverPortal;
var Content22 = PopoverContent;

// node_modules/frimousse/dist/index.js
var import_react67 = __toESM(require_react());
var import_react68 = __toESM(require_react());
var import_react69 = __toESM(require_react());
var import_jsx_runtime104 = __toESM(require_jsx_runtime());
var import_react70 = __toESM(require_react());
var import_react71 = __toESM(require_react());
var import_jsx_runtime105 = __toESM(require_jsx_runtime());
var ct = Object.defineProperty;
var ut = (e3, t3) => {
  for (var o3 in t3) ct(e3, o3, { get: t3[o3], enumerable: true });
};
var at = {};
ut(at, { ActiveEmoji: () => it, Empty: () => nt, List: () => tt, Loading: () => rt, Root: () => Je, Search: () => qe, SkinTone: () => st, SkinToneSelector: () => ot, Viewport: () => Ge });
var q = "'Apple Color Emoji', 'Noto Color Emoji', 'Twemoji Mozilla', 'Android Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', EmojiSymbols, sans-serif";
var O = ["none", "light", "medium-light", "medium", "medium-dark", "dark"];
function G2(e3) {
  return e3.charAt(0).toUpperCase() + e3.slice(1);
}
var $2 = 2;
var x = null;
function ie(e3) {
  try {
    x ?? (x = document.createElement("canvas").getContext("2d", { willReadFrequently: true }));
  } catch {
  }
  if (!x || (queueMicrotask(() => {
    x && (x = null);
  }), x.canvas.width = $2, x.canvas.height = $2, x.font = `2px ${q}`, x.textBaseline = "middle", x.measureText(e3).width >= $2 * 2)) return false;
  x.fillStyle = "#00f", x.fillText(e3, 0, 0);
  let t3 = x.getImageData(0, 0, $2, $2).data;
  x.clearRect(0, 0, $2, $2), x.fillStyle = "#f00", x.fillText(e3, 0, 0);
  let o3 = x.getImageData(0, 0, $2, $2).data;
  for (let r2 = 0; r2 < $2 * $2 * 4; r2 += 4) if (t3[r2] !== o3[r2] || t3[r2 + 1] !== o3[r2 + 1] || t3[r2 + 2] !== o3[r2 + 2]) return false;
  return true;
}
function se(e3, t3, o3) {
  try {
    let r2 = e3.getItem(t3);
    if (!r2) throw new Error(`No value found for "${t3}".`);
    let n3 = JSON.parse(r2);
    return o3(n3);
  } catch {
    return null;
  }
}
function ae(e3, t3, o3) {
  e3.setItem(t3, JSON.stringify(o3));
}
function ce2(e3) {
  return (t3) => t3 === void 0 ? void 0 : e3(t3);
}
function ue2(e3) {
  return (t3) => t3 === null ? null : e3(t3);
}
function v(e3) {
  if (typeof e3 != "string") throw new Error();
  return e3;
}
function _(e3) {
  if (typeof e3 != "number") throw new Error();
  return e3;
}
function le2(e3) {
  if (typeof e3 != "boolean") throw new Error();
  return e3;
}
function F(e3) {
  return (t3) => {
    if (typeof t3 != "object" || t3 === null) throw new Error();
    let o3 = {};
    for (let r2 in e3) {
      let n3 = t3[r2];
      n3 === void 0 && e3[r2](void 0), o3[r2] = e3[r2](n3);
    }
    return o3;
  };
}
function Z2(e3) {
  return (t3) => {
    if (!Array.isArray(t3)) throw new Error();
    return t3.length > 0 && e3(t3[0]), t3;
  };
}
var ke2 = (e3, t3) => `${e3}/${t3}/data.json`;
var we2 = (e3, t3) => `${e3}/${t3}/messages.json`;
var mt = ["bn", "da", "de", "en-gb", "en", "es-mx", "es", "et", "fi", "fr", "hi", "hu", "it", "ja", "ko", "lt", "ms", "nb", "nl", "pl", "pt", "ru", "sv", "th", "uk", "vi", "zh-hant", "zh"];
var pe2 = "en";
var ye2 = (e3) => `frimousse/data/${e3}`;
var Ee2 = "frimousse/metadata";
async function he2(e3, t3) {
  try {
    return (await fetch(e3, { method: "HEAD", signal: t3 })).headers.get("etag");
  } catch {
    return null;
  }
}
async function dt(e3, t3, o3) {
  let [{ emojis: r2, emojisEtag: n3 }, { messages: s, messagesEtag: a }] = await Promise.all([fetch(ke2(e3, t3), { signal: o3 }).then(async (i) => ({ emojis: await i.json(), emojisEtag: i.headers.get("etag") })), fetch(we2(e3, t3), { signal: o3 }).then(async (i) => ({ messages: await i.json(), messagesEtag: i.headers.get("etag") }))]);
  return { emojis: r2, messages: s, emojisEtag: n3, messagesEtag: a };
}
async function ft(e3, t3, o3) {
  let [r2, n3] = await Promise.all([he2(ke2(e3, t3), o3), he2(we2(e3, t3), o3)]);
  return { emojisEtag: r2, messagesEtag: n3 };
}
function gt(e3) {
  return e3.skins ? e3.skins.filter((o3) => typeof o3.tone == "number").reduce((o3, r2) => {
    let n3 = O[r2.tone];
    return o3[n3] = r2.emoji, o3;
  }, {}) : void 0;
}
async function je(e3, t3, o3) {
  let { emojis: r2, emojisEtag: n3, messages: s, messagesEtag: a } = await dt(e3, t3, o3), i = s.subgroups.find((l2) => l2.key === "country-flag" || l2.key === "subdivision-flag"), m2 = s.groups.filter((l2) => l2.key !== "component"), c = r2.filter((l2) => "group" in l2), f = m2.map((l2) => ({ index: l2.order, label: G2(l2.message) })), u2 = s.skinTones.reduce((l2, j) => (l2[j.key] = G2(j.message), l2), {}), h = c.map((l2) => ({ emoji: l2.emoji, category: l2.group, version: l2.version, label: G2(l2.label), tags: l2.tags ?? [], countryFlag: i && l2.subgroup === i.order || void 0, skins: gt(l2) })), d = { locale: t3, emojis: h, categories: f, skinTones: u2 };
  return ae(localStorage, ye2(t3), { data: d, metadata: { emojisEtag: n3, messagesEtag: a } }), d;
}
function pt(e3, t3) {
  let o3 = /* @__PURE__ */ new Map();
  for (let a of e3) o3.has(a.version) || o3.set(a.version, a.emoji);
  let r2 = [...o3.keys()].sort((a, i) => i - a), n3 = r2[0] ?? 0, s = ie("🇪🇺");
  if (typeof t3 == "number") return { emojiVersion: t3, countryFlags: s };
  for (let a of r2) {
    let i = o3.get(a);
    if (ie(i)) return { emojiVersion: a, countryFlags: s };
  }
  return { emojiVersion: n3, countryFlags: s };
}
var Et = F({ emojiVersion: _, countryFlags: le2 });
var ht = F({ data: F({ locale: v, emojis: Z2(F({ emoji: v, category: _, label: v, version: _, tags: Z2(v), countryFlag: ce2(le2), skins: ce2(F({ light: v, "medium-light": v, medium: v, "medium-dark": v, dark: v })) })), categories: Z2(F({ index: _, label: v })), skinTones: F({ light: v, "medium-light": v, medium: v, "medium-dark": v, dark: v }) }), metadata: F({ emojisEtag: ue2(v), messagesEtag: ue2(v) }) });
async function Se2({ locale: e3, emojiVersion: t3, emojibaseUrl: o3, signal: r2 }) {
  let n3 = typeof o3 == "string" ? o3 : `https://cdn.jsdelivr.net/npm/emojibase-data@${typeof t3 == "number" ? Math.floor(t3) : "latest"}`, s = se(sessionStorage, Ee2, Et), a = se(localStorage, ye2(e3), ht), i;
  if (!a) i = await je(n3, e3, r2);
  else if (s) i = a.data;
  else try {
    let { emojisEtag: c, messagesEtag: f } = await ft(n3, e3, r2);
    i = !c || !f || c !== a.metadata.emojisEtag || f !== a.metadata.messagesEtag ? await je(n3, e3, r2) : a.data;
  } catch {
    i = a.data;
  }
  s ?? (s = pt(i.emojis, t3)), ae(sessionStorage, Ee2, s);
  let m2 = i.emojis.filter((c) => {
    let f = c.version <= s.emojiVersion;
    return c.countryFlag ? f && s.countryFlags : f;
  });
  return { locale: e3, emojis: m2, categories: i.categories, skinTones: i.skinTones };
}
function me2(e3) {
  return mt.includes(e3) ? e3 : (console.warn(`Locale "${e3}" is not supported, using "${pe2}" instead.`), pe2);
}
function de2(e3) {
  return O.includes(e3) ? e3 : (console.warn(`Skin tone "${e3}" is not valid, using "none" instead.`), "none");
}
function ve2(e3, t3) {
  let o3 = [];
  if (t3 <= 0) return o3;
  for (let r2 = 0, n3 = e3.length; r2 < n3; r2 += t3) o3.push(e3.slice(r2, r2 + t3));
  return o3;
}
function jt(e3, t3) {
  if (!t3) return e3;
  let o3 = t3.toLowerCase().trim(), r2 = /* @__PURE__ */ new WeakMap();
  return e3.filter((n3) => {
    let s = 0;
    n3.label.toLowerCase().includes(o3) && (s += 10);
    for (let a of n3.tags) a.toLowerCase().includes(o3) && (s += 1);
    return s > 0 ? (r2.set(n3, s), true) : false;
  }).sort((n3, s) => (r2.get(s) ?? 0) - (r2.get(n3) ?? 0));
}
function Pe2(e3, t3, o3, r2) {
  let n3 = jt(e3.emojis, r2), s = [], a = [], i = [], m2 = {}, c = 0, f = 0;
  for (let u2 of n3) m2[u2.category] || (m2[u2.category] = []), m2[u2.category].push({ emoji: o3 && o3 !== "none" && u2.skins ? u2.skins[o3] : u2.emoji, label: u2.label });
  for (let u2 of e3.categories) {
    let h = m2[u2.index];
    if (!h || h.length === 0) continue;
    let d = ve2(Array.from(h), t3).map((l2) => ({ categoryIndex: c, emojis: l2 }));
    s.push(...d), a.push({ label: u2.label, rowsCount: d.length, startRowIndex: f }), i.push(f), c++, f += d.length;
  }
  return { count: n3.length, categories: a, categoriesStartRowIndices: i, rows: s, skinTones: e3.skinTones };
}
function Te2(e3) {
  let t3 = {}, o3 = null, r2 = null, n3 = /* @__PURE__ */ new Set(), s = () => {
    if (o3) {
      t3 = o3, o3 = null;
      for (let c of n3) c(t3);
    }
    r2 = null;
  }, a = () => o3 ?? t3, i = (c) => {
    o3 ?? (o3 = t3), Object.assign(o3, typeof c == "function" ? c(a()) : c), r2 || (r2 = requestAnimationFrame(s));
  }, m2 = (c) => (n3.add(c), () => n3.delete(c));
  return t3 = e3(i, a), { get: a, set: i, subscribe: m2 };
}
function xe2(e3) {
  let [t3] = (0, import_react69.useState)(e3);
  return t3;
}
function Ce2(e3) {
  let t3 = (0, import_react69.createContext)(null);
  return { useStore: () => {
    let n3 = (0, import_react69.useContext)(t3);
    if (!n3) throw new Error(e3);
    return n3;
  }, Provider: ({ store: n3, children: s }) => (0, import_jsx_runtime104.jsx)(t3.Provider, { value: n3, children: s }) };
}
function L2(e3, t3, o3 = Object.is) {
  let [r2, n3] = (0, import_react69.useState)(() => t3(e3.get()));
  return (0, import_react69.useEffect)(() => e3.subscribe(() => {
    let s = t3(e3.get());
    n3((a) => o3(a, s) ? a : s);
  }), [e3, t3, o3]), (0, import_react69.useDebugValue)(r2), r2;
}
function M(e3, t3, o3) {
  let r2 = (0, import_react69.useCallback)((n3) => n3[t3], [t3]);
  return L2(e3, r2, o3);
}
var Re2 = 2;
function Le(e3, t3, o3, r2) {
  let n3 = 0;
  return Te2((s, a) => ({ locale: t3, columns: o3, skinTone: r2, onEmojiSelect: e3, data: null, search: "", interaction: "none", activeColumnIndex: 0, activeRowIndex: 0, rowHeight: null, categoryHeaderHeight: null, viewportWidth: null, viewportHeight: null, viewportCurrentCategoryIndex: null, viewportStartCategoryIndex: 0, viewportStartRowIndex: 0, viewportEndRowIndex: 0, rootRef: null, searchRef: null, viewportRef: null, listRef: null, updateViewportState: (i) => {
    var _a3;
    let m2 = a(), c = (i == null ? void 0 : i.data) ?? m2.data, f = (i == null ? void 0 : i.categoryHeaderHeight) ?? m2.categoryHeaderHeight, u2 = (i == null ? void 0 : i.rowHeight) ?? m2.rowHeight, h = (i == null ? void 0 : i.viewportHeight) ?? m2.viewportHeight;
    if (!c || c.rows.length === 0 || !f || !u2 || !h) return s({ ...i, viewportStartCategoryIndex: 0, viewportStartRowIndex: 0, viewportEndRowIndex: 0 });
    let d = 0, l2 = 0;
    for (let R of c.categories) if (l2++ * f + R.startRowIndex * u2 < n3) d += f;
    else break;
    let j = c.categories.length * f + c.rows.length * u2, g = Math.floor(Re2 * u2 / 2), w = Math.ceil(Re2 * u2 / 2), P2 = Math.min(n3 - d - g, j - h), T2 = P2 + h + w, p2 = Math.max(0, Math.floor(P2 / u2)), y = Math.min(c.rows.length - 1, Math.ceil(T2 / u2)), S = (_a3 = c.rows[p2]) == null ? void 0 : _a3.categoryIndex;
    return s(S === void 0 && i ? i : { ...i, viewportStartCategoryIndex: S, viewportStartRowIndex: p2, viewportEndRowIndex: y });
  }, onDataChange: (i) => {
    a().updateViewportState({ data: i, activeColumnIndex: 0, activeRowIndex: 0 });
  }, onSearchChange: (i) => {
    s({ search: i, interaction: i ? "keyboard" : "none" });
  }, onActiveEmojiChange: (i, m2, c) => {
    if (s({ interaction: i, activeColumnIndex: m2, activeRowIndex: c }), i !== "keyboard") return;
    let { listRef: f, viewportRef: u2, rowHeight: h, viewportHeight: d, categoryHeaderHeight: l2 } = a(), j = f == null ? void 0 : f.current, g = u2 == null ? void 0 : u2.current;
    if (!j || !g || !h || !l2 || !d) return;
    let w = c;
    w === 0 && g.scrollTo({ top: 0, behavior: "instant" });
    let P2 = j.querySelector(`[aria-rowindex="${w}"]`);
    if (!(P2 instanceof HTMLElement)) return;
    let T2 = P2.offsetTop, p2 = getComputedStyle(P2), y = Number.parseFloat(p2.scrollMarginTop), S = Number.parseFloat(p2.scrollMarginBottom), R = n3 + y;
    T2 < n3 + d / 2 && (R += l2);
    let A = R + d - S;
    (T2 < R || T2 + h > A) && g.scrollTo({ top: Math.max(T2 < R + l2 ? T2 - Math.max(l2, y) : T2 - d + h + S, 0), behavior: "instant" });
  }, onActiveEmojiReset: () => {
    s({ interaction: "none", activeColumnIndex: 0, activeRowIndex: 0 });
  }, onRowHeightChange: (i) => {
    a().updateViewportState({ rowHeight: i });
  }, onCategoryHeaderHeightChange: (i) => {
    a().updateViewportState({ categoryHeaderHeight: i });
  }, onViewportSizeChange: (i, m2) => {
    a().updateViewportState({ viewportWidth: i, viewportHeight: m2 });
  }, onViewportScroll: (i) => {
    n3 = i, a().updateViewportState();
  } }));
}
var { useStore: C, Provider: He } = Ce2("EmojiPicker.Root is missing.");
function Ie2(e3) {
  return e3.search;
}
function N2(e3) {
  var _a3, _b;
  return e3.interaction === "none" ? void 0 : (_b = (_a3 = e3.data) == null ? void 0 : _a3.rows[e3.activeRowIndex]) == null ? void 0 : _b.emojis[e3.activeColumnIndex];
}
function De2(e3) {
  var _a3;
  return e3.data === void 0 || typeof ((_a3 = e3.data) == null ? void 0 : _a3.count) == "number" && e3.data.count === 0;
}
function Ae(e3) {
  return e3.data === null || e3.viewportHeight === null || e3.rowHeight === null || e3.categoryHeaderHeight === null;
}
function fe2(e3) {
  var _a3;
  return (_a3 = e3.data) == null ? void 0 : _a3.rows.length;
}
function $e(e3) {
  var _a3;
  return (_a3 = e3.data) == null ? void 0 : _a3.categories.length;
}
function Me2(e3) {
  var _a3;
  return (_a3 = e3.data) == null ? void 0 : _a3.categoriesStartRowIndices;
}
function Fe(e3) {
  var _a3;
  return (_a3 = e3.data) == null ? void 0 : _a3.skinTones;
}
function ge(e3, t3) {
  return (e3 == null ? void 0 : e3.emoji) === (t3 == null ? void 0 : t3.emoji);
}
function Ve(e3, t3) {
  return (e3 == null ? void 0 : e3.categoryIndex) !== (t3 == null ? void 0 : t3.categoryIndex) || (e3 == null ? void 0 : e3.emojis.length) !== (t3 == null ? void 0 : t3.emojis.length) ? false : !!(e3 == null ? void 0 : e3.emojis.every((o3, r2) => ge(o3, t3 == null ? void 0 : t3.emojis[r2])));
}
var W2 = "‍";
var Oe = new RegExp("\\p{Emoji_Modifier_Base}", "u");
var bt = /\uFE0F$/;
var Tt = /\u{1F3FB}|\u{1F3FC}|\u{1F3FD}|\u{1F3FE}|\u{1F3FF}/gu;
var xt = { light: "🏻", "medium-light": "🏼", medium: "🏽", "medium-dark": "🏾", dark: "🏿" };
function Ct(e3, t3) {
  if (!e3.split(W2).some((r2) => Oe.test(r2))) return e3;
  let o3 = e3.split(W2).map((r2) => r2.replace(Tt, "")).join(W2);
  return t3 === "none" ? o3 : o3.split(W2).map((r2, n3, s) => {
    let a = s.length > 1;
    return !Oe.test(r2) || a && r2 === "🤝" ? r2 : r2.replace(bt, "") + xt[t3];
  }).join(W2);
}
function _e2(e3) {
  return O.map((t3) => ({ skinTone: t3, emoji: Ct(e3, t3) }));
}
function X2() {
  let e3 = C(), t3 = L2(e3, N2, ge);
  return (0, import_react68.useDeferredValue)(t3);
}
function Q(e3 = "✋") {
  let t3 = C(), o3 = M(t3, "skinTone"), r2 = (0, import_react68.useMemo)(() => _e2(e3), [e3]), n3 = (0, import_react68.useCallback)((s) => {
    t3.set({ skinTone: s });
  }, []);
  return [o3, n3, r2];
}
function ee2(e3, t3) {
  if (Object.is(e3, t3)) return true;
  if (typeof e3 != "object" || typeof t3 != "object" || e3 === null || t3 === null || Array.isArray(e3) !== Array.isArray(t3)) return false;
  let o3 = Object.keys(e3), r2 = Object.keys(t3);
  return o3.length !== r2.length ? false : o3.every((n3) => n3 in t3 && e3[n3] === t3[n3]);
}
function Ne(...e3) {
}
function We(e3, t3) {
  let o3 = null;
  if (typeof window.requestIdleCallback == "function") o3 = window.requestIdleCallback(e3, t3);
  else {
    let r2 = Date.now();
    o3 = window.setTimeout(() => {
      e3({ didTimeout: false, timeRemaining: () => Math.max(0, ((t3 == null ? void 0 : t3.timeout) ?? 50) - (Date.now() - r2)) });
    }, 10);
  }
  return () => {
    typeof window.cancelIdleCallback == "function" ? window.cancelIdleCallback(o3) : window.clearTimeout(o3);
  };
}
var I = typeof window < "u" ? import_react70.useLayoutEffect : import_react70.useEffect;
function Be(e3) {
  let t3 = (0, import_react71.useRef)(e3);
  return I(() => {
    t3.current = e3;
  }), (0, import_react71.useCallback)((...o3) => t3.current(...o3), []);
}
function Ft({ emojiVersion: e3, emojibaseUrl: t3 }) {
  let [o3, r2] = (0, import_react67.useState)(void 0), n3 = C(), s = M(n3, "locale"), a = M(n3, "columns"), i = M(n3, "skinTone"), m2 = M(n3, "search");
  return (0, import_react67.useEffect)(() => {
    let c = new AbortController(), f = c.signal;
    return Se2({ locale: s, emojiVersion: e3, emojibaseUrl: t3, signal: f }).then((u2) => {
      r2(u2);
    }).catch((u2) => {
      f.aborted || console.error(u2);
    }), () => {
      c.abort();
    };
  }, [e3, t3, s]), (0, import_react67.useEffect)(() => {
    if (o3) return We(() => {
      n3.get().onDataChange(Pe2(o3, a, i, m2));
    }, { timeout: 100 });
  }, [o3, a, i, m2]), null;
}
var Je = (0, import_react67.forwardRef)(({ locale: e3 = "en", columns: t3 = 9, skinTone: o3 = "none", onEmojiSelect: r2 = Ne, emojiVersion: n3, emojibaseUrl: s, onFocusCapture: a, onBlurCapture: i, children: m2, style: c, ...f }, u2) => {
  let h = Be(r2), d = xe2(() => Le(h, me2(e3), t3, de2(o3))), [l2, j] = (0, import_react67.useState)(false), g = (0, import_react67.useRef)(null), w = (0, import_react67.useCallback)((p2) => {
    p2 && (g.current = p2, d.set({ rootRef: g }));
  }, []);
  I(() => {
    d.set({ locale: me2(e3) });
  }, [e3]), I(() => {
    d.set({ columns: t3 });
  }, [t3]), I(() => {
    d.set({ skinTone: de2(o3) });
  }, [o3]);
  let P2 = (0, import_react67.useCallback)((p2) => {
    a == null ? void 0 : a(p2);
    let { searchRef: y, viewportRef: S } = d.get(), R = p2.target === (y == null ? void 0 : y.current) || p2.target.hasAttribute("frimousse-search"), A = p2.target === (S == null ? void 0 : S.current) || p2.target.hasAttribute("frimousse-viewport");
    p2.isDefaultPrevented() || (j(R || A), p2.isDefaultPrevented() || (j(R || A), A ? d.get().onActiveEmojiChange("keyboard", 0, 0) : R && d.get().search === "" && d.set({ interaction: "none" })));
  }, [a]), T2 = (0, import_react67.useCallback)((p2) => {
    i == null ? void 0 : i(p2), !p2.isDefaultPrevented() && !p2.currentTarget.contains(p2.relatedTarget) && j(false);
  }, [i]);
  return I(() => {
    l2 || d.get().onActiveEmojiReset();
  }, [l2]), (0, import_react67.useImperativeHandle)(u2, () => g.current), (0, import_react67.useEffect)(() => {
    if (!l2) return;
    function p2(y) {
      if (y.defaultPrevented || !y.key.startsWith("Arrow") && y.key !== "Enter") return;
      let { data: S, onEmojiSelect: R, onActiveEmojiChange: A, interaction: U2, activeColumnIndex: Y3, activeRowIndex: J2 } = d.get();
      if (y.key === "Enter") {
        let b = N2(d.get());
        b && (y.preventDefault(), R(b));
      }
      if (y.key.startsWith("Arrow")) {
        let b = Y3, k3 = J2;
        if (y.preventDefault(), U2 !== "none") {
          if ((S == null ? void 0 : S.rows) && S.rows.length > 0) switch (y.key) {
            case "ArrowLeft": {
              if (b === 0) {
                let H2 = k3 - 1, ne = S.rows[H2];
                ne && (k3 = H2, b = ne.emojis.length - 1);
              } else b -= 1;
              break;
            }
            case "ArrowRight": {
              if (b === S.rows[k3].emojis.length - 1) {
                let H2 = k3 + 1;
                S.rows[H2] && (k3 = H2, b = 0);
              } else b += 1;
              break;
            }
            case "ArrowUp": {
              let H2 = S.rows[k3 - 1];
              H2 && (k3 -= 1, H2.emojis[b] || (b = H2.emojis.length - 1));
              break;
            }
            case "ArrowDown": {
              let H2 = S.rows[k3 + 1];
              H2 && (k3 += 1, H2.emojis[b] || (b = H2.emojis.length - 1));
              break;
            }
          }
          A("keyboard", b, k3);
        } else A("keyboard", 0, 0);
      }
    }
    return document.addEventListener("keydown", p2), () => {
      document.removeEventListener("keydown", p2);
    };
  }, [l2]), I(() => {
    let p2 = null, y = null, S = null, R = null, A = d.subscribe((k3) => {
      g.current && (p2 !== k3.viewportWidth && (p2 = k3.viewportWidth, g.current.style.setProperty("--frimousse-viewport-width", `${k3.viewportWidth}px`)), y !== k3.viewportHeight && (y = k3.viewportHeight, g.current.style.setProperty("--frimousse-viewport-height", `${k3.viewportHeight}px`)), S !== k3.rowHeight && (S = k3.rowHeight, g.current.style.setProperty("--frimousse-row-height", `${k3.rowHeight}px`)), R !== k3.categoryHeaderHeight && (R = k3.categoryHeaderHeight, g.current.style.setProperty("--frimousse-category-header-height", `${k3.categoryHeaderHeight}px`)));
    }), { viewportWidth: U2, viewportHeight: Y3, rowHeight: J2, categoryHeaderHeight: b } = d.get();
    return U2 && g.current.style.setProperty("--frimousse-viewport-width", `${U2}px`), Y3 && g.current.style.setProperty("--frimousse-viewport-height", `${Y3}px`), J2 && g.current.style.setProperty("--frimousse-row-height", `${J2}px`), b && g.current.style.setProperty("--frimousse-category-header-height", `${b}px`), A;
  }, []), (0, import_jsx_runtime105.jsx)("div", { "data-focused": l2 ? "" : void 0, "frimousse-root": "", onBlurCapture: T2, onFocusCapture: P2, ...f, ref: w, style: { "--frimousse-emoji-font": q, ...c }, children: (0, import_jsx_runtime105.jsxs)(He, { store: d, children: [(0, import_jsx_runtime105.jsx)(Ft, { emojiVersion: n3, emojibaseUrl: s }), m2] }) });
});
var qe = (0, import_react67.forwardRef)(({ value: e3, defaultValue: t3, onChange: o3, ...r2 }, n3) => {
  let s = C(), a = (0, import_react67.useRef)(null), i = (0, import_react67.useCallback)((u2) => {
    u2 && (a.current = u2, s.set({ searchRef: a }));
  }, []), m2 = typeof e3 == "string", c = (0, import_react67.useRef)(m2);
  (0, import_react67.useEffect)(() => {
    c.current !== m2 && console.warn(`EmojiPicker.Search is changing from ${c ? "controlled" : "uncontrolled"} to ${m2 ? "controlled" : "uncontrolled"}.`), c.current = m2;
  }, [m2]), I(() => {
    s.set({ search: typeof e3 == "string" ? e3 : typeof t3 == "string" ? t3 : "" });
  }, []), I(() => {
    typeof e3 == "string" && s.get().onSearchChange(e3);
  }, [e3]);
  let f = (0, import_react67.useCallback)((u2) => {
    o3 == null ? void 0 : o3(u2), u2.isDefaultPrevented() || s.get().onSearchChange(u2.target.value);
  }, [o3]);
  return (0, import_react67.useImperativeHandle)(n3, () => a.current), (0, import_jsx_runtime105.jsx)("input", { autoCapitalize: "off", autoComplete: "off", autoCorrect: "off", enterKeyHint: "done", "frimousse-search": "", placeholder: "Search…", spellCheck: false, type: "search", ...r2, defaultValue: t3, onChange: f, ref: i, value: e3 });
});
var Vt = (0, import_react67.memo)(() => {
  let e3 = X2();
  return e3 ? (0, import_jsx_runtime105.jsx)("div", { "aria-live": "polite", style: { border: 0, clip: "rect(0, 0, 0, 0)", height: 1, margin: -1, overflow: "hidden", padding: 0, position: "absolute", whiteSpace: "nowrap", width: 1, wordWrap: "normal" }, children: e3.label }) : null;
});
var Ge = (0, import_react67.forwardRef)(({ children: e3, onScroll: t3, onKeyDown: o3, style: r2, ...n3 }, s) => {
  let a = C(), i = (0, import_react67.useRef)(null), m2 = (0, import_react67.useCallback)((h) => {
    h && (i.current = h, a.set({ viewportRef: i }));
  }, []), c = L2(a, fe2), f = L2(a, $e), u2 = (0, import_react67.useCallback)((h) => {
    t3 == null ? void 0 : t3(h), a.get().onViewportScroll(h.currentTarget.scrollTop);
  }, [t3]);
  return I(() => {
    if (!i.current) return;
    let h = new ResizeObserver(([d]) => {
      var _a3, _b;
      let l2 = ((_a3 = d == null ? void 0 : d.borderBoxSize[0]) == null ? void 0 : _a3.inlineSize) ?? 0, j = ((_b = d == null ? void 0 : d.borderBoxSize[0]) == null ? void 0 : _b.blockSize) ?? 0, { onViewportSizeChange: g, viewportHeight: w, viewportWidth: P2 } = a.get();
      (w !== j || P2 !== l2) && g(l2, j);
    });
    return h.observe(i.current), a.get().onViewportSizeChange(i.current.offsetWidth, i.current.clientHeight), () => {
      h.disconnect();
    };
  }, []), (0, import_react67.useImperativeHandle)(s, () => i.current), (0, import_jsx_runtime105.jsxs)("div", { "frimousse-viewport": "", ...n3, onScroll: u2, ref: m2, style: { position: "relative", boxSizing: "border-box", contain: "layout paint", containIntrinsicSize: typeof c == "number" && typeof f == "number" ? `var(--frimousse-viewport-width, auto) calc(${c} * var(--frimousse-row-height) + ${f} * var(--frimousse-category-header-height))` : void 0, overflowY: "auto", overscrollBehavior: "contain", scrollbarGutter: "stable", willChange: "scroll-position", ...r2 }, children: [(0, import_jsx_runtime105.jsx)(Vt, {}), e3] });
});
function Ze(e3, t3, o3) {
  return { emoji: { ...e3, isActive: o3 }, role: "gridcell", "aria-colindex": t3, "aria-selected": o3 || void 0, "aria-label": e3.label, "data-active": o3 ? "" : void 0, "frimousse-emoji": "", style: { fontFamily: "var(--frimousse-emoji-font)" }, tabIndex: -1 };
}
function Xe(e3, t3 = false) {
  return { role: t3 ? void 0 : "row", "aria-rowindex": t3 ? void 0 : e3, "frimousse-row": "", style: { contain: t3 ? void 0 : "content", height: t3 ? void 0 : "var(--frimousse-row-height)", display: "flex" } };
}
function Qe(e3, t3) {
  return { "frimousse-category": "", style: { contain: "content", top: t3 ? `calc(${e3} * var(--frimousse-category-header-height) + ${t3.startRowIndex} * var(--frimousse-row-height))` : void 0, height: t3 ? `calc(var(--frimousse-category-header-height) + ${t3.rowsCount} * var(--frimousse-row-height))` : void 0, width: "100%", pointerEvents: "none", position: "absolute" } };
}
function et(e3, t3 = false) {
  return { category: e3, "frimousse-category-header": "", style: { contain: t3 ? void 0 : "layout paint", height: t3 ? void 0 : "var(--frimousse-category-header-height)", pointerEvents: "auto", position: "sticky", top: 0 } };
}
function ze(e3, t3, o3, r2) {
  return { "frimousse-list-sizer": "", style: { position: "relative", boxSizing: "border-box", height: `calc(${e3} * var(--frimousse-row-height) + ${t3} * var(--frimousse-category-header-height))`, paddingTop: `calc(${o3} * var(--frimousse-row-height) + ${r2} * var(--frimousse-category-header-height))` } };
}
function Ke(e3, t3, o3) {
  return { "aria-colcount": e3, "aria-rowcount": t3, "frimousse-list": "", style: { "--frimousse-list-columns": e3, ...o3 }, role: "grid" };
}
function Ot(e3) {
  e3.preventDefault();
}
var _t = (0, import_react67.memo)(({ Emoji: e3, emoji: t3, columnIndex: o3, rowIndex: r2 }) => {
  let n3 = C(), s = L2(n3, (c) => {
    var _a3;
    return ((_a3 = N2(c)) == null ? void 0 : _a3.emoji) === t3.emoji;
  }), a = (0, import_react67.useCallback)(() => {
    n3.get().onEmojiSelect(t3);
  }, [t3]), i = (0, import_react67.useCallback)(() => {
    n3.get().onActiveEmojiChange("pointer", o3, r2);
  }, [o3, r2]), m2 = (0, import_react67.useCallback)(() => {
    n3.get().onActiveEmojiReset();
  }, []);
  return (0, import_jsx_runtime105.jsx)(e3, { ...Ze(t3, o3, s), onClick: a, onPointerDown: Ot, onPointerEnter: i, onPointerLeave: m2 });
});
var Nt = (0, import_react67.memo)(({ Row: e3, Emoji: t3, rowIndex: o3 }) => {
  let r2 = C(), n3 = L2(r2, (s) => {
    var _a3;
    return (_a3 = s.data) == null ? void 0 : _a3.rows[o3];
  }, Ve);
  return n3 ? (0, import_jsx_runtime105.jsx)(e3, { ...Xe(o3), children: n3.emojis.map((s, a) => (0, import_jsx_runtime105.jsx)(_t, { Emoji: t3, columnIndex: a, emoji: s, rowIndex: o3 }, s.label)) }) : null;
});
var Wt = (0, import_react67.memo)(({ CategoryHeader: e3, categoryIndex: t3 }) => {
  let o3 = C(), r2 = L2(o3, (n3) => {
    var _a3;
    return (_a3 = n3.data) == null ? void 0 : _a3.categories[t3];
  }, ee2);
  return r2 ? (0, import_jsx_runtime105.jsx)("div", { ...Qe(t3, r2), children: (0, import_jsx_runtime105.jsx)(e3, { ...et({ label: r2.label }) }) }) : null;
});
var Ue = (0, import_react67.memo)(({ CategoryHeader: e3, Row: t3, Emoji: o3 }) => {
  let r2 = (0, import_react67.useRef)(null), n3 = C(), s = M(n3, "columns"), a = (0, import_react67.useMemo)(() => Array(s).fill({ emoji: "🙂", label: "" }), [s]), i = (0, import_react67.useMemo)(() => ({ label: "Category" }), []), m2 = (0, import_react67.useRef)(null), c = (0, import_react67.useRef)(null);
  return I(() => {
    var _a3, _b;
    let f = (_b = (_a3 = r2.current) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b.parentElement;
    if (!f || !m2.current || !c.current) return;
    let u2 = new ResizeObserver((l2) => {
      for (let j of l2) {
        let g = j.contentRect.height, { onRowHeightChange: w, onCategoryHeaderHeightChange: P2, rowHeight: T2, categoryHeaderHeight: p2 } = n3.get();
        j.target === m2.current && T2 !== g && w(g), j.target === c.current && p2 !== g && P2(g);
      }
    });
    u2.observe(f), u2.observe(m2.current), u2.observe(c.current);
    let { onRowHeightChange: h, onCategoryHeaderHeightChange: d } = n3.get();
    return h(m2.current.clientHeight), d(c.current.clientHeight), () => {
      u2.disconnect();
    };
  }, []), (0, import_jsx_runtime105.jsxs)("div", { "aria-hidden": true, ref: r2, style: { height: 0, visibility: "hidden" }, children: [(0, import_jsx_runtime105.jsx)("div", { "frimousse-row-sizer": "", ref: m2, children: (0, import_jsx_runtime105.jsx)(t3, { ...Xe(-1, true), children: a.map((f, u2) => (0, import_jsx_runtime105.jsx)(o3, { ...Ze(f, u2, false) }, u2)) }) }), (0, import_jsx_runtime105.jsx)("div", { ...Qe(-1), children: (0, import_jsx_runtime105.jsx)("div", { "frimousse-category-header-sizer": "", ref: c, children: (0, import_jsx_runtime105.jsx)(e3, { ...et(i, true) }) }) })] });
});
function Bt({ category: e3, ...t3 }) {
  return (0, import_jsx_runtime105.jsx)("div", { ...t3, children: e3.label });
}
function zt({ emoji: e3, ...t3 }) {
  return (0, import_jsx_runtime105.jsx)("button", { type: "button", ...t3, children: e3.emoji });
}
function Kt({ ...e3 }) {
  return (0, import_jsx_runtime105.jsx)("div", { ...e3 });
}
var tt = (0, import_react67.forwardRef)(({ style: e3, components: t3, ...o3 }, r2) => {
  let n3 = C(), s = (0, import_react67.useRef)(null), a = (0, import_react67.useCallback)((w) => {
    w && (s.current = w, n3.set({ listRef: s }));
  }, []), i = (t3 == null ? void 0 : t3.CategoryHeader) ?? Bt, m2 = (t3 == null ? void 0 : t3.Emoji) ?? zt, c = (t3 == null ? void 0 : t3.Row) ?? Kt, f = M(n3, "columns"), u2 = M(n3, "viewportStartRowIndex"), h = M(n3, "viewportEndRowIndex"), d = L2(n3, fe2), l2 = L2(n3, Me2, ee2), j = (0, import_react67.useMemo)(() => (l2 == null ? void 0 : l2.filter((w) => w < u2).length) ?? 0, [l2, u2]), g = (l2 == null ? void 0 : l2.length) ?? 0;
  return (0, import_react67.useImperativeHandle)(r2, () => s.current), !d || !l2 || g === 0 ? (0, import_jsx_runtime105.jsx)("div", { ...Ke(f, 0, e3), ...o3, children: (0, import_jsx_runtime105.jsx)("div", { ...ze(0, 0, 0, 0), children: (0, import_jsx_runtime105.jsx)(Ue, { CategoryHeader: i, Emoji: m2, Row: c }) }) }) : (0, import_jsx_runtime105.jsx)("div", { ...Ke(f, d, e3), ...o3, ref: a, children: (0, import_jsx_runtime105.jsxs)("div", { ...ze(d, g, u2, j), children: [(0, import_jsx_runtime105.jsx)(Ue, { CategoryHeader: i, Emoji: m2, Row: c }), Array.from({ length: h - u2 + 1 }, (w, P2) => {
    let T2 = u2 + P2, p2 = l2.indexOf(T2);
    return (0, import_jsx_runtime105.jsxs)(import_react67.Fragment, { children: [p2 >= 0 && (0, import_jsx_runtime105.jsx)("div", { style: { height: "var(--frimousse-category-header-height)" } }), (0, import_jsx_runtime105.jsx)(Nt, { Emoji: m2, Row: c, rowIndex: T2 })] }, T2);
  }), Array.from({ length: g }, (w, P2) => (0, import_jsx_runtime105.jsx)(Wt, { CategoryHeader: i, categoryIndex: P2 }, P2))] }) });
});
var ot = (0, import_react67.forwardRef)(({ emoji: e3, onClick: t3, "aria-label": o3 = "Change skin tone", ...r2 }, n3) => {
  let s = C(), a = L2(s, Fe, ee2), [i, m2, c] = Q(e3), f = (0, import_react67.useMemo)(() => Math.max(0, c.findIndex((w) => w.skinTone === i)), [i, c]), u2 = c[f], d = c[(f + 1) % c.length].skinTone, l2 = i === "none" ? void 0 : a == null ? void 0 : a[i], j = d === "none" ? void 0 : a == null ? void 0 : a[d], g = (0, import_react67.useCallback)((w) => {
    t3 == null ? void 0 : t3(w), w.isDefaultPrevented() || m2(d);
  }, [t3, m2, d]);
  return (0, import_jsx_runtime105.jsx)("button", { type: "button", ...r2, "aria-label": o3 + (j ? ` (${j})` : ""), "aria-live": "polite", "aria-valuetext": l2, "frimousse-skin-tone-selector": "", onClick: g, ref: n3, children: u2.emoji });
});
function rt({ children: e3, ...t3 }) {
  let o3 = C();
  return L2(o3, Ae) ? (0, import_jsx_runtime105.jsx)("span", { "frimousse-loading": "", ...t3, children: e3 }) : null;
}
function Ut({ children: e3 }) {
  let t3 = C(), o3 = L2(t3, Ie2);
  return e3({ search: o3 });
}
function nt({ children: e3, ...t3 }) {
  let o3 = C();
  return L2(o3, De2) ? (0, import_jsx_runtime105.jsx)("span", { "frimousse-empty": "", ...t3, children: typeof e3 == "function" ? (0, import_jsx_runtime105.jsx)(Ut, { children: e3 }) : e3 }) : null;
}
function it({ children: e3 }) {
  let t3 = X2();
  return e3({ emoji: t3 });
}
function st({ children: e3, emoji: t3 }) {
  let [o3, r2, n3] = Q(t3);
  return e3({ skinTone: o3, setSkinTone: r2, skinToneVariations: n3 });
}
Je.displayName = "EmojiPicker.Root";
qe.displayName = "EmojiPicker.Search";
Ge.displayName = "EmojiPicker.Viewport";
tt.displayName = "EmojiPicker.List";
rt.displayName = "EmojiPicker.Loading";
nt.displayName = "EmojiPicker.Empty";
ot.displayName = "EmojiPicker.SkinToneSelector";
it.displayName = "EmojiPicker.ActiveEmoji";
st.displayName = "EmojiPicker.SkinTone";

// node_modules/@liveblocks/react-ui/dist/components/internal/EmojiPicker.js
var import_react72 = __toESM(require_react(), 1);
function EmojiPickerListEmoji({
  emoji,
  className,
  ...props
}) {
  return (0, import_jsx_runtime106.jsx)("button", {
    className: cn("lb-emoji-picker-emoji", className),
    ...props,
    children: (0, import_jsx_runtime106.jsx)(Emoji, {
      emoji: emoji.emoji
    })
  });
}
function EmojiPickerListRow({
  children,
  className,
  ...props
}) {
  return (0, import_jsx_runtime106.jsx)("div", {
    className: cn("lb-emoji-picker-row", className),
    ...props,
    children
  });
}
function EmojiPickerListCategoryHeader({
  category,
  className,
  ...props
}) {
  return (0, import_jsx_runtime106.jsx)("div", {
    className: cn("lb-emoji-picker-category-header", className),
    ...props,
    children: (0, import_jsx_runtime106.jsx)("span", {
      className: "lb-emoji-picker-category-header-title",
      children: category.label
    })
  });
}
var EmojiPicker = (0, import_react72.forwardRef)(
  ({ onEmojiSelect, onOpenChange, children, className, ...props }, forwardedRef) => {
    const [isOpen, setOpen] = (0, import_react72.useState)(false);
    const { portalContainer, emojibaseUrl } = useLiveblocksUiConfig();
    const $3 = useOverrides();
    const handleOpenChange = (0, import_react72.useCallback)(
      (isOpen2) => {
        setOpen(isOpen2);
        onOpenChange == null ? void 0 : onOpenChange(isOpen2);
      },
      [onOpenChange]
    );
    const handleEmojiSelect = (0, import_react72.useCallback)(
      ({ emoji }) => {
        setOpen(false);
        onEmojiSelect == null ? void 0 : onEmojiSelect(emoji);
      },
      [onEmojiSelect]
    );
    const stopPropagation = (0, import_react72.useCallback)((event) => {
      event.stopPropagation();
    }, []);
    return (0, import_jsx_runtime106.jsxs)(Root22, {
      open: isOpen,
      onOpenChange: handleOpenChange,
      children: [
        children,
        (0, import_jsx_runtime106.jsx)(Portal5, {
          container: portalContainer,
          children: (0, import_jsx_runtime106.jsx)(Content22, {
            side: "top",
            align: "center",
            sideOffset: FLOATING_ELEMENT_SIDE_OFFSET,
            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,
            className: cn(
              "lb-root lb-portal lb-elevation lb-emoji-picker",
              className
            ),
            ...props,
            ref: forwardedRef,
            asChild: true,
            children: (0, import_jsx_runtime106.jsxs)(at.Root, {
              onEmojiSelect: handleEmojiSelect,
              locale: $3.locale,
              columns: 10,
              emojiVersion: 15.1,
              emojibaseUrl,
              onClick: stopPropagation,
              children: [
                (0, import_jsx_runtime106.jsx)("div", {
                  className: "lb-emoji-picker-header",
                  children: (0, import_jsx_runtime106.jsxs)("div", {
                    className: "lb-emoji-picker-search-container",
                    children: [
                      (0, import_jsx_runtime106.jsx)(at.Search, {
                        className: "lb-emoji-picker-search",
                        placeholder: $3.EMOJI_PICKER_SEARCH_PLACEHOLDER,
                        autoFocus: true
                      }),
                      (0, import_jsx_runtime106.jsx)(SearchIcon, {})
                    ]
                  })
                }),
                (0, import_jsx_runtime106.jsxs)(at.Viewport, {
                  className: "lb-emoji-picker-content",
                  children: [
                    (0, import_jsx_runtime106.jsx)(at.Loading, {
                      className: "lb-loading lb-emoji-picker-loading",
                      children: (0, import_jsx_runtime106.jsx)(SpinnerIcon, {})
                    }),
                    (0, import_jsx_runtime106.jsx)(at.Empty, {
                      className: "lb-empty lb-emoji-picker-empty",
                      children: $3.EMOJI_PICKER_EMPTY
                    }),
                    (0, import_jsx_runtime106.jsx)(at.List, {
                      className: "lb-emoji-picker-list",
                      components: {
                        CategoryHeader: EmojiPickerListCategoryHeader,
                        Row: EmojiPickerListRow,
                        Emoji: EmojiPickerListEmoji
                      }
                    })
                  ]
                }),
                (0, import_jsx_runtime106.jsxs)("div", {
                  className: "lb-emoji-picker-footer",
                  children: [
                    (0, import_jsx_runtime106.jsx)(at.ActiveEmoji, {
                      children: ({ emoji }) => emoji ? (0, import_jsx_runtime106.jsxs)(import_jsx_runtime106.Fragment, {
                        children: [
                          (0, import_jsx_runtime106.jsx)("div", {
                            className: "lb-emoji-picker-active-emoji",
                            children: emoji.emoji
                          }),
                          (0, import_jsx_runtime106.jsx)("span", {
                            className: "lb-emoji-picker-active-emoji-label",
                            children: emoji.label
                          })
                        ]
                      }) : (0, import_jsx_runtime106.jsx)("span", {
                        className: "lb-emoji-picker-active-emoji-label lb-emoji-picker-active-emoji-label-placeholder",
                        children: "Select an emoji…"
                      })
                    }),
                    (0, import_jsx_runtime106.jsx)(Tooltip2, {
                      content: $3.EMOJI_PICKER_CHANGE_SKIN_TONE,
                      children: (0, import_jsx_runtime106.jsx)(at.SkinToneSelector, {
                        className: "lb-button lb-emoji-picker-skin-tone-selector"
                      })
                    })
                  ]
                })
              ]
            })
          })
        })
      ]
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/Composer.js
function ComposerInsertMentionEditorAction({
  label,
  tooltipLabel,
  className,
  onClick,
  ...props
}) {
  const { createMention } = useComposer();
  const preventDefault = (0, import_react74.useCallback)((event) => {
    event.preventDefault();
  }, []);
  const handleClick = (0, import_react74.useCallback)(
    (event) => {
      onClick == null ? void 0 : onClick(event);
      if (!event.isDefaultPrevented()) {
        event.stopPropagation();
        createMention();
      }
    },
    [createMention, onClick]
  );
  return (0, import_jsx_runtime107.jsx)(Tooltip2, {
    content: tooltipLabel ?? label,
    children: (0, import_jsx_runtime107.jsx)(Button, {
      className: cn("lb-composer-editor-action", className),
      onPointerDown: preventDefault,
      onClick: handleClick,
      "aria-label": label,
      icon: (0, import_jsx_runtime107.jsx)(MentionIcon, {}),
      ...props
    })
  });
}
function ComposerInsertEmojiEditorAction({
  label,
  tooltipLabel,
  onPickerOpenChange,
  className,
  ...props
}) {
  const { insertText: insertText3 } = useComposer();
  const preventDefault = (0, import_react74.useCallback)((event) => {
    event.preventDefault();
  }, []);
  const stopPropagation = (0, import_react74.useCallback)((event) => {
    event.stopPropagation();
  }, []);
  return (0, import_jsx_runtime107.jsx)(EmojiPicker, {
    onEmojiSelect: insertText3,
    onOpenChange: onPickerOpenChange,
    children: (0, import_jsx_runtime107.jsx)(Tooltip2, {
      content: tooltipLabel ?? label,
      children: (0, import_jsx_runtime107.jsx)(PopoverTrigger, {
        asChild: true,
        children: (0, import_jsx_runtime107.jsx)(Button, {
          className: cn("lb-composer-editor-action", className),
          onPointerDown: preventDefault,
          onClick: stopPropagation,
          "aria-label": label,
          icon: (0, import_jsx_runtime107.jsx)(EmojiIcon, {}),
          ...props
        })
      })
    })
  });
}
function ComposerAttachFilesEditorAction({
  label,
  tooltipLabel,
  className,
  ...props
}) {
  const preventDefault = (0, import_react74.useCallback)((event) => {
    event.preventDefault();
  }, []);
  const stopPropagation = (0, import_react74.useCallback)((event) => {
    event.stopPropagation();
  }, []);
  return (0, import_jsx_runtime107.jsx)(Tooltip2, {
    content: tooltipLabel ?? label,
    children: (0, import_jsx_runtime107.jsx)(ComposerAttachFiles, {
      asChild: true,
      children: (0, import_jsx_runtime107.jsx)(Button, {
        className: cn("lb-composer-editor-action", className),
        onPointerDown: preventDefault,
        onClick: stopPropagation,
        "aria-label": label,
        icon: (0, import_jsx_runtime107.jsx)(AttachmentIcon, {}),
        ...props
      })
    })
  });
}
function ComposerUserMention({ mention }) {
  return (0, import_jsx_runtime107.jsxs)(ComposerMention, {
    className: "lb-mention lb-composer-mention",
    children: [
      (0, import_jsx_runtime107.jsx)("span", {
        className: "lb-mention-symbol",
        children: MENTION_CHARACTER
      }),
      (0, import_jsx_runtime107.jsx)(User, {
        userId: mention.id
      })
    ]
  });
}
function ComposerGroupMention({ mention }) {
  const isMember = useIsGroupMentionMember(mention);
  return (0, import_jsx_runtime107.jsxs)(ComposerMention, {
    className: "lb-mention lb-composer-mention",
    "data-self": isMember ? "" : void 0,
    children: [
      (0, import_jsx_runtime107.jsx)("span", {
        className: "lb-mention-symbol",
        children: MENTION_CHARACTER
      }),
      (0, import_jsx_runtime107.jsx)(Group, {
        groupId: mention.id
      })
    ]
  });
}
function ComposerMention2({ mention, ...props }) {
  switch (mention.kind) {
    case "user":
      return (0, import_jsx_runtime107.jsx)(ComposerUserMention, {
        mention,
        ...props
      });
    case "group":
      return (0, import_jsx_runtime107.jsx)(ComposerGroupMention, {
        mention,
        ...props
      });
    default:
      return assertNever(mention, "Unhandled mention kind");
  }
}
function ComposerMentionSuggestions({
  mentions
}) {
  return mentions.length > 0 ? (0, import_jsx_runtime107.jsx)(ComposerSuggestions, {
    className: "lb-root lb-portal lb-elevation lb-composer-suggestions lb-composer-mention-suggestions",
    children: (0, import_jsx_runtime107.jsx)(ComposerSuggestionsList, {
      className: "lb-composer-suggestions-list lb-composer-mention-suggestions-list",
      children: mentions.map((mention) => {
        return (0, import_jsx_runtime107.jsx)(ComposerSuggestionsListItem, {
          className: "lb-composer-suggestions-list-item lb-composer-mention-suggestion",
          value: mention.id,
          children: mention.kind === "user" ? (0, import_jsx_runtime107.jsxs)(import_jsx_runtime107.Fragment, {
            children: [
              (0, import_jsx_runtime107.jsx)(Avatar, {
                userId: mention.id,
                className: "lb-composer-mention-suggestion-avatar"
              }),
              (0, import_jsx_runtime107.jsx)(User, {
                userId: mention.id,
                className: "lb-composer-mention-suggestion-user"
              })
            ]
          }) : mention.kind === "group" ? (0, import_jsx_runtime107.jsxs)(import_jsx_runtime107.Fragment, {
            children: [
              (0, import_jsx_runtime107.jsx)(Avatar, {
                groupId: mention.id,
                className: "lb-composer-mention-suggestion-avatar",
                icon: (0, import_jsx_runtime107.jsx)(UsersIcon, {})
              }),
              (0, import_jsx_runtime107.jsx)(Group, {
                groupId: mention.id,
                className: "lb-composer-mention-suggestion-group",
                children: (0, import_jsx_runtime107.jsx)(GroupDescription, {
                  groupId: mention.id,
                  className: "lb-composer-mention-suggestion-group-description"
                })
              })
            ]
          }) : assertNever(mention, "Unhandled mention kind")
        }, mention.id);
      })
    })
  }) : null;
}
function MarkToggle({
  mark,
  icon,
  shortcut,
  children,
  ...props
}) {
  const $3 = useOverrides();
  const label = (0, import_react74.useMemo)(() => {
    return $3.COMPOSER_TOGGLE_MARK(mark);
  }, [$3, mark]);
  return (0, import_jsx_runtime107.jsx)(ShortcutTooltip, {
    content: label,
    shortcut,
    sideOffset: FLOATING_ELEMENT_SIDE_OFFSET + 2,
    children: (0, import_jsx_runtime107.jsx)(ComposerMarkToggle, {
      mark,
      asChild: true,
      ...props,
      children: (0, import_jsx_runtime107.jsx)(Button, {
        "aria-label": label,
        variant: "toolbar",
        icon,
        children
      })
    })
  });
}
var markToggles = {
  bold: () => (0, import_jsx_runtime107.jsx)(MarkToggle, {
    mark: "bold",
    shortcut: "Mod-B",
    icon: (0, import_jsx_runtime107.jsx)(BoldIcon, {})
  }),
  italic: () => (0, import_jsx_runtime107.jsx)(MarkToggle, {
    mark: "italic",
    shortcut: "Mod-I",
    icon: (0, import_jsx_runtime107.jsx)(ItalicIcon, {})
  }),
  strikethrough: () => (0, import_jsx_runtime107.jsx)(MarkToggle, {
    mark: "strikethrough",
    shortcut: "Mod-Shift-S",
    icon: (0, import_jsx_runtime107.jsx)(StrikethroughIcon, {})
  }),
  code: () => (0, import_jsx_runtime107.jsx)(MarkToggle, {
    mark: "code",
    shortcut: "Mod-E",
    icon: (0, import_jsx_runtime107.jsx)(CodeIcon, {})
  })
};
var markTogglesList = Object.entries(markToggles).map(([mark, Toggle2]) => (0, import_jsx_runtime107.jsx)(Toggle2, {}, mark));
function ComposerFloatingToolbar2() {
  return (0, import_jsx_runtime107.jsx)(ComposerFloatingToolbar, {
    className: "lb-root lb-portal lb-elevation lb-composer-floating-toolbar",
    children: markTogglesList
  });
}
function ComposerLink2({ href, children }) {
  return (0, import_jsx_runtime107.jsx)(ComposerLink, {
    href,
    className: "lb-composer-link",
    children
  });
}
function ComposerFileAttachment({
  attachment,
  className,
  overrides,
  ...props
}) {
  const { removeAttachment } = useComposer();
  const { roomId } = useComposerEditorContext();
  const handleDeleteClick = (0, import_react74.useCallback)(() => {
    removeAttachment(attachment.id);
  }, [attachment.id, removeAttachment]);
  return (0, import_jsx_runtime107.jsx)(FileAttachment, {
    className: cn("lb-composer-attachment", className),
    ...props,
    attachment,
    onDeleteClick: handleDeleteClick,
    preventFocusOnDelete: true,
    overrides,
    roomId
  });
}
function ComposerAttachments({
  overrides,
  className,
  ...props
}) {
  const { attachments } = useComposer();
  if (attachments.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime107.jsx)("div", {
    className: cn("lb-composer-attachments", className),
    ...props,
    children: (0, import_jsx_runtime107.jsx)("div", {
      className: "lb-attachments",
      children: attachments.map((attachment) => {
        return (0, import_jsx_runtime107.jsx)(ComposerFileAttachment, {
          attachment,
          overrides
        }, attachment.id);
      })
    })
  });
}
var editorRequiredComponents = {
  Mention: ComposerMention2,
  MentionSuggestions: ComposerMentionSuggestions,
  Link: ComposerLink2
};
function ComposerEditorContainer({
  showAttachments = true,
  showFormattingControls = true,
  showAttribution,
  defaultValue,
  isCollapsed,
  overrides,
  actions,
  autoFocus,
  disabled,
  hasResolveMentionSuggestions,
  onEmojiPickerOpenChange,
  onEmptyChange,
  onEditorClick
}) {
  const { isEmpty: isEmpty3 } = useComposer();
  const { hasMaxAttachments } = useComposerAttachmentsContext();
  const $3 = useOverrides(overrides);
  const components = (0, import_react74.useMemo)(() => {
    return {
      ...editorRequiredComponents,
      FloatingToolbar: showFormattingControls ? ComposerFloatingToolbar2 : void 0
    };
  }, [showFormattingControls]);
  const [isDraggingOver, dropAreaProps] = useComposerAttachmentsDropArea({
    disabled: disabled || !showAttachments || hasMaxAttachments
  });
  useLayoutEffect2(() => {
    onEmptyChange(isEmpty3);
  }, [isEmpty3, onEmptyChange]);
  const preventDefault = (0, import_react74.useCallback)((event) => {
    event.preventDefault();
  }, []);
  const stopPropagation = (0, import_react74.useCallback)((event) => {
    event.stopPropagation();
  }, []);
  return (0, import_jsx_runtime107.jsxs)("div", {
    className: "lb-composer-editor-container",
    ...dropAreaProps,
    children: [
      (0, import_jsx_runtime107.jsx)(ComposerEditor, {
        className: "lb-composer-editor",
        onClick: onEditorClick,
        placeholder: $3.COMPOSER_PLACEHOLDER,
        defaultValue,
        autoFocus,
        components,
        disabled,
        dir: $3.dir
      }),
      showAttachments && (0, import_jsx_runtime107.jsx)(ComposerAttachments, {
        overrides
      }),
      (!isCollapsed || isDraggingOver) && (0, import_jsx_runtime107.jsxs)("div", {
        className: "lb-composer-footer",
        children: [
          (0, import_jsx_runtime107.jsxs)("div", {
            className: "lb-composer-editor-actions",
            children: [
              hasResolveMentionSuggestions && (0, import_jsx_runtime107.jsx)(ComposerInsertMentionEditorAction, {
                label: $3.COMPOSER_INSERT_MENTION,
                disabled
              }),
              (0, import_jsx_runtime107.jsx)(ComposerInsertEmojiEditorAction, {
                label: $3.COMPOSER_INSERT_EMOJI,
                onPickerOpenChange: onEmojiPickerOpenChange,
                disabled
              }),
              showAttachments && (0, import_jsx_runtime107.jsx)(ComposerAttachFilesEditorAction, {
                label: $3.COMPOSER_ATTACH_FILES,
                disabled
              })
            ]
          }),
          showAttribution && (0, import_jsx_runtime107.jsx)(Attribution, {}),
          (0, import_jsx_runtime107.jsx)("div", {
            className: "lb-composer-actions",
            children: actions ?? (0, import_jsx_runtime107.jsx)(import_jsx_runtime107.Fragment, {
              children: (0, import_jsx_runtime107.jsx)(ShortcutTooltip, {
                content: $3.COMPOSER_SEND,
                shortcut: "Enter",
                children: (0, import_jsx_runtime107.jsx)(ComposerSubmit, {
                  asChild: true,
                  children: (0, import_jsx_runtime107.jsx)(Button, {
                    onPointerDown: preventDefault,
                    onClick: stopPropagation,
                    className: "lb-composer-action",
                    variant: "primary",
                    "aria-label": $3.COMPOSER_SEND,
                    icon: (0, import_jsx_runtime107.jsx)(SendIcon, {})
                  })
                })
              })
            })
          })
        ]
      }),
      showAttachments && isDraggingOver && (0, import_jsx_runtime107.jsx)("div", {
        className: "lb-composer-attachments-drop-area",
        children: (0, import_jsx_runtime107.jsxs)("div", {
          className: "lb-composer-attachments-drop-area-label",
          children: [
            (0, import_jsx_runtime107.jsx)(AttachmentIcon, {}),
            $3.COMPOSER_ATTACH_FILES
          ]
        })
      })
    ]
  });
}
var ComposerRoomIdContext = (0, import_react74.createContext)(null);
var Composer = (0, import_react74.forwardRef)(
  ({
    threadId,
    commentId,
    metadata,
    defaultValue,
    defaultAttachments,
    onComposerSubmit,
    collapsed: controlledCollapsed,
    defaultCollapsed,
    onCollapsedChange: controlledOnCollapsedChange,
    overrides,
    actions,
    onBlur,
    className,
    onFocus,
    autoFocus,
    disabled,
    blurOnSubmit = true,
    showAttachments = true,
    showFormattingControls = true,
    showAttribution,
    roomId: _roomId,
    ...props
  }, forwardedRef) => {
    const room = _useRoom({ allowOutsideRoom: true });
    const roomId = _roomId !== void 0 ? _roomId : room == null ? void 0 : room.id;
    if (roomId === void 0) {
      throw new Error(
        "Composer must be a descendant of RoomProvider component"
      );
    }
    const createThread = useCreateRoomThread(roomId);
    const createComment = useCreateRoomComment(roomId);
    const editComment = useEditRoomComment(roomId);
    const { preventUnsavedComposerChanges } = useLiveblocksUiConfig();
    const hasResolveMentionSuggestions = useResolveMentionSuggestions() !== void 0;
    const isEmptyRef = (0, import_react74.useRef)(true);
    const isEmojiPickerOpenRef = (0, import_react74.useRef)(false);
    const $3 = useOverrides(overrides);
    const [isCollapsed, onCollapsedChange] = useControllableState2(
      defaultCollapsed ?? false,
      controlledCollapsed,
      controlledOnCollapsedChange
    );
    const canCommentFallback = (0, import_react74.useSyncExternalStore)(
      (0, import_react74.useCallback)(
        (callback) => {
          if (room === null)
            return () => {
            };
          return room.events.self.subscribeOnce(callback);
        },
        [room]
      ),
      (0, import_react74.useCallback)(() => {
        var _a3;
        return ((_a3 = room == null ? void 0 : room.getSelf()) == null ? void 0 : _a3.canComment) ?? true;
      }, [room]),
      (0, import_react74.useCallback)(() => true, [])
    );
    const permissions = useRoomPermissions(roomId);
    const canComment = permissions.size > 0 ? permissions.has(Permission.CommentsWrite) || permissions.has(Permission.Write) : canCommentFallback;
    const setEmptyRef = (0, import_react74.useCallback)((isEmpty3) => {
      isEmptyRef.current = isEmpty3;
    }, []);
    const setEmojiPickerOpenRef = (0, import_react74.useCallback)((isEmojiPickerOpen) => {
      isEmojiPickerOpenRef.current = isEmojiPickerOpen;
    }, []);
    const handleFocus = (0, import_react74.useCallback)(
      (event) => {
        onFocus == null ? void 0 : onFocus(event);
        if (event.isDefaultPrevented()) {
          return;
        }
        if (isEmptyRef.current && canComment) {
          onCollapsedChange == null ? void 0 : onCollapsedChange(false);
        }
      },
      [onCollapsedChange, onFocus, canComment]
    );
    const handleBlur = (0, import_react74.useCallback)(
      (event) => {
        onBlur == null ? void 0 : onBlur(event);
        if (event.isDefaultPrevented()) {
          return;
        }
        const isOutside = !event.currentTarget.contains(
          event.relatedTarget ?? document.activeElement
        );
        if (isOutside && isEmptyRef.current && !isEmojiPickerOpenRef.current) {
          onCollapsedChange == null ? void 0 : onCollapsedChange(true);
        }
      },
      [onBlur, onCollapsedChange]
    );
    const handleEditorClick = (0, import_react74.useCallback)(
      (event) => {
        event.stopPropagation();
        if (isEmptyRef.current && canComment) {
          onCollapsedChange == null ? void 0 : onCollapsedChange(false);
        }
      },
      [onCollapsedChange, canComment]
    );
    const handleComposerSubmit = (0, import_react74.useCallback)(
      (comment, event) => {
        onComposerSubmit == null ? void 0 : onComposerSubmit(comment, event);
        if (event.isDefaultPrevented()) {
          return;
        }
        event.stopPropagation();
        if (commentId && threadId) {
          editComment({
            commentId,
            threadId,
            body: comment.body,
            attachments: comment.attachments
          });
        } else if (threadId) {
          createComment({
            threadId,
            body: comment.body,
            attachments: comment.attachments
          });
        } else {
          createThread({
            body: comment.body,
            metadata: metadata ?? {},
            attachments: comment.attachments
          });
        }
      },
      [
        commentId,
        createComment,
        createThread,
        editComment,
        metadata,
        onComposerSubmit,
        threadId
      ]
    );
    return (0, import_jsx_runtime107.jsx)(TooltipProvider, {
      children: (0, import_jsx_runtime107.jsx)(ComposerForm, {
        onComposerSubmit: handleComposerSubmit,
        className: cn("lb-root lb-composer lb-composer-form", className),
        dir: $3.dir,
        ...props,
        ref: forwardedRef,
        "data-collapsed": isCollapsed ? "" : void 0,
        onFocus: handleFocus,
        onBlur: handleBlur,
        disabled: disabled || !canComment,
        defaultAttachments,
        pasteFilesAsAttachments: showAttachments,
        preventUnsavedChanges: preventUnsavedComposerChanges,
        blurOnSubmit,
        roomId,
        children: (0, import_jsx_runtime107.jsx)(ComposerEditorContainer, {
          defaultValue,
          actions,
          overrides,
          isCollapsed,
          showAttachments,
          showAttribution,
          showFormattingControls,
          hasResolveMentionSuggestions,
          onEmptyChange: setEmptyRef,
          onEmojiPickerOpenChange: setEmojiPickerOpenRef,
          onEditorClick: handleEditorClick,
          autoFocus,
          disabled
        })
      })
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/internal/Dropdown.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var React41 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-menu/dist/index.mjs
var React40 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react75 = __toESM(require_react(), 1);
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react76 = __toESM(require_react(), 1);
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope4] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react75.default.useRef(null);
    const itemMap = import_react75.default.useRef(/* @__PURE__ */ new Map()).current;
    return (0, import_jsx_runtime108.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react75.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime108.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react75.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = import_react75.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react75.default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return (0, import_jsx_runtime108.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection4(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react75.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection4,
    createCollectionScope4
  ];
}

// node_modules/@radix-ui/react-direction/dist/index.mjs
var React38 = __toESM(require_react(), 1);
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var DirectionContext = React38.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React38.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React39 = __toESM(require_react(), 1);
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React39.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime111.jsx)(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime111.jsx)(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime111.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React39.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React39.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React39.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React39.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React39.useState(0);
  React39.useEffect(() => {
    const node3 = ref.current;
    if (node3) {
      node3.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node3.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return (0, import_jsx_runtime111.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React39.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React39.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React39.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React39.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: (0, import_jsx_runtime111.jsx)(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = React39.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React39.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return (0, import_jsx_runtime111.jsx)(
      Collection.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: (0, import_jsx_runtime111.jsx)(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root6 = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// node_modules/@radix-ui/react-menu/dist/index.mjs
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope3 = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope3(__scopeMenu);
  const [content, setContent] = React40.useState(null);
  const isUsingKeyboardRef = React40.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React40.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return (0, import_jsx_runtime112.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime112.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: (0, import_jsx_runtime112.jsx)(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React40.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME3 = "MenuAnchor";
var MenuAnchor = React40.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope3(__scopeMenu);
    return (0, import_jsx_runtime112.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME3;
var PORTAL_NAME6 = "MenuPortal";
var [PortalProvider4, usePortalContext4] = createMenuContext(PORTAL_NAME6, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME6, __scopeMenu);
  return (0, import_jsx_runtime112.jsx)(PortalProvider4, { scope: __scopeMenu, forceMount, children: (0, import_jsx_runtime112.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime112.jsx)(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME6;
var CONTENT_NAME5 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME5);
var MenuContent = React40.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext4(CONTENT_NAME5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME5, props.__scopeMenu);
    return (0, import_jsx_runtime112.jsx)(Collection2.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime112.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime112.jsx)(Collection2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? (0, import_jsx_runtime112.jsx)(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime112.jsx)(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React40.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME5, props.__scopeMenu);
    const ref = React40.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React40.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime112.jsx)(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React40.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME5, props.__scopeMenu);
  return (0, import_jsx_runtime112.jsx)(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot4 = createSlot("MenuContent.ScrollLock");
var MenuContentImpl = React40.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME5, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME5, __scopeMenu);
    const popperScope = usePopperScope3(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const getItems = useCollection2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React40.useState(null);
    const contentRef = React40.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React40.useRef(0);
    const searchRef = React40.useRef("");
    const pointerGraceTimerRef = React40.useRef(0);
    const pointerGraceIntentRef = React40.useRef(null);
    const pointerDirRef = React40.useRef("right");
    const lastPointerXRef = React40.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React40.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot4, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a3, _b;
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a3 = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a3.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React40.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React40.useCallback((event) => {
      var _a3, _b;
      const isMovingTowards = pointerDirRef.current === ((_a3 = pointerGraceIntentRef.current) == null ? void 0 : _a3.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b = pointerGraceIntentRef.current) == null ? void 0 : _b.area);
    }, []);
    return (0, import_jsx_runtime112.jsx)(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React40.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React40.useCallback(
          (event) => {
            var _a3;
            if (isPointerMovingToSubmenu(event)) return;
            (_a3 = contentRef.current) == null ? void 0 : _a3.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React40.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React40.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: (0, import_jsx_runtime112.jsx)(ScrollLockWrapper, { ...scrollLockWrapperProps, children: (0, import_jsx_runtime112.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a3;
              event.preventDefault();
              (_a3 = contentRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: (0, import_jsx_runtime112.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: (0, import_jsx_runtime112.jsx)(
                  Root6,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: (0, import_jsx_runtime112.jsx)(
                      Content,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst3(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME5;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React40.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return (0, import_jsx_runtime112.jsx)(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React40.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return (0, import_jsx_runtime112.jsx)(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME2 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React40.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React40.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME2, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME2, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React40.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return (0, import_jsx_runtime112.jsx)(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a3;
          (_a3 = props.onPointerDown) == null ? void 0 : _a3.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          var _a3;
          if (!isPointerDownRef.current) (_a3 = event.currentTarget) == null ? void 0 : _a3.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME2;
var MenuItemImpl = React40.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME2, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const ref = React40.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React40.useState(false);
    const [textContent, setTextContent] = React40.useState("");
    React40.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return (0, import_jsx_runtime112.jsx)(
      Collection2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: (0, import_jsx_runtime112.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: (0, import_jsx_runtime112.jsx)(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React40.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return (0, import_jsx_runtime112.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime112.jsx)(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React40.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef(onValueChange);
    return (0, import_jsx_runtime112.jsx)(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: (0, import_jsx_runtime112.jsx)(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React40.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);
    const checked = value === context.value;
    return (0, import_jsx_runtime112.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime112.jsx)(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a3;
            return (_a3 = context.onValueChange) == null ? void 0 : _a3.call(context, value);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = React40.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return (0, import_jsx_runtime112.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: (0, import_jsx_runtime112.jsx)(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React40.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return (0, import_jsx_runtime112.jsx)(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME4 = "MenuArrow";
var MenuArrow = React40.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope3(__scopeMenu);
    return (0, import_jsx_runtime112.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME4;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope3(__scopeMenu);
  const [trigger2, setTrigger] = React40.useState(null);
  const [content, setContent] = React40.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React40.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return (0, import_jsx_runtime112.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime112.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: (0, import_jsx_runtime112.jsx)(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger: trigger2,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React40.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const openTimerRef = React40.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React40.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React40.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React40.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return (0, import_jsx_runtime112.jsx)(MenuAnchor, { asChild: true, ...scope, children: (0, import_jsx_runtime112.jsx)(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a3;
          (_a3 = props.onClick) == null ? void 0 : _a3.call(props, event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            var _a3, _b;
            clearOpenTimer();
            const contentRect = (_a3 = context.content) == null ? void 0 : _a3.getBoundingClientRect();
            if (contentRect) {
              const side = (_b = context.content) == null ? void 0 : _b.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a3;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a3 = context.content) == null ? void 0 : _a3.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React40.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext4(CONTENT_NAME5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME5, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);
    const ref = React40.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return (0, import_jsx_runtime112.jsx)(Collection2.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime112.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime112.jsx)(Collection2.Slot, { scope: props.__scopeMenu, children: (0, import_jsx_runtime112.jsx)(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a3;
          if (rootContext.isUsingKeyboardRef.current) (_a3 = ref.current) == null ? void 0 : _a3.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a3;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a3 = subContext.trigger) == null ? void 0 : _a3.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v2) => v2 !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon2(point3, polygon) {
  const { x: x2, y } = point3;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon2(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root33 = Menu;
var Anchor2 = MenuAnchor;
var Portal6 = MenuPortal;
var Content23 = MenuContent;
var Group2 = MenuGroup;
var Label = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow22 = MenuArrow;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;

// node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React41.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return (0, import_jsx_runtime113.jsx)(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React41.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: (0, import_jsx_runtime113.jsx)(Root33, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME4 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React41.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime113.jsx)(Anchor2, { asChild: true, ...menuScope, children: (0, import_jsx_runtime113.jsx)(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME4;
var PORTAL_NAME7 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(Portal6, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME7;
var CONTENT_NAME6 = "DropdownMenuContent";
var DropdownMenuContent = React41.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME6, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React41.useRef(false);
    return (0, import_jsx_runtime113.jsx)(
      Content23,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a3;
          if (!hasInteractedOutsideRef.current) (_a3 = context.triggerRef.current) == null ? void 0 : _a3.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME6;
var GROUP_NAME3 = "DropdownMenuGroup";
var DropdownMenuGroup = React41.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime113.jsx)(Group2, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "DropdownMenuLabel";
var DropdownMenuLabel = React41.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime113.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME3 = "DropdownMenuItem";
var DropdownMenuItem = React41.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime113.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME3;
var CHECKBOX_ITEM_NAME2 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React41.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React41.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React41.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React41.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME2 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React41.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME5 = "DropdownMenuArrow";
var DropdownMenuArrow = React41.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime113.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME5;
var SUB_TRIGGER_NAME2 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React41.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React41.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime113.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME2;
var Root23 = DropdownMenu;
var Portal22 = DropdownMenuPortal;
var Content24 = DropdownMenuContent;

// node_modules/@liveblocks/react-ui/dist/components/internal/Dropdown.js
var import_react77 = __toESM(require_react(), 1);
function Dropdown({
  children,
  content,
  defaultOpen,
  open,
  onOpenChange,
  className,
  ...props
}) {
  const $3 = useOverrides();
  const { portalContainer } = useLiveblocksUiConfig();
  return (0, import_jsx_runtime114.jsxs)(Root23, {
    defaultOpen,
    open,
    onOpenChange,
    dir: $3.dir,
    children: [
      children,
      (0, import_jsx_runtime114.jsx)(Portal22, {
        container: portalContainer,
        children: (0, import_jsx_runtime114.jsx)(Content24, {
          className: cn(
            "lb-root lb-portal lb-elevation lb-dropdown",
            className
          ),
          sideOffset: FLOATING_ELEMENT_SIDE_OFFSET,
          collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,
          ...props,
          children: content
        })
      })
    ]
  });
}
var DropdownItem = (0, import_react77.forwardRef)(
  ({ children, className, icon, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime114.jsxs)(DropdownMenuItem, {
      className: cn("lb-dropdown-item", className),
      ...props,
      ref: forwardedRef,
      children: [
        icon ? (0, import_jsx_runtime114.jsx)("span", {
          className: "lb-dropdown-item-icon lb-icon-container",
          children: icon
        }) : null,
        children ? (0, import_jsx_runtime114.jsx)("span", {
          className: "lb-dropdown-item-label",
          children
        }) : null
      ]
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/Comment.js
var REACTIONS_TRUNCATE = 5;
function CommentUserMention({
  mention,
  className,
  ...props
}) {
  const currentId = useCurrentUserId();
  return (0, import_jsx_runtime115.jsxs)(CommentMention, {
    className: cn("lb-mention lb-comment-mention", className),
    "data-self": mention.id === currentId ? "" : void 0,
    ...props,
    children: [
      (0, import_jsx_runtime115.jsx)("span", {
        className: "lb-mention-symbol",
        children: MENTION_CHARACTER
      }),
      (0, import_jsx_runtime115.jsx)(User, {
        userId: mention.id
      })
    ]
  });
}
function CommentGroupMention({
  mention,
  className,
  ...props
}) {
  const isMember = useIsGroupMentionMember(mention);
  return (0, import_jsx_runtime115.jsxs)(CommentMention, {
    className: cn("lb-mention lb-comment-mention", className),
    "data-self": isMember ? "" : void 0,
    ...props,
    children: [
      (0, import_jsx_runtime115.jsx)("span", {
        className: "lb-mention-symbol",
        children: MENTION_CHARACTER
      }),
      (0, import_jsx_runtime115.jsx)(Group, {
        groupId: mention.id
      })
    ]
  });
}
function CommentMention2({ mention, ...props }) {
  switch (mention.kind) {
    case "user":
      return (0, import_jsx_runtime115.jsx)(CommentUserMention, {
        mention,
        ...props
      });
    case "group":
      return (0, import_jsx_runtime115.jsx)(CommentGroupMention, {
        mention,
        ...props
      });
    default:
      return assertNever(mention, "Unhandled mention kind");
  }
}
function CommentLink2({
  href,
  children,
  className,
  ...props
}) {
  const { Anchor: Anchor3 } = useComponents();
  return (0, import_jsx_runtime115.jsx)(CommentLink, {
    className: cn("lb-comment-link", className),
    href,
    ...props,
    asChild: true,
    children: (0, import_jsx_runtime115.jsx)(Anchor3, {
      ...props,
      children
    })
  });
}
function CommentNonInteractiveLink({
  href: _href,
  children,
  className,
  ...props
}) {
  return (0, import_jsx_runtime115.jsx)("span", {
    className: cn("lb-comment-link", className),
    ...props,
    children
  });
}
var CommentReactionButton = (0, import_react78.forwardRef)(({ reaction, overrides, className, ...props }, forwardedRef) => {
  const $3 = useOverrides(overrides);
  return (0, import_jsx_runtime115.jsxs)(CustomButton, {
    className: cn("lb-comment-reaction", className),
    variant: "outline",
    "aria-label": $3.COMMENT_REACTION_DESCRIPTION(
      reaction.emoji,
      reaction.users.length
    ),
    ...props,
    ref: forwardedRef,
    children: [
      (0, import_jsx_runtime115.jsx)(Emoji, {
        className: "lb-comment-reaction-emoji",
        emoji: reaction.emoji
      }),
      (0, import_jsx_runtime115.jsx)("span", {
        className: "lb-comment-reaction-count",
        children: reaction.users.length
      })
    ]
  });
});
var CommentReaction = (0, import_react78.forwardRef)(({ comment, reaction, overrides, disabled, ...props }, forwardedRef) => {
  const addReaction = useAddRoomCommentReaction(comment.roomId);
  const removeReaction = useRemoveRoomCommentReaction(comment.roomId);
  const currentId = useCurrentUserId();
  const isActive = (0, import_react78.useMemo)(() => {
    return reaction.users.some((users) => users.id === currentId);
  }, [currentId, reaction]);
  const $3 = useOverrides(overrides);
  const tooltipContent = (0, import_react78.useMemo)(
    () => (0, import_jsx_runtime115.jsx)("span", {
      children: $3.COMMENT_REACTION_LIST(
        (0, import_jsx_runtime115.jsx)(List, {
          values: reaction.users.map((users) => (0, import_jsx_runtime115.jsx)(User, {
            userId: users.id,
            replaceSelf: true
          }, users.id)),
          formatRemaining: $3.LIST_REMAINING_USERS,
          truncate: REACTIONS_TRUNCATE,
          locale: $3.locale
        }),
        reaction.emoji,
        reaction.users.length
      )
    }),
    [$3, reaction]
  );
  const stopPropagation = (0, import_react78.useCallback)((event) => {
    event.stopPropagation();
  }, []);
  const handlePressedChange = (0, import_react78.useCallback)(
    (isPressed) => {
      if (isPressed) {
        addReaction({
          threadId: comment.threadId,
          commentId: comment.id,
          emoji: reaction.emoji
        });
      } else {
        removeReaction({
          threadId: comment.threadId,
          commentId: comment.id,
          emoji: reaction.emoji
        });
      }
    },
    [addReaction, comment.threadId, comment.id, reaction.emoji, removeReaction]
  );
  return (0, import_jsx_runtime115.jsx)(Tooltip2, {
    content: tooltipContent,
    multiline: true,
    className: "lb-comment-reaction-tooltip",
    children: (0, import_jsx_runtime115.jsx)(Root5, {
      asChild: true,
      pressed: isActive,
      onPressedChange: handlePressedChange,
      onClick: stopPropagation,
      disabled,
      ref: forwardedRef,
      children: (0, import_jsx_runtime115.jsx)(CommentReactionButton, {
        "data-self": isActive ? "" : void 0,
        reaction,
        overrides,
        ...props
      })
    })
  });
});
var CommentNonInteractiveReaction = (0, import_react78.forwardRef)(({ reaction, overrides, ...props }, forwardedRef) => {
  const currentId = useCurrentUserId();
  const isActive = (0, import_react78.useMemo)(() => {
    return reaction.users.some((users) => users.id === currentId);
  }, [currentId, reaction]);
  return (0, import_jsx_runtime115.jsx)(CommentReactionButton, {
    disableable: false,
    "data-self": isActive ? "" : void 0,
    reaction,
    overrides,
    ...props,
    ref: forwardedRef
  });
});
function openAttachment({ attachment, url }) {
  if (attachment.mimeType === "application/pdf" || attachment.mimeType.startsWith("image/") || attachment.mimeType.startsWith("video/") || attachment.mimeType.startsWith("audio/")) {
    window.open(url, "_blank");
  } else {
    download(url, attachment.name);
  }
}
function CommentMediaAttachment({
  attachment,
  onAttachmentClick,
  roomId,
  className,
  overrides,
  ...props
}) {
  const { url } = useRoomAttachmentUrl(attachment.id, roomId);
  const handleClick = (0, import_react78.useCallback)(
    (event) => {
      if (!url) {
        return;
      }
      const args = { attachment, url };
      onAttachmentClick == null ? void 0 : onAttachmentClick(args, event);
      if (event.isDefaultPrevented()) {
        return;
      }
      openAttachment(args);
    },
    [attachment, onAttachmentClick, url]
  );
  return (0, import_jsx_runtime115.jsx)(MediaAttachment, {
    className: cn("lb-comment-attachment", className),
    ...props,
    attachment,
    overrides,
    onClick: url ? handleClick : void 0,
    roomId
  });
}
function CommentFileAttachment({
  attachment,
  onAttachmentClick,
  roomId,
  className,
  overrides,
  ...props
}) {
  const { url } = useRoomAttachmentUrl(attachment.id, roomId);
  const handleClick = (0, import_react78.useCallback)(
    (event) => {
      if (!url) {
        return;
      }
      const args = { attachment, url };
      onAttachmentClick == null ? void 0 : onAttachmentClick(args, event);
      if (event.isDefaultPrevented()) {
        return;
      }
      openAttachment(args);
    },
    [attachment, onAttachmentClick, url]
  );
  return (0, import_jsx_runtime115.jsx)(FileAttachment, {
    className: cn("lb-comment-attachment", className),
    ...props,
    attachment,
    overrides,
    onClick: url ? handleClick : void 0,
    roomId
  });
}
function CommentNonInteractiveFileAttachment({
  className,
  ...props
}) {
  return (0, import_jsx_runtime115.jsx)(FileAttachment, {
    className: cn("lb-comment-attachment", className),
    allowMediaPreview: false,
    ...props
  });
}
function AutoMarkReadThreadIdHandler({
  threadId,
  roomId,
  commentRef
}) {
  const markThreadAsRead = useMarkRoomThreadAsRead(roomId);
  const isWindowFocused = useWindowFocus();
  useIntersectionCallback(
    commentRef,
    (isIntersecting) => {
      if (isIntersecting) {
        markThreadAsRead(threadId);
      }
    },
    {
      enabled: isWindowFocused
    }
  );
  return null;
}
var Comment = (0, import_react78.forwardRef)(
  ({
    comment,
    indentContent = true,
    showDeleted,
    showActions = "hover",
    showReactions = true,
    showAttachments = true,
    showComposerFormattingControls = true,
    onAuthorClick,
    onMentionClick,
    onAttachmentClick,
    onCommentEdit,
    onCommentDelete,
    overrides,
    components,
    className,
    additionalActions,
    additionalActionsClassName,
    additionalDropdownItemsBefore,
    additionalDropdownItemsAfter,
    autoMarkReadThreadId,
    ...props
  }, forwardedRef) => {
    const ref = (0, import_react78.useRef)(null);
    const mergedRefs = useRefs(forwardedRef, ref);
    const currentUserId = useCurrentUserId();
    const deleteComment = useDeleteRoomComment(comment.roomId);
    const editComment = useEditRoomComment(comment.roomId);
    const addReaction = useAddRoomCommentReaction(comment.roomId);
    const removeReaction = useRemoveRoomCommentReaction(comment.roomId);
    const $3 = useOverrides(overrides);
    const [isEditing, setEditing] = (0, import_react78.useState)(false);
    const [isTarget, setTarget] = (0, import_react78.useState)(false);
    const [isMoreActionOpen, setMoreActionOpen] = (0, import_react78.useState)(false);
    const [isReactionActionOpen, setReactionActionOpen] = (0, import_react78.useState)(false);
    const { mediaAttachments, fileAttachments } = (0, import_react78.useMemo)(() => {
      return separateMediaAttachments(comment.attachments);
    }, [comment.attachments]);
    const permissions = useRoomPermissions(comment.roomId);
    const canComment = permissions.size > 0 ? permissions.has(Permission.CommentsWrite) || permissions.has(Permission.Write) : true;
    const stopPropagation = (0, import_react78.useCallback)((event) => {
      event.stopPropagation();
    }, []);
    const handleEdit = (0, import_react78.useCallback)(() => {
      setEditing(true);
    }, []);
    const handleEditCancel = (0, import_react78.useCallback)(
      (event) => {
        event.stopPropagation();
        setEditing(false);
      },
      []
    );
    const handleEditSubmit = (0, import_react78.useCallback)(
      ({ body, attachments }, event) => {
        onCommentEdit == null ? void 0 : onCommentEdit(comment);
        if (event.isDefaultPrevented()) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        setEditing(false);
        editComment({
          commentId: comment.id,
          threadId: comment.threadId,
          body,
          attachments
        });
      },
      [comment, editComment, onCommentEdit]
    );
    const handleDelete = (0, import_react78.useCallback)(() => {
      onCommentDelete == null ? void 0 : onCommentDelete(comment);
      deleteComment({
        commentId: comment.id,
        threadId: comment.threadId
      });
    }, [comment, deleteComment, onCommentDelete]);
    const handleAuthorClick = (0, import_react78.useCallback)(
      (event) => {
        onAuthorClick == null ? void 0 : onAuthorClick(comment.userId, event);
      },
      [comment.userId, onAuthorClick]
    );
    const handleReactionSelect = (0, import_react78.useCallback)(
      (emoji) => {
        var _a3;
        const reactionIndex = comment.reactions.findIndex(
          (reaction) => reaction.emoji === emoji
        );
        if (reactionIndex >= 0 && currentUserId && ((_a3 = comment.reactions[reactionIndex]) == null ? void 0 : _a3.users.some(
          (user) => user.id === currentUserId
        ))) {
          removeReaction({
            threadId: comment.threadId,
            commentId: comment.id,
            emoji
          });
        } else {
          addReaction({
            threadId: comment.threadId,
            commentId: comment.id,
            emoji
          });
        }
      },
      [
        addReaction,
        comment.id,
        comment.reactions,
        comment.threadId,
        removeReaction,
        currentUserId
      ]
    );
    (0, import_react78.useEffect)(() => {
      const isWindowDefined = typeof window !== "undefined";
      if (!isWindowDefined)
        return;
      const hash = window.location.hash;
      const commentId = hash.slice(1);
      if (commentId === comment.id) {
        setTarget(true);
      }
    }, []);
    if (!showDeleted && !comment.body) {
      return null;
    }
    return (0, import_jsx_runtime115.jsx)(TooltipProvider, {
      children: (0, import_jsx_runtime115.jsxs)(ComponentsProvider, {
        components,
        children: [
          autoMarkReadThreadId && (0, import_jsx_runtime115.jsx)(AutoMarkReadThreadIdHandler, {
            commentRef: ref,
            threadId: autoMarkReadThreadId,
            roomId: comment.roomId
          }),
          (0, import_jsx_runtime115.jsxs)("div", {
            id: comment.id,
            className: cn(
              "lb-root lb-comment",
              indentContent && "lb-comment:indent-content",
              showActions === "hover" && "lb-comment:show-actions-hover",
              (isMoreActionOpen || isReactionActionOpen) && "lb-comment:action-open",
              className
            ),
            "data-deleted": !comment.body ? "" : void 0,
            "data-editing": isEditing ? "" : void 0,
            "data-target": isTarget ? "" : void 0,
            dir: $3.dir,
            ...props,
            ref: mergedRefs,
            children: [
              (0, import_jsx_runtime115.jsxs)("div", {
                className: "lb-comment-header",
                children: [
                  (0, import_jsx_runtime115.jsxs)("div", {
                    className: "lb-comment-details",
                    children: [
                      (0, import_jsx_runtime115.jsx)(Avatar, {
                        className: "lb-comment-avatar",
                        userId: comment.userId,
                        onClick: handleAuthorClick
                      }),
                      (0, import_jsx_runtime115.jsxs)("span", {
                        className: "lb-comment-details-labels",
                        children: [
                          (0, import_jsx_runtime115.jsx)(User, {
                            className: "lb-comment-author",
                            userId: comment.userId,
                            onClick: handleAuthorClick
                          }),
                          (0, import_jsx_runtime115.jsxs)("span", {
                            className: "lb-comment-date",
                            children: [
                              (0, import_jsx_runtime115.jsx)(Timestamp, {
                                locale: $3.locale,
                                date: comment.createdAt,
                                className: "lb-date lb-comment-date-created"
                              }),
                              comment.editedAt && comment.body && (0, import_jsx_runtime115.jsxs)(import_jsx_runtime115.Fragment, {
                                children: [
                                  " ",
                                  (0, import_jsx_runtime115.jsx)("span", {
                                    className: "lb-comment-date-edited",
                                    children: $3.COMMENT_EDITED
                                  })
                                ]
                              })
                            ]
                          })
                        ]
                      })
                    ]
                  }),
                  showActions && !isEditing && (0, import_jsx_runtime115.jsxs)("div", {
                    className: cn(
                      "lb-comment-actions",
                      additionalActionsClassName
                    ),
                    children: [
                      additionalActions ?? null,
                      showReactions && canComment ? (0, import_jsx_runtime115.jsx)(EmojiPicker, {
                        onEmojiSelect: handleReactionSelect,
                        onOpenChange: setReactionActionOpen,
                        children: (0, import_jsx_runtime115.jsx)(Tooltip2, {
                          content: $3.COMMENT_ADD_REACTION,
                          children: (0, import_jsx_runtime115.jsx)(PopoverTrigger, {
                            asChild: true,
                            children: (0, import_jsx_runtime115.jsx)(Button, {
                              className: "lb-comment-action",
                              onClick: stopPropagation,
                              "aria-label": $3.COMMENT_ADD_REACTION,
                              icon: (0, import_jsx_runtime115.jsx)(EmojiPlusIcon, {})
                            })
                          })
                        })
                      }) : null,
                      comment.userId === currentUserId || additionalDropdownItemsBefore || additionalDropdownItemsAfter ? (0, import_jsx_runtime115.jsx)(Dropdown, {
                        open: isMoreActionOpen,
                        onOpenChange: setMoreActionOpen,
                        align: "end",
                        content: (0, import_jsx_runtime115.jsxs)(import_jsx_runtime115.Fragment, {
                          children: [
                            additionalDropdownItemsBefore,
                            comment.userId === currentUserId && (0, import_jsx_runtime115.jsxs)(import_jsx_runtime115.Fragment, {
                              children: [
                                (0, import_jsx_runtime115.jsx)(DropdownItem, {
                                  onSelect: handleEdit,
                                  onClick: stopPropagation,
                                  icon: (0, import_jsx_runtime115.jsx)(EditIcon, {}),
                                  children: $3.COMMENT_EDIT
                                }),
                                (0, import_jsx_runtime115.jsx)(DropdownItem, {
                                  onSelect: handleDelete,
                                  onClick: stopPropagation,
                                  icon: (0, import_jsx_runtime115.jsx)(DeleteIcon, {}),
                                  children: $3.COMMENT_DELETE
                                })
                              ]
                            }),
                            additionalDropdownItemsAfter
                          ]
                        }),
                        children: (0, import_jsx_runtime115.jsx)(Tooltip2, {
                          content: $3.COMMENT_MORE,
                          children: (0, import_jsx_runtime115.jsx)(DropdownMenuTrigger, {
                            asChild: true,
                            children: (0, import_jsx_runtime115.jsx)(Button, {
                              className: "lb-comment-action",
                              disabled: !comment.body,
                              onClick: stopPropagation,
                              "aria-label": $3.COMMENT_MORE,
                              icon: (0, import_jsx_runtime115.jsx)(EllipsisIcon, {})
                            })
                          })
                        })
                      }) : null
                    ]
                  })
                ]
              }),
              (0, import_jsx_runtime115.jsx)("div", {
                className: "lb-comment-content",
                children: isEditing ? (0, import_jsx_runtime115.jsx)(Composer, {
                  className: "lb-comment-composer",
                  onComposerSubmit: handleEditSubmit,
                  defaultValue: comment.body,
                  defaultAttachments: comment.attachments,
                  autoFocus: true,
                  showAttribution: false,
                  showAttachments,
                  showFormattingControls: showComposerFormattingControls,
                  actions: (0, import_jsx_runtime115.jsxs)(import_jsx_runtime115.Fragment, {
                    children: [
                      (0, import_jsx_runtime115.jsx)(Tooltip2, {
                        content: $3.COMMENT_EDIT_COMPOSER_CANCEL,
                        "aria-label": $3.COMMENT_EDIT_COMPOSER_CANCEL,
                        children: (0, import_jsx_runtime115.jsx)(Button, {
                          className: "lb-composer-action",
                          onClick: handleEditCancel,
                          icon: (0, import_jsx_runtime115.jsx)(CrossIcon, {})
                        })
                      }),
                      (0, import_jsx_runtime115.jsx)(ShortcutTooltip, {
                        content: $3.COMMENT_EDIT_COMPOSER_SAVE,
                        shortcut: "Enter",
                        children: (0, import_jsx_runtime115.jsx)(ComposerSubmit, {
                          asChild: true,
                          children: (0, import_jsx_runtime115.jsx)(Button, {
                            variant: "primary",
                            className: "lb-composer-action",
                            onClick: stopPropagation,
                            "aria-label": $3.COMMENT_EDIT_COMPOSER_SAVE,
                            icon: (0, import_jsx_runtime115.jsx)(CheckIcon, {})
                          })
                        })
                      })
                    ]
                  }),
                  overrides: {
                    COMPOSER_PLACEHOLDER: $3.COMMENT_EDIT_COMPOSER_PLACEHOLDER
                  },
                  roomId: comment.roomId
                }) : comment.body ? (0, import_jsx_runtime115.jsxs)(import_jsx_runtime115.Fragment, {
                  children: [
                    (0, import_jsx_runtime115.jsx)(CommentBody, {
                      className: "lb-comment-body",
                      body: comment.body,
                      components: {
                        Mention: ({ mention }) => (0, import_jsx_runtime115.jsx)(CommentMention2, {
                          mention,
                          onClick: (event) => onMentionClick == null ? void 0 : onMentionClick(mention, event),
                          overrides
                        }),
                        Link: CommentLink2
                      }
                    }),
                    showAttachments && (mediaAttachments.length > 0 || fileAttachments.length > 0) ? (0, import_jsx_runtime115.jsxs)("div", {
                      className: "lb-comment-attachments",
                      children: [
                        mediaAttachments.length > 0 ? (0, import_jsx_runtime115.jsx)("div", {
                          className: "lb-attachments",
                          children: mediaAttachments.map((attachment) => (0, import_jsx_runtime115.jsx)(CommentMediaAttachment, {
                            attachment,
                            overrides,
                            onAttachmentClick,
                            roomId: comment.roomId
                          }, attachment.id))
                        }) : null,
                        fileAttachments.length > 0 ? (0, import_jsx_runtime115.jsx)("div", {
                          className: "lb-attachments",
                          children: fileAttachments.map((attachment) => (0, import_jsx_runtime115.jsx)(CommentFileAttachment, {
                            attachment,
                            overrides,
                            onAttachmentClick,
                            roomId: comment.roomId
                          }, attachment.id))
                        }) : null
                      ]
                    }) : null,
                    showReactions && comment.reactions.length > 0 && (0, import_jsx_runtime115.jsxs)("div", {
                      className: "lb-comment-reactions",
                      children: [
                        comment.reactions.map((reaction) => (0, import_jsx_runtime115.jsx)(CommentReaction, {
                          comment,
                          reaction,
                          overrides,
                          disabled: !canComment
                        }, reaction.emoji)),
                        canComment ? (0, import_jsx_runtime115.jsx)(EmojiPicker, {
                          onEmojiSelect: handleReactionSelect,
                          children: (0, import_jsx_runtime115.jsx)(Tooltip2, {
                            content: $3.COMMENT_ADD_REACTION,
                            children: (0, import_jsx_runtime115.jsx)(PopoverTrigger, {
                              asChild: true,
                              children: (0, import_jsx_runtime115.jsx)(Button, {
                                className: "lb-comment-reaction lb-comment-reaction-add",
                                variant: "outline",
                                onClick: stopPropagation,
                                "aria-label": $3.COMMENT_ADD_REACTION,
                                icon: (0, import_jsx_runtime115.jsx)(EmojiPlusIcon, {})
                              })
                            })
                          })
                        }) : null
                      ]
                    })
                  ]
                }) : (0, import_jsx_runtime115.jsx)("div", {
                  className: "lb-comment-body",
                  children: (0, import_jsx_runtime115.jsx)("p", {
                    className: "lb-comment-deleted",
                    children: $3.COMMENT_DELETED
                  })
                })
              })
            ]
          })
        ]
      })
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/components/HistoryVersionSummary.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);
var AUTHORS_TRUNCATE = 3;
var HistoryVersionSummary = (0, import_react79.forwardRef)(({ version: version2, selected, className, ...props }, forwardedRef) => {
  const $3 = useOverrides();
  return (0, import_jsx_runtime116.jsxs)("button", {
    ...props,
    className: cn("lb-root lb-history-version-summary", className),
    ref: forwardedRef,
    "data-selected": selected ? "" : void 0,
    children: [
      (0, import_jsx_runtime116.jsx)(Timestamp, {
        locale: $3.locale,
        date: version2.createdAt,
        className: "lb-date lb-history-version-summary-date"
      }),
      (0, import_jsx_runtime116.jsx)("span", {
        className: "lb-history-version-summary-authors",
        children: (0, import_jsx_runtime116.jsx)(List, {
          values: version2.authors.map((author) => (0, import_jsx_runtime116.jsx)(User, {
            userId: author.id,
            replaceSelf: true
          }, author.id)),
          formatRemaining: $3.LIST_REMAINING_USERS,
          truncate: AUTHORS_TRUNCATE,
          locale: $3.locale
        })
      })
    ]
  });
});

// node_modules/@liveblocks/react-ui/dist/components/HistoryVersionSummaryList.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react80 = __toESM(require_react(), 1);
var HistoryVersionSummaryList = (0, import_react80.forwardRef)(({ children, className, ...props }, forwardedRef) => {
  return (0, import_jsx_runtime117.jsx)("ol", {
    className: cn("lb-root lb-history-version-summary-list", className),
    ...props,
    ref: forwardedRef,
    children: import_react80.Children.map(children, (child, index2) => (0, import_jsx_runtime117.jsx)("li", {
      className: "lb-history-version-summary-list-item",
      children: child
    }, index2))
  });
});

// node_modules/@liveblocks/react-ui/dist/components/InboxNotification.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react84 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-ui/dist/components/internal/InboxNotificationThread.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var INBOX_NOTIFICATION_THREAD_MAX_COMMENTS = 3;
function InboxNotificationComment({
  comment,
  showHeader = true,
  showAttachments = true,
  showReactions = true,
  overrides,
  className,
  ...props
}) {
  const $3 = useOverrides(overrides);
  return (0, import_jsx_runtime118.jsxs)("div", {
    className: cn(
      "lb-root lb-inbox-notification-comment lb-comment",
      className
    ),
    ...props,
    children: [
      showHeader && (0, import_jsx_runtime118.jsx)("div", {
        className: "lb-comment-header",
        children: (0, import_jsx_runtime118.jsx)(User, {
          className: "lb-comment-author",
          userId: comment.userId
        })
      }),
      (0, import_jsx_runtime118.jsx)("div", {
        className: "lb-comment-content",
        children: comment.body ? (0, import_jsx_runtime118.jsxs)(import_jsx_runtime118.Fragment, {
          children: [
            (0, import_jsx_runtime118.jsx)(CommentBody, {
              className: "lb-comment-body",
              body: comment.body,
              components: {
                Mention: CommentMention2,
                Link: CommentNonInteractiveLink
              }
            }),
            showReactions && comment.reactions.length > 0 && (0, import_jsx_runtime118.jsx)("div", {
              className: "lb-comment-reactions",
              children: comment.reactions.map((reaction) => (0, import_jsx_runtime118.jsx)(CommentNonInteractiveReaction, {
                reaction,
                overrides,
                disabled: true
              }, reaction.emoji))
            }),
            showAttachments && comment.attachments.length > 0 ? (0, import_jsx_runtime118.jsx)("div", {
              className: "lb-comment-attachments",
              children: (0, import_jsx_runtime118.jsx)("div", {
                className: "lb-attachments",
                children: comment.attachments.map((attachment) => (0, import_jsx_runtime118.jsx)(CommentNonInteractiveFileAttachment, {
                  attachment,
                  overrides,
                  roomId: comment.roomId
                }, attachment.id))
              })
            }) : null
          ]
        }) : (0, import_jsx_runtime118.jsx)("div", {
          className: "lb-comment-body",
          children: (0, import_jsx_runtime118.jsx)("p", {
            className: "lb-comment-deleted",
            children: $3.COMMENT_DELETED
          })
        })
      })
    ]
  });
}
function findLastCommentWithMentionedId(client, comments, mentionedId) {
  var _a3;
  if (!comments.length) {
    return;
  }
  for (let i = comments.length - 1; i >= 0; i--) {
    const comment = comments[i];
    if (comment.userId === mentionedId) {
      continue;
    }
    if (comment.body) {
      const mentions = getMentionsFromCommentBody(comment.body);
      for (const mention of mentions) {
        if (mention.kind === "user" && mention.id === mentionedId) {
          return comment;
        }
        if (mention.kind === "group" && ((_a3 = mention.userIds) == null ? void 0 : _a3.includes(mentionedId))) {
          return comment;
        }
        if (mention.kind === "group" && mention.userIds === void 0) {
          const group = client[kInternal].httpClient.groupsStore.getData(
            mention.id
          );
          if (group == null ? void 0 : group.members.some((member) => member.id === mentionedId)) {
            return comment;
          }
        }
      }
    }
  }
  return;
}
function getUserIdsFromComments(comments) {
  return Array.from(new Set(comments.map((comment) => comment.userId)));
}
function generateInboxNotificationThreadContents(client, inboxNotification, thread, userId) {
  const unreadComments = thread.comments.filter((comment) => {
    if (!comment.body) {
      return false;
    }
    return inboxNotification.readAt ? comment.createdAt > inboxNotification.readAt && comment.createdAt <= inboxNotification.notifiedAt : comment.createdAt <= inboxNotification.notifiedAt;
  });
  if (unreadComments.length === 0) {
    const lastComments = thread.comments.filter((comment) => comment.body).slice(-INBOX_NOTIFICATION_THREAD_MAX_COMMENTS);
    return {
      type: "comments",
      unread: false,
      comments: lastComments,
      userIds: getUserIdsFromComments(lastComments),
      date: inboxNotification.notifiedAt
    };
  }
  const commentWithMention = findLastCommentWithMentionedId(
    client,
    unreadComments,
    userId
  );
  if (commentWithMention) {
    return {
      type: "mention",
      unread: true,
      comments: [commentWithMention],
      userIds: [commentWithMention.userId],
      date: commentWithMention.createdAt
    };
  }
  const lastUnreadComments = unreadComments.slice(
    -INBOX_NOTIFICATION_THREAD_MAX_COMMENTS
  );
  return {
    type: "comments",
    unread: true,
    comments: lastUnreadComments,
    userIds: getUserIdsFromComments(unreadComments),
    date: inboxNotification.notifiedAt
  };
}

// node_modules/@liveblocks/react-ui/dist/components/internal/Room.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);
function Room({ roomId, className, ...props }) {
  const { info, isLoading } = useRoomInfo(roomId);
  const resolvedRoomName = (0, import_react82.useMemo)(() => {
    return (info == null ? void 0 : info.name) ?? roomId;
  }, [info == null ? void 0 : info.name, roomId]);
  return (0, import_jsx_runtime119.jsx)("span", {
    className: cn("lb-name lb-room", className),
    "data-loading": isLoading ? "" : void 0,
    ...props,
    children: isLoading ? null : resolvedRoomName
  });
}

// node_modules/@liveblocks/react-ui/dist/components/InboxNotification.js
var InboxNotificationLayout = (0, import_react84.forwardRef)(
  ({
    inboxNotification,
    children,
    aside,
    title,
    date,
    unread,
    markAsReadOnClick,
    onClick,
    href,
    showActions,
    overrides,
    components,
    className,
    asChild,
    additionalDropdownItemsBefore,
    additionalDropdownItemsAfter,
    ...props
  }, forwardedRef) => {
    const $3 = useOverrides(overrides);
    const { Anchor: Anchor3 } = useComponents(components);
    const Component3 = asChild ? Slot : Anchor3;
    const [isMoreActionOpen, setMoreActionOpen] = (0, import_react84.useState)(false);
    const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();
    const deleteInboxNotification = useDeleteInboxNotification();
    const handleClick = (0, import_react84.useCallback)(
      (event) => {
        onClick == null ? void 0 : onClick(event);
        const shouldMarkAsReadOnClick = markAsReadOnClick ?? Boolean(href);
        if (unread && shouldMarkAsReadOnClick) {
          markInboxNotificationAsRead(inboxNotification.id);
        }
      },
      [
        href,
        inboxNotification.id,
        markAsReadOnClick,
        markInboxNotificationAsRead,
        onClick,
        unread
      ]
    );
    const stopPropagation = (0, import_react84.useCallback)((event) => {
      event.stopPropagation();
    }, []);
    const preventDefaultAndStopPropagation = (0, import_react84.useCallback)(
      (event) => {
        event.preventDefault();
        event.stopPropagation();
      },
      []
    );
    const handleMoreClick = (0, import_react84.useCallback)((event) => {
      event.preventDefault();
      event.stopPropagation();
      setMoreActionOpen((open) => !open);
    }, []);
    const handleMarkAsRead = (0, import_react84.useCallback)(() => {
      markInboxNotificationAsRead(inboxNotification.id);
    }, [inboxNotification.id, markInboxNotificationAsRead]);
    const handleDelete = (0, import_react84.useCallback)(() => {
      deleteInboxNotification(inboxNotification.id);
    }, [inboxNotification.id, deleteInboxNotification]);
    return (0, import_jsx_runtime120.jsx)(TooltipProvider, {
      children: (0, import_jsx_runtime120.jsxs)(Component3, {
        className: cn(
          "lb-root lb-inbox-notification",
          showActions === "hover" && "lb-inbox-notification:show-actions-hover",
          isMoreActionOpen && "lb-inbox-notification:action-open",
          className
        ),
        dir: $3.dir,
        "data-unread": unread ? "" : void 0,
        "data-kind": inboxNotification.kind,
        onClick: handleClick,
        href,
        ...props,
        ref: forwardedRef,
        children: [
          aside && (0, import_jsx_runtime120.jsx)("div", {
            className: "lb-inbox-notification-aside",
            children: aside
          }),
          (0, import_jsx_runtime120.jsxs)("div", {
            className: "lb-inbox-notification-content",
            children: [
              (0, import_jsx_runtime120.jsxs)("div", {
                className: "lb-inbox-notification-header",
                children: [
                  (0, import_jsx_runtime120.jsx)("span", {
                    className: "lb-inbox-notification-title",
                    children: title
                  }),
                  (0, import_jsx_runtime120.jsx)("div", {
                    className: "lb-inbox-notification-details",
                    children: (0, import_jsx_runtime120.jsxs)("span", {
                      className: "lb-inbox-notification-details-labels",
                      children: [
                        (0, import_jsx_runtime120.jsx)(Timestamp, {
                          locale: $3.locale,
                          date,
                          className: "lb-date lb-inbox-notification-date"
                        }),
                        unread && (0, import_jsx_runtime120.jsx)("span", {
                          className: "lb-inbox-notification-unread-indicator",
                          role: "presentation"
                        })
                      ]
                    })
                  }),
                  showActions && (0, import_jsx_runtime120.jsx)("div", {
                    className: "lb-inbox-notification-actions",
                    children: (0, import_jsx_runtime120.jsx)(Dropdown, {
                      open: isMoreActionOpen,
                      onOpenChange: setMoreActionOpen,
                      align: "end",
                      content: (0, import_jsx_runtime120.jsxs)(import_jsx_runtime120.Fragment, {
                        children: [
                          additionalDropdownItemsBefore,
                          unread ? (0, import_jsx_runtime120.jsx)(DropdownItem, {
                            onSelect: handleMarkAsRead,
                            onClick: stopPropagation,
                            icon: (0, import_jsx_runtime120.jsx)(CheckIcon, {}),
                            children: $3.INBOX_NOTIFICATION_MARK_AS_READ
                          }) : null,
                          (0, import_jsx_runtime120.jsx)(DropdownItem, {
                            onSelect: handleDelete,
                            onClick: stopPropagation,
                            icon: (0, import_jsx_runtime120.jsx)(DeleteIcon, {}),
                            children: $3.INBOX_NOTIFICATION_DELETE
                          }),
                          additionalDropdownItemsAfter
                        ]
                      }),
                      children: (0, import_jsx_runtime120.jsx)(Tooltip2, {
                        content: $3.INBOX_NOTIFICATION_MORE,
                        children: (0, import_jsx_runtime120.jsx)(DropdownMenuTrigger, {
                          asChild: true,
                          children: (0, import_jsx_runtime120.jsx)(Button, {
                            className: "lb-inbox-notification-action",
                            onClick: handleMoreClick,
                            onPointerDown: preventDefaultAndStopPropagation,
                            onPointerUp: preventDefaultAndStopPropagation,
                            "aria-label": $3.INBOX_NOTIFICATION_MORE,
                            icon: (0, import_jsx_runtime120.jsx)(EllipsisIcon, {})
                          })
                        })
                      })
                    })
                  })
                ]
              }),
              (0, import_jsx_runtime120.jsx)("div", {
                className: "lb-inbox-notification-body",
                children
              })
            ]
          })
        ]
      })
    });
  }
);
function InboxNotificationIcon({
  className,
  ...props
}) {
  return (0, import_jsx_runtime120.jsx)("div", {
    className: cn("lb-inbox-notification-icon", className),
    ...props
  });
}
function InboxNotificationAvatar({
  className,
  ...props
}) {
  return (0, import_jsx_runtime120.jsx)(Avatar, {
    className: cn("lb-inbox-notification-avatar", className),
    ...props
  });
}
var InboxNotificationThread = (0, import_react84.forwardRef)(
  ({
    inboxNotification,
    href,
    showRoomName = true,
    showReactions = true,
    showAttachments = true,
    showActions = "hover",
    overrides,
    ...props
  }, forwardedRef) => {
    const $3 = useOverrides(overrides);
    const client = useClient();
    const thread = _useInboxNotificationThread(inboxNotification.id);
    const {
      status: subscriptionStatus,
      subscribe: subscribe2,
      unsubscribe
    } = useRoomThreadSubscription(thread.roomId, thread.id);
    const currentUserId = useCurrentUserId();
    const { info } = useRoomInfo(inboxNotification.roomId);
    const contents = (0, import_react84.useMemo)(() => {
      const contents2 = generateInboxNotificationThreadContents(
        client,
        inboxNotification,
        thread,
        currentUserId ?? ""
      );
      if (contents2.comments.length === 0 || contents2.userIds.length === 0) {
        return null;
      }
      switch (contents2.type) {
        case "comments": {
          const reversedUserIds = [...contents2.userIds].reverse();
          const firstUserId = reversedUserIds[0];
          const aside2 = (0, import_jsx_runtime120.jsx)(InboxNotificationAvatar, {
            userId: firstUserId
          });
          const title2 = $3.INBOX_NOTIFICATION_THREAD_COMMENTS_LIST(
            (0, import_jsx_runtime120.jsx)(List, {
              values: reversedUserIds.map((userId) => (0, import_jsx_runtime120.jsx)(User, {
                userId,
                replaceSelf: true
              }, userId)),
              formatRemaining: $3.LIST_REMAINING_USERS,
              truncate: INBOX_NOTIFICATION_THREAD_MAX_COMMENTS - 1,
              locale: $3.locale
            }),
            showRoomName ? (0, import_jsx_runtime120.jsx)(Room, {
              roomId: thread.roomId
            }) : void 0,
            reversedUserIds.length
          );
          const content2 = (0, import_jsx_runtime120.jsx)("div", {
            className: "lb-inbox-notification-comments",
            children: contents2.comments.map((comment) => (0, import_jsx_runtime120.jsx)(InboxNotificationComment, {
              comment,
              showHeader: contents2.comments.length > 1,
              showAttachments,
              showReactions,
              overrides
            }, comment.id))
          });
          return {
            unread: contents2.unread,
            date: contents2.date,
            aside: aside2,
            title: title2,
            content: content2,
            threadId: thread.id,
            commentId: contents2.comments[contents2.comments.length - 1].id
          };
        }
        case "mention": {
          const mentionCreatedBy = contents2.userIds[0];
          const mentionComment = contents2.comments[0];
          const aside2 = (0, import_jsx_runtime120.jsx)(InboxNotificationAvatar, {
            userId: mentionCreatedBy
          });
          const title2 = $3.INBOX_NOTIFICATION_THREAD_MENTION(
            (0, import_jsx_runtime120.jsx)(User, {
              userId: mentionCreatedBy
            }, mentionCreatedBy),
            showRoomName ? (0, import_jsx_runtime120.jsx)(Room, {
              roomId: thread.roomId
            }) : void 0
          );
          const content2 = (0, import_jsx_runtime120.jsx)("div", {
            className: "lb-inbox-notification-comments",
            children: (0, import_jsx_runtime120.jsx)(InboxNotificationComment, {
              comment: mentionComment,
              showHeader: false,
              showAttachments,
              showReactions,
              overrides
            }, mentionComment.id)
          });
          return {
            unread: contents2.unread,
            date: contents2.date,
            aside: aside2,
            title: title2,
            content: content2,
            threadId: thread.id,
            commentId: mentionComment.id
          };
        }
        default:
          return assertNever(
            contents2,
            "Unexpected thread inbox notification type"
          );
      }
    }, [
      $3,
      client,
      currentUserId,
      inboxNotification,
      overrides,
      showRoomName,
      showAttachments,
      showReactions,
      thread
    ]);
    const resolvedHref = (0, import_react84.useMemo)(() => {
      const resolvedHref2 = href ?? (info == null ? void 0 : info.url);
      return resolvedHref2 ? generateUrl(resolvedHref2, void 0, contents == null ? void 0 : contents.commentId) : void 0;
    }, [contents == null ? void 0 : contents.commentId, href, info == null ? void 0 : info.url]);
    const handleSubscribeChange = (0, import_react84.useCallback)(() => {
      if (subscriptionStatus === "subscribed") {
        unsubscribe();
      } else {
        subscribe2();
      }
    }, [subscriptionStatus, subscribe2, unsubscribe]);
    const stopPropagation = (0, import_react84.useCallback)((event) => {
      event.stopPropagation();
    }, []);
    if (!contents) {
      return null;
    }
    const { aside, title, content, date, unread } = contents;
    return (0, import_jsx_runtime120.jsx)(InboxNotificationLayout, {
      inboxNotification,
      aside,
      title,
      date,
      unread,
      overrides,
      href: resolvedHref,
      showActions,
      markAsReadOnClick: false,
      additionalDropdownItemsBefore: (0, import_jsx_runtime120.jsx)(DropdownItem, {
        onSelect: handleSubscribeChange,
        onClick: stopPropagation,
        icon: subscriptionStatus === "subscribed" ? (0, import_jsx_runtime120.jsx)(BellCrossedIcon, {}) : (0, import_jsx_runtime120.jsx)(BellIcon, {}),
        children: subscriptionStatus === "subscribed" ? $3.THREAD_UNSUBSCRIBE : $3.THREAD_SUBSCRIBE
      }),
      ...props,
      ref: forwardedRef,
      children: content
    });
  }
);
var InboxNotificationTextMention = (0, import_react84.forwardRef)(
  ({
    inboxNotification,
    showActions = "hover",
    showRoomName = true,
    href,
    overrides,
    ...props
  }, ref) => {
    const $3 = useOverrides(overrides);
    const { info } = useRoomInfo(inboxNotification.roomId);
    const resolvedHref = (0, import_react84.useMemo)(() => {
      const resolvedHref2 = href ?? (info == null ? void 0 : info.url);
      return resolvedHref2 ? sanitizeUrl(resolvedHref2) ?? void 0 : void 0;
    }, [href, info == null ? void 0 : info.url]);
    const unread = (0, import_react84.useMemo)(() => {
      return !inboxNotification.readAt || inboxNotification.notifiedAt > inboxNotification.readAt;
    }, [inboxNotification.notifiedAt, inboxNotification.readAt]);
    return (0, import_jsx_runtime120.jsx)(InboxNotificationLayout, {
      inboxNotification,
      aside: (0, import_jsx_runtime120.jsx)(InboxNotificationAvatar, {
        userId: inboxNotification.createdBy
      }),
      title: $3.INBOX_NOTIFICATION_TEXT_MENTION(
        (0, import_jsx_runtime120.jsx)(User, {
          userId: inboxNotification.createdBy
        }, inboxNotification.createdBy),
        showRoomName ? (0, import_jsx_runtime120.jsx)(Room, {
          roomId: inboxNotification.roomId
        }) : void 0
      ),
      date: inboxNotification.notifiedAt,
      unread,
      overrides,
      showActions,
      href: resolvedHref,
      ...props,
      ref
    });
  }
);
var InboxNotificationCustom = (0, import_react84.forwardRef)(
  ({
    inboxNotification,
    showActions = "hover",
    title,
    aside,
    children,
    overrides,
    ...props
  }, forwardedRef) => {
    const unread = (0, import_react84.useMemo)(() => {
      return !inboxNotification.readAt || inboxNotification.notifiedAt > inboxNotification.readAt;
    }, [inboxNotification.notifiedAt, inboxNotification.readAt]);
    return (0, import_jsx_runtime120.jsx)(InboxNotificationLayout, {
      inboxNotification,
      aside,
      title,
      date: inboxNotification.notifiedAt,
      unread,
      overrides,
      showActions,
      ...props,
      ref: forwardedRef,
      children
    });
  }
);
var InboxNotificationInspector = (0, import_react84.forwardRef)(
  ({ inboxNotification, showActions = "hover", overrides, ...props }, forwardedRef) => {
    const unread = (0, import_react84.useMemo)(() => {
      return !inboxNotification.readAt || inboxNotification.notifiedAt > inboxNotification.readAt;
    }, [inboxNotification.notifiedAt, inboxNotification.readAt]);
    return (0, import_jsx_runtime120.jsx)(InboxNotificationLayout, {
      inboxNotification,
      title: (0, import_jsx_runtime120.jsx)("code", {
        children: inboxNotification.id
      }),
      date: inboxNotification.notifiedAt,
      unread,
      overrides,
      showActions,
      ...props,
      ref: forwardedRef,
      "data-inspector": "",
      children: (0, import_jsx_runtime120.jsx)(CodeBlock, {
        title: "Data",
        code: JSON.stringify(inboxNotification, null, 2)
      })
    });
  }
);
var InboxNotificationCustomMissing = (0, import_react84.forwardRef)(({ inboxNotification, ...props }, forwardedRef) => {
  return (0, import_jsx_runtime120.jsxs)(InboxNotificationCustom, {
    inboxNotification,
    ...props,
    title: (0, import_jsx_runtime120.jsxs)(import_jsx_runtime120.Fragment, {
      children: [
        "Custom notification kind ",
        (0, import_jsx_runtime120.jsx)("code", {
          children: inboxNotification.kind
        }),
        " is not handled"
      ]
    }),
    aside: (0, import_jsx_runtime120.jsx)(InboxNotificationIcon, {
      children: (0, import_jsx_runtime120.jsx)(WarningIcon, {})
    }),
    ref: forwardedRef,
    "data-missing": "",
    children: [
      "Notifications of this kind won’t be displayed in production. Use the",
      " ",
      (0, import_jsx_runtime120.jsx)("code", {
        children: "kinds"
      }),
      " prop to define how they should be rendered, learn more in the console."
    ]
  });
});
var InboxNotification = Object.assign(
  (0, import_react84.forwardRef)(
    ({ inboxNotification, kinds, ...props }, forwardedRef) => {
      switch (inboxNotification.kind) {
        case "thread": {
          const ResolvedInboxNotificationThread = (kinds == null ? void 0 : kinds.thread) ?? InboxNotificationThread;
          return (0, import_jsx_runtime120.jsx)(ResolvedInboxNotificationThread, {
            inboxNotification,
            ...props,
            ref: forwardedRef
          });
        }
        case "textMention": {
          const ResolvedInboxNotificationTextMention = (kinds == null ? void 0 : kinds.textMention) ?? InboxNotificationTextMention;
          return (0, import_jsx_runtime120.jsx)(ResolvedInboxNotificationTextMention, {
            inboxNotification,
            ...props,
            ref: forwardedRef
          });
        }
        default: {
          const ResolvedInboxNotificationCustom = kinds == null ? void 0 : kinds[inboxNotification.kind];
          if (!ResolvedInboxNotificationCustom) {
            if (true) {
              warnOnce(
                `Custom notification kind "${inboxNotification.kind}" is not handled so notifications of this kind will not be displayed in production. Use the kinds prop to define how they should be rendered. Learn more: https://liveblocks.io/docs/api-reference/liveblocks-react-ui#Rendering-notification-kinds-differently.`
              );
              return (0, import_jsx_runtime120.jsx)(InboxNotificationCustomMissing, {
                inboxNotification,
                ...props,
                ref: forwardedRef
              });
            } else {
              return null;
            }
          }
          return (0, import_jsx_runtime120.jsx)(ResolvedInboxNotificationCustom, {
            inboxNotification,
            ...props,
            ref: forwardedRef
          });
        }
      }
    }
  ),
  {
    Thread: InboxNotificationThread,
    TextMention: InboxNotificationTextMention,
    Custom: InboxNotificationCustom,
    Inspector: InboxNotificationInspector,
    Icon: InboxNotificationIcon,
    Avatar: InboxNotificationAvatar
  }
);

// node_modules/@liveblocks/react-ui/dist/components/InboxNotificationList.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react85 = __toESM(require_react(), 1);
function ReachEndMarker({
  enabled,
  onReachEnd
}) {
  const markerRef = (0, import_react85.useRef)(null);
  useIntersectionCallback(
    markerRef,
    (isIntersecting) => {
      if (isIntersecting) {
        onReachEnd();
      }
    },
    {
      enabled
    }
  );
  return (0, import_jsx_runtime121.jsx)("div", {
    ref: markerRef,
    style: { height: 0 }
  });
}
var InboxNotificationList = (0, import_react85.forwardRef)(({ onReachEnd, children, className, ...props }, forwardedRef) => {
  return (0, import_jsx_runtime121.jsxs)("ol", {
    className: cn("lb-root lb-inbox-notification-list", className),
    ...props,
    ref: forwardedRef,
    children: [
      import_react85.Children.map(children, (child, index2) => (0, import_jsx_runtime121.jsx)("li", {
        className: "lb-inbox-notification-list-item",
        children: child
      }, index2)),
      onReachEnd && (0, import_jsx_runtime121.jsx)(ReachEndMarker, {
        onReachEnd,
        enabled: import_react85.Children.count(children) > 0
      })
    ]
  });
});

// node_modules/@liveblocks/react-ui/dist/components/Thread.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);
var Thread = (0, import_react86.forwardRef)(
  ({
    thread,
    indentCommentContent = true,
    showActions = "hover",
    showDeletedComments,
    showResolveAction = true,
    showReactions = true,
    showComposer = "collapsed",
    showAttachments = true,
    showComposerFormattingControls = true,
    maxVisibleComments,
    onResolvedChange,
    onCommentEdit,
    onCommentDelete,
    onThreadDelete,
    onAuthorClick,
    onMentionClick,
    onAttachmentClick,
    onComposerSubmit,
    blurComposerOnSubmit,
    overrides,
    components,
    className,
    ...props
  }, forwardedRef) => {
    const markThreadAsResolved = useMarkRoomThreadAsResolved(thread.roomId);
    const markThreadAsUnresolved = useMarkRoomThreadAsUnresolved(thread.roomId);
    const $3 = useOverrides(overrides);
    const [showAllComments, setShowAllComments] = (0, import_react86.useState)(false);
    const firstCommentIndex = (0, import_react86.useMemo)(() => {
      return showDeletedComments ? 0 : thread.comments.findIndex((comment) => comment.body);
    }, [showDeletedComments, thread.comments]);
    const lastCommentIndex = (0, import_react86.useMemo)(() => {
      return showDeletedComments ? thread.comments.length - 1 : findLastIndex(thread.comments, (comment) => Boolean(comment.body));
    }, [showDeletedComments, thread.comments]);
    const hiddenComments = (0, import_react86.useMemo)(() => {
      var _a3, _b;
      const maxVisibleCommentsCount = typeof maxVisibleComments === "number" ? maxVisibleComments : maxVisibleComments == null ? void 0 : maxVisibleComments.max;
      const visibleCommentsShow = (typeof maxVisibleComments === "object" ? maxVisibleComments == null ? void 0 : maxVisibleComments.show : void 0) ?? "newest";
      if (showAllComments || maxVisibleCommentsCount === void 0) {
        return;
      }
      const comments = thread.comments.map((comment, index2) => ({ comment, index: index2 })).filter(({ comment }) => showDeletedComments || comment.body);
      if (comments.length <= Math.max(maxVisibleCommentsCount, 2)) {
        return;
      }
      const firstVisibleComment = comments[0];
      const lastVisibleComment = comments[comments.length - 1];
      if (maxVisibleCommentsCount <= 2) {
        const firstHiddenCommentIndex = ((_a3 = comments[1]) == null ? void 0 : _a3.index) ?? firstVisibleComment.index;
        const lastHiddenCommentIndex = ((_b = comments[comments.length - 2]) == null ? void 0 : _b.index) ?? lastVisibleComment.index;
        return {
          firstIndex: firstHiddenCommentIndex,
          lastIndex: lastHiddenCommentIndex,
          count: comments.slice(1, comments.length - 1).length
        };
      }
      const remainingVisibleCommentsCount = maxVisibleCommentsCount - 2;
      const beforeVisibleCommentsCount = visibleCommentsShow === "oldest" ? remainingVisibleCommentsCount : visibleCommentsShow === "newest" ? 0 : Math.floor(remainingVisibleCommentsCount / 2);
      const afterVisibleCommentsCount = visibleCommentsShow === "oldest" ? 0 : visibleCommentsShow === "newest" ? remainingVisibleCommentsCount : Math.ceil(remainingVisibleCommentsCount / 2);
      const firstHiddenComment = comments[1 + beforeVisibleCommentsCount];
      const lastHiddenComment = comments[comments.length - 2 - afterVisibleCommentsCount];
      if (!firstHiddenComment || !lastHiddenComment || firstHiddenComment.index > lastHiddenComment.index) {
        return;
      }
      return {
        firstIndex: firstHiddenComment.index,
        lastIndex: lastHiddenComment.index,
        count: thread.comments.slice(firstHiddenComment.index, lastHiddenComment.index + 1).filter((comment) => showDeletedComments || comment.body).length
      };
    }, [
      maxVisibleComments,
      showAllComments,
      showDeletedComments,
      thread.comments
    ]);
    const {
      status: subscriptionStatus,
      unreadSince,
      subscribe: subscribe2,
      unsubscribe
    } = useRoomThreadSubscription(thread.roomId, thread.id);
    const unreadIndex = (0, import_react86.useMemo)(() => {
      if (subscriptionStatus !== "subscribed") {
        return;
      }
      if (unreadSince === null) {
        return firstCommentIndex;
      }
      const unreadIndex2 = thread.comments.findIndex(
        (comment) => (showDeletedComments ? true : comment.body) && comment.createdAt > unreadSince
      );
      return unreadIndex2 >= 0 && unreadIndex2 < thread.comments.length ? unreadIndex2 : void 0;
    }, [
      firstCommentIndex,
      showDeletedComments,
      subscriptionStatus,
      thread.comments,
      unreadSince
    ]);
    const [newIndex, setNewIndex] = (0, import_react86.useState)();
    const newIndicatorIndex = newIndex === void 0 ? unreadIndex : newIndex;
    (0, import_react86.useEffect)(() => {
      if (unreadIndex) {
        setNewIndex(
          (persistedUnreadIndex) => Math.min(persistedUnreadIndex ?? Infinity, unreadIndex)
        );
      }
    }, [unreadIndex]);
    const permissions = useRoomPermissions(thread.roomId);
    const canComment = permissions.size > 0 ? permissions.has(Permission.CommentsWrite) || permissions.has(Permission.Write) : true;
    const stopPropagation = (0, import_react86.useCallback)((event) => {
      event.stopPropagation();
    }, []);
    const handleResolvedChange = (0, import_react86.useCallback)(
      (resolved) => {
        onResolvedChange == null ? void 0 : onResolvedChange(resolved);
        if (resolved) {
          markThreadAsResolved(thread.id);
        } else {
          markThreadAsUnresolved(thread.id);
        }
      },
      [
        markThreadAsResolved,
        markThreadAsUnresolved,
        onResolvedChange,
        thread.id
      ]
    );
    const handleCommentDelete = (0, import_react86.useCallback)(
      (comment) => {
        onCommentDelete == null ? void 0 : onCommentDelete(comment);
        const filteredComments = thread.comments.filter(
          (comment2) => comment2.body
        );
        if (filteredComments.length <= 1) {
          onThreadDelete == null ? void 0 : onThreadDelete(thread);
        }
      },
      [onCommentDelete, onThreadDelete, thread]
    );
    const handleSubscribeChange = (0, import_react86.useCallback)(() => {
      if (subscriptionStatus === "subscribed") {
        unsubscribe();
      } else {
        subscribe2();
      }
    }, [subscriptionStatus, subscribe2, unsubscribe]);
    return (0, import_jsx_runtime122.jsx)(TooltipProvider, {
      children: (0, import_jsx_runtime122.jsxs)("div", {
        className: cn(
          "lb-root lb-thread",
          showActions === "hover" && "lb-thread:show-actions-hover",
          className
        ),
        "data-resolved": thread.resolved ? "" : void 0,
        "data-unread": unreadIndex !== void 0 ? "" : void 0,
        dir: $3.dir,
        ...props,
        ref: forwardedRef,
        children: [
          (0, import_jsx_runtime122.jsx)("div", {
            className: "lb-thread-comments",
            children: thread.comments.map((comment, index2) => {
              const isFirstComment = index2 === firstCommentIndex;
              const isUnread = unreadIndex !== void 0 && index2 >= unreadIndex;
              const isHidden3 = hiddenComments && index2 >= hiddenComments.firstIndex && index2 <= hiddenComments.lastIndex;
              const isFirstHiddenComment = isHidden3 && index2 === hiddenComments.firstIndex;
              if (isFirstHiddenComment) {
                return (0, import_jsx_runtime122.jsx)("div", {
                  className: "lb-thread-show-more",
                  children: (0, import_jsx_runtime122.jsx)(Button, {
                    variant: "ghost",
                    className: "lb-thread-show-more-button",
                    onClick: () => setShowAllComments(true),
                    children: $3.THREAD_SHOW_MORE_COMMENTS(hiddenComments.count)
                  })
                }, `${comment.id}-show-more`);
              }
              if (isHidden3) {
                return null;
              }
              const children = (0, import_jsx_runtime122.jsx)(Comment, {
                overrides,
                className: "lb-thread-comment",
                "data-unread": isUnread ? "" : void 0,
                comment,
                indentContent: indentCommentContent,
                showDeleted: showDeletedComments,
                showActions,
                showReactions,
                showAttachments,
                showComposerFormattingControls,
                onCommentEdit,
                onCommentDelete: handleCommentDelete,
                onAuthorClick,
                onMentionClick,
                onAttachmentClick,
                components,
                autoMarkReadThreadId: index2 === lastCommentIndex && isUnread ? thread.id : void 0,
                additionalActionsClassName: isFirstComment ? "lb-thread-actions" : void 0,
                additionalActions: isFirstComment && showResolveAction ? (0, import_jsx_runtime122.jsx)(Tooltip2, {
                  content: thread.resolved ? $3.THREAD_UNRESOLVE : $3.THREAD_RESOLVE,
                  children: (0, import_jsx_runtime122.jsx)(Root5, {
                    pressed: thread.resolved,
                    onPressedChange: handleResolvedChange,
                    asChild: true,
                    children: (0, import_jsx_runtime122.jsx)(Button, {
                      className: "lb-comment-action",
                      onClick: stopPropagation,
                      "aria-label": thread.resolved ? $3.THREAD_UNRESOLVE : $3.THREAD_RESOLVE,
                      icon: thread.resolved ? (0, import_jsx_runtime122.jsx)(CheckCircleFillIcon, {}) : (0, import_jsx_runtime122.jsx)(CheckCircleIcon, {}),
                      disabled: !canComment
                    })
                  })
                }) : null,
                additionalDropdownItemsBefore: isFirstComment ? (0, import_jsx_runtime122.jsx)(DropdownItem, {
                  onSelect: handleSubscribeChange,
                  onClick: stopPropagation,
                  icon: subscriptionStatus === "subscribed" ? (0, import_jsx_runtime122.jsx)(BellCrossedIcon, {}) : (0, import_jsx_runtime122.jsx)(BellIcon, {}),
                  children: subscriptionStatus === "subscribed" ? $3.THREAD_UNSUBSCRIBE : $3.THREAD_SUBSCRIBE
                }) : null
              }, comment.id);
              return index2 === newIndicatorIndex && newIndicatorIndex !== firstCommentIndex && newIndicatorIndex <= lastCommentIndex ? (0, import_jsx_runtime122.jsxs)(import_react86.Fragment, {
                children: [
                  (0, import_jsx_runtime122.jsx)("div", {
                    className: "lb-thread-new-indicator",
                    "aria-label": $3.THREAD_NEW_INDICATOR_DESCRIPTION,
                    children: (0, import_jsx_runtime122.jsxs)("span", {
                      className: "lb-thread-new-indicator-label",
                      children: [
                        (0, import_jsx_runtime122.jsx)(ArrowDownIcon, {
                          className: "lb-thread-new-indicator-label-icon"
                        }),
                        $3.THREAD_NEW_INDICATOR
                      ]
                    })
                  }),
                  children
                ]
              }, comment.id) : children;
            })
          }),
          showComposer && (0, import_jsx_runtime122.jsx)(Composer, {
            className: "lb-thread-composer",
            threadId: thread.id,
            defaultCollapsed: showComposer === "collapsed" ? true : void 0,
            showAttachments,
            showFormattingControls: showComposerFormattingControls,
            onComposerSubmit,
            blurOnSubmit: blurComposerOnSubmit,
            overrides: {
              COMPOSER_PLACEHOLDER: $3.THREAD_COMPOSER_PLACEHOLDER,
              COMPOSER_SEND: $3.THREAD_COMPOSER_SEND,
              ...overrides
            },
            roomId: thread.roomId
          })
        ]
      })
    });
  }
);

// node_modules/@liveblocks/react-ui/dist/index.js
detectDupes(PKG_NAME3, PKG_VERSION3, PKG_FORMAT3);

// node_modules/@liveblocks/react-tiptap/dist/comments/AnchoredThreads.js
var import_react88 = __toESM(require_react(), 1);
var DEFAULT_GAP = 20;
var DEFAULT_ACTIVE_THREAD_OFFSET = -12;
var GAP = `var(--lb-tiptap-anchored-threads-gap, ${DEFAULT_GAP}px)`;
var ACTIVE_THREAD_OFFSET = `var(--lb-tiptap-anchored-threads-active-thread-offset, ${DEFAULT_ACTIVE_THREAD_OFFSET}px)`;
function AnchoredThreads({
  threads,
  components,
  className,
  style,
  editor,
  ...props
}) {
  const Thread$1 = (components == null ? void 0 : components.Thread) ?? Thread;
  const containerRef = (0, import_react88.useRef)(null);
  const [orderedThreads, setOrderedThreads] = (0, import_react88.useState)([]);
  const [elements, setElements] = (0, import_react88.useState)(/* @__PURE__ */ new Map());
  const [positions2, setPositions] = (0, import_react88.useState)(/* @__PURE__ */ new Map());
  const { pluginState } = useEditorState({
    editor,
    selector: (ctx) => {
      var _a3;
      if (!((_a3 = ctx == null ? void 0 : ctx.editor) == null ? void 0 : _a3.state))
        return { pluginState: void 0 };
      const state = THREADS_PLUGIN_KEY.getState(ctx.editor.state);
      return {
        pluginState: state
      };
    },
    equalityFn: (prev, next3) => {
      var _a3, _b, _c, _d;
      if (!prev || !next3)
        return false;
      return ((_a3 = prev.pluginState) == null ? void 0 : _a3.selectedThreadId) === ((_b = next3.pluginState) == null ? void 0 : _b.selectedThreadId) && ((_c = prev.pluginState) == null ? void 0 : _c.threadPositions) === ((_d = next3.pluginState) == null ? void 0 : _d.threadPositions);
    }
  }) ?? { pluginState: void 0 };
  const handlePositionThreads = (0, import_react88.useCallback)(() => {
    const container = containerRef.current;
    if (container === null || !editor || !editor.view)
      return;
    const activeIndex = orderedThreads.findIndex(
      ({ thread }) => thread.id === (pluginState == null ? void 0 : pluginState.selectedThreadId)
    );
    const ascending = activeIndex !== -1 ? orderedThreads.slice(activeIndex) : orderedThreads;
    const descending = activeIndex !== -1 ? orderedThreads.slice(0, activeIndex) : [];
    const newPositions = /* @__PURE__ */ new Map();
    for (const { thread, position } of ascending) {
      const coords = editor.view.coordsAtPos(
        Math.min(position.from, editor.view.state.doc.content.size - 1)
      );
      const rect = getRectFromCoords(coords);
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [id, position2] of newPositions) {
        const el = elements.get(id);
        if (el === void 0)
          continue;
        if (top >= position2 && top <= position2 + el.getBoundingClientRect().height) {
          top = position2 + el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    for (const { thread, position } of descending.reverse()) {
      const coords = editor.view.coordsAtPos(position.from);
      const rect = getRectFromCoords(coords);
      const el = elements.get(thread.id);
      if (el === void 0)
        continue;
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [, position2] of newPositions) {
        if (top >= position2 - el.getBoundingClientRect().height) {
          top = position2 - el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    setPositions(newPositions);
  }, [editor, orderedThreads, pluginState == null ? void 0 : pluginState.selectedThreadId, elements]);
  (0, import_react88.useEffect)(() => {
    if (!pluginState)
      return;
    setOrderedThreads(
      Array.from(pluginState.threadPositions, ([threadId, position]) => ({
        threadId,
        position
      })).reduce(
        (acc, { threadId, position }) => {
          const thread = threads.find(
            (thread2) => thread2.id === threadId && !thread2.resolved
          );
          if (!thread)
            return acc;
          acc.push({ thread, position });
          return acc;
        },
        []
      )
    );
    handlePositionThreads();
  }, [pluginState, threads]);
  useLayoutEffect2(handlePositionThreads, [handlePositionThreads]);
  (0, import_react88.useEffect)(() => {
    var _a3;
    const observer = new ResizeObserver(handlePositionThreads);
    const container = (_a3 = editor == null ? void 0 : editor.view) == null ? void 0 : _a3.dom;
    if (container) {
      observer.observe(container);
    }
    for (const element of elements.values()) {
      observer.observe(element);
    }
    return () => observer.disconnect();
  }, [elements, editor, handlePositionThreads]);
  const onItemAdd = (0, import_react88.useCallback)((id, el) => {
    setElements((prev) => new Map(prev).set(id, el));
  }, []);
  const onItemRemove = (0, import_react88.useCallback)((id) => {
    setElements((prev) => {
      const items = new Map(prev);
      items.delete(id);
      return items;
    });
  }, []);
  const onThreadSelect = (0, import_react88.useCallback)(
    (id) => {
      if (!editor)
        return;
      editor.commands.selectThread(id);
    },
    [editor]
  );
  if (!editor)
    return null;
  return (0, import_jsx_runtime123.jsx)("div", {
    ...props,
    className: cn(className, "lb-root lb-tiptap-anchored-threads"),
    ref: containerRef,
    style: {
      position: "relative",
      ...style
    },
    children: orderedThreads.map(({ thread, position }) => {
      if (!editor.view) {
        return null;
      }
      const coords = editor.view.coordsAtPos(
        Math.min(position.from, editor.state.doc.content.size - 1)
      );
      const rect = getRectFromCoords(coords);
      const offset4 = editor.options.element.getBoundingClientRect().top;
      let top = rect.top - offset4;
      if (positions2.has(thread.id)) {
        top = positions2.get(thread.id);
      }
      const isActive = thread.id === (pluginState == null ? void 0 : pluginState.selectedThreadId);
      return (0, import_jsx_runtime123.jsx)(ThreadWrapper, {
        onThreadClick: onThreadSelect,
        onItemAdd,
        onItemRemove,
        Thread: Thread$1,
        thread,
        isActive,
        style: {
          position: "absolute",
          transform: `translate3d(${isActive ? ACTIVE_THREAD_OFFSET : 0}, ${top}px, 0)`,
          insetInlineStart: 0,
          inlineSize: "100%",
          paddingBlockEnd: GAP
        }
      }, thread.id);
    })
  });
}
function ThreadWrapper({
  onThreadClick,
  onItemAdd,
  onItemRemove,
  thread,
  Thread: Thread2,
  className,
  isActive,
  ...props
}) {
  const divRef = (0, import_react88.useRef)(null);
  useLayoutEffect2(() => {
    const el = divRef.current;
    if (el === null)
      return;
    onItemAdd(thread.id, el);
    return () => {
      onItemRemove(thread.id);
    };
  }, [onItemAdd, onItemRemove, thread.id]);
  function handleThreadClick() {
    onThreadClick(thread.id);
  }
  return (0, import_jsx_runtime123.jsx)("div", {
    ref: divRef,
    className: cn("lb-tiptap-anchored-threads-thread-container", className),
    ...props,
    children: (0, import_jsx_runtime123.jsx)(Thread2, {
      thread,
      "data-state": isActive ? "active" : "inactive",
      onClick: handleThreadClick,
      className: "lb-tiptap-anchored-threads-thread",
      showComposer: isActive ? true : false
    })
  });
}

// node_modules/@liveblocks/react-tiptap/dist/comments/FloatingComposer.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);
var import_react_dom10 = __toESM(require_react_dom(), 1);
var FLOATING_COMPOSER_COLLISION_PADDING = 10;
var FloatingComposer = (0, import_react91.forwardRef)(function FloatingComposer2({ editor, onComposerSubmit, onKeyDown, onClick, components, ...props }, forwardedRef) {
  const Composer$1 = (components == null ? void 0 : components.Composer) ?? Composer;
  const createThread = _useCreateThread();
  const pendingCommentSelection = useEditorState({
    editor,
    selector: (ctx) => {
      var _a3;
      if (!ctx.editor)
        return;
      return ((_a3 = ctx.editor.storage.liveblocksComments) == null ? void 0 : _a3.pendingComment) && !ctx.editor.state.selection.empty ? ctx.editor.state.selection : void 0;
    },
    equalityFn: compareSelections
  }) ?? void 0;
  const isOpen = pendingCommentSelection !== void 0;
  const {
    refs: { setReference, setFloating },
    strategy,
    x: x2,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [
      inline3({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      flip3({ padding: FLOATING_COMPOSER_COLLISION_PADDING, crossAxis: false }),
      offset3(10),
      hide3({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      shift3({
        padding: FLOATING_COMPOSER_COLLISION_PADDING,
        limiter: limitShift3()
      }),
      size3({ padding: FLOATING_COMPOSER_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect2(() => {
    if (!editor || !isOpen) {
      return;
    }
    if (!pendingCommentSelection) {
      setReference(null);
    } else {
      const domRange = getDomRangeFromSelection(
        editor,
        pendingCommentSelection
      );
      setReference(domRange);
    }
  }, [pendingCommentSelection, editor, isOpen, setReference]);
  const handleComposerSubmit = (0, import_react91.useCallback)(
    (comment, event) => {
      onComposerSubmit == null ? void 0 : onComposerSubmit(comment, event);
      if (event.defaultPrevented)
        return;
      if (!editor) {
        return;
      }
      event.preventDefault();
      const thread = createThread({
        body: comment.body,
        attachments: comment.attachments,
        metadata: props.metadata ?? {}
      });
      editor.commands.addComment(thread.id);
    },
    [onComposerSubmit, editor, createThread, props.metadata]
  );
  const handleKeyDown = (0, import_react91.useCallback)(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (event.isDefaultPrevented() || !editor) {
        return;
      }
      if (event.key === "Escape") {
        editor.chain().closePendingComment().run();
      }
    },
    [editor, onKeyDown]
  );
  const handleClick = (0, import_react91.useCallback)(
    (event) => {
      onClick == null ? void 0 : onClick(event);
      if (event.defaultPrevented) {
        return;
      }
      event.stopPropagation();
    },
    [onClick]
  );
  if (!isOpen || !editor) {
    return null;
  }
  return (0, import_react_dom10.createPortal)(
    (0, import_jsx_runtime124.jsx)("div", {
      className: "lb-root lb-portal lb-elevation lb-tiptap-floating lb-tiptap-floating-composer",
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x2)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      children: (0, import_jsx_runtime124.jsx)(Composer$1, {
        ref: forwardedRef,
        autoFocus: true,
        ...props,
        onKeyDown: handleKeyDown,
        onComposerSubmit: handleComposerSubmit,
        onClick: handleClick
      })
    }),
    document.body
  );
});

// node_modules/@liveblocks/react-tiptap/dist/comments/FloatingThreads.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react93 = __toESM(require_react(), 1);
var import_react_dom12 = __toESM(require_react_dom(), 1);
function FloatingThreads({
  threads,
  components,
  editor,
  ...props
}) {
  const Thread$1 = (components == null ? void 0 : components.Thread) ?? Thread;
  const { pluginState } = useEditorState({
    editor,
    selector: (ctx) => {
      var _a3;
      if (!((_a3 = ctx == null ? void 0 : ctx.editor) == null ? void 0 : _a3.state))
        return { pluginState: void 0 };
      const state = THREADS_PLUGIN_KEY.getState(ctx.editor.state);
      return {
        pluginState: state
      };
    },
    equalityFn: (prev, next3) => {
      var _a3, _b, _c, _d;
      if (!prev || !next3)
        return false;
      return ((_a3 = prev.pluginState) == null ? void 0 : _a3.selectedThreadPos) === ((_b = next3.pluginState) == null ? void 0 : _b.selectedThreadPos) && ((_c = prev.pluginState) == null ? void 0 : _c.selectedThreadId) === ((_d = next3.pluginState) == null ? void 0 : _d.selectedThreadId);
    }
  }) ?? { pluginState: void 0 };
  const [activeThread, setActiveThread] = (0, import_react93.useState)(null);
  (0, import_react93.useEffect)(() => {
    if (!editor || !pluginState) {
      setActiveThread(null);
      return;
    }
    const { selectedThreadId, selectedThreadPos } = pluginState;
    if (selectedThreadId === null || selectedThreadPos === null) {
      setActiveThread(null);
      return;
    }
    const active = (threads ?? []).find(
      (thread) => selectedThreadId === thread.id
    );
    setActiveThread(active ?? null);
  }, [editor, pluginState, threads]);
  const handleEscapeKeydown = (0, import_react93.useCallback)(() => {
    if (!editor || activeThread === null)
      return false;
    editor.commands.selectThread(null);
    return true;
  }, [activeThread, editor]);
  if (!activeThread || !editor || activeThread.resolved)
    return null;
  return (0, import_jsx_runtime125.jsx)(FloatingThreadPortal, {
    thread: activeThread,
    editor,
    container: document.body,
    ...props,
    children: activeThread && (0, import_jsx_runtime125.jsx)(ThreadWrapper2, {
      thread: activeThread,
      Thread: Thread$1,
      onEscapeKeydown: handleEscapeKeydown,
      className: "lb-tiptap-floating-threads-thread"
    }, activeThread.id)
  });
}
var FLOATING_THREAD_COLLISION_PADDING = 10;
function FloatingThreadPortal({
  container,
  editor,
  thread,
  children,
  className,
  style,
  ...props
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x: x2,
    y
  } = useFloating({
    strategy: "absolute",
    placement: "bottom",
    middleware: [
      flip3({ padding: FLOATING_THREAD_COLLISION_PADDING, crossAxis: false }),
      offset3(10),
      hide3({ padding: FLOATING_THREAD_COLLISION_PADDING }),
      shift3({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        limiter: limitShift3()
      }),
      size3({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        apply({ availableWidth, availableHeight, elements }) {
          elements.floating.style.setProperty(
            "--lb-tiptap-floating-threads-available-width",
            `${availableWidth}px`
          );
          elements.floating.style.setProperty(
            "--lb-tiptap-floating-threads-available-height",
            `${availableHeight}px`
          );
        }
      })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  const updateRef = (0, import_react93.useCallback)(() => {
    const el = editor.view.dom.querySelector(
      `[data-lb-thread-id="${thread.id}"]`
    );
    if (el) {
      setReference(el);
    }
  }, [setReference, editor, thread.id]);
  (0, import_react93.useEffect)(() => {
    editor.on("transaction", updateRef);
    return () => {
      editor.off("transaction", updateRef);
    };
  }, [editor, updateRef]);
  useLayoutEffect2(updateRef, [updateRef]);
  return (0, import_react_dom12.createPortal)(
    (0, import_jsx_runtime125.jsx)("div", {
      ref: setFloating,
      ...props,
      style: {
        ...style,
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x2)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: cn(
        "lb-root lb-portal lb-elevation lb-tiptap-floating lb-tiptap-floating-threads",
        className
      ),
      children
    }),
    container
  );
}
function ThreadWrapper2({
  thread,
  Thread: Thread2,
  onEscapeKeydown,
  onKeyDown,
  ...threadProps
}) {
  const handleKeyDown = (0, import_react93.useCallback)(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (event.key === "Escape") {
        onEscapeKeydown();
      }
    },
    [onEscapeKeydown, onKeyDown]
  );
  return (0, import_jsx_runtime125.jsx)(Thread2, {
    thread,
    onKeyDown: handleKeyDown,
    ...threadProps
  });
}

// node_modules/js-base64/base64.mjs
var version = "3.7.8";
var VERSION = version;
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it2) => new Uint8Array(Array.prototype.slice.call(it2, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l2 = u8a.length; i < l2; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u2) => u2.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset4 = cp - 65536;
      return _fromCC((offset4 >>> 10) + 55296) + _fromCC((offset4 & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, r1, r2;
  let binArray = [];
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    if (r1 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255));
    } else if (r2 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
    } else {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
    }
  }
  return binArray.join("");
};
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v2) => {
  return {
    value: v2,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// node_modules/lib0/indexeddb.js
var rtop = (request) => create2((resolve, reject) => {
  request.onerror = (event) => reject(new Error(event.target.error));
  request.onsuccess = (event) => resolve(event.target.result);
});
var openDB = (name, initDB) => create2((resolve, reject) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject(create(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve(db);
  };
});
var deleteDB = (name) => rtop(indexedDB.deleteDatabase(name));
var createStores = (db, definitions) => definitions.forEach(
  (d) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d)
  )
);
var transact2 = (db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
};
var count3 = (store, range2) => rtop(store.count(range2));
var get = (store, key) => rtop(store.get(key));
var del = (store, key) => rtop(store.delete(key));
var put = (store, item, key) => rtop(store.put(item, key));
var addAutoKey = (store, item) => rtop(store.add(item));
var getAll = (store, range2, limit) => rtop(store.getAll(range2, limit));
var queryFirst = (store, query, direction) => {
  let first2 = null;
  return iterateKeys(store, query, (key) => {
    first2 = key;
    return false;
  }, direction).then(() => first2);
};
var getLastKey = (store, range2 = null) => queryFirst(store, range2, "prev");
var iterateOnRequest = (request, f) => create2((resolve, reject) => {
  request.onerror = reject;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve();
    }
    cursor.continue();
  };
});
var iterateKeys = (store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key));
var getStore = (t3, store) => t3.objectStore(store);
var createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);
var createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count3(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
};
var storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count3(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
});
var IndexeddbPersistence = class extends Observable {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc) {
    super();
    this.doc = doc;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create2((resolve) => this.on("synced", () => resolve(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = (updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc));
      const afterApplyUpdatesCallback = () => {
        if (this._destroyed) return this;
        this.synced = true;
        this.emit("synced", [this]);
      };
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update, origin) => {
      if (this.db && origin !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};

// node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift4) {
  return word << 32 - shift4 | word >>> shift4;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_2, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg2) => hashCons().update(toBytes(msg2)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n3, le3 = false) {
  if (le3)
    return { h: Number(n3 & U32_MASK64), l: Number(n3 >> _32n & U32_MASK64) };
  return { h: Number(n3 >> _32n & U32_MASK64) | 0, l: Number(n3 & U32_MASK64) | 0 };
}
function split(lst, le3 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l: l2 } = fromBig(lst[i], le3);
    [Ah[i], Al[i]] = [h, l2];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l2, s) => h << 32 - s | l2 >>> s;
var rotrSH = (h, l2, s) => h >>> s | l2 << 32 - s;
var rotrSL = (h, l2, s) => h << 32 - s | l2 >>> s;
var rotrBH = (h, l2, s) => h << 64 - s | l2 >>> s - 32;
var rotrBL = (h, l2, s) => h >>> s - 32 | l2 << 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B: B4, C: C2, D: D3, E: E2, F: F2, G: G3, H: H2 } = this;
    return [A, B4, C2, D3, E2, F2, G3, H2];
  }
  // prettier-ignore
  set(A, B4, C2, D3, E2, F2, G3, H2) {
    this.A = A | 0;
    this.B = B4 | 0;
    this.C = C2 | 0;
    this.D = D3 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G3 | 0;
    this.H = H2 | 0;
  }
  process(view, offset4) {
    for (let i = 0; i < 16; i++, offset4 += 4)
      SHA256_W[i] = view.getUint32(offset4, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W22 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B: B4, C: C2, D: D3, E: E2, F: F2, G: G3, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G3) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B4, C2) | 0;
      H2 = G3;
      G3 = F2;
      F2 = E2;
      E2 = D3 + T1 | 0;
      D3 = C2;
      C2 = B4;
      B4 = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B4 = B4 + this.B | 0;
    C2 = C2 + this.C | 0;
    D3 = D3 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G3 = G3 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A, B4, C2, D3, E2, F2, G3, H2);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = SHA224_IV[0] | 0;
    this.B = SHA224_IV[1] | 0;
    this.C = SHA224_IV[2] | 0;
    this.D = SHA224_IV[3] | 0;
    this.E = SHA224_IV[4] | 0;
    this.F = SHA224_IV[5] | 0;
    this.G = SHA224_IV[6] | 0;
    this.H = SHA224_IV[7] | 0;
  }
};
var K512 = (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n3) => BigInt(n3))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset4) {
    for (let i = 0; i < 16; i++, offset4 += 4) {
      SHA512_W_H[i] = view.getUint32(offset4);
      SHA512_W_L[i] = view.getUint32(offset4 += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = T224_IV[0] | 0;
    this.Al = T224_IV[1] | 0;
    this.Bh = T224_IV[2] | 0;
    this.Bl = T224_IV[3] | 0;
    this.Ch = T224_IV[4] | 0;
    this.Cl = T224_IV[5] | 0;
    this.Dh = T224_IV[6] | 0;
    this.Dl = T224_IV[7] | 0;
    this.Eh = T224_IV[8] | 0;
    this.El = T224_IV[9] | 0;
    this.Fh = T224_IV[10] | 0;
    this.Fl = T224_IV[11] | 0;
    this.Gh = T224_IV[12] | 0;
    this.Gl = T224_IV[13] | 0;
    this.Hh = T224_IV[14] | 0;
    this.Hl = T224_IV[15] | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = T256_IV[0] | 0;
    this.Al = T256_IV[1] | 0;
    this.Bh = T256_IV[2] | 0;
    this.Bl = T256_IV[3] | 0;
    this.Ch = T256_IV[4] | 0;
    this.Cl = T256_IV[5] | 0;
    this.Dh = T256_IV[6] | 0;
    this.Dl = T256_IV[7] | 0;
    this.Eh = T256_IV[8] | 0;
    this.El = T256_IV[9] | 0;
    this.Fh = T256_IV[10] | 0;
    this.Fl = T256_IV[11] | 0;
    this.Gh = T256_IV[12] | 0;
    this.Gl = T256_IV[13] | 0;
    this.Hh = T256_IV[14] | 0;
    this.Hl = T256_IV[15] | 0;
  }
};
var sha256 = createHasher(() => new SHA256());
var sha224 = createHasher(() => new SHA224());
var sha512 = createHasher(() => new SHA512());
var sha384 = createHasher(() => new SHA384());
var sha512_256 = createHasher(() => new SHA512_256());
var sha512_224 = createHasher(() => new SHA512_224());

// node_modules/@liveblocks/yjs/dist/index.js
var PKG_NAME4 = "@liveblocks/yjs";
var PKG_VERSION4 = "3.7.1";
var PKG_FORMAT4 = "esm";
var create4 = () => /* @__PURE__ */ new Map();
var setIfUndefined = (map, key, createT) => {
  let set2 = map.get(key);
  if (set2 === void 0) {
    map.set(key, set2 = createT());
  }
  return set2;
};
var create22 = () => /* @__PURE__ */ new Set();
var from = Array.from;
var isArray = Array.isArray;
var Observable2 = class {
  constructor() {
    this._observers = create4();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create22).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args) => {
      this.off(name, _f);
      f(...args);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args) {
    return from((this._observers.get(name) || create4()).values()).forEach((f) => f(...args));
  }
  destroy() {
    this._observers = create4();
  }
};
var Y_PRESENCE_KEY = "__yjs";
var Y_PRESENCE_ID_KEY = "__yjs_clientid";
var Awareness = class extends Observable2 {
  constructor(doc, room) {
    super();
    __publicField(this, "room");
    __publicField(this, "doc");
    __publicField(this, "states", /* @__PURE__ */ new Map());
    // used to map liveblock's ActorId to Yjs ClientID, both unique numbers representing a client
    __publicField(this, "actorToClientMap", /* @__PURE__ */ new Map());
    // Meta is used to keep track and timeout users who disconnect. Liveblocks provides this for us, so we don't need to
    // manage it here. Unfortunately, it's expected to exist by various integrations, so it's an empty map.
    __publicField(this, "meta", /* @__PURE__ */ new Map());
    // _checkInterval this would hold a timer to remove users, but Liveblock's presence already handles this
    // unfortunately it's typed by various integrations
    __publicField(this, "_checkInterval", 0);
    __publicField(this, "othersUnsub");
    this.doc = doc;
    this.room = room;
    this.room.updatePresence({
      [Y_PRESENCE_ID_KEY]: this.doc.clientID
    });
    this.othersUnsub = this.room.events.others.subscribe((event) => {
      let updates;
      if (event.type === "leave") {
        const targetClientId = this.actorToClientMap.get(
          event.user.connectionId
        );
        if (targetClientId !== void 0) {
          updates = { added: [], updated: [], removed: [targetClientId] };
        }
        this.rebuildActorToClientMap(event.others);
      }
      if (event.type === "enter" || event.type === "update") {
        this.rebuildActorToClientMap(event.others);
        const targetClientId = this.actorToClientMap.get(
          event.user.connectionId
        );
        if (targetClientId !== void 0) {
          updates = {
            added: event.type === "enter" ? [targetClientId] : [],
            updated: event.type === "update" ? [targetClientId] : [],
            removed: []
          };
        }
      }
      if (event.type === "reset") {
        this.rebuildActorToClientMap(event.others);
      }
      if (updates !== void 0) {
        this.emit("change", [updates, "presence"]);
        this.emit("update", [updates, "presence"]);
      }
    });
  }
  rebuildActorToClientMap(others) {
    this.actorToClientMap.clear();
    others.forEach((user) => {
      if (user.presence[Y_PRESENCE_ID_KEY] !== void 0) {
        this.actorToClientMap.set(
          user.connectionId,
          user.presence[Y_PRESENCE_ID_KEY]
        );
      }
    });
  }
  destroy() {
    this.emit("destroy", [this]);
    this.othersUnsub();
    this.setLocalState(null);
    super.destroy();
  }
  getLocalState() {
    const presence = this.room.getPresence();
    if (Object.keys(presence).length === 0 || typeof presence[Y_PRESENCE_KEY] === "undefined") {
      return null;
    }
    return presence[Y_PRESENCE_KEY];
  }
  setLocalState(state) {
    var _a3;
    const presence = (_a3 = this.room.getSelf()) == null ? void 0 : _a3.presence;
    if (state === null) {
      if (presence === void 0) {
        return;
      }
      this.room.updatePresence({ ...presence, [Y_PRESENCE_KEY]: null });
      this.emit("update", [
        { added: [], updated: [], removed: [this.doc.clientID] },
        "local"
      ]);
      return;
    }
    const yPresence = presence == null ? void 0 : presence[Y_PRESENCE_KEY];
    const added = yPresence === void 0 ? [this.doc.clientID] : [];
    const updated = yPresence === void 0 ? [] : [this.doc.clientID];
    this.room.updatePresence({
      [Y_PRESENCE_KEY]: {
        ...yPresence || {},
        ...state || {}
      }
    });
    this.emit("update", [{ added, updated, removed: [] }, "local"]);
  }
  setLocalStateField(field, value) {
    var _a3;
    const presence = (_a3 = this.room.getSelf()) == null ? void 0 : _a3.presence[Y_PRESENCE_KEY];
    const update = { [field]: value };
    this.room.updatePresence({
      [Y_PRESENCE_KEY]: { ...presence || {}, ...update }
    });
  }
  // Translate liveblocks presence to yjs awareness
  getStates() {
    var _a3;
    const others = this.room.getOthers();
    const states = others.reduce((acc, otherUser) => {
      const otherPresence = otherUser.presence[Y_PRESENCE_KEY];
      const otherClientId = otherUser.presence[Y_PRESENCE_ID_KEY];
      if (otherPresence !== void 0 && otherClientId !== void 0) {
        acc.set(otherClientId, otherPresence || {});
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    const localPresence = (_a3 = this.room.getSelf()) == null ? void 0 : _a3.presence[Y_PRESENCE_KEY];
    if (localPresence !== void 0) {
      states.set(this.doc.clientID, localPresence);
    }
    return states;
  }
};
var _a2;
var yDocHandler = (_a2 = class extends Observable2 {
  constructor({
    doc,
    isRoot,
    updateDoc,
    fetchDoc,
    useV2Encoding
  }) {
    super();
    __publicField(this, "unsubscribers", []);
    __publicField(this, "_synced", false);
    __publicField(this, "doc");
    __publicField(this, "updateRoomDoc");
    __publicField(this, "fetchRoomDoc");
    __publicField(this, "useV2Encoding");
    __publicField(this, "localSnapshotHashΣ");
    __publicField(this, "remoteSnapshotHashΣ");
    __publicField(this, "debounceTimer", null);
    __publicField(this, "isLocalAndRemoteSnapshotEqualΣ");
    __publicField(this, "handleServerUpdate", ({
      update,
      stateVector,
      readOnly,
      v2,
      remoteSnapshotHash
    }) => {
      const applyUpdate2 = v2 ? applyUpdateV2 : applyUpdate;
      applyUpdate2(this.doc, update, "backend");
      if (stateVector) {
        if (!readOnly) {
          try {
            const encodeUpdate = this.useV2Encoding ? encodeStateAsUpdateV2 : encodeStateAsUpdate;
            const localUpdate = encodeUpdate(
              this.doc,
              gBase64.toUint8Array(stateVector)
            );
            this.updateRoomDoc(localUpdate);
          } catch (e3) {
            console.warn(e3);
          }
        }
        this.synced = true;
      }
      this.remoteSnapshotHashΣ.set(remoteSnapshotHash);
    });
    __publicField(this, "syncDoc", () => {
      this.synced = false;
      const encodedVector = gBase64.fromUint8Array(encodeStateVector(this.doc));
      this.fetchRoomDoc(encodedVector);
    });
    __publicField(this, "updateHandler", (update, origin) => {
      this.debounced_updateLocalSnapshot();
      const isFromLocal = origin instanceof IndexeddbPersistence;
      if (origin !== "backend" && !isFromLocal) {
        this.updateRoomDoc(update);
      }
    });
    this.doc = doc;
    this.useV2Encoding = useV2Encoding;
    this.doc.on(useV2Encoding ? "updateV2" : "update", this.updateHandler);
    this.updateRoomDoc = (update) => {
      updateDoc(update, isRoot ? void 0 : this.doc.guid);
    };
    this.fetchRoomDoc = (vector) => {
      fetchDoc(vector, isRoot ? void 0 : this.doc.guid);
    };
    this.syncDoc();
    const encodedSnapshot = this.useV2Encoding ? encodeSnapshotV2(snapshot(this.doc)) : encodeSnapshot(snapshot(this.doc));
    this.localSnapshotHashΣ = new Signal(
      gBase64.fromUint8Array(sha256(encodedSnapshot))
    );
    this.remoteSnapshotHashΣ = new Signal(null);
    this.isLocalAndRemoteSnapshotEqualΣ = DerivedSignal.from(() => {
      const remoteSnapshotHash = this.remoteSnapshotHashΣ.get();
      if (remoteSnapshotHash === null) return false;
      const localSnapshotHash = this.localSnapshotHashΣ.get();
      if (localSnapshotHash !== remoteSnapshotHash) {
        return false;
      }
      return true;
    });
  }
  // The sync'd property is required by some provider implementations
  get synced() {
    return this._synced;
  }
  set synced(state) {
    if (this._synced !== state) {
      this._synced = state;
      this.emit("synced", [state]);
      this.emit("sync", [state]);
    }
  }
  debounced_updateLocalSnapshot() {
    if (this.debounceTimer) clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => {
      const encodedSnapshot = this.useV2Encoding ? encodeSnapshotV2(snapshot(this.doc)) : encodeSnapshot(snapshot(this.doc));
      this.localSnapshotHashΣ.set(
        gBase64.fromUint8Array(sha256(encodedSnapshot))
      );
      this.debounceTimer = null;
    }, _a2.DEBOUNCE_INTERVAL_MS);
  }
  experimental_getSyncStatus() {
    const remoteSnapshotHash = this.remoteSnapshotHashΣ.get();
    if (remoteSnapshotHash === null) {
      return "loading";
    }
    if (!this.isLocalAndRemoteSnapshotEqualΣ.get()) {
      return "synchronizing";
    }
    return "synchronized";
  }
  destroy() {
    if (this.debounceTimer) clearTimeout(this.debounceTimer);
    this.doc.off("update", this.updateHandler);
    this.unsubscribers.forEach((unsub) => unsub());
    this._observers = /* @__PURE__ */ new Map();
    this.doc.destroy();
  }
}, __publicField(_a2, "DEBOUNCE_INTERVAL_MS", 200), _a2);
var LiveblocksYjsProvider = class extends Observable2 {
  constructor(room, doc, options2 = {}) {
    super();
    __publicField(this, "room");
    __publicField(this, "rootDoc");
    __publicField(this, "options");
    __publicField(this, "indexeddbProvider", null);
    __publicField(this, "isPaused", false);
    __publicField(this, "unsubscribers", []);
    __publicField(this, "awareness");
    __publicField(this, "rootDocHandler");
    __publicField(this, "subdocHandlersΣ", new MutableSignal(/* @__PURE__ */ new Map()));
    __publicField(this, "syncStatusΣ");
    __publicField(this, "permanentUserData");
    __publicField(this, "setupOfflineSupport", () => {
      this.indexeddbProvider = new IndexeddbPersistence(
        this.room.id,
        this.rootDoc
      );
      const onIndexedDbSync = () => {
        this.rootDocHandler.synced = true;
      };
      this.indexeddbProvider.on("synced", onIndexedDbSync);
      this.unsubscribers.push(() => {
        var _a3;
        (_a3 = this.indexeddbProvider) == null ? void 0 : _a3.off("synced", onIndexedDbSync);
      });
    });
    __publicField(this, "handleSubdocs", ({
      loaded,
      removed,
      added
    }) => {
      var _a3;
      loaded.forEach(this.createSubdocHandler);
      const subdocHandlers = this.subdocHandlersΣ.get();
      if (this.options.autoloadSubdocs) {
        for (const subdoc of added) {
          if (!subdocHandlers.has(subdoc.guid)) {
            subdoc.load();
          }
        }
      }
      for (const subdoc of removed) {
        if (subdocHandlers.has(subdoc.guid)) {
          (_a3 = subdocHandlers.get(subdoc.guid)) == null ? void 0 : _a3.destroy();
          subdocHandlers.delete(subdoc.guid);
        }
      }
    });
    __publicField(this, "updateDoc", (update, guid) => {
      var _a3;
      const canWrite = ((_a3 = this.room.getSelf()) == null ? void 0 : _a3.canWrite) ?? true;
      if (canWrite && !this.isPaused) {
        this.room.updateYDoc(
          gBase64.fromUint8Array(update),
          guid,
          this.useV2Encoding
        );
      }
    });
    __publicField(this, "fetchDoc", (vector, guid) => {
      this.room.fetchYDoc(vector, guid, this.useV2Encoding);
    });
    __publicField(this, "createSubdocHandler", (subdoc) => {
      var _a3;
      const subdocHandlers = this.subdocHandlersΣ.get();
      if (subdocHandlers.has(subdoc.guid)) {
        (_a3 = subdocHandlers.get(subdoc.guid)) == null ? void 0 : _a3.syncDoc();
        return;
      }
      const handler = new yDocHandler({
        doc: subdoc,
        isRoot: false,
        updateDoc: this.updateDoc,
        fetchDoc: this.fetchDoc,
        useV2Encoding: this.options.useV2Encoding_experimental ?? false
      });
      subdocHandlers.set(subdoc.guid, handler);
    });
    // attempt to load a subdoc of a given guid
    __publicField(this, "loadSubdoc", (guid) => {
      for (const subdoc of this.rootDoc.subdocs) {
        if (subdoc.guid === guid) {
          subdoc.load();
          return true;
        }
      }
      return false;
    });
    __publicField(this, "syncDoc", () => {
      this.rootDocHandler.syncDoc();
      for (const [_2, handler] of this.subdocHandlersΣ.get()) {
        handler.syncDoc();
      }
    });
    this.rootDoc = doc;
    this.room = room;
    this.options = options2;
    this.rootDocHandler = new yDocHandler({
      doc,
      isRoot: true,
      updateDoc: this.updateDoc,
      fetchDoc: this.fetchDoc,
      useV2Encoding: this.options.useV2Encoding_experimental ?? false
    });
    if (this.options.enablePermanentUserData) {
      this.permanentUserData = new PermanentUserData(doc);
    }
    room[kInternal].setYjsProvider(this);
    this.awareness = new Awareness(this.rootDoc, this.room);
    this.unsubscribers.push(
      this.room.events.status.subscribe((status) => {
        if (status === "connected") {
          this.rootDocHandler.syncDoc();
        } else {
          this.rootDocHandler.synced = false;
        }
      })
    );
    this.unsubscribers.push(
      this.room.events.ydoc.subscribe((message) => {
        var _a3, _b;
        const { type } = message;
        if (type === ClientMsgCode.UPDATE_YDOC) {
          return;
        }
        const {
          stateVector,
          update: updateStr,
          guid,
          v2,
          remoteSnapshotHash
        } = message;
        const canWrite = ((_a3 = this.room.getSelf()) == null ? void 0 : _a3.canWrite) ?? true;
        const update = gBase64.toUint8Array(updateStr);
        if (guid !== void 0) {
          (_b = this.subdocHandlersΣ.get().get(guid)) == null ? void 0 : _b.handleServerUpdate({
            update,
            stateVector,
            readOnly: !canWrite,
            v2,
            remoteSnapshotHash
          });
        } else {
          this.rootDocHandler.handleServerUpdate({
            update,
            stateVector,
            readOnly: !canWrite,
            v2,
            remoteSnapshotHash
          });
        }
      })
    );
    if (options2.offlineSupport_experimental) {
      this.setupOfflineSupport();
    }
    this.rootDocHandler.on("synced", () => {
      const state = this.rootDocHandler.synced;
      for (const [_2, handler] of this.subdocHandlersΣ.get()) {
        handler.syncDoc();
      }
      this.emit("synced", [state]);
      this.emit("sync", [state]);
    });
    this.rootDoc.on("subdocs", this.handleSubdocs);
    this.syncDoc();
    this.syncStatusΣ = DerivedSignal.from(() => {
      const rootDocumentStatus = this.rootDocHandler.experimental_getSyncStatus();
      if (rootDocumentStatus === "loading" || rootDocumentStatus === "synchronizing") {
        return rootDocumentStatus;
      }
      const subdocumentStatuses = Array.from(
        this.subdocHandlersΣ.get().values()
      ).map((handler) => handler.experimental_getSyncStatus());
      if (subdocumentStatuses.some((state) => state !== "synchronized")) {
        return "synchronizing";
      }
      return "synchronized";
    });
    this.emit("status", [this.getStatus()]);
    this.unsubscribers.push(
      this.syncStatusΣ.subscribe(() => {
        this.emit("status", [this.getStatus()]);
      })
    );
  }
  get useV2Encoding() {
    return this.options.useV2Encoding_experimental ?? false;
  }
  // The sync'd property is required by some provider implementations
  get synced() {
    return this.rootDocHandler.synced;
  }
  async pause() {
    var _a3;
    await ((_a3 = this.indexeddbProvider) == null ? void 0 : _a3.destroy());
    this.indexeddbProvider = null;
    this.isPaused = true;
  }
  unpause() {
    this.isPaused = false;
    if (this.options.offlineSupport_experimental) {
      this.setupOfflineSupport();
    }
    this.rootDocHandler.syncDoc();
  }
  getStatus() {
    return this.syncStatusΣ.get();
  }
  destroy() {
    this.unsubscribers.forEach((unsub) => unsub());
    this.awareness.destroy();
    this.rootDocHandler.destroy();
    this._observers = /* @__PURE__ */ new Map();
    for (const [_2, handler] of this.subdocHandlersΣ.get()) {
      handler.destroy();
    }
    this.subdocHandlersΣ.get().clear();
    super.destroy();
  }
  async clearOfflineData() {
    if (!this.indexeddbProvider) return;
    return this.indexeddbProvider.clearData();
  }
  getYDoc() {
    return this.rootDoc;
  }
  // Some provider implementations expect to be able to call connect/disconnect, implement as noop
  disconnect() {
  }
  connect() {
  }
  get subdocHandlers() {
    return this.subdocHandlersΣ.get();
  }
  set subdocHandlers(value) {
    this.subdocHandlersΣ.mutate((map) => {
      map.clear();
      for (const [key, handler] of value) {
        map.set(key, handler);
      }
    });
  }
};
var providersMap = /* @__PURE__ */ new WeakMap();
var getYjsProviderForRoom = (room, options2 = {}) => {
  const provider = providersMap.get(room);
  if (provider !== void 0) {
    return provider;
  }
  const doc = new Doc();
  const newProvider = new LiveblocksYjsProvider(room, doc, options2);
  room.events.roomWillDestroy.subscribeOnce(() => {
    newProvider.destroy();
  });
  providersMap.set(room, newProvider);
  return newProvider;
};
detectDupes(PKG_NAME4, PKG_VERSION4, PKG_FORMAT4);

// node_modules/@tiptap/extension-collaboration/dist/index.js
var Collaboration = Extension.create({
  name: "collaboration",
  priority: 1e3,
  addOptions() {
    return {
      document: null,
      field: "default",
      fragment: null
    };
  },
  addStorage() {
    return {
      isDisabled: false
    };
  },
  onCreate() {
    if (this.editor.extensionManager.extensions.find((extension) => extension.name === "history")) {
      console.warn('[tiptap warn]: "@tiptap/extension-collaboration" comes with its own history support and is not compatible with "@tiptap/extension-history".');
    }
  },
  addCommands() {
    return {
      undo: () => ({ tr, state, dispatch }) => {
        tr.setMeta("preventDispatch", true);
        const undoManager = yUndoPluginKey.getState(state).undoManager;
        if (undoManager.undoStack.length === 0) {
          return false;
        }
        if (!dispatch) {
          return true;
        }
        return undo(state);
      },
      redo: () => ({ tr, state, dispatch }) => {
        tr.setMeta("preventDispatch", true);
        const undoManager = yUndoPluginKey.getState(state).undoManager;
        if (undoManager.redoStack.length === 0) {
          return false;
        }
        if (!dispatch) {
          return true;
        }
        return redo(state);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo()
    };
  },
  addProseMirrorPlugins() {
    var _a3;
    const fragment2 = this.options.fragment ? this.options.fragment : this.options.document.getXmlFragment(this.options.field);
    const yUndoPluginInstance = yUndoPlugin(this.options.yUndoOptions);
    const originalUndoPluginView = yUndoPluginInstance.spec.view;
    yUndoPluginInstance.spec.view = (view) => {
      const { undoManager } = yUndoPluginKey.getState(view.state);
      if (undoManager.restore) {
        undoManager.restore();
        undoManager.restore = () => {
        };
      }
      const viewRet = originalUndoPluginView ? originalUndoPluginView(view) : void 0;
      return {
        destroy: () => {
          const hasUndoManSelf = undoManager.trackedOrigins.has(undoManager);
          const observers = undoManager._observers;
          undoManager.restore = () => {
            if (hasUndoManSelf) {
              undoManager.trackedOrigins.add(undoManager);
            }
            undoManager.doc.on("afterTransaction", undoManager.afterTransactionHandler);
            undoManager._observers = observers;
          };
          if (viewRet === null || viewRet === void 0 ? void 0 : viewRet.destroy) {
            viewRet.destroy();
          }
        }
      };
    };
    const ySyncPluginOptions = {
      ...this.options.ySyncOptions,
      onFirstRender: this.options.onFirstRender
    };
    const ySyncPluginInstance = ySyncPlugin(fragment2, ySyncPluginOptions);
    if (this.editor.options.enableContentCheck) {
      (_a3 = fragment2.doc) === null || _a3 === void 0 ? void 0 : _a3.on("beforeTransaction", () => {
        try {
          const jsonContent = yXmlFragmentToProsemirrorJSON(fragment2);
          if (jsonContent.content.length === 0) {
            return;
          }
          this.editor.schema.nodeFromJSON(jsonContent).check();
        } catch (error) {
          this.editor.emit("contentError", {
            error,
            editor: this.editor,
            disableCollaboration: () => {
              var _a4;
              (_a4 = fragment2.doc) === null || _a4 === void 0 ? void 0 : _a4.destroy();
              this.storage.isDisabled = true;
            }
          });
          return false;
        }
      });
    }
    return [
      ySyncPluginInstance,
      yUndoPluginInstance,
      // Only add the filterInvalidContent plugin if content checking is enabled
      this.editor.options.enableContentCheck && new Plugin({
        key: new PluginKey("filterInvalidContent"),
        filterTransaction: () => {
          var _a4;
          if (this.storage.isDisabled) {
            (_a4 = fragment2.doc) === null || _a4 === void 0 ? void 0 : _a4.destroy();
            return true;
          }
          return true;
        }
      })
    ].filter(Boolean);
  }
});

// node_modules/@liveblocks/react-tiptap/dist/LiveblocksExtension.js
var import_react102 = __toESM(require_react(), 1);

// node_modules/@liveblocks/react-tiptap/dist/comments/CommentsExtension.js
var FILTERED_THREADS_PLUGIN_KEY = new PluginKey();
var Comment2 = Mark.create({
  name: LIVEBLOCKS_COMMENT_MARK_TYPE,
  excludes: "",
  inclusive: false,
  keepOnSplit: true,
  parseHTML: () => {
    return [
      {
        tag: "span",
        getAttrs: (node3) => node3.getAttribute("data-lb-thread-id") !== null && null
      }
    ];
  },
  addAttributes() {
    return {
      orphan: {
        parseHTML: (element) => !!element.getAttribute("data-orphan"),
        renderHTML: (attributes) => {
          return attributes.orphan ? {
            "data-orphan": "true"
          } : {};
        },
        default: false
      },
      threadId: {
        parseHTML: (element) => element.getAttribute("data-lb-thread-id"),
        renderHTML: (attributes) => {
          return {
            "data-lb-thread-id": attributes.threadId
          };
        },
        default: ""
      }
    };
  },
  renderHTML({ HTMLAttributes }) {
    var _a3;
    const filteredThreads = this.editor ? (_a3 = FILTERED_THREADS_PLUGIN_KEY.getState(this.editor.state)) == null ? void 0 : _a3.filteredThreads : void 0;
    const threadId = HTMLAttributes["data-lb-thread-id"];
    if (filteredThreads && !filteredThreads.has(threadId)) {
      return [
        "span",
        mergeAttributes(HTMLAttributes, {
          class: "lb-root lb-tiptap-thread-mark",
          "data-hidden": ""
        })
      ];
    }
    return [
      "span",
      mergeAttributes(HTMLAttributes, {
        class: "lb-root lb-tiptap-thread-mark"
      })
    ];
  },
  addProseMirrorPlugins() {
    const updateState = (doc, selectedThreadId) => {
      var _a3;
      const threadPositions = /* @__PURE__ */ new Map();
      const decorations = [];
      doc.descendants((node3, pos) => {
        node3.marks.forEach((mark) => {
          if (mark.type === this.type) {
            const thisThreadId = mark.attrs.threadId;
            if (!thisThreadId) {
              return;
            }
            const from2 = pos;
            const to = from2 + node3.nodeSize;
            const currentPosition = threadPositions.get(thisThreadId) ?? {
              from: Infinity,
              to: 0
            };
            threadPositions.set(thisThreadId, {
              from: Math.min(from2, currentPosition.from),
              to: Math.max(to, currentPosition.to)
            });
            if (selectedThreadId === thisThreadId) {
              decorations.push(
                Decoration.inline(from2, to, {
                  class: "lb-root lb-tiptap-thread-mark-selected"
                })
              );
              const decoration = this.editor.view.dom.querySelector(
                `.lb-tiptap-thread-mark[data-lb-thread-id="${thisThreadId}"]`
              );
              if (decoration) {
                decoration.scrollIntoView({
                  behavior: "smooth",
                  block: "nearest"
                });
              }
            }
          }
        });
      });
      return {
        decorations: DecorationSet.create(doc, decorations),
        selectedThreadId,
        threadPositions,
        selectedThreadPos: selectedThreadId !== null ? ((_a3 = threadPositions.get(selectedThreadId)) == null ? void 0 : _a3.to) ?? null : null
      };
    };
    return [
      new Plugin({
        key: THREADS_PLUGIN_KEY,
        state: {
          init() {
            return {
              threadPositions: /* @__PURE__ */ new Map(),
              selectedThreadId: null,
              selectedThreadPos: null,
              decorations: DecorationSet.empty
            };
          },
          apply(tr, state) {
            const action = tr.getMeta(THREADS_PLUGIN_KEY);
            if (!tr.docChanged && !action) {
              return state;
            }
            if (!action) {
              return updateState(tr.doc, state.selectedThreadId);
            }
            if (action.name === ThreadPluginActions.SET_SELECTED_THREAD_ID && state.selectedThreadId !== action.data) {
              return updateState(tr.doc, action.data);
            }
            return state;
          }
        },
        props: {
          decorations: (state) => {
            var _a3;
            return ((_a3 = THREADS_PLUGIN_KEY.getState(state)) == null ? void 0 : _a3.decorations) ?? DecorationSet.empty;
          },
          handleClick: (view, pos, event) => {
            var _a3;
            if (event.button !== 0) {
              return;
            }
            const selectThread = (threadId2) => {
              view.dispatch(
                view.state.tr.setMeta(THREADS_PLUGIN_KEY, {
                  name: ThreadPluginActions.SET_SELECTED_THREAD_ID,
                  data: threadId2
                })
              );
            };
            const node3 = view.state.doc.nodeAt(pos);
            if (!node3) {
              selectThread(null);
              return;
            }
            const commentMark = node3.marks.find(
              (mark) => mark.type === this.type && !mark.attrs.orphan
            );
            if (!commentMark) {
              selectThread(null);
              return;
            }
            const threadId = commentMark == null ? void 0 : commentMark.attrs.threadId;
            const filtered = (_a3 = FILTERED_THREADS_PLUGIN_KEY.getState(
              view.state
            )) == null ? void 0 : _a3.filteredThreads;
            if (threadId && filtered && !filtered.has(threadId)) {
              selectThread(null);
              return;
            }
            selectThread(threadId ?? null);
          }
        }
      })
    ];
  }
});
var CommentsExtension = Extension.create({
  name: "liveblocksComments",
  priority: 95,
  addExtensions() {
    return [Comment2];
  },
  addStorage() {
    return {
      pendingComment: false
    };
  },
  addCommands() {
    return {
      addPendingComment: () => () => {
        if (this.editor.state.selection.empty) {
          return false;
        }
        this.editor.view.dispatch(
          this.editor.state.tr.setMeta(THREADS_PLUGIN_KEY, {
            name: ThreadPluginActions.SET_SELECTED_THREAD_ID,
            data: null
          })
        );
        this.storage.pendingComment = true;
        return true;
      },
      closePendingComment: () => () => {
        this.storage.pendingComment = false;
        return true;
      },
      selectThread: (id) => () => {
        var _a3;
        const filtered = (_a3 = FILTERED_THREADS_PLUGIN_KEY.getState(
          this.editor.state
        )) == null ? void 0 : _a3.filteredThreads;
        if (id && filtered && !filtered.has(id)) {
          this.editor.view.dispatch(
            this.editor.state.tr.setMeta(THREADS_PLUGIN_KEY, {
              name: ThreadPluginActions.SET_SELECTED_THREAD_ID,
              data: null
            })
          );
          return true;
        }
        this.editor.view.dispatch(
          this.editor.state.tr.setMeta(THREADS_PLUGIN_KEY, {
            name: ThreadPluginActions.SET_SELECTED_THREAD_ID,
            data: id
          })
        );
        return true;
      },
      addComment: (id) => ({ commands }) => {
        if (!this.storage.pendingComment || this.editor.state.selection.empty) {
          return false;
        }
        commands.setMark(LIVEBLOCKS_COMMENT_MARK_TYPE, { threadId: id });
        this.storage.pendingComment = false;
        return true;
      }
    };
  },
  onSelectionUpdate({ transaction }) {
    if (!this.storage.pendingComment || transaction.getMeta(ySyncPluginKey)) {
      return;
    }
    this.storage.pendingComment = false;
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: THREADS_ACTIVE_SELECTION_PLUGIN,
        props: {
          decorations: ({ doc, selection }) => {
            if (!this.storage.pendingComment) {
              return DecorationSet.create(doc, []);
            }
            const { from: from2, to } = selection;
            const decorations = [
              Decoration.inline(from2, to, {
                class: "lb-root lb-selection lb-tiptap-active-selection"
              })
            ];
            return DecorationSet.create(doc, decorations);
          }
        }
      }),
      new Plugin({
        key: FILTERED_THREADS_PLUGIN_KEY,
        state: {
          init: () => ({
            filteredThreads: this.options.filteredThreads
          }),
          apply(tr, value) {
            const meta = tr.getMeta(FILTERED_THREADS_PLUGIN_KEY);
            if (meta == null ? void 0 : meta.filteredThreads) {
              return { filteredThreads: meta.filteredThreads };
            }
            return value;
          }
        },
        view: (view) => {
          const syncDom = () => {
            var _a3;
            const filteredThreads = (_a3 = FILTERED_THREADS_PLUGIN_KEY.getState(
              view.state
            )) == null ? void 0 : _a3.filteredThreads;
            const els = view.dom.querySelectorAll(
              "span.lb-tiptap-thread-mark[data-lb-thread-id]"
            );
            els.forEach((el) => {
              const id = el.getAttribute("data-lb-thread-id");
              if (!id)
                return;
              if (!filteredThreads || filteredThreads.has(id)) {
                el.removeAttribute("data-hidden");
              } else {
                el.setAttribute("data-hidden", "");
              }
            });
          };
          queueMicrotask(syncDom);
          return {
            update: (view2, prevState) => {
              var _a3, _b, _c;
              const curr = (_a3 = FILTERED_THREADS_PLUGIN_KEY.getState(
                view2.state
              )) == null ? void 0 : _a3.filteredThreads;
              const prev = (_b = FILTERED_THREADS_PLUGIN_KEY.getState(
                prevState
              )) == null ? void 0 : _b.filteredThreads;
              if (!areSetsEqual(prev, curr) || view2.state.doc !== prevState.doc) {
                syncDom();
                const selected = (_c = THREADS_PLUGIN_KEY.getState(
                  view2.state
                )) == null ? void 0 : _c.selectedThreadId;
                if (selected && curr && !curr.has(selected)) {
                  view2.dispatch(
                    view2.state.tr.setMeta(THREADS_PLUGIN_KEY, {
                      name: ThreadPluginActions.SET_SELECTED_THREAD_ID,
                      data: null
                    })
                  );
                }
              }
            }
          };
        }
      })
    ];
  }
});
function areSetsEqual(a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  if (a.size !== b.size)
    return false;
  for (const v2 of a)
    if (!b.has(v2))
      return false;
  return true;
}

// node_modules/@tiptap/suggestion/dist/index.js
function findSuggestionMatch(config) {
  var _a3;
  const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position } = config;
  const allowSpaces = allowSpacesOption && !allowToIncludeChar;
  const escapedChar = escapeForRegEx(char);
  const suffix = new RegExp(`\\s${escapedChar}$`);
  const prefix = startOfLine ? "^" : "";
  const finalEscapedChar = allowToIncludeChar ? "" : escapedChar;
  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${finalEscapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${finalEscapedChar}]*`, "gm");
  const text = ((_a3 = $position.nodeBefore) === null || _a3 === void 0 ? void 0 : _a3.isText) && $position.nodeBefore.text;
  if (!text) {
    return null;
  }
  const textFrom = $position.pos - text.length;
  const match = Array.from(text.matchAll(regexp)).pop();
  if (!match || match.input === void 0 || match.index === void 0) {
    return null;
  }
  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from2 = textFrom + match.index;
  let to = from2 + match[0].length;
  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {
    match[0] += " ";
    to += 1;
  }
  if (from2 < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from2,
        to
      },
      query: match[0].slice(char.length),
      text: match[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowToIncludeChar = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", decorationContent = "", decorationEmptyClass = "is-empty", command = () => null, items = () => [], render = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {
  let props;
  const renderer = render === null || render === void 0 ? void 0 : render();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a3, _b, _c, _d, _e3, _f, _g;
          const prev = (_a3 = this.key) === null || _a3 === void 0 ? void 0 : _a3.getState(prevState);
          const next3 = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
          const moved = prev.active && next3.active && prev.range.from !== next3.range.from;
          const started = !prev.active && next3.active;
          const stopped = prev.active && !next3.active;
          const changed = !started && !stopped && prev.query !== next3.query;
          const handleStart = started || moved && changed;
          const handleChange = changed || moved;
          const handleExit = stopped || moved && changed;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next3;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              return command({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a4;
              const { decorationId } = (_a4 = this.key) === null || _a4 === void 0 ? void 0 : _a4.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
          }
          if (handleChange) {
            (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e3 = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e3 === void 0 ? void 0 : _e3.call(renderer, props);
          }
          if (handleChange) {
            (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a3;
          if (!props) {
            return;
          }
          (_a3 = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a3 === void 0 ? void 0 : _a3.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, _oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty, from: from2 } = selection;
        const next3 = { ...prev };
        next3.composing = composing;
        if (isEditable && (empty || editor.view.composing)) {
          if ((from2 < prev.range.from || from2 > prev.range.to) && !composing && !prev.composing) {
            next3.active = false;
          }
          const match = findSuggestionMatch$1({
            char,
            allowSpaces,
            allowToIncludeChar,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match && allow({
            editor,
            state,
            range: match.range,
            isActive: prev.active
          })) {
            next3.active = true;
            next3.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next3.range = match.range;
            next3.query = match.query;
            next3.text = match.text;
          } else {
            next3.active = false;
          }
        } else {
          next3.active = false;
        }
        if (!next3.active) {
          next3.decorationId = null;
          next3.range = { from: 0, to: 0 };
          next3.query = null;
          next3.text = null;
        }
        return next3;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a3;
        const { active, range: range2 } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a3 = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(renderer, { view, event, range: range2 })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range: range2, decorationId, query } = plugin.getState(state);
        if (!active) {
          return null;
        }
        const isEmpty3 = !(query === null || query === void 0 ? void 0 : query.length);
        const classNames = [decorationClass];
        if (isEmpty3) {
          classNames.push(decorationEmptyClass);
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range2.from, range2.to, {
            nodeName: decorationTag,
            class: classNames.join(" "),
            "data-decoration-id": decorationId,
            "data-decoration-content": decorationContent
          })
        ]);
      }
    }
  });
  return plugin;
}

// node_modules/@liveblocks/react-tiptap/dist/mentions/Mention.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
var UserMention = (0, import_react95.forwardRef)(
  ({ mention, isSelected }, forwardedRef) => {
    return (0, import_jsx_runtime126.jsxs)(NodeViewWrapper, {
      className: cn(
        "lb-root lb-mention lb-tiptap-mention",
        isSelected && "lb-mention-selected"
      ),
      as: "span",
      ref: forwardedRef,
      children: [
        (0, import_jsx_runtime126.jsx)("span", {
          className: "lb-mention-symbol",
          children: MENTION_CHARACTER
        }),
        (0, import_jsx_runtime126.jsx)(User, {
          userId: mention.id
        })
      ]
    });
  }
);
var GroupMention = (0, import_react95.forwardRef)(
  ({ mention, isSelected }, forwardedRef) => {
    return (0, import_jsx_runtime126.jsxs)(NodeViewWrapper, {
      className: cn(
        "lb-root lb-mention lb-tiptap-mention",
        isSelected && "lb-mention-selected"
      ),
      as: "span",
      ref: forwardedRef,
      children: [
        (0, import_jsx_runtime126.jsx)("span", {
          className: "lb-mention-symbol",
          children: MENTION_CHARACTER
        }),
        (0, import_jsx_runtime126.jsx)(Group, {
          groupId: mention.id
        })
      ]
    });
  }
);
function deserializeGroupUserIds(userIds) {
  if (typeof userIds !== "string") {
    return void 0;
  }
  try {
    const parsedUserIds = JSON.parse(userIds);
    if (Array.isArray(parsedUserIds)) {
      return parsedUserIds;
    }
    return void 0;
  } catch {
    return void 0;
  }
}
var Mention = (0, import_react95.forwardRef)(({ node: node3, selected: isSelected }, forwardedRef) => {
  const attrs = node3.attrs;
  if (node3.type.name === LIVEBLOCKS_MENTION_TYPE) {
    const mention = {
      kind: "user",
      id: attrs.id
    };
    return (0, import_jsx_runtime126.jsx)(UserMention, {
      mention,
      isSelected,
      ref: forwardedRef
    });
  }
  if (node3.type.name === LIVEBLOCKS_GROUP_MENTION_TYPE) {
    const mention = {
      kind: "group",
      id: attrs.id,
      userIds: deserializeGroupUserIds(attrs.userIds)
    };
    return (0, import_jsx_runtime126.jsx)(GroupMention, {
      mention,
      isSelected,
      ref: forwardedRef
    });
  }
  return null;
});

// node_modules/@liveblocks/react-tiptap/dist/mentions/GroupMentionNode.js
var GroupMentionNode = Node2.create({
  name: LIVEBLOCKS_GROUP_MENTION_TYPE,
  group: "inline",
  inline: true,
  selectable: true,
  atom: true,
  priority: 101,
  parseHTML() {
    return [
      {
        tag: "liveblocks-group-mention"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["liveblocks-group-mention", mergeAttributes(HTMLAttributes)];
  },
  addNodeView() {
    return ReactNodeViewRenderer(Mention, {
      contentDOMElementTag: "span"
    });
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      },
      userIds: {
        default: void 0,
        parseHTML: (element) => {
          const userIdsAttribute = element.getAttribute("data-user-ids");
          if (!userIdsAttribute) {
            return void 0;
          }
          try {
            const userIds = JSON.parse(userIdsAttribute);
            return Array.isArray(userIds) ? userIds : void 0;
          } catch {
            return void 0;
          }
        },
        renderHTML: (attributes) => {
          if (!attributes.userIds || !Array.isArray(attributes.userIds)) {
            return {};
          }
          return {
            "data-user-ids": JSON.stringify(attributes.userIds)
          };
        }
      },
      notificationId: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-notification-id"),
        renderHTML: (attributes) => {
          if (!attributes.notificationId) {
            return {};
          }
          return {
            "data-notification-id": attributes.notificationId
          };
        }
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr, state }) => {
        let isMention = false;
        const { selection } = state;
        const { empty, anchor } = selection;
        if (!empty) {
          return false;
        }
        state.doc.nodesBetween(anchor - 1, anchor, (node3, pos) => {
          if (node3.type.name === this.name) {
            isMention = true;
            tr.insertText("", pos, pos + node3.nodeSize);
          }
        });
        return isMention;
      })
    };
  }
});

// node_modules/@liveblocks/react-tiptap/dist/mentions/MentionNode.js
var MentionNode = Node2.create({
  name: LIVEBLOCKS_MENTION_TYPE,
  group: "inline",
  inline: true,
  selectable: true,
  atom: true,
  priority: 101,
  parseHTML() {
    return [
      {
        tag: "liveblocks-mention"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["liveblocks-mention", mergeAttributes(HTMLAttributes)];
  },
  addNodeView() {
    return ReactNodeViewRenderer(Mention, {
      contentDOMElementTag: "span"
    });
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      },
      notificationId: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-notification-id"),
        renderHTML: (attributes) => {
          if (!attributes.notificationId) {
            return {};
          }
          return {
            "data-notification-id": attributes.notificationId
          };
        }
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr, state }) => {
        let isMention = false;
        const { selection } = state;
        const { empty, anchor } = selection;
        if (!empty) {
          return false;
        }
        state.doc.nodesBetween(anchor - 1, anchor, (node3, pos) => {
          if (node3.type.name === this.name) {
            isMention = true;
            tr.insertText("", pos, pos + node3.nodeSize);
          }
        });
        return isMention;
      })
    };
  }
});

// node_modules/@liveblocks/react-tiptap/dist/mentions/MentionsList.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react99 = __toESM(require_react(), 1);
var SUGGESTIONS_COLLISION_PADDING = 10;
var MentionsList = (0, import_react99.forwardRef)(
  (props, ref) => {
    const [selectedIndex, setSelectedIndex] = (0, import_react99.useState)(0);
    const room = _useRoom();
    const suggestions = useMentionSuggestions(room.id, props.query);
    const { onMouseEnter, onClick } = props;
    const {
      refs: { setReference, setFloating },
      strategy,
      x: x2,
      y
    } = useFloating({
      strategy: "fixed",
      placement: "top-start",
      middleware: [
        flip3({ padding: SUGGESTIONS_COLLISION_PADDING, crossAxis: false }),
        offset3(10),
        hide3({ padding: SUGGESTIONS_COLLISION_PADDING }),
        shift3({
          padding: SUGGESTIONS_COLLISION_PADDING,
          limiter: limitShift3()
        }),
        size3({ padding: SUGGESTIONS_COLLISION_PADDING })
      ],
      whileElementsMounted: (...args) => {
        return autoUpdate(...args, {
          animationFrame: true
        });
      }
    });
    useLayoutEffect2(() => {
      setReference({
        getBoundingClientRect: props.clientRect
      });
    }, [setReference, props.clientRect]);
    const selectItem = (index2) => {
      const mention = (suggestions ?? [])[index2];
      if (!mention) {
        return;
      }
      const notificationId = createInboxNotificationId();
      switch (mention.kind) {
        case "user":
          props.command({
            kind: "user",
            id: mention.id,
            notificationId
          });
          break;
        case "group":
          props.command({
            kind: "group",
            id: mention.id,
            userIds: mention.userIds,
            notificationId
          });
          break;
        default:
          return assertNever(mention, "Unhandled mention kind");
      }
    };
    const upHandler = () => {
      setSelectedIndex(
        (selectedIndex + ((suggestions == null ? void 0 : suggestions.length) ?? 0) - 1) % ((suggestions == null ? void 0 : suggestions.length) ?? 0)
      );
    };
    const downHandler = () => {
      setSelectedIndex((selectedIndex + 1) % ((suggestions == null ? void 0 : suggestions.length) ?? 0));
    };
    const enterHandler = () => {
      selectItem(selectedIndex);
    };
    (0, import_react99.useEffect)(() => setSelectedIndex(0), [suggestions]);
    (0, import_react99.useImperativeHandle)(ref, () => ({
      onKeyDown: ({ event }) => {
        if (event.key === "ArrowUp") {
          upHandler();
          return true;
        }
        if (event.key === "ArrowDown") {
          downHandler();
          return true;
        }
        if (event.key === "Enter") {
          enterHandler();
          return true;
        }
        return false;
      }
    }));
    const handleClick = (index2) => (event) => {
      onClick == null ? void 0 : onClick(event);
      if (event.isDefaultPrevented())
        return;
      selectItem(index2);
    };
    const handleMouseEnter = (index2) => (event) => {
      onMouseEnter == null ? void 0 : onMouseEnter(event);
      if (event.isDefaultPrevented())
        return;
      setSelectedIndex(index2);
    };
    if (suggestions === void 0 || suggestions.length === 0) {
      return null;
    }
    return (0, import_jsx_runtime127.jsx)("div", {
      className: "lb-root lb-portal lb-elevation lb-tiptap-suggestions lb-tiptap-mention-suggestions",
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x2)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content",
        display: props.hide ? "none" : "block"
      },
      children: (0, import_jsx_runtime127.jsx)("div", {
        className: "lb-tiptap-suggestions-list lb-tiptap-mention-suggestions-list",
        children: suggestions.map((mention, index2) => {
          return (0, import_jsx_runtime127.jsx)("div", {
            className: "lb-tiptap-suggestions-list-item lb-tiptap-mention-suggestion",
            role: "option",
            "data-highlighted": index2 === selectedIndex || void 0,
            onMouseEnter: handleMouseEnter(index2),
            onClick: handleClick(index2),
            children: mention.kind === "user" ? (0, import_jsx_runtime127.jsxs)(import_jsx_runtime127.Fragment, {
              children: [
                (0, import_jsx_runtime127.jsx)(Avatar, {
                  userId: mention.id,
                  className: "lb-tiptap-mention-suggestion-avatar"
                }),
                (0, import_jsx_runtime127.jsx)(User, {
                  userId: mention.id,
                  className: "lb-tiptap-mention-suggestion-user"
                })
              ]
            }) : mention.kind === "group" ? (0, import_jsx_runtime127.jsxs)(import_jsx_runtime127.Fragment, {
              children: [
                (0, import_jsx_runtime127.jsx)(Avatar, {
                  groupId: mention.id,
                  className: "lb-tiptap-mention-suggestion-avatar",
                  icon: (0, import_jsx_runtime127.jsx)(UsersIcon, {})
                }),
                (0, import_jsx_runtime127.jsx)(Group, {
                  groupId: mention.id,
                  className: "lb-tiptap-mention-suggestion-group",
                  children: (0, import_jsx_runtime127.jsx)(GroupDescription, {
                    groupId: mention.id,
                    className: "lb-tiptap-mention-suggestion-group-description"
                  })
                })
              ]
            }) : assertNever(mention, "Unhandled mention kind")
          }, index2);
        })
      })
    });
  }
);

// node_modules/@liveblocks/react-tiptap/dist/mentions/MentionExtension.js
var mentionPasteHandler = () => {
  return new Plugin({
    key: LIVEBLOCKS_MENTION_PASTE_KEY,
    props: {
      transformPasted: (slice) => {
        const getNewNotificationIds = (node3) => {
          if (node3.type.name === LIVEBLOCKS_MENTION_TYPE || node3.type.name === LIVEBLOCKS_GROUP_MENTION_TYPE) {
            return node3.type.create(
              { ...node3.attrs, notificationId: createInboxNotificationId() },
              node3.content
            );
          }
          return node3.copy(node3.content);
        };
        const fragment2 = mapFragment(slice.content, getNewNotificationIds);
        return new Slice(fragment2, slice.openStart, slice.openEnd);
      }
    }
  });
};
var notifier = ({
  onCreateMention,
  onDeleteMention
}) => {
  return new Plugin({
    key: LIVEBLOCKS_MENTION_NOTIFIER_KEY,
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      if (transactions.some((transaction) => transaction.getMeta(ySyncPluginKey))) {
        return;
      }
      const transform = combineTransactionSteps(oldState.doc, [
        ...transactions
      ]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange, oldRange }) => {
        const newMentions = getMentionsFromNode(newState.doc, newRange);
        const oldMentions = getMentionsFromNode(oldState.doc, oldRange);
        if (oldMentions.size || newMentions.size) {
          newMentions.forEach((mention) => {
            if (!oldMentions.has(mention.notificationId)) {
              onCreateMention(mention);
            }
          });
          oldMentions.forEach((mention) => {
            if (!newMentions.has(mention.notificationId)) {
              onDeleteMention(mention.notificationId);
            }
          });
        }
      });
      return void 0;
    }
  });
};
var MentionExtension = Extension.create({
  name: LIVEBLOCKS_MENTION_EXTENSION,
  priority: 101,
  addOptions() {
    return {
      onCreateMention: () => {
      },
      onDeleteMention: () => {
      }
    };
  },
  addExtensions() {
    return [MentionNode, GroupMentionNode];
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: MENTION_CHARACTER,
        pluginKey: LIVEBLOCKS_MENTION_KEY,
        command: ({ editor, range: range2, props }) => {
          var _a3, _b, _c;
          const nodeAfter = editor.view.state.selection.$to.nodeAfter;
          const overrideSpace = (_a3 = nodeAfter == null ? void 0 : nodeAfter.text) == null ? void 0 : _a3.startsWith(" ");
          if (overrideSpace) {
            range2.to += 1;
          }
          const mention = props;
          let mentionNode;
          if (mention.kind === "user") {
            mentionNode = {
              type: LIVEBLOCKS_MENTION_TYPE,
              attrs: {
                id: mention.id,
                notificationId: mention.notificationId
              }
            };
          } else if (mention.kind === "group") {
            mentionNode = {
              type: LIVEBLOCKS_GROUP_MENTION_TYPE,
              attrs: {
                id: mention.id,
                userIds: mention.userIds ? JSON.stringify(mention.userIds) : void 0,
                notificationId: mention.notificationId
              }
            };
          } else {
            assertNever(mention, "Unhandled mention kind");
          }
          editor.chain().focus().insertContentAt(range2, [
            mentionNode,
            {
              type: "text",
              text: " "
            }
          ]).run();
          (_c = (_b = editor.view.dom.ownerDocument.defaultView) == null ? void 0 : _b.getSelection()) == null ? void 0 : _c.collapseToEnd();
        },
        allow: ({ state, range: range2 }) => {
          const $fromParentType = state.doc.resolve(range2.from).parent.type;
          return Boolean(
            $fromParentType.contentMatch.matchType(
              state.schema.nodes[LIVEBLOCKS_MENTION_TYPE]
            ) || $fromParentType.contentMatch.matchType(
              state.schema.nodes[LIVEBLOCKS_GROUP_MENTION_TYPE]
            )
          );
        },
        allowSpaces: true,
        items: () => [],
        render: () => {
          let component;
          return {
            onStart: (props) => {
              component = new ReactRenderer(MentionsList, {
                props,
                editor: props.editor
              });
              if (!props.clientRect) {
                return;
              }
              document.body.appendChild(component.element);
            },
            onUpdate(props) {
              component.updateProps(props);
            },
            onKeyDown(props) {
              var _a3;
              if (props.event.key === "Escape") {
                component.updateProps({
                  ...props,
                  hide: true
                });
                return true;
              }
              return ((_a3 = component.ref) == null ? void 0 : _a3.onKeyDown(props)) ?? false;
            },
            onExit() {
              if (document.body.contains(component.element)) {
                document.body.removeChild(component.element);
              }
              component.destroy();
            }
          };
        }
      }),
      notifier(this.options),
      mentionPasteHandler()
    ];
  }
});

// node_modules/@liveblocks/react-tiptap/dist/LiveblocksExtension.js
var DEFAULT_OPTIONS = {
  field: "default",
  comments: true,
  mentions: true,
  offlineSupport_experimental: false,
  enablePermanentUserData: false
};
var LiveblocksCollab = Collaboration.extend({
  onCreate() {
    if (!this.editor.extensionManager.extensions.find((e3) => e3.name === "doc")) {
      console.warn(
        "[Liveblocks] The tiptap document extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension."
      );
    }
    if (!this.editor.extensionManager.extensions.find(
      (e3) => e3.name === "paragraph"
    )) {
      console.warn(
        "[Liveblocks] The tiptap paragraph extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension."
      );
    }
    if (!this.editor.extensionManager.extensions.find((e3) => e3.name === "text")) {
      console.warn(
        "[Liveblocks] The tiptap text extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension."
      );
    }
    if (this.editor.extensionManager.extensions.find((e3) => e3.name === "history")) {
      console.warn(
        "[Liveblocks] The history extension is enabled, Liveblocks extension provides its own. Please remove or disable the History plugin to prevent unwanted conflicts."
      );
    }
  }
});
function useIsEditorReady() {
  const yjsProvider = useYjsProvider();
  const getSnapshot2 = (0, import_react102.useCallback)(() => {
    const status = yjsProvider == null ? void 0 : yjsProvider.getStatus();
    return status === "synchronizing" || status === "synchronized";
  }, [yjsProvider]);
  const subscribe2 = (0, import_react102.useCallback)(
    (callback) => {
      if (yjsProvider === void 0)
        return () => {
        };
      yjsProvider.on("status", callback);
      return () => {
        yjsProvider.off("status", callback);
      };
    },
    [yjsProvider]
  );
  return (0, import_react102.useSyncExternalStore)(subscribe2, getSnapshot2, getSnapshot2);
}
var YChangeMark = Mark.create({
  name: "ychange",
  inclusive: false,
  parseHTML() {
    return [{ tag: "ychange" }];
  },
  addAttributes() {
    return {
      user: {
        default: null,
        parseHTML: (element) => element.getAttribute("ychange_user") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.user) {
            return {};
          }
          return { "data-ychange-user": attributes.user };
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("ychange_type") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.type) {
            return {};
          }
          return {
            "data-ychange-type": attributes.type,
            "data-liveblocks": "",
            class: `lb-root lb-tiptap-change lb-tiptap-change-${attributes.type}`
          };
        }
      },
      color: {
        default: null,
        parseHTML: (element) => {
          return element.getAttribute("ychange_color") ?? null;
        },
        renderHTML: () => {
          return {};
        }
      }
    };
  },
  renderHTML({ HTMLAttributes }) {
    return ["ychange", HTMLAttributes, 0];
  }
});
var useLiveblocksExtension = (opts) => {
  const options2 = {
    ...DEFAULT_OPTIONS,
    ...opts
  };
  const textEditorType = useInitial(
    options2.textEditorType ?? TextEditorType.TipTap
  );
  const editor = (0, import_react102.useRef)(null);
  const room = _useRoom();
  const isEditorReady = useIsEditorReady();
  const client = useClient();
  const store = getUmbrellaStoreForClient(client);
  const roomId = room.id;
  const yjsProvider = useYjsProvider();
  (0, import_react102.useEffect)(() => {
    if (!isEditorReady || !yjsProvider || !options2.initialContent || !editor.current)
      return;
    const ydoc = yjsProvider.getYDoc();
    const hasContentSet = ydoc.getMap("liveblocks_config").get("hasContentSet");
    if (!hasContentSet) {
      ydoc.getMap("liveblocks_config").set("hasContentSet", true);
      editor.current.commands.setContent(options2.initialContent);
    }
  }, [isEditorReady, yjsProvider, options2.initialContent]);
  useReportTextEditor(textEditorType, options2.field ?? DEFAULT_OPTIONS.field);
  const prevThreadsRef = (0, import_react102.useRef)(void 0);
  (0, import_react102.useEffect)(() => {
    if (!isEditorReady)
      return;
    if (!editor.current)
      return;
    const newThreads = options2.threads_experimental ? new Set(options2.threads_experimental.map((t3) => t3.id)) : void 0;
    const hasFilteredThreadsChanged = !areSetsEqual(
      prevThreadsRef.current,
      newThreads
    );
    if (hasFilteredThreadsChanged) {
      prevThreadsRef.current = newThreads;
    }
    if (hasFilteredThreadsChanged) {
      editor.current.view.dispatch(
        editor.current.state.tr.setMeta(FILTERED_THREADS_PLUGIN_KEY, {
          filteredThreads: options2.threads_experimental ? new Set(options2.threads_experimental.map((t3) => t3.id)) : void 0
        })
      );
    }
  }, [isEditorReady, options2.threads_experimental]);
  const createTextMention = useCreateTextMention();
  const deleteTextMention = useDeleteTextMention();
  return Extension.create({
    name: "liveblocksExtension",
    onCreate() {
      editor.current = this.editor;
      if (this.editor.options.content) {
        console.warn(
          "[Liveblocks] Initial content must be set in the useLiveblocksExtension hook option. Remove content from your editor options."
        );
      }
      if (options2.mentions && this.editor.extensionManager.extensions.find(
        (e3) => e3.name.toLowerCase() === "mention"
      )) {
        console.warn(
          "[Liveblocks] Liveblocks own mention plugin is enabled, using another mention plugin may cause a conflict."
        );
      }
      const self2 = room.getSelf();
      const updateUser = ({
        info,
        id: userId
      }) => {
        if (!info) {
          return;
        }
        const { user: storedUser } = this.storage.provider.awareness.getLocalState();
        if (this.storage.permanentUserData) {
          const pud = this.storage.permanentUserData.clients.get(
            this.storage.doc.clientID
          );
          if (!pud || pud !== userId) {
            this.storage.permanentUserData.setUserMapping(
              this.storage.doc,
              this.storage.doc.clientID,
              userId ?? "Unknown"
            );
          }
        }
        if (info.name !== (storedUser == null ? void 0 : storedUser.name) || info.color !== (storedUser == null ? void 0 : storedUser.color)) {
          this.editor.commands.updateUser({
            name: info.name,
            color: info.color
          });
        }
      };
      if (self2 == null ? void 0 : self2.info) {
        updateUser(self2);
      }
      this.storage.unsubs.push(room.events.self.subscribe(updateUser));
      if (options2.comments) {
        const commentMarkType = getMarkType(
          LIVEBLOCKS_COMMENT_MARK_TYPE,
          this.editor.schema
        );
        this.storage.unsubs.push(
          store.outputs.threads.subscribe(() => {
            const threadMap = new Map(
              store.outputs.threads.get().findMany(roomId, { resolved: false }, "asc").map((thread) => [thread.id, true])
            );
            function isComment(mark) {
              return mark.type.name === LIVEBLOCKS_COMMENT_MARK_TYPE;
            }
            this.editor.state.doc.descendants((node3, pos) => {
              node3.marks.forEach((mark) => {
                if (isComment(mark)) {
                  const markThreadId = mark.attrs.threadId;
                  const isOrphan = !threadMap.has(markThreadId);
                  if (isOrphan !== mark.attrs.orphan) {
                    const { tr } = this.editor.state;
                    const trimmedFrom = Math.max(pos, 0);
                    const trimmedTo = Math.min(
                      pos + node3.nodeSize,
                      this.editor.state.doc.content.size - 1
                    );
                    tr.removeMark(trimmedFrom, trimmedTo, mark);
                    tr.addMark(
                      trimmedFrom,
                      trimmedTo,
                      commentMarkType.create({
                        ...mark.attrs,
                        orphan: isOrphan
                      })
                    );
                    this.editor.view.dispatch(tr);
                  }
                }
              });
            });
          })
        );
      }
    },
    onDestroy() {
      this.storage.unsubs.forEach((unsub) => unsub());
    },
    addGlobalAttributes() {
      return [
        {
          types: ["paragraph", "heading"],
          attributes: {
            ychange: { default: null }
          }
        }
      ];
    },
    addStorage() {
      const provider = getYjsProviderForRoom(room, {
        enablePermanentUserData: !!options2.ai || options2.enablePermanentUserData,
        offlineSupport_experimental: options2.offlineSupport_experimental
      });
      return {
        doc: provider.getYDoc(),
        provider,
        permanentUserData: provider.permanentUserData,
        unsubs: []
      };
    },
    addExtensions() {
      const extensions = [
        YChangeMark,
        LiveblocksCollab.configure({
          ySyncOptions: {
            permanentUserData: this.storage.permanentUserData
          },
          document: this.storage.doc,
          field: options2.field
        }),
        CollaborationCursor.configure({
          provider: this.storage.provider
        })
      ];
      if (options2.comments) {
        extensions.push(CommentsExtension);
      }
      if (options2.mentions) {
        extensions.push(
          MentionExtension.configure({
            onCreateMention: (mention) => {
              createTextMention(mention.notificationId, mention);
            },
            onDeleteMention: deleteTextMention
          })
        );
      }
      if (options2.ai) {
        const resolveContextualPrompt = async ({
          prompt,
          context,
          previous: previous3,
          signal
        }) => {
          const result = await room[kInternal].executeContextualPrompt({
            prompt,
            context,
            previous: previous3,
            signal
          });
          return JSON.parse(result);
        };
        extensions.push(
          AiExtension.configure({
            resolveContextualPrompt,
            ...typeof options2.ai === "boolean" ? {} : options2.ai,
            doc: this.storage.doc,
            pud: this.storage.permanentUserData
          })
        );
      }
      return extensions;
    }
  });
};

// node_modules/@liveblocks/react-tiptap/dist/toolbar/FloatingToolbar.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react106 = __toESM(require_react(), 1);
var import_react_dom15 = __toESM(require_react_dom(), 1);

// node_modules/@liveblocks/react-tiptap/dist/toolbar/shared.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_react103 = __toESM(require_react(), 1);
var FloatingToolbarContext = (0, import_react103.createContext)(null);
var FloatingToolbarExternal = (0, import_react103.forwardRef)(({ children, style, ...props }, forwardedRef) => {
  const id = (0, import_react103.useId)();
  const externalId = `liveblocks-floating-toolbar-external-${id}`;
  const floatingToolbarContext = (0, import_react103.useContext)(FloatingToolbarContext);
  const registerExternal = floatingToolbarContext == null ? void 0 : floatingToolbarContext.registerExternal;
  useLayoutEffect2(() => {
    if (!registerExternal) {
      return;
    }
    return registerExternal(externalId);
  }, [registerExternal, externalId]);
  if (!floatingToolbarContext || import_react103.Children.count(children) === 0) {
    return (0, import_jsx_runtime128.jsx)(import_jsx_runtime128.Fragment, {
      children
    });
  }
  return (0, import_jsx_runtime128.jsx)("div", {
    ref: forwardedRef,
    style: { display: "contents", ...style },
    "data-liveblocks-floating-toolbar-external": id,
    ...props,
    id: externalId,
    children
  });
});

// node_modules/@liveblocks/react-tiptap/dist/toolbar/Toolbar.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-select/dist/index.mjs
var React43 = __toESM(require_react(), 1);
var ReactDOM5 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/number/dist/index.mjs
function clamp3(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}

// node_modules/@radix-ui/react-use-previous/dist/index.mjs
var React42 = __toESM(require_react(), 1);
function usePrevious(value) {
  const ref = React42.useRef({ value, previous: value });
  return React42.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}

// node_modules/@radix-ui/react-select/dist/index.mjs
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS2 = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection3, useCollection3, createCollectionScope3] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope3,
  createPopperScope
]);
var usePopperScope4 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope4(__scopeSelect);
  const [trigger2, setTrigger] = React43.useState(null);
  const [valueNode, setValueNode] = React43.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React43.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = React43.useRef(null);
  const isFormControl = trigger2 ? form || !!trigger2.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React43.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return (0, import_jsx_runtime129.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime129.jsxs)(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        (0, import_jsx_runtime129.jsx)(Collection3.Provider, { scope: __scopeSelect, children: (0, import_jsx_runtime129.jsx)(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React43.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React43.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? (0, import_jsx_runtime129.jsxs)(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? (0, import_jsx_runtime129.jsx)("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME5 = "SelectTrigger";
var SelectTrigger = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope4(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME5, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection3(__scopeSelect);
    const pointerTypeRef = React43.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return (0, import_jsx_runtime129.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime129.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME5;
var VALUE_NAME = "SelectValue";
var SelectValue = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect22(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return (0, import_jsx_runtime129.jsx)(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? (0, import_jsx_runtime129.jsx)(import_jsx_runtime129.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return (0, import_jsx_runtime129.jsx)(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME8 = "SelectPortal";
var SelectPortal = (props) => {
  return (0, import_jsx_runtime129.jsx)(Portal, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME8;
var CONTENT_NAME7 = "SelectContent";
var SelectContent = React43.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME7, props.__scopeSelect);
    const [fragment2, setFragment] = React43.useState();
    useLayoutEffect22(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment2;
      return frag ? ReactDOM5.createPortal(
        (0, import_jsx_runtime129.jsx)(SelectContentProvider, { scope: props.__scopeSelect, children: (0, import_jsx_runtime129.jsx)(Collection3.Slot, { scope: props.__scopeSelect, children: (0, import_jsx_runtime129.jsx)("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return (0, import_jsx_runtime129.jsx)(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME7;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME7);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot5 = createSlot("SelectContent.RemoveScroll");
var SelectContentImpl = React43.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME7, __scopeSelect);
    const [content, setContent] = React43.useState(null);
    const [viewport, setViewport] = React43.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node3) => setContent(node3));
    const [selectedItem, setSelectedItem] = React43.useState(null);
    const [selectedItemText, setSelectedItemText] = React43.useState(
      null
    );
    const getItems = useCollection3(__scopeSelect);
    const [isPositioned, setIsPositioned] = React43.useState(false);
    const firstValidItemFoundRef = React43.useRef(false);
    React43.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst4 = React43.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React43.useCallback(
      () => focusFirst4([selectedItem, content]),
      [focusFirst4, selectedItem, content]
    );
    React43.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React43.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a3, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a3 = triggerPointerDownPosRef.current) == null ? void 0 : _a3.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React43.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React43.useCallback(
      (node3, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node3);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React43.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React43.useCallback(
      (node3, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node3);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return (0, import_jsx_runtime129.jsx)(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: (0, import_jsx_runtime129.jsx)(Combination_default, { as: Slot5, allowPinchZoom: true, children: (0, import_jsx_runtime129.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a3;
              (_a3 = context.trigger) == null ? void 0 : _a3.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: (0, import_jsx_runtime129.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: (0, import_jsx_runtime129.jsx)(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst4(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React43.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME7, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME7, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React43.useState(null);
  const [content, setContent] = React43.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node3) => setContent(node3));
  const getItems = useCollection3(__scopeSelect);
  const shouldExpandOnScrollRef = React43.useRef(false);
  const shouldRepositionRef = React43.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React43.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp3(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp3(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect22(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React43.useState();
  useLayoutEffect22(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React43.useCallback(
    (node3) => {
      if (node3 && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return (0, import_jsx_runtime129.jsx)(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: (0, import_jsx_runtime129.jsx)(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: (0, import_jsx_runtime129.jsx)(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React43.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope4(__scopeSelect);
  return (0, import_jsx_runtime129.jsx)(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME7, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React43.useRef(0);
    return (0, import_jsx_runtime129.jsxs)(import_jsx_runtime129.Fragment, { children: [
      (0, import_jsx_runtime129.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      (0, import_jsx_runtime129.jsx)(Collection3.Slot, { scope: __scopeSelect, children: (0, import_jsx_runtime129.jsx)(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME4 = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME4);
var SelectGroup = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return (0, import_jsx_runtime129.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: (0, import_jsx_runtime129.jsx)(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME4;
var LABEL_NAME3 = "SelectLabel";
var SelectLabel = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME3, __scopeSelect);
    return (0, import_jsx_runtime129.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME3;
var ITEM_NAME4 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME4);
var SelectItem = React43.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME4, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME4, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React43.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React43.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node3) => {
        var _a3;
        return (_a3 = contentContext.itemRefCallback) == null ? void 0 : _a3.call(contentContext, node3, value, disabled);
      }
    );
    const textId = useId();
    const pointerTypeRef = React43.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return (0, import_jsx_runtime129.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React43.useCallback((node3) => {
          setTextValue((prevTextValue) => prevTextValue || ((node3 == null ? void 0 : node3.textContent) ?? "").trim());
        }, []),
        children: (0, import_jsx_runtime129.jsx)(
          Collection3.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: (0, import_jsx_runtime129.jsx)(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a3;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a3 = contentContext.onItemLeave) == null ? void 0 : _a3.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a3;
                  if (event.currentTarget === document.activeElement) {
                    (_a3 = contentContext.onItemLeave) == null ? void 0 : _a3.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a3;
                  const isTypingAhead = ((_a3 = contentContext.searchRef) == null ? void 0 : _a3.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS2.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME4;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React43.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node3) => setItemTextNode(node3),
      itemContext.onItemTextChange,
      (node3) => {
        var _a3;
        return (_a3 = contentContext.itemTextRefCallback) == null ? void 0 : _a3.call(contentContext, node3, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React43.useMemo(
      () => (0, import_jsx_runtime129.jsx)("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect22(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return (0, import_jsx_runtime129.jsxs)(import_jsx_runtime129.Fragment, { children: [
      (0, import_jsx_runtime129.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM5.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME2 = "SelectItemIndicator";
var SelectItemIndicator = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME2, __scopeSelect);
    return itemContext.isSelected ? (0, import_jsx_runtime129.jsx)(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME2;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React43.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React43.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? (0, import_jsx_runtime129.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React43.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React43.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? (0, import_jsx_runtime129.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React43.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React43.useRef(null);
  const getItems = useCollection3(__scopeSelect);
  const clearAutoScrollTimer = React43.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React43.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect22(() => {
    var _a3;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a3 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a3.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return (0, import_jsx_runtime129.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a3;
        (_a3 = contentContext.onItemLeave) == null ? void 0 : _a3.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME3 = "SelectSeparator";
var SelectSeparator = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return (0, import_jsx_runtime129.jsx)(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME3;
var ARROW_NAME6 = "SelectArrow";
var SelectArrow = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope4(__scopeSelect);
    const context = useSelectContext(ARROW_NAME6, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME6, __scopeSelect);
    return context.open && contentContext.position === "popper" ? (0, import_jsx_runtime129.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME6;
var BUBBLE_INPUT_NAME = "SelectBubbleInput";
var SelectBubbleInput = React43.forwardRef(
  ({ __scopeSelect, value, ...props }, forwardedRef) => {
    const ref = React43.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React43.useEffect(() => {
      const select2 = ref.current;
      if (!select2) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select2, value);
        select2.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return (0, import_jsx_runtime129.jsx)(
      Primitive.select,
      {
        ...props,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef(onSearchChange);
  const searchRef = React43.useRef("");
  const timerRef = React43.useRef(0);
  const handleTypeaheadSearch = React43.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React43.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React43.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray3(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v2) => v2 !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray3(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root24 = Select;
var Trigger2 = SelectTrigger;
var Portal7 = SelectPortal;
var Content25 = SelectContent;
var Item3 = SelectItem;

// node_modules/@liveblocks/react-tiptap/dist/toolbar/Toolbar.js
var import_react104 = __toESM(require_react(), 1);
var BLOCK_SELECT_SIDE_OFFSET = 10;
var FLOATING_ELEMENT_COLLISION_PADDING2 = 10;
function applyToolbarSlot(slot, props) {
  if (typeof slot === "function") {
    const Component3 = slot;
    return (0, import_jsx_runtime130.jsx)(Component3, {
      ...props
    });
  }
  return slot;
}
var ToolbarButton = (0, import_react104.forwardRef)(
  ({ icon, children, name, shortcut, onKeyDown, ...props }, forwardedRef) => {
    const floatingToolbarContext = (0, import_react104.useContext)(FloatingToolbarContext);
    const closeFloatingToolbar = floatingToolbarContext == null ? void 0 : floatingToolbarContext.close;
    const handleKeyDown = (0, import_react104.useCallback)(
      (event) => {
        onKeyDown == null ? void 0 : onKeyDown(event);
        if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
          closeFloatingToolbar();
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [onKeyDown, closeFloatingToolbar]
    );
    return (0, import_jsx_runtime130.jsx)(ShortcutTooltip, {
      content: name,
      shortcut,
      children: (0, import_jsx_runtime130.jsx)(Button, {
        type: "button",
        variant: "toolbar",
        ref: forwardedRef,
        icon,
        "aria-label": !children ? name : void 0,
        tabIndex: 0,
        ...props,
        onKeyDown: handleKeyDown,
        children: !children && !icon ? name : children
      })
    });
  }
);
var ToolbarToggle = (0, import_react104.forwardRef)(
  ({ active, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime130.jsx)(Root5, {
      asChild: true,
      pressed: active,
      children: (0, import_jsx_runtime130.jsx)(ToolbarButton, {
        ref: forwardedRef,
        ...props
      })
    });
  }
);
function createDefaultBlockSelectorItems(editor) {
  const items = [
    {
      name: "Text",
      icon: (0, import_jsx_runtime130.jsx)(TextIcon, {}),
      isActive: "default",
      setActive: (editor2) => editor2.chain().focus().clearNodes().run()
    },
    "toggleHeading" in editor.commands ? {
      name: "Heading 1",
      icon: (0, import_jsx_runtime130.jsx)(H1Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 1 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 1 }).run()
    } : null,
    "toggleHeading" in editor.commands ? {
      name: "Heading 2",
      icon: (0, import_jsx_runtime130.jsx)(H2Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 2 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 2 }).run()
    } : null,
    "toggleHeading" in editor.commands ? {
      name: "Heading 3",
      icon: (0, import_jsx_runtime130.jsx)(H3Icon, {}),
      isActive: (editor2) => editor2.isActive("heading", { level: 3 }),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 3 }).run()
    } : null,
    "toggleBulletList" in editor.commands ? {
      name: "Bullet list",
      icon: (0, import_jsx_runtime130.jsx)(ListUnorderedIcon, {}),
      isActive: (editor2) => editor2.isActive("bulletList"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBulletList().run()
    } : null,
    "toggleOrderedList" in editor.commands ? {
      name: "Numbered list",
      icon: (0, import_jsx_runtime130.jsx)(ListOrderedIcon, {}),
      isActive: (editor2) => editor2.isActive("orderedList"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleOrderedList().run()
    } : null,
    "toggleBlockquote" in editor.commands ? {
      name: "Blockquote",
      icon: (0, import_jsx_runtime130.jsx)(BlockquoteIcon, {}),
      isActive: (editor2) => editor2.isActive("blockquote"),
      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBlockquote().run()
    } : null
  ];
  return items.filter(Boolean);
}
var ToolbarBlockSelector = (0, import_react104.forwardRef)(({ items, onKeyDown, ...props }, forwardedRef) => {
  const floatingToolbarContext = (0, import_react104.useContext)(FloatingToolbarContext);
  const closeFloatingToolbar = floatingToolbarContext == null ? void 0 : floatingToolbarContext.close;
  const editor = useCurrentEditor(
    "BlockSelector",
    "Toolbar or FloatingToolbar"
  );
  const resolvedItems = (0, import_react104.useMemo)(() => {
    if (Array.isArray(items)) {
      return items;
    }
    const defaultItems = createDefaultBlockSelectorItems(editor);
    return items ? items(defaultItems) : defaultItems;
  }, [editor, items]);
  let defaultItem;
  let activeItem = editor.isInitialized ? resolvedItems.find((item) => {
    if (item.isActive === "default") {
      defaultItem = item;
      return false;
    }
    return item.isActive(editor);
  }) : void 0;
  if (!activeItem) {
    activeItem = defaultItem;
  }
  const handleItemChange = (name) => {
    const item = resolvedItems.find((item2) => item2.name === name);
    if (item) {
      item.setActive(editor);
      floatingToolbarContext == null ? void 0 : floatingToolbarContext.close();
    }
  };
  const handleKeyDown = (0, import_react104.useCallback)(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
        closeFloatingToolbar();
        event.preventDefault();
        event.stopPropagation();
      }
    },
    [onKeyDown, closeFloatingToolbar]
  );
  return (0, import_jsx_runtime130.jsxs)(Root24, {
    value: activeItem == null ? void 0 : activeItem.name,
    onValueChange: handleItemChange,
    children: [
      (0, import_jsx_runtime130.jsx)(ShortcutTooltip, {
        content: "Turn into…",
        children: (0, import_jsx_runtime130.jsx)(Trigger2, {
          asChild: true,
          ...props,
          ref: forwardedRef,
          onKeyDown: handleKeyDown,
          disabled: resolvedItems.length === 0,
          children: (0, import_jsx_runtime130.jsx)(SelectButton, {
            variant: "toolbar",
            children: (activeItem == null ? void 0 : activeItem.name) ?? "Turn into…"
          })
        })
      }),
      (0, import_jsx_runtime130.jsx)(Portal7, {
        children: (0, import_jsx_runtime130.jsx)(FloatingToolbarExternal, {
          children: (0, import_jsx_runtime130.jsx)(Content25, {
            position: "popper",
            sideOffset: BLOCK_SELECT_SIDE_OFFSET,
            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING2,
            className: "lb-root lb-portal lb-elevation lb-dropdown lb-select-dropdown lb-tiptap-block-selector-dropdown",
            children: resolvedItems.map((item) => (0, import_jsx_runtime130.jsxs)(Item3, {
              value: item.name,
              className: "lb-dropdown-item",
              "data-name": item.name,
              children: [
                item.icon ? (0, import_jsx_runtime130.jsx)("span", {
                  className: "lb-dropdown-item-icon lb-icon-container",
                  children: item.icon
                }) : null,
                (0, import_jsx_runtime130.jsx)("span", {
                  className: "lb-dropdown-item-label",
                  children: item.label ?? item.name
                }),
                item.name === (activeItem == null ? void 0 : activeItem.name) ? (0, import_jsx_runtime130.jsx)("span", {
                  className: "lb-dropdown-item-accessory lb-icon-container",
                  children: (0, import_jsx_runtime130.jsx)(CheckIcon, {})
                }) : null
              ]
            }, item.name))
          })
        })
      })
    ]
  });
});
var ToolbarSeparator = (0, import_react104.forwardRef)(
  ({ className, ...props }, forwardedRef) => {
    return (0, import_jsx_runtime130.jsx)("div", {
      ref: forwardedRef,
      role: "separator",
      "aria-orientation": "vertical",
      className: cn("lb-tiptap-toolbar-separator", className),
      ...props
    });
  }
);
function ToolbarSectionHistory() {
  const editor = useCurrentEditor(
    "SectionHistory",
    "Toolbar or FloatingToolbar"
  );
  return (0, import_jsx_runtime130.jsxs)(import_jsx_runtime130.Fragment, {
    children: [
      (0, import_jsx_runtime130.jsx)(ToolbarButton, {
        name: "Undo",
        icon: (0, import_jsx_runtime130.jsx)(UndoIcon, {}),
        shortcut: "Mod-Z",
        onClick: () => editor.chain().focus().undo().run(),
        disabled: !editor.can().chain().focus().undo().run()
      }),
      (0, import_jsx_runtime130.jsx)(ToolbarButton, {
        name: "Redo",
        icon: (0, import_jsx_runtime130.jsx)(RedoIcon, {}),
        shortcut: "Mod-Shift-Z",
        onClick: () => editor.chain().focus().redo().run(),
        disabled: !editor.can().chain().focus().redo().run()
      })
    ]
  });
}
function ToolbarSectionInline() {
  const editor = useCurrentEditor(
    "SectionInline",
    "Toolbar or FloatingToolbar"
  );
  const supportsBold = "toggleBold" in editor.commands;
  const supportsItalic = "toggleItalic" in editor.commands;
  const supportsUnderline = "toggleUnderline" in editor.commands;
  const supportsStrike = "toggleStrike" in editor.commands;
  const supportsCode = "toggleCode" in editor.commands;
  return (0, import_jsx_runtime130.jsxs)(import_jsx_runtime130.Fragment, {
    children: [
      supportsBold && (0, import_jsx_runtime130.jsx)(ToolbarToggle, {
        name: "Bold",
        icon: (0, import_jsx_runtime130.jsx)(BoldIcon, {}),
        shortcut: "Mod-B",
        onClick: () => editor.chain().focus().toggleBold().run(),
        disabled: !editor.can().chain().focus().toggleBold().run(),
        active: editor.isActive("bold")
      }),
      supportsItalic && (0, import_jsx_runtime130.jsx)(ToolbarToggle, {
        name: "Italic",
        icon: (0, import_jsx_runtime130.jsx)(ItalicIcon, {}),
        shortcut: "Mod-I",
        onClick: () => editor.chain().focus().toggleItalic().run(),
        disabled: !editor.can().chain().focus().toggleItalic().run(),
        active: editor.isActive("italic")
      }),
      supportsUnderline && (0, import_jsx_runtime130.jsx)(ToolbarToggle, {
        name: "Underline",
        icon: (0, import_jsx_runtime130.jsx)(UnderlineIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.chain().focus().toggleUnderline().run(),
        disabled: !editor.can().chain().focus().toggleUnderline().run(),
        active: editor.isActive("underline")
      }),
      supportsStrike && (0, import_jsx_runtime130.jsx)(ToolbarToggle, {
        name: "Strikethrough",
        icon: (0, import_jsx_runtime130.jsx)(StrikethroughIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.chain().focus().toggleStrike().run(),
        disabled: !editor.can().chain().focus().toggleStrike().run(),
        active: editor.isActive("strike")
      }),
      supportsCode && (0, import_jsx_runtime130.jsx)(ToolbarToggle, {
        name: "Inline code",
        icon: (0, import_jsx_runtime130.jsx)(CodeIcon, {}),
        shortcut: "Mod-E",
        onClick: () => editor.chain().focus().toggleCode().run(),
        disabled: !editor.can().chain().focus().toggleCode().run(),
        active: editor.isActive("code")
      })
    ]
  });
}
function ToolbarSectionCollaboration() {
  const editor = useCurrentEditor(
    "SectionCollaboration",
    "Toolbar or FloatingToolbar"
  );
  const supportsThread = "addPendingComment" in editor.commands;
  return (0, import_jsx_runtime130.jsx)(import_jsx_runtime130.Fragment, {
    children: supportsThread && (0, import_jsx_runtime130.jsx)(ToolbarButton, {
      name: "Add a comment",
      icon: (0, import_jsx_runtime130.jsx)(CommentIcon, {}),
      onClick: () => editor.chain().focus().addPendingComment().run(),
      children: "Comment"
    })
  });
}
function ToolbarSectionAi() {
  var _a3;
  const editor = useCurrentEditor("SectionAi", "Toolbar or FloatingToolbar");
  const supportsAi = "askAi" in editor.commands;
  const aiName = (_a3 = editor.storage.liveblocksAi) == null ? void 0 : _a3.name;
  return (0, import_jsx_runtime130.jsx)(import_jsx_runtime130.Fragment, {
    children: supportsAi && (0, import_jsx_runtime130.jsxs)(import_jsx_runtime130.Fragment, {
      children: [
        (0, import_jsx_runtime130.jsxs)(ToolbarButton, {
          name: `Ask ${aiName} anything…`,
          icon: (0, import_jsx_runtime130.jsx)(SparklesIcon, {}),
          onClick: () => editor.chain().focus().askAi(),
          children: [
            "Ask ",
            aiName
          ]
        }),
        (0, import_jsx_runtime130.jsx)(ToolbarButton, {
          name: "Explain",
          icon: (0, import_jsx_runtime130.jsx)(QuestionMarkIcon, {}),
          onClick: () => editor.chain().focus().askAi("Explain what the text is about"),
          children: "Explain"
        })
      ]
    })
  });
}
function DefaultToolbarContent({ editor }) {
  const supportsThread = "addPendingComment" in editor.commands;
  const supportsAi = "askAi" in editor.commands;
  return (0, import_jsx_runtime130.jsxs)(import_jsx_runtime130.Fragment, {
    children: [
      (0, import_jsx_runtime130.jsx)(ToolbarSectionHistory, {}),
      (0, import_jsx_runtime130.jsx)(ToolbarSeparator, {}),
      supportsAi ? (0, import_jsx_runtime130.jsxs)(import_jsx_runtime130.Fragment, {
        children: [
          (0, import_jsx_runtime130.jsx)(ToolbarSectionAi, {}),
          (0, import_jsx_runtime130.jsx)(ToolbarSeparator, {})
        ]
      }) : null,
      (0, import_jsx_runtime130.jsx)(ToolbarBlockSelector, {}),
      (0, import_jsx_runtime130.jsx)(ToolbarSectionInline, {}),
      supportsThread ? (0, import_jsx_runtime130.jsxs)(import_jsx_runtime130.Fragment, {
        children: [
          (0, import_jsx_runtime130.jsx)(ToolbarSeparator, {}),
          (0, import_jsx_runtime130.jsx)(ToolbarSectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
var Toolbar = Object.assign(
  (0, import_react104.forwardRef)(
    ({
      before: before3,
      after: after3,
      children = DefaultToolbarContent,
      editor,
      className,
      ...props
    }, forwardedRef) => {
      if (!editor) {
        return null;
      }
      const slotProps = { editor };
      return (0, import_jsx_runtime130.jsx)(TooltipProvider, {
        children: (0, import_jsx_runtime130.jsx)(EditorProvider, {
          editor,
          children: (0, import_jsx_runtime130.jsxs)("div", {
            ref: forwardedRef,
            role: "toolbar",
            "aria-label": "Toolbar",
            "aria-orientation": "horizontal",
            className: cn("lb-root lb-tiptap-toolbar", className),
            ...props,
            children: [
              applyToolbarSlot(before3, slotProps),
              applyToolbarSlot(children, slotProps),
              applyToolbarSlot(after3, slotProps)
            ]
          })
        })
      });
    }
  ),
  {
    Button: ToolbarButton,
    Toggle: ToolbarToggle,
    BlockSelector: ToolbarBlockSelector,
    Separator: ToolbarSeparator,
    SectionHistory: ToolbarSectionHistory,
    SectionInline: ToolbarSectionInline,
    SectionCollaboration: ToolbarSectionCollaboration,
    SectionAi: ToolbarSectionAi
  }
);

// node_modules/@liveblocks/react-tiptap/dist/toolbar/FloatingToolbar.js
var FLOATING_TOOLBAR_COLLISION_PADDING = 10;
var FLOATING_TOOLBAR_OPEN_DELAY = 50;
function DefaultFloatingToolbarContent({ editor }) {
  const supportsThread = "addPendingComment" in editor.commands;
  const supportsAi = "askAi" in editor.commands;
  return (0, import_jsx_runtime131.jsxs)(import_jsx_runtime131.Fragment, {
    children: [
      supportsAi ? (0, import_jsx_runtime131.jsxs)(import_jsx_runtime131.Fragment, {
        children: [
          (0, import_jsx_runtime131.jsx)(Toolbar.SectionAi, {}),
          (0, import_jsx_runtime131.jsx)(Toolbar.Separator, {})
        ]
      }) : null,
      (0, import_jsx_runtime131.jsx)(Toolbar.BlockSelector, {}),
      (0, import_jsx_runtime131.jsx)(Toolbar.SectionInline, {}),
      supportsThread ? (0, import_jsx_runtime131.jsxs)(import_jsx_runtime131.Fragment, {
        children: [
          (0, import_jsx_runtime131.jsx)(Toolbar.Separator, {}),
          (0, import_jsx_runtime131.jsx)(Toolbar.SectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
var FloatingToolbar = Object.assign(
  (0, import_react106.forwardRef)(
    ({
      children = DefaultFloatingToolbarContent,
      before: before3,
      after: after3,
      position = "top",
      offset: sideOffset = 6,
      editor,
      onPointerDown,
      onFocus,
      onBlur,
      className,
      ...props
    }, forwardedRef) => {
      const toolbarRef = (0, import_react106.useRef)(null);
      const externalIds = useInitial(() => /* @__PURE__ */ new Set());
      const [isPointerDown, setPointerDown] = (0, import_react106.useState)(false);
      const [isFocused, setFocused] = (0, import_react106.useState)(false);
      const [isManuallyClosed, setManuallyClosed] = (0, import_react106.useState)(false);
      const hasSelectionRange = useEditorState({
        editor,
        equalityFn: Object.is,
        selector: (ctx) => {
          const editor2 = ctx.editor;
          if (!editor2) {
            return false;
          }
          const { doc, selection } = editor2.state;
          const { empty, ranges } = selection;
          const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
          const to = Math.max(...ranges.map((range2) => range2.$to.pos));
          if (empty) {
            return false;
          }
          return isTextSelection(selection) && doc.textBetween(from2, to).length > 0;
        }
      }) ?? false;
      const isOpen = isFocused && !isPointerDown && hasSelectionRange && !isManuallyClosed;
      const [delayedIsOpen, setDelayedIsOpen] = (0, import_react106.useState)(isOpen);
      const delayedIsOpenTimeoutRef = (0, import_react106.useRef)();
      (0, import_react106.useEffect)(() => {
        if (!editor) {
          return;
        }
        setManuallyClosed(false);
        const handleSelectionChange = () => {
          setManuallyClosed(false);
        };
        editor.on("selectionUpdate", handleSelectionChange);
        return () => {
          editor.off("selectionUpdate", handleSelectionChange);
        };
      }, [isFocused, hasSelectionRange, editor]);
      (0, import_react106.useEffect)(() => {
        if (!editor) {
          return;
        }
        const handleFocus2 = () => {
          setFocused(true);
        };
        const handleBlur2 = (event) => {
          var _a3, _b;
          if (event.relatedTarget && ((_a3 = toolbarRef.current) == null ? void 0 : _a3.contains(event.relatedTarget))) {
            return;
          }
          if (event.relatedTarget === editor.view.dom) {
            return;
          }
          for (const externalId of externalIds) {
            if ((_b = document.getElementById(externalId)) == null ? void 0 : _b.contains(event.relatedTarget)) {
              return;
            }
          }
          setFocused(false);
        };
        editor.view.dom.addEventListener("focus", handleFocus2);
        editor.view.dom.addEventListener("blur", handleBlur2);
        return () => {
          editor.view.dom.removeEventListener("focus", handleFocus2);
          editor.view.dom.removeEventListener("blur", handleBlur2);
        };
      }, [editor, externalIds]);
      const handleFocus = (0, import_react106.useCallback)(
        (event) => {
          onFocus == null ? void 0 : onFocus(event);
          if (!event.isDefaultPrevented()) {
            setFocused(true);
          }
        },
        [onFocus]
      );
      const handleBlur = (0, import_react106.useCallback)(
        (event) => {
          var _a3, _b;
          onBlur == null ? void 0 : onBlur(event);
          if (!event.isDefaultPrevented()) {
            if (event.relatedTarget && ((_a3 = toolbarRef.current) == null ? void 0 : _a3.contains(event.relatedTarget))) {
              return;
            }
            if (event.relatedTarget === (editor == null ? void 0 : editor.view.dom)) {
              return;
            }
            for (const externalId of externalIds) {
              if ((_b = document.getElementById(externalId)) == null ? void 0 : _b.contains(event.relatedTarget)) {
                return;
              }
            }
            setFocused(false);
          }
        },
        [onBlur, editor, externalIds]
      );
      (0, import_react106.useEffect)(() => {
        if (isOpen) {
          delayedIsOpenTimeoutRef.current = window.setTimeout(() => {
            setDelayedIsOpen(true);
          }, FLOATING_TOOLBAR_OPEN_DELAY);
        } else {
          setDelayedIsOpen(false);
        }
        return () => {
          window.clearTimeout(delayedIsOpenTimeoutRef.current);
        };
      }, [isOpen]);
      const floatingOptions = (0, import_react106.useMemo)(() => {
        const detectOverflowOptions = {
          padding: FLOATING_TOOLBAR_COLLISION_PADDING
        };
        return {
          strategy: "fixed",
          placement: position,
          middleware: [
            inline3(detectOverflowOptions),
            flip3({ ...detectOverflowOptions, crossAxis: false }),
            hide3(detectOverflowOptions),
            shift3({
              ...detectOverflowOptions,
              limiter: limitShift3()
            }),
            offset3(sideOffset),
            size3(detectOverflowOptions)
          ],
          whileElementsMounted: (...args) => {
            return autoUpdate(...args, {
              animationFrame: true
            });
          }
        };
      }, [position, sideOffset]);
      const {
        refs: { setReference, setFloating },
        strategy,
        x: x2,
        y,
        isPositioned
      } = useFloating({
        ...floatingOptions,
        open: delayedIsOpen
      });
      const mergedRefs = useRefs(forwardedRef, toolbarRef, setFloating);
      const handlePointerDown = (0, import_react106.useCallback)(
        (event) => {
          onPointerDown == null ? void 0 : onPointerDown(event);
          event.stopPropagation();
          if (event.target === toolbarRef.current) {
            event.preventDefault();
          }
        },
        [onPointerDown]
      );
      (0, import_react106.useEffect)(() => {
        if (!editor) {
          return;
        }
        const handlePointerDown2 = () => {
          setPointerDown(true);
        };
        const handlePointerUp = () => {
          setPointerDown(false);
        };
        editor.view.dom.addEventListener("pointerdown", handlePointerDown2);
        document.addEventListener("pointercancel", handlePointerUp);
        document.addEventListener("pointerup", handlePointerUp);
        return () => {
          editor.view.dom.removeEventListener("pointerdown", handlePointerDown2);
          document.removeEventListener("pointercancel", handlePointerUp);
          document.removeEventListener("pointerup", handlePointerUp);
        };
      }, [editor]);
      useLayoutEffect2(() => {
        if (!editor || !delayedIsOpen) {
          return;
        }
        const updateSelectionReference = () => {
          const domSelection = window.getSelection();
          if (editor.state.selection.empty || !domSelection || !domSelection.rangeCount) {
            setReference(null);
          } else {
            const domRange = domSelection.getRangeAt(0);
            setReference(domRange);
          }
        };
        editor.on("transaction", updateSelectionReference);
        updateSelectionReference();
        return () => {
          editor.off("transaction", updateSelectionReference);
        };
      }, [editor, delayedIsOpen, setReference]);
      (0, import_react106.useEffect)(() => {
        if (!editor || !delayedIsOpen) {
          return;
        }
        const handleKeyDown = (event) => {
          if (event.target !== editor.view.dom && event.defaultPrevented) {
            return;
          }
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            editor.commands.focus();
            setManuallyClosed(true);
          }
        };
        editor.view.dom.addEventListener("keydown", handleKeyDown);
        return () => {
          editor.view.dom.removeEventListener("keydown", handleKeyDown);
        };
      }, [editor, delayedIsOpen]);
      const close = (0, import_react106.useCallback)(() => {
        setManuallyClosed(true);
      }, [setManuallyClosed]);
      const registerExternal = (0, import_react106.useCallback)(
        (id) => {
          externalIds.add(id);
          return () => {
            externalIds.delete(id);
          };
        },
        [externalIds]
      );
      if (!editor || !delayedIsOpen) {
        return null;
      }
      const slotProps = { editor };
      return (0, import_react_dom15.createPortal)(
        (0, import_jsx_runtime131.jsx)(TooltipProvider, {
          children: (0, import_jsx_runtime131.jsx)(EditorProvider, {
            editor,
            children: (0, import_jsx_runtime131.jsx)(FloatingToolbarContext.Provider, {
              value: { close, registerExternal },
              children: (0, import_jsx_runtime131.jsxs)("div", {
                role: "toolbar",
                "aria-label": "Floating toolbar",
                "aria-orientation": "horizontal",
                className: cn(
                  "lb-root lb-portal lb-elevation lb-tiptap-floating-toolbar lb-tiptap-toolbar",
                  className
                ),
                ref: mergedRefs,
                style: {
                  position: strategy,
                  top: 0,
                  left: 0,
                  transform: isPositioned ? `translate3d(${Math.round(x2)}px, ${Math.round(y)}px, 0)` : "translate3d(0, -200%, 0)",
                  minWidth: "max-content"
                },
                onPointerDown: handlePointerDown,
                onFocus: handleFocus,
                onBlur: handleBlur,
                ...props,
                children: [
                  applyToolbarSlot(before3, slotProps),
                  applyToolbarSlot(children, slotProps),
                  applyToolbarSlot(after3, slotProps)
                ]
              })
            })
          })
        }),
        document.body
      );
    }
  ),
  {
    External: FloatingToolbarExternal
  }
);

// node_modules/@liveblocks/react-tiptap/dist/version-history/HistoryVersionPreview.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react109 = __toESM(require_react(), 1);
var AUTHORS_TRUNCATE2 = 3;
var HistoryVersionPreview = (0, import_react109.forwardRef)(
  ({ version: version2, editor: parentEditor, onVersionRestore, className, ...props }, forwardedRef) => {
    const $3 = useOverrides();
    const { isLoading, data, error } = useHistoryVersionData(version2.id);
    const previewEditor = useEditor({
      editable: false,
      extensions: parentEditor.extensionManager.extensions.filter(
        (e3) => e3.type !== "extension"
      )
    });
    (0, import_react109.useEffect)(() => {
      if (data && previewEditor) {
        const doc = new Doc();
        applyUpdate(doc, data);
        const root = doc.getXmlFragment("default");
        const node3 = yXmlFragmentToProseMirrorRootNode(
          root,
          parentEditor.schema
        );
        previewEditor.commands.setContent(node3.toJSON());
      }
    }, [data, previewEditor, parentEditor]);
    const restore = (0, import_react109.useCallback)(() => {
      parentEditor.commands.setContent((previewEditor == null ? void 0 : previewEditor.getJSON()) ?? "");
      onVersionRestore == null ? void 0 : onVersionRestore(version2);
    }, [onVersionRestore, parentEditor, previewEditor, version2]);
    return (0, import_jsx_runtime132.jsxs)("div", {
      ...props,
      className: cn(
        "lb-root lb-history-version-preview lb-tiptap-version-preview",
        className
      ),
      ref: forwardedRef,
      children: [
        isLoading ? (0, import_jsx_runtime132.jsx)("div", {
          className: "lb-loading lb-history-version-preview-loading",
          children: (0, import_jsx_runtime132.jsx)(SpinnerIcon, {})
        }) : error ? (0, import_jsx_runtime132.jsx)("div", {
          className: "lb-error lb-history-version-preview-error",
          children: $3.HISTORY_VERSION_PREVIEW_ERROR(error)
        }) : (0, import_jsx_runtime132.jsx)("div", {
          className: "lb-history-version-preview-content lb-tiptap-editor-container lb-tiptap-version-preview-editor-container",
          children: (0, import_jsx_runtime132.jsx)(EditorContent, {
            editor: previewEditor
          })
        }),
        (0, import_jsx_runtime132.jsxs)("div", {
          className: "lb-history-version-preview-footer",
          children: [
            (0, import_jsx_runtime132.jsx)("span", {
              className: "lb-history-version-preview-authors",
              children: $3.HISTORY_VERSION_PREVIEW_AUTHORS_LIST(
                (0, import_jsx_runtime132.jsx)(List, {
                  values: version2.authors.map((author) => (0, import_jsx_runtime132.jsx)(User, {
                    userId: author.id,
                    replaceSelf: true
                  }, author.id)),
                  formatRemaining: $3.LIST_REMAINING_USERS,
                  truncate: AUTHORS_TRUNCATE2,
                  locale: $3.locale
                })
              )
            }),
            (0, import_jsx_runtime132.jsx)("div", {
              className: "lb-history-version-preview-actions",
              children: (0, import_jsx_runtime132.jsx)(Button, {
                onClick: restore,
                disabled: !data,
                variant: "primary",
                size: "large",
                className: "lb-history-version-preview-action",
                icon: (0, import_jsx_runtime132.jsx)(RestoreIcon, {}),
                children: $3.HISTORY_VERSION_PREVIEW_RESTORE
              })
            })
          ]
        })
      ]
    });
  }
);

// node_modules/@liveblocks/react-tiptap/dist/index.js
detectDupes(PKG_NAME2, PKG_VERSION2, PKG_FORMAT2);
export {
  AiToolbar,
  AnchoredThreads,
  FloatingComposer,
  FloatingThreads,
  FloatingToolbar,
  GroupMentionNode,
  HistoryVersionPreview,
  MentionExtension,
  MentionNode,
  Toolbar,
  useIsEditorReady,
  useLiveblocksExtension
};
/*! Bundled license information:

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@liveblocks_react-tiptap.js.map
